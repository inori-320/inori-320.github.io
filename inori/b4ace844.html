<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>项目常见问题梳理（持续更新中） | 楪祈のBlog</title><meta name="author" content="楪舞飞祈"><meta name="copyright" content="楪舞飞祈"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面试专题——项目篇">
<meta property="og:type" content="article">
<meta property="og:title" content="项目常见问题梳理（持续更新中）">
<meta property="og:url" content="http://example.com/inori/b4ace844.html">
<meta property="og:site_name" content="楪祈のBlog">
<meta property="og:description" content="面试专题——项目篇">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://api.suyanw.cn/api/comic3.php">
<meta property="article:published_time" content="2025-05-31T08:17:54.000Z">
<meta property="article:modified_time" content="2025-06-05T10:28:43.253Z">
<meta property="article:author" content="楪舞飞祈">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://api.suyanw.cn/api/comic3.php"><link rel="shortcut icon" href="/img/favicon_32.png"><link rel="canonical" href="http://example.com/inori/b4ace844.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '项目常见问题梳理（持续更新中）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-05 18:28:43'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/rss2.xml" title="楪祈のBlog" type="application/rss+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://api.suyanw.cn/api/comic3.php')"><nav id="nav"><span id="blog-info"><a href="/" title="楪祈のBlog"><span class="site-name">楪祈のBlog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">项目常见问题梳理（持续更新中）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-31T08:17:54.000Z" title="发表于 2025-05-31 16:17:54">2025-05-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-05T10:28:43.253Z" title="更新于 2025-06-05 18:28:43">2025-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="项目常见问题梳理（持续更新中）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h1><h2 id="为什么要做RPC项目"><a href="#为什么要做RPC项目" class="headerlink" title="为什么要做RPC项目"></a>为什么要做RPC项目</h2><p>目前的应用大部分都是分布式或者微服务架构，通常各个模块之间都是通过rpc来进行调用的，所以我认为自己写一个rpc项目可以更加深入的理解rpc的原理</p>
<p>然后在写rpc项目的过程中，学会了对Zookeeper和netty的使用，也学会了通信协议设计、序列化算法、服务注册与发现、负载均衡策略的设计和使用。</p>
<h2 id="项目有什么难点，如何解决的"><a href="#项目有什么难点，如何解决的" class="headerlink" title="项目有什么难点，如何解决的"></a>项目有什么难点，如何解决的</h2><ol>
<li>关于通信协议的实现和切换模块，我希望客户端和服务端支持http，socket和netty传输协议，并且根据配置自动切换。我的解决方案是首先定义了统一的接口<code>RpcClient</code> 和 <code>RpcServer</code>，然后实现其协议子类比如<code>NettyRpcServer</code>和<code>HttpRpcServer</code>，利用Spring Boot的 <code>@ConditionalOnProperty</code>和<code>@ConditionalOnMissingBean</code> 机制，支持配置项自动装配对应的协议实现</li>
<li>关于负载均衡模块的实现，就是服务调用时如何在多个服务节点直接选择一个合适的目标节点。我的解决方案是定义一个统一的接口<code>LoadBalance</code>，在此基础上扩展成随机、轮询和一致性哈希三种方法，使用SPI的方式决定具体使用哪种策略，最后把LoadBalance注入到服务发现模块中，实现调用时选择</li>
<li>关于服务注册和发现模块的实现，我编写了一个注解<code>RpcService</code>，服务启动时会遍历所有使用了这个注解的Bean，然后将服务的接口全限定名和服务提供地址注册到注册中心，然后在Zookeeper层面会创建一个临时节点，表明这个服务被创建成功。然后在客户端通过代理类发起远程调用时，如果存在多个地址，就是用负载均衡模块选择一个，最后建立连接发起远程调用</li>
<li>还有就是Kryo序列化与多线程环境的兼容性。因为Kryo是线程不安全的，直接复用同一个实例会导致数据错乱。后来我通过ThreadLocal为每个线程分配独立的Kryo实例，避免了线程间冲突，同时保持了性能</li>
</ol>
<h2 id="为什么用Netty做网络通信"><a href="#为什么用Netty做网络通信" class="headerlink" title="为什么用Netty做网络通信"></a>为什么用Netty做网络通信</h2><p>因为相比于Java原生的Socket和Http更适合高性能和高并发的场景</p>
<ul>
<li>Netty的IO是异步非阻塞的，支持大量并发连接，吞吐量高</li>
<li>Netty使用线程复用、事件驱动机制，资源占用低，GC压力小</li>
<li>Netty内部提供粘包半包处理器，实现rpc协议更方便</li>
</ul>
<h2 id="http、socket、netty三种网络通信方式的区别"><a href="#http、socket、netty三种网络通信方式的区别" class="headerlink" title="http、socket、netty三种网络通信方式的区别"></a>http、socket、netty三种网络通信方式的区别</h2><ul>
<li>socket是传输层的协议，是操作系统提供的网络编程接口，只提供最基础的通信方式，可以是阻塞或者非阻塞的，需要自己实现编解码器和传输的逻辑</li>
<li>http是应用层的协议，基于请求-响应的模式，默认是短连接的，并且不支持双向通信，性能比较低，但是http被很多框架支持，使用比较方便</li>
<li>netty是一个基于NIO的网络通信框架，底层用到了socket，是异步非阻塞，基于事件驱动的，性能比较高，并且其中提供了粘包半包的处理器和对自定义协议的支持，扩展性比较好</li>
</ul>
<h2 id="JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别"><a href="#JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别" class="headerlink" title="JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别"></a>JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别</h2><ul>
<li>JDK是Java原生的序列化方式，不需要引入三方库，但是序列化后体积比较大，性能低，反序列化速度慢</li>
<li>Json的可读性比较强，支持跨语言调用，比较适合web接口，但是它占用空间比较大，而且不支持复杂的对象图</li>
<li>Protostuff是基于Protobuf的序列化方式，支持基础的Java Bean，可以跨语言，并且序列化后体积小，性能高，但是它序列化后不可读</li>
<li>Hession是一个二进制协议，支持序列化复杂对象，也可以跨语言支持，兼容性比较好</li>
<li>Kryo适合Java内部序列化，不支持跨语言，序列化性能非常高，默认要求类有无参构造器，而且kryo是线程不安全的</li>
</ul>
<h2 id="讲一下自定义协议"><a href="#讲一下自定义协议" class="headerlink" title="讲一下自定义协议"></a>讲一下自定义协议</h2><p>我在rpc项目中的自定义协议头有魔数（4byte，识别协议是否合法），版本号（1byte，兼容后续可能的更新），序列化算法（1byte，具体使用的序列化协议），消息类型（1byte，有请求、响应、心跳），消息状态（1byte，成功，失败，超时），消息序列号（4byte，每个请求的唯一id，处理多路复用的时候可以用到），消息长度（4byte）</p>
<h2 id="讲一下编解码器"><a href="#讲一下编解码器" class="headerlink" title="讲一下编解码器"></a>讲一下编解码器</h2><p>编码部分是出站处理，把RpcMessage编码成Bytebuf对象，先把自定义协议头写到bytebuf中，再把协议体经过序列化后填充到bytebuf中</p>
<p>解码部分分为粘包半包解码器和具体解码两部分，关于粘包半包处理我使用的是Netty的定长解码器，在解码器中我设定了偏移量和消息体长度值，因为我的协议有16字节，后4字节代表消息体长度，所以偏移量是12字节，长度是4字节，解码器就通过长度字段，得出body的长度，然后从TCP流中拼接出这条完整消息，或者如果多条消息被粘在一起，Netty会按每条消息长度拆分出多条消息。然后再是具体解码，先校验是否符合我自定义协议的格式，再解出具体消息体</p>
<h2 id="讲一下Netty心跳机制和Channel的连接复用"><a href="#讲一下Netty心跳机制和Channel的连接复用" class="headerlink" title="讲一下Netty心跳机制和Channel的连接复用"></a>讲一下Netty心跳机制和Channel的连接复用</h2><p>TCP是长连接，但不会自动告诉你对方是否断线，如果一端异常断开，另一端会长时间挂起资源，会造成一定的资源浪费，所以我使用了定期的心跳检测，确认连接是否存活。我使用了netty的IdleStateHandler来实现心跳检测，当检测到写空闲时自动发送一个心跳检测数据包</p>
<p>然后在rpc框架中，如果每发一次请求就新建TCP连接，就会导致大量Socket打开关闭，并且并发高时会造成端口耗尽的问题。我在项目中使用ConcurrentHashMap存放每个<code>IP+端口号</code>使用过的Channel，如果当前IP的端口再次发起rpc请求后，检测到之前的Channel还没关闭，就可以再次使用，避免重复连接服务端</p>
<p>然后是多路复用的实现，因为同一个服务可能会发出多个不同的rpc请求，我使用一个<code>ConcurrentHashMap</code>存放每个请求的等待结果区，key是协议头中的sequenceId，value是Netty的Promise（代表一个异步响应），当响应回来时，用sequenceId找到对应的Promise完成结果，就可以做到同一个连接处理多个不同的请求。</p>
<h2 id="注册中心为什么使用Zookeeper不用Nacos"><a href="#注册中心为什么使用Zookeeper不用Nacos" class="headerlink" title="注册中心为什么使用Zookeeper不用Nacos"></a>注册中心为什么使用Zookeeper不用Nacos</h2><p>我这个RPC框架作为一个独立项目，需要自己实现服务注册&#x2F;发现、监听机制、负载均衡等功能。</p>
<ul>
<li>项目对一致性的要求更高，服务注册、注销都是临时节点，Zookeeper会在连接断开时自动清理</li>
<li>Zookeeper支持监听机制，服务节点变化能即时通知客户端，便于实现本地缓存刷新，Nacos的监听更偏配置文件，服务变化通知粒度更粗一些</li>
<li>项目使用的是Netty和SpringBoot，整体较轻量，不需要配置中心功能</li>
<li>Nacos提供了配置中心和服务注册功能，对于微服务项目来说非常适合。但我的RPC框架更偏向于底层架构搭建和分布式通信机制学习，所以我更偏向选用Zookeeper，它更容易控制细节、简洁可定制</li>
</ul>
<h2 id="服务如何注册、客户端如何发现、服务如何下线"><a href="#服务如何注册、客户端如何发现、服务如何下线" class="headerlink" title="服务如何注册、客户端如何发现、服务如何下线"></a>服务如何注册、客户端如何发现、服务如何下线</h2><p>服务注册的逻辑在服务提供端，主要流程是服务启动时，连接到Zookeeper，创建持久结点，表示这个服务，然后在持久结点下面创建临时子节点，表示提供这个服务的IP地址和端口号，临时节点中会存数据，是Json格式的服务对象，有服务名，ip地址，端口号和版本号。注册成功后，Zookeeper会维持与该服务实例的心跳连接</p>
<p>服务发现的逻辑在服务调用端，主要流程是服务启动时连接到Zookeeper，发送rpc请求时，先根据服务名查找服务。如果客户端第一次查找该服务，会从Zookeeper拉取服务列表，构建本地缓存，并设置监听器，后续若服务变化，缓存会自动更新。不是第一次的话则直接调用缓存，然后使用负载均衡算法从服务列表中选一个可用实例，返回该实例信息用于客户端建立连接并发起请求</p>
<p>服务下线分为两种情况，第一种情况是服务主动下线，服务关闭时使用注销方法将服务从Zookeeper中删除，然后客户端因为配置了监听器，会自动更新缓存列表。第二种情况是服务异常下线，因为Zookeeper有心跳机制，当检测不到这个服务时，会认为这个服务已经停止了，删除这个服务</p>
<h2 id="介绍一下客户端调用、服务端响应的一个完整流程"><a href="#介绍一下客户端调用、服务端响应的一个完整流程" class="headerlink" title="介绍一下客户端调用、服务端响应的一个完整流程"></a>介绍一下客户端调用、服务端响应的一个完整流程</h2><p>客户端通过代理类发起服务调用，动态代理类会封装请求，客户端进行服务发现，然后使用负载均衡算法选择一个服务提供者发起网络通信请求，请求成功后，使用自定义协议将信息封装为消息头和消息体，并通过编码器和序列化器转成字节数组，将数据发送到目标Channel，服务端收到数据后，进行解码和反序列化，还原消息体，然后通过反射调用目标方法，获取返回结果，再封装消息，进行编码和序列化后将字节数组通过Channel发回到客户端中，然后客户端再进行解码和反序列化获得结果。</p>
<h2 id="如果zk中的服务节点退出了，服务还能访问吗，怎么做"><a href="#如果zk中的服务节点退出了，服务还能访问吗，怎么做" class="headerlink" title="如果zk中的服务节点退出了，服务还能访问吗，怎么做"></a>如果zk中的服务节点退出了，服务还能访问吗，怎么做</h2><p>如果Zookeeper中某个服务节点退出，它注册的临时节点会自动被删除。客户端如果还用旧地址调用，就会访问失败。为避免这个问题，我在客户端实现了本地服务地址缓存和动态监听机制，保证地址列表是实时更新的。客户端在读取服务地址的时候会注册监听器，一旦某个节点下线了，Zookeeper会提交一个事件给监听器，进而更新本地缓存。但是如果是一个客户端已经请求到这个服务节点了，但是此时这个节点宕机了，那么会出现请求失败的情况，关于这种情况，我配置了失败重试策略，请求发送失败时，使用负载均衡策略切换下一个地址重试</p>
<h2 id="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信"><a href="#如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信" class="headerlink" title="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信"></a>如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信</h2><p>如果一个服务正在被请求，此时直接下线可能会导致请求失败或连接中断。我采用的是优雅下线策略，先从注册中心摘除服务，但不会马上关闭进程，等待处理中的请求完成后再关闭服务进程，保证客户端本次调用能够完成（netty的EventLoopGroup.shutdownGracefully()）</p>
<h2 id="你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别"><a href="#你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别" class="headerlink" title="你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别"></a>你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别</h2><p>我做的这个RPC框架虽然不如Dubbo、gRPC功能全面，但胜在轻量级，更适合作为学习、定制型服务通信的基础框架。同时我也实现了一些Dubbo和gRPC中的重要特性，如服务注册、序列化、连接复用、自动注入等功能。</p>
<p>当然与成熟框架相比，我的RPC框架还存在一些后续可以升级的点：</p>
<ul>
<li>服务治理能力（如限流、熔断、降级）</li>
<li>跨语言支持</li>
<li>服务可观测性（如日志链路追踪）</li>
</ul>
<h2 id="实现一个RPC框架最主要看重哪些点"><a href="#实现一个RPC框架最主要看重哪些点" class="headerlink" title="实现一个RPC框架最主要看重哪些点"></a>实现一个RPC框架最主要看重哪些点</h2><ol>
<li>通信协议的设计，协议需要清晰的定义请求和响应结构，序列化格式和状态码等数据</li>
<li>编解码和序列化，编解码和序列化的效率应该要高，然后序列化后的数据体积应该小，看具体业务判断是否需要跨语言</li>
<li>网络通信性能，阻塞式或者异步式，是否支持连接池、长连接、心跳机制</li>
<li>服务注册与发现，负载均衡，是否具备故障感知能力</li>
<li>容错与高可用机制，是否支持失败重试，熔断和降级策略</li>
<li>还有易用性和可扩展性，是否支持注解，自动装配和可插拔机制</li>
</ol>
<h2 id="本地方法调用和远程过程调用有什么区别"><a href="#本地方法调用和远程过程调用有什么区别" class="headerlink" title="本地方法调用和远程过程调用有什么区别"></a>本地方法调用和远程过程调用有什么区别</h2><p>本地方法调用是程序内的方法直接调用，属于同一个进程内的方法调用，延迟很低，调用比较可靠，不需要中间件支持，但是代码的耦合度比较高</p>
<p>远程过程调用是调用远程服务器上提供的方法，属于不同进程或者不同机器上的方法调用，需要进行网络通信，所以有网络延迟，效率相对较低，也会有网络中断，超时等异常情况，需要中间件的支持，但是做到了服务之间的解耦合</p>
<h2 id="rpc如何支持服务的熔断和降级的"><a href="#rpc如何支持服务的熔断和降级的" class="headerlink" title="rpc如何支持服务的熔断和降级的"></a>rpc如何支持服务的熔断和降级的</h2><p>熔断是如果某个服务连续调用失败，系统就会临时阻止再发起请求，防止拖垮系统，可以在rpc中引入熔断器组件Sentinel，每个服务接口调用前先经过熔断器判断是否“断路”，统计失败率、超时数等动态判断是否进入熔断状态，还可以支持闭合-&gt;半开-&gt;打开的状态转换</p>
<p>降级是如果调用失败次数太多，系统就自动返回默认数据或走备用逻辑，可以编写Fallback方法，方法调用失败&#x2F;超时后，调用备用逻辑，返回默认值</p>
<h2 id="介绍一下一致性哈希算法"><a href="#介绍一下一致性哈希算法" class="headerlink" title="介绍一下一致性哈希算法"></a>介绍一下一致性哈希算法</h2><p>如果使用简单的哈希方式，当服务节点发生变化的时候，所有请求的分发都会大范围变化，这会导致缓存失效，影响系统效率。一致性哈希算法可以做到：节点数量变化时，尽量少地影响原有请求的分配规律，就是请求一致性和低扰动性。</p>
<p>一致性哈希算法把哈希空间想象成一个环，所有服务实例都通过哈希函数映射到这个环上某个位置，对服务的ip地址，端口号以及服务名称进行hash后对一个比较大的数进行取模，对数据key也进行hash，然后顺时针找到某一个node，就是这个key要存储的服务器。这样如果增加或者删除一台服务器的话，就只会影响部分数据。但是这样做，当节点比较少的时候会造成数据倾斜的问题，大部分数据会集中在某一个服务上。我的项目中使用了虚拟节点的解决方式，每个真实节点会映射为160个虚拟节点，通过MD5算法再生成多个哈希值，映射到哈希环上，对于请求来说，使用服务方法名加请求参数拼接后做MD5，再映射成哈希值，定位到哈希环上离它最近的服务节点，当服务列表变更时，重新构建哈希环，保证一致性，然后这个重建是不会造成大批量请求映射出错的，比如某个请求落到虚拟节点 A，服务列表变了，A 还在，请求还是到 A，如果A不在了，请求会顺时针走一点落到B。</p>
<h2 id="项目中哪些地方使用到了异步"><a href="#项目中哪些地方使用到了异步" class="headerlink" title="项目中哪些地方使用到了异步"></a>项目中哪些地方使用到了异步</h2><ul>
<li>Netty的核心通信是异步的，就是所有的IO操作都是异步非阻塞的</li>
<li>发送rpc请求是异步的，可以发送消息后立刻返回，监听发送是否成功</li>
<li>接收响应也是异步的，我在发生时生成了一个id，将future对象存到HashMap里，等收到响应后再异步完成这个future</li>
</ul>
<h1 id="小程序项目"><a href="#小程序项目" class="headerlink" title="小程序项目"></a>小程序项目</h1><h2 id="你用自定义注解实现了权限控制，讲讲具体是怎么做的"><a href="#你用自定义注解实现了权限控制，讲讲具体是怎么做的" class="headerlink" title="你用自定义注解实现了权限控制，讲讲具体是怎么做的"></a>你用自定义注解实现了权限控制，讲讲具体是怎么做的</h2><p>在这个小程序中，会涉及到三种角色：管理员root，活动发起者admin和活动参与者visitor，不同角色访问系统中接口的权限是不同的。</p>
<p>在项目中我使用JWT实现用户认证，用户登录后会签发Token，并将用户信息存入上下文，作为认证依据。</p>
<p>授权部分，我设计了一个自定义注解<code>@CheckPermission</code>来标记每个接口需要的具体权限，并结合AOP实现了权限切面。切面会在方法执行前解析注解，获取当前用户权限列表，进行匹配校验。如果用户具备权限，就放行接口，否则抛出无权限异常，交由全局异常处理器处理。</p>
<h2 id="用了三级缓存，讲一下细节"><a href="#用了三级缓存，讲一下细节" class="headerlink" title="用了三级缓存，讲一下细节"></a>用了三级缓存，讲一下细节</h2><p>我的项目中使用了Caffeine、Redis和MySQL结构来优化数据访问性能，本地缓存用于存储访问最频繁的数据，活动列表和当前登录用户信息。Redis作为二级缓存，用于存储访问过的活动详情、活动列表和用户信息，最后由数据库层面，存储全部数据</p>
<p>整体流程是用户访问数据时，先查本地缓存，未命中则查Redis，如果Redis也未命中再查数据库，并将结果同步回前两级缓存。</p>
<p>关于过期策略，活动信息在Caffeine中缓存5分钟左右，在Redis中缓存30分钟左右。</p>
<p>本地缓存层面，我使用了Caffeine的<code>CacheLoader</code>和<code>refreshAfterWrite</code>来预先加载数据避免本地的缓存穿透</p>
<h2 id="数据库表是怎么设计的"><a href="#数据库表是怎么设计的" class="headerlink" title="数据库表是怎么设计的"></a>数据库表是怎么设计的</h2><p>用户表，存放用户信息和用户的角色</p>
<p>活动表，存放已经发布的活动，活动的相关信息和发起人</p>
<p>活动报名表，表示活动id和用户id之间的关系</p>
<h2 id="如何部署项目，上线流程讲一下"><a href="#如何部署项目，上线流程讲一下" class="headerlink" title="如何部署项目，上线流程讲一下"></a>如何部署项目，上线流程讲一下</h2><p>预先在yaml文件中配置好生产环境参数，然后使用maven对项目进行打包，生成jar文件，传到服务器上，使用systemd后台运行项目，然后配置Nginx，将小程序API请求代理到SpringBoot项目端口，然后配置Nginx的ssl，让小程序支持HTTPS。</p>
<p>redis和mysql都部署在同一台服务器上，SpringBoot通过配置文件连接到redis和mysql</p>
<h2 id="活动报名如果高并发，怎么防止名额超限或重复提交"><a href="#活动报名如果高并发，怎么防止名额超限或重复提交" class="headerlink" title="活动报名如果高并发，怎么防止名额超限或重复提交"></a>活动报名如果高并发，怎么防止名额超限或重复提交</h2><p>我在每个活动创建的时候，会把名额写入redis中，使用<code>DECR</code>命令，用户报名前先<code>DECR</code>名额，如果减成功则允许报名，否则失败，因为<code>DECR</code>操作是Redis原子命令，天然支持并发控制，报名成功之后我使用redis创建一个活动名加上用户id的分布式锁，表示这个用户已经报名了这个活动，然后这个设置了一个过期时间，在过期时间内我会把这个报名数据写到数据库中，后续用户再重复报名时，因为redis层面的对应数据已经过期了，就会去查询数据库是否有他的信息，如果有再返回已报名的提示，用这个方式防止名额超限和重复报名</p>
<h2 id="三级缓存的缓存一致性怎么保证"><a href="#三级缓存的缓存一致性怎么保证" class="headerlink" title="三级缓存的缓存一致性怎么保证"></a>三级缓存的缓存一致性怎么保证</h2><p>读请求是如果访问的是用户信息和首页活动列表，那么会先查询本地缓存，在查询redis，最后查询数据库，然后把数据库返回的数据存到redis和本地缓存中</p>
<p>如果访问的不是这两个，就直接查询redis，没查到再查询数据库，再写会redis。</p>
<p>写请求的话，我使用的是先更新数据库，在删除缓存的策略。</p>
<h1 id="电商项目"><a href="#电商项目" class="headerlink" title="电商项目"></a>电商项目</h1><h2 id="说一下分布式事务"><a href="#说一下分布式事务" class="headerlink" title="说一下分布式事务"></a>说一下分布式事务</h2><p>由多个服务通过网络完成一个事务叫分布式事务。</p>
<p>首先根据CAP原理决定我们的需求，是要实现CP、还是要实现AP。</p>
<p>实现CP就是要实现强一致性，可以使用 Seata 框架基于AT、TCC模式去实现。</p>
<p>我们项目中大部分实现的是AP，使用本地消息表加任务调度完成分布式事务最终数据一致性。</p>
<h2 id="项目中哪里用到了分布式事务，如何解决的"><a href="#项目中哪里用到了分布式事务，如何解决的" class="headerlink" title="项目中哪里用到了分布式事务，如何解决的"></a>项目中哪里用到了分布式事务，如何解决的</h2><ol>
<li>发布商品，发布商品需要在商品服务的数据库表中记录，同时将商品信息同步到redis和ES</li>
</ol>
<ul>
<li>发布商品使用本地事务向商品表中写入商品数据，同时写入一条待处理的消息到本地消息表</li>
<li>提交本地事务之后，xxl的调度中心使用分片广播模式向执行器下发任务，开始扫描消息表，查询待处理的消息</li>
<li>根据消息内容，通过调用Redis和ES的接口完成数据同步</li>
<li>任务完成后删除消息表记录</li>
</ul>
<ol start="2">
<li>用户下单，需要调用商品服务扣减库存，订单服务创建订单，用户服务添加购买记录</li>
</ol>
<ul>
<li>订单服务收到下单请求后，开启本地事务，生成订单记录，然后写入本地消息表，记录要通知商品服务和用户服务的消息，提交事务后，通过消息队列发送通知消息</li>
<li>商品服务和用户服务通过监听消息队列来处理库存的扣减和添加购买记录的逻辑</li>
<li>如果消息队列发送失败或者没有被消费，就会使用xxl作为定时任务调度器，每隔一段时间扫描本地消息表中的异常记录进行消息补发</li>
</ul>
<h2 id="如何进行分布式事务的回滚"><a href="#如何进行分布式事务的回滚" class="headerlink" title="如何进行分布式事务的回滚"></a>如何进行分布式事务的回滚</h2><p>我项目中采用的是一种基于本地消息表和补偿机制的最终一致性方案。没有使用传统的强一致性分布式事务框架，通过状态标记和异步处理来实现逻辑上的回滚</p>
<p>在整个业务流程中，每个关键操作都配合本地消息表记录执行状态。当某个服务执行失败时，首先在服务内部有失败重试机制，尽最大努力成功，如果重试后仍失败，会将失败消息记录转移到数据库中的事务失败表，并在消息表中更新状态字段，最后使用xxl定时扫描失败记录表，执行补偿逻辑，并且对于一致性要求比较强的场景，我还使用了消息队列进行即时的通知，xxl作为兜底</p>
<p>比如用户下单操作中，订单服务已经创建好订单了，但是后续商品扣减库存出了问题，现在想要回滚，那么首先商品服务会发送一条失败消息到消息队列中，并且将失败消息记录到数据库中，订单服务获取到之后，会修改订单表中的状态字段为失败，通过状态标记避免后续的处理</p>
<h2 id="除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路"><a href="#除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路" class="headerlink" title="除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路"></a>除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路</h2><ul>
<li>XA，两阶段提交，先准备资源，再统一提交或者回滚</li>
<li>TCC，把每个操作拆分成三部分，先预检查，再尝试获取资源，最后提交实际操作</li>
<li>SAGA，长事务补偿，将事务拆分为一系列子事务，每个子事务完成后立刻提交，如果后续事务失败，则按顺序调用每个子事务的补偿操作来回滚</li>
</ul>
<p>为什么我选择任务调度这种方式，因为我认为这个项目中主要以性能和并发为优先考虑，不适合xa和tcc，并且业务是允许最终一致性的，不是强一致性的，而且消息队列和xxl的方式比较好实现</p>
<h2 id="Elasticsearch是怎么使用的"><a href="#Elasticsearch是怎么使用的" class="headerlink" title="Elasticsearch是怎么使用的"></a>Elasticsearch是怎么使用的</h2><p>1）首先创建索引（相当于mysql的表），将商品信息添加到索引库，对商品信息进行分词，存储到索引库</p>
<p>2）在商品服务中编写商品搜索接口，调用es的rest接口根据关键字、课程分类信息进行搜索</p>
<h3 id="如何保证索引同步"><a href="#如何保证索引同步" class="headerlink" title="如何保证索引同步"></a>如何保证索引同步</h3><p>我项目是使用本地任务表加xxl-job任务调度进行索引同步</p>
<p>1）添加或修改或删除商品的同时向任务表插入一条记录，这条记录就记录了是修改了哪个课程</p>
<p>2）任务调度定时扫描任务表，根据任务表的内容对课程信息进行同步，如果添加了课程将课程添加到索引库，如果修改了课程就修改索引库的课程，如果是删除了课程将课程信息从索引库删除</p>
<h2 id="xxl-job的工作原理是什么"><a href="#xxl-job的工作原理是什么" class="headerlink" title="xxl-job的工作原理是什么"></a>xxl-job的工作原理是什么</h2><p>xxl由调度中心和执行器组成，在应用启动时，执行器会将自己注册到调度中心Admin，然后在Admin中配置定时任务，指定要调哪个Bean和方法，到达任务触发时间后，Admin通过HTTP请求调用对应的执行器，执行结果会通过回调上传给调度中心，如果失败还可以配置自动重试机制。并且如果有很多执行器，xxl还支持负载均衡策略和任务分片</p>
<p>在我的项目中，我主要使用xxl实现对本地消息表和失败记录表的定时扫描，还有对于优惠券和商品的限时抢购的时间预订功能</p>
<h2 id="如何保证任务不重复执行"><a href="#如何保证任务不重复执行" class="headerlink" title="如何保证任务不重复执行"></a>如何保证任务不重复执行</h2><p>主要有两种方式，一个是每个任务都会生成一个唯一的Id，业务层判断该任务是否已经执行过，还有每条待处理的消息记录在消息表中含有状态字段，调度器扫描任务时，通过状态判断是否执行过，避免重复触发</p>
<h2 id="未支付订单如何处理"><a href="#未支付订单如何处理" class="headerlink" title="未支付订单如何处理"></a>未支付订单如何处理</h2><p>在我的项目中使用RabbitMQ的死信队列机制处理未支付订单，用户提交订单之后，系统会向消息队列中发送一条消息，交换机配置为死信交换机，过期后，消息被路由到死信队列，然后执行取消订单，恢复库存的逻辑</p>
<h2 id="如何保证RabbitMQ的消息可靠性"><a href="#如何保证RabbitMQ的消息可靠性" class="headerlink" title="如何保证RabbitMQ的消息可靠性"></a>如何保证RabbitMQ的消息可靠性</h2><p>可靠性保证主要分为三部分，一个是生产者到消息队列的可靠性，这部分由消息确认机制保证，就是生产者发送消息后，会异步等待消息队列反馈ACK，一个是消息队列内部的可靠性，消息队列内部有持久化机制，可以将未消费消息保存到硬盘中，一个是消息队列到消费者的可靠性，这个与生产者类似，消费者接收到消息并且成功处理之后，会反馈给消息队列，然后消息队列才会把这条消息删除，如果处理失败或者一直没有处理会触发重试机制</p>
<h3 id="如何避免消息重复消费"><a href="#如何避免消息重复消费" class="headerlink" title="如何避免消息重复消费"></a>如何避免消息重复消费</h3><p>每个业务操作都有唯一ID，这个ID会随着消息一起发送到消息队列中，如果这个消息已经被消费了，就一定会在数据库中有记录，就算消费者后续反馈到消息队列的ack丢失，触发消息队列的重试机制了，消费者再次收到相同消息时也不会重复消费</p>
<h2 id="为什么选择RabbitMQ"><a href="#为什么选择RabbitMQ" class="headerlink" title="为什么选择RabbitMQ"></a>为什么选择RabbitMQ</h2><p>首先RabbitMQ支持可靠性传输机制，提供了持久化，ack确认机制，消息重试和死信机制，然后它提供了很多的消息路由类型（点对点路由、模糊匹配路由、广播路由），可以应对不同的业务场景</p>
<h2 id="项目使用Redis缓存了哪些数据"><a href="#项目使用Redis缓存了哪些数据" class="headerlink" title="项目使用Redis缓存了哪些数据"></a>项目使用Redis缓存了哪些数据</h2><p>缓存内容有商品详情、商品列表、用户信息等访问频率可能比较高的数据</p>
<p>使用的数据结构：</p>
<ul>
<li>String：商品详情</li>
<li>Hash：用户信息、购物车数据</li>
<li>List：排行榜、热门商品</li>
</ul>
<h2 id="如何保证Redis缓存一致性"><a href="#如何保证Redis缓存一致性" class="headerlink" title="如何保证Redis缓存一致性"></a>如何保证Redis缓存一致性</h2><p>对于正常读写场景，我采用的是先更新数据库，再删除缓存的方式，对于高并发写场景，我采用的是先更新缓存，再异步更新数据库的方式，高并发为了减轻数据库压力、提高写入性能，直接写缓存，再通过消息队列异步写数据库，确保最终一致</p>
<h2 id="优惠券秒杀部分怎么实现的"><a href="#优惠券秒杀部分怎么实现的" class="headerlink" title="优惠券秒杀部分怎么实现的"></a>优惠券秒杀部分怎么实现的</h2><p>秒杀的核心目标首先是保证优惠券不能超卖，同一用户不能重复领券。首先我会把券的库存预加载进Redis中，然后把校验用户身份和扣减库存这两步写到lua脚本里原子执行，然后如果redis返回成功，就会向消息队列中发一条更新数据库的消息，把优惠券写到用户信息中，这样既能流量削峰，也能保证幂等性。</p>
<h2 id="秒杀的核心瓶颈是什么"><a href="#秒杀的核心瓶颈是什么" class="headerlink" title="秒杀的核心瓶颈是什么"></a>秒杀的核心瓶颈是什么</h2><ul>
<li>高并发，瞬间就会有上万的用户访问同一个服务，可能会导致服务崩溃。可以使用令牌桶拦截多余请求，或者使用消息队列异步处理</li>
<li>库存超卖，多个用户并发抢购，有可能库存为0时仍被扣减。可以使用Redis+Lua脚本原子操作</li>
<li>数据库写入压力，秒杀成功时大量请求写入数据库。可以使用消息队列异步写入，或者分库分表缓解单表写入瓶颈</li>
<li>重复下单，在redis加一个用户id锁，然后在过期之前把优惠券持有情况写到数据库中，后续分布式锁过期了也可以保证幂等性</li>
</ul>
<h2 id="当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施"><a href="#当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施" class="headerlink" title="当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施"></a>当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施</h2><ul>
<li>首先可以在网关层限流，对IP限流，每个IP每秒不超过5次</li>
<li>然后可以在服务层限流，以用户id统计单位时间内的访问次数，超出阈值后进入冷却期，在一定时间内限制该用户的访问</li>
<li>然后在核心接口的访问使用令牌桶，用户抢到令牌才能继续请求</li>
</ul>
<h2 id="假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理"><a href="#假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理" class="headerlink" title="假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理"></a>假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理</h2><p>关于这一点，我采用了订单状态控制和幂等机制来确保流程正确性。我在设计订单支付功能时，订单表中有一个状态字段，支付成功只能从未支付转为已支付，退款只能从已支付状态进入。支付成功后立马发起退款，如果当前数据库的订单状态还没转换成未支付，说明当前的订单服务都还没执行完，就会拒绝退款，如果订单状态已经转换成已支付了，就会进入退款流程，然后把订单状态改为已退款，因为订单服务之后会走用户服务和商品服务，用户服务是一定会走的，因为用户曾经创建过这个订单，然后商品服务的话会执行恢复库存这样的操作</p>
<h2 id="订单失败如何给用户进行反馈的"><a href="#订单失败如何给用户进行反馈的" class="headerlink" title="订单失败如何给用户进行反馈的"></a>订单失败如何给用户进行反馈的</h2><p>用户下单请求是通过接口发起的，在Controller层会捕获所有异常情况，如果业务逻辑执行失败，后端会返回统一格式的失败响应结构，前端拿到响应后通过异常响应信息提示用户。在订单表中有一个状态字段，每个订单可能的到达的状态在字段中都有记录，无论哪一步失败，都会更新订单状态字段，保障用户能获取订单失败的原因</p>
<h2 id="当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做"><a href="#当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做" class="headerlink" title="当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做"></a>当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做</h2><p>首先将先将失败订单进行归类管理，为后续调度处理提供依据，比如超时未支付，扣库存失败等情况，每一类对应着不同的处理策略</p>
<p>然后为每个服务维护一张失败任务表，记录异常信息与状态字段，用xxl定时扫描任务表，使用分片广播模式将任务分发到多个执行器实例，每次任务执行前先通过订单状态字段判断是否已经处理保证幂等性，高并发场景下，也可结合分布式锁，确保订单只被一个任务执行，对处理失败的任务，支持自动重试机制，配置最大重试次数，失败次数超过阈值后自动转为人工处理，处理完成后更新订单状态，防止重复处理</p>
<h2 id="项目中的线程池使用什么方式创建的"><a href="#项目中的线程池使用什么方式创建的" class="headerlink" title="项目中的线程池使用什么方式创建的"></a>项目中的线程池使用什么方式创建的</h2><p>在项目中我使用的是Java原生的ThreadPoolExecutor，核心线程数我选择的是CPU核心数的两倍，最大线程数我用的核心线程数的两倍，非核心线程存活时间我设置的是一分钟，任务队列我用的有界数组队列，长度2000，拒绝策略使用的CallerRunsPolicy，当前线程执行任务。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">楪舞飞祈</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/inori/b4ace844.html">http://example.com/inori/b4ace844.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">楪祈のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://api.suyanw.cn/api/comic3.php" data-sites="qq,wechat,twitter,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/inori/2408437c.html" title="基于Netty的RPC框架实现"><img class="cover" src="/img/loading.gif" data-original="https://imgapi.xl0408.top/index.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">基于Netty的RPC框架实现</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">楪舞飞祈</div><div class="author-info__description">星座になれたら。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">69</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/inori-320"><i class="fab fa-github"></i><span>My GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:719471785@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p align="center" color="brown">多读书，多看报，少吃零食，多睡觉。</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">RPC项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9ARPC%E9%A1%B9%E7%9B%AE"><span class="toc-number">1.1.</span> <span class="toc-text">为什么要做RPC项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%9C%89%E4%BB%80%E4%B9%88%E9%9A%BE%E7%82%B9%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="toc-number">1.2.</span> <span class="toc-text">项目有什么难点，如何解决的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8Netty%E5%81%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.</span> <span class="toc-text">为什么用Netty做网络通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E3%80%81socket%E3%80%81netty%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">http、socket、netty三种网络通信方式的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E3%80%81JSON%E3%80%81Protostuff%E3%80%81Hession%E3%80%81Kryo%E4%BA%94%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.6.</span> <span class="toc-text">讲一下自定义协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">讲一下编解码器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BNetty%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E5%92%8CChannel%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%A4%8D%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">讲一下Netty心跳机制和Channel的连接复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Zookeeper%E4%B8%8D%E7%94%A8Nacos"><span class="toc-number">1.9.</span> <span class="toc-text">注册中心为什么使用Zookeeper不用Nacos</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E3%80%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E3%80%81%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E4%B8%8B%E7%BA%BF"><span class="toc-number">1.10.</span> <span class="toc-text">服务如何注册、客户端如何发现、服务如何下线</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%B0%83%E7%94%A8%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%93%8D%E5%BA%94%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">1.11.</span> <span class="toc-text">介绍一下客户端调用、服务端响应的一个完整流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9Czk%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9%E9%80%80%E5%87%BA%E4%BA%86%EF%BC%8C%E6%9C%8D%E5%8A%A1%E8%BF%98%E8%83%BD%E8%AE%BF%E9%97%AE%E5%90%97%EF%BC%8C%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">1.12.</span> <span class="toc-text">如果zk中的服务节点退出了，服务还能访问吗，怎么做</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%A2%AB%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E6%96%B9%E5%87%86%E5%A4%87%E4%B8%8B%E7%BA%BF%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E6%96%B9%E6%B3%95%E8%83%BD%E4%BF%9D%E8%AF%81%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%99%E6%AC%A1%E8%83%BD%E6%AD%A3%E5%B8%B8%E9%80%9A%E4%BF%A1"><span class="toc-number">1.13.</span> <span class="toc-text">如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%81%9A%E7%9A%84rpc%E9%A1%B9%E7%9B%AE%E4%B8%8E%E7%9B%AE%E5%89%8D%E4%B8%BB%E6%B5%81%E7%9A%84rpc%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%E6%88%96%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARPC%E6%A1%86%E6%9E%B6%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9C%8B%E9%87%8D%E5%93%AA%E4%BA%9B%E7%82%B9"><span class="toc-number">1.15.</span> <span class="toc-text">实现一个RPC框架最主要看重哪些点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.</span> <span class="toc-text">本地方法调用和远程过程调用有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rpc%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%86%94%E6%96%AD%E5%92%8C%E9%99%8D%E7%BA%A7%E7%9A%84"><span class="toc-number">1.17.</span> <span class="toc-text">rpc如何支持服务的熔断和降级的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.18.</span> <span class="toc-text">介绍一下一致性哈希算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BD%BF%E7%94%A8%E5%88%B0%E4%BA%86%E5%BC%82%E6%AD%A5"><span class="toc-number">1.19.</span> <span class="toc-text">项目中哪些地方使用到了异步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">小程序项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%EF%BC%8C%E8%AE%B2%E8%AE%B2%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="toc-number">2.1.</span> <span class="toc-text">你用自定义注解实现了权限控制，讲讲具体是怎么做的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BA%86%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%8C%E8%AE%B2%E4%B8%80%E4%B8%8B%E7%BB%86%E8%8A%82"><span class="toc-number">2.2.</span> <span class="toc-text">用了三级缓存，讲一下细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E7%9A%84"><span class="toc-number">2.3.</span> <span class="toc-text">数据库表是怎么设计的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%EF%BC%8C%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B%E8%AE%B2%E4%B8%80%E4%B8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">如何部署项目，上线流程讲一下</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E6%8A%A5%E5%90%8D%E5%A6%82%E6%9E%9C%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%8C%E6%80%8E%E4%B9%88%E9%98%B2%E6%AD%A2%E5%90%8D%E9%A2%9D%E8%B6%85%E9%99%90%E6%88%96%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4"><span class="toc-number">2.5.</span> <span class="toc-text">活动报名如果高并发，怎么防止名额超限或重复提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81"><span class="toc-number">2.6.</span> <span class="toc-text">三级缓存的缓存一致性怎么保证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE"><span class="toc-number">3.</span> <span class="toc-text">电商项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">说一下分布式事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E4%BA%86%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%9A%84"><span class="toc-number">3.2.</span> <span class="toc-text">项目中哪里用到了分布式事务，如何解决的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9E%E6%BB%9A"><span class="toc-number">3.3.</span> <span class="toc-text">如何进行分布式事务的回滚</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E6%9C%AC%E5%9C%B0%E4%BF%A1%E6%81%AF%E8%A1%A8%E5%8A%A0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E4%BF%9D%E8%AF%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E6%80%9D%E8%B7%AF%E5%8E%BB%E5%81%9A%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E8%BF%99%E7%A7%8D%E6%80%9D%E8%B7%AF"><span class="toc-number">3.4.</span> <span class="toc-text">除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Elasticsearch%E6%98%AF%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E7%9A%84"><span class="toc-number">3.5.</span> <span class="toc-text">Elasticsearch是怎么使用的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%B4%A2%E5%BC%95%E5%90%8C%E6%AD%A5"><span class="toc-number">3.5.1.</span> <span class="toc-text">如何保证索引同步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xxl-job%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.6.</span> <span class="toc-text">xxl-job的工作原理是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BB%BB%E5%8A%A1%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%89%A7%E8%A1%8C"><span class="toc-number">3.7.</span> <span class="toc-text">如何保证任务不重复执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%94%AF%E4%BB%98%E8%AE%A2%E5%8D%95%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">3.8.</span> <span class="toc-text">未支付订单如何处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81RabbitMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">3.9.</span> <span class="toc-text">如何保证RabbitMQ的消息可靠性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9"><span class="toc-number">3.9.1.</span> <span class="toc-text">如何避免消息重复消费</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9RabbitMQ"><span class="toc-number">3.10.</span> <span class="toc-text">为什么选择RabbitMQ</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8Redis%E7%BC%93%E5%AD%98%E4%BA%86%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE"><span class="toc-number">3.11.</span> <span class="toc-text">项目使用Redis缓存了哪些数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">3.12.</span> <span class="toc-text">如何保证Redis缓存一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%88%B8%E7%A7%92%E6%9D%80%E9%83%A8%E5%88%86%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">3.13.</span> <span class="toc-text">优惠券秒杀部分怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E7%9A%84%E6%A0%B8%E5%BF%83%E7%93%B6%E9%A2%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.14.</span> <span class="toc-text">秒杀的核心瓶颈是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E6%9C%89%E4%BA%BA%E6%81%B6%E6%84%8F%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E5%A4%9A%E5%8F%B0%E6%9C%BA%E5%99%A8%E5%A4%9A%E4%B8%AA%E8%B4%A6%E5%8F%B7%E5%8E%BB%E8%BF%9B%E8%A1%8C%E6%8A%A2%E8%B4%AD%EF%BC%8C%E8%BE%BE%E5%88%B0%E4%B8%80%E4%B8%AA%E5%8D%81%E5%87%A0%E4%B8%87%E7%9A%84%E5%B9%B6%E5%8F%91%E9%87%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E5%81%9A%E9%99%90%E6%B5%81%E6%8E%AA%E6%96%BD"><span class="toc-number">3.15.</span> <span class="toc-text">当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E5%BD%93%E6%9C%89%E4%BA%BA%E6%94%AF%E4%BB%98%E6%88%90%E5%8A%9F%E5%90%8E%E7%AB%8B%E9%A9%AC%E5%8F%88%E5%8F%91%E8%B5%B7%E4%BA%86%E9%80%80%E6%AC%BE%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%98%E6%B2%A1%E6%9C%89%E5%AE%8C%E6%88%90%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%8C%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">3.16.</span> <span class="toc-text">假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A2%E5%8D%95%E5%A4%B1%E8%B4%A5%E5%A6%82%E4%BD%95%E7%BB%99%E7%94%A8%E6%88%B7%E8%BF%9B%E8%A1%8C%E5%8F%8D%E9%A6%88%E7%9A%84"><span class="toc-number">3.17.</span> <span class="toc-text">订单失败如何给用户进行反馈的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E6%9C%89%E5%A4%A7%E9%87%8F%E5%A4%B1%E8%B4%A5%E8%AE%A2%E5%8D%95%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E6%9D%A5%E8%AE%BE%E8%AE%A1%E5%A6%82%E4%BD%95%E5%8E%BB%E8%B0%83%E5%BA%A6%E5%A4%84%E7%90%86%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">3.18.</span> <span class="toc-text">当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%9A%84"><span class="toc-number">3.19.</span> <span class="toc-text">项目中的线程池使用什么方式创建的</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/inori/b4ace844.html" title="项目常见问题梳理（持续更新中）"><img src="/img/loading.gif" data-original="https://api.suyanw.cn/api/comic3.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目常见问题梳理（持续更新中）"/></a><div class="content"><a class="title" href="/inori/b4ace844.html" title="项目常见问题梳理（持续更新中）">项目常见问题梳理（持续更新中）</a><time datetime="2025-05-31T08:17:54.000Z" title="发表于 2025-05-31 16:17:54">2025-05-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/inori/2408437c.html" title="基于Netty的RPC框架实现"><img src="/img/loading.gif" data-original="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="基于Netty的RPC框架实现"/></a><div class="content"><a class="title" href="/inori/2408437c.html" title="基于Netty的RPC框架实现">基于Netty的RPC框架实现</a><time datetime="2025-05-28T02:53:58.000Z" title="发表于 2025-05-28 10:53:58">2025-05-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/inori/4840342e.html" title="Netty常见问题"><img src="/img/loading.gif" data-original="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty常见问题"/></a><div class="content"><a class="title" href="/inori/4840342e.html" title="Netty常见问题">Netty常见问题</a><time datetime="2025-05-25T09:02:19.000Z" title="发表于 2025-05-25 17:02:19">2025-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/inori/25b752cd.html" title="Netty优化"><img src="/img/loading.gif" data-original="https://api.suyanw.cn/api/comic3.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty优化"/></a><div class="content"><a class="title" href="/inori/25b752cd.html" title="Netty优化">Netty优化</a><time datetime="2025-05-25T06:54:55.000Z" title="发表于 2025-05-25 14:54:55">2025-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/inori/56930530.html" title="Netty进阶篇"><img src="/img/loading.gif" data-original="https://api.suyanw.cn/api/comic3.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Netty进阶篇"/></a><div class="content"><a class="title" href="/inori/56930530.html" title="Netty进阶篇">Netty进阶篇</a><time datetime="2025-05-22T01:59:31.000Z" title="发表于 2025-05-22 09:59:31">2025-05-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://api.suyanw.cn/api/comic3.php')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 楪舞飞祈</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas id="snow"></canvas><script async src="/js/snow.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>