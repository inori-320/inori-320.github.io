<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM垃圾回收机制 | 楪祈のBlog</title><meta name="author" content="楪舞飞祈"><meta name="copyright" content="楪舞飞祈"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM垃圾回收部分">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM垃圾回收机制">
<meta property="og:url" content="http://ltynote.cn/inori/4af053c8.html">
<meta property="og:site_name" content="楪祈のBlog">
<meta property="og:description" content="JVM垃圾回收部分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imgapi.xl0408.top/index.php">
<meta property="article:published_time" content="2025-03-14T04:55:14.000Z">
<meta property="article:modified_time" content="2025-03-14T06:59:36.365Z">
<meta property="article:author" content="楪舞飞祈">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgapi.xl0408.top/index.php"><link rel="shortcut icon" href="/img/favicon_32.png"><link rel="canonical" href="http://ltynote.cn/inori/4af053c8.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM垃圾回收机制',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-14 14:59:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/rss2.xml" title="楪祈のBlog" type="application/rss+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://imgapi.xl0408.top/index.php')"><nav id="nav"><span id="blog-info"><a href="/" title="楪祈のBlog"><span class="site-name">楪祈のBlog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM垃圾回收机制</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-14T04:55:14.000Z" title="发表于 2025-03-14 12:55:14">2025-03-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-14T06:59:36.365Z" title="更新于 2025-03-14 14:59:36">2025-03-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM垃圾回收机制"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Java会自动管理和释放内存，它不像C&#x2F;C++那样要求我们手动管理内存，JVM提供了一套全自动的内存管理机制，当一个Java对象不再用到时，JVM会自动将其进行回收并释放内存，那么对象所占内存在什么时候被回收，如何判定对象可以被回收，以及如何去进行回收工作也是JVM需要关注的问题。</p>
<h2 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h2><p>对象在什么情况下可以被判定为不再使用已经可以回收了？</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>如果要经常操作一个对象，那么首先一定会创建一个引用变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str就是一个引用类型的变量，它持有对后面字符串对象的引用，可以代表后面这个字符串对象本身</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>只要一个对象还有使用价值，就可以通过它的引用变量来进行操作，那么可否这样判断一个对象是否还需要被使用：</p>
<ul>
<li>每个对象都包含一个引用计数器，用于存放引用计数（存放被引用的次数）</li>
<li>每当有一个地方引用此对象时，引用计数<code>+1</code></li>
<li>当引用失效（比如离开了局部变量的作用域或是引用被设定为<code>null</code>）时，引用计数<code>-1</code></li>
<li>当引用计数为<code>0</code>时，表示此对象不可能再被使用，因为这时我们已经没有任何方法可以得到此对象的引用了</li>
</ul>
<p>但是这样存在一个问题，如果两个对象相互引用呢？                  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        a.another = b;</span><br><span class="line">        b.another = a;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里直接把a和b赋值为null，这样前面的两个对象我们不可能再得到了</span></span><br><span class="line">        a = b = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        Test another;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照引用计数算法，那么当出现以上情况时，虽然无法得到此对象的引用，并且此对象也无需再使用，但是由于这两个对象直接存在相互引用的情况，那么引用计数器的值将会永远是<code>1</code>，永远不会被回收，引用计数法并不是最好的解决方案。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>目前比较主流的编程语言，一般都会使用可达性分析算法来判断对象是否存活，它采用了类似于树结构的搜索机制。</p>
<p>首先每个对象的引用都有机会成为树的根节点（GC Roots），可以被选定作为根节点条件如下：</p>
<ul>
<li><strong>虚拟机栈中的局部变量</strong>：当前正在执行的方法中的局部变量引用的对象</li>
<li><strong>方法区中的静态变量</strong>：类的静态成员变量引用的对象。</li>
<li><strong>方法区中的常量</strong>：运行时常量池中的常量引用的对象（如字符串常量）</li>
<li><strong>本地方法栈中的 JNI 引用</strong>：Native 方法引用的对象</li>
<li><strong>被添加了锁的对象</strong>：比如synchronized关键字</li>
<li><strong>JVM 内部的特殊对象</strong>：如基本数据类型对应的 Class 对象、异常对象等</li>
</ul>
<p>一旦已经存在的根节点不满足存在的条件时，那么根节点与对象之间的连接将被断开。此时虽然对象1仍存在对其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。只要某个对象无法到达任何GC Roots，则证明此对象是不可能再被使用的，就可以被回收。</p>
<h3 id="最终判定"><a href="#最终判定" class="headerlink" title="最终判定"></a>最终判定</h3><p>虽然在经历了可达性分析算法之后基本可能判定哪些对象能够被回收，但是并不代表此对象一定会被回收，我们依然可以在最终判定阶段对其进行挽留。</p>
<p><code>finalize()</code>是 Java 中的一个对象生命周期方法，定义在<code>Object</code>类中。它允许对象在垃圾回收之前执行一些清理操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called by the garbage collector on an object when garbage collection</span></span><br><span class="line"><span class="comment"> * determines that there are no more references to the object.</span></span><br><span class="line"><span class="comment"> * A subclass overrides the &#123;<span class="doctag">@code</span> finalize&#125; method to dispose of</span></span><br><span class="line"><span class="comment"> * system resources or to perform other cleanup.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>如果子类重写了此方法，那么子类对象在被判定为可回收时，会进行二次确认，也就是执行<code>finalize()</code>方法，而在此方法中，当前对象是完全有可能重新建立GC Roots的。</p>
<p>所以，如果在二次确认后对象不满足可回收的条件，那么此对象不会被回收，巧妙地逃过了垃圾回收的命运。比如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里直接把a赋值为null，这样前面的对象不可能再得到了</span></span><br><span class="line">        a  = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动申请执行垃圾回收操作（注意只是申请，并不一定会执行，但是一般情况下都会执行）</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等垃圾回收</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(a);	<span class="comment">// 仍然没有被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            a = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>finalize()</code>方法并不是在主线程调用的，而是虚拟机自动建立的一个<strong>低优先级</strong>的<code>Finalizer</code>线程进行处理。同一个对象的<code>finalize()</code>方法只会有一次调用机会，也就是说，如果连续两次这样操作，那么第二次，对象必定被回收：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    a = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    <span class="comment">// 再来一次</span></span><br><span class="line">    a = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(a);	<span class="comment">// a没了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，<code>finalize()</code>方法也并不是专门防止对象被回收的，我们可以使用它来释放一些程序使用中的资源等。<code>finalize()</code>方法的使用需要非常谨慎，因为它可能导致性能问题和不可预测的行为。</p>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>垃圾收集器会不定期地检查堆中的对象，查看它们是否满足被回收的条件。我们该如何对这些对象进行回收？</p>
<h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记清楚算法会标记出所有需要回收的对象，然后再依次回收掉被标记的对象，或是标记出所有不需要回收的对象，只回收未标记的对象。</p>
<p><img src="/img/loading.gif" data-original="/inori/4af053c8/clear.png" alt="clear"></p>
<p>虽然此方法非常简单，但是缺点也是非常明显的 ，首先如果内存中存在大量的对象，那么可能就会存在大量的标记，并且大规模进行清除。</p>
<p>并且一次标记清除之后，连续的内存空间可能会出现许许多多的空隙，碎片化会导致连续内存空间利用率降低</p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>标记复制算法就是将内存区域划分为大小相同的两块区域，每次只使用其中的一块区域，每次垃圾回收结束后，将所有存活的对象全部复制到另一块区域中，并一次性清空当前区域。虽然浪费了一些时间进行复制操作，但是这样能够很好地解决对象大面积回收后空间碎片化严重的问题</p>
<p><img src="/img/loading.gif" data-original="/inori/4af053c8/copy.png" alt="copy"></p>
<p>这种算法非常适用于新生代（因为新生代的回收效率极高，一般不会留下太多的对象）的垃圾回收，新生代Survivor区就是这个思路，包括8:1:1的比例也正是为了对标记复制算法进行优化而采取的</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>虽然标记-复制算法能够很好地应对新生代高回收率的场景，但是放到老年代，它就显得很鸡肋了。一般长期不回收的对象，才有机会进入到老年代，所以老年代一般都是些钉子户，可能一次GC后，仍然存留很多对象。而标记复制算法会在GC后完整复制整个区域内容，并且会折损50%的区域，显然这并不适用于老年代。</p>
<p>标记整理算法在标记所有待回收对象之后，不急着去进行回收操作，而是将所有待回收的对象整齐排列在一段内存空间中，而需要回收的对象全部往后丢，这样，前半部分的所有对象都是无需进行回收的，而后半部分直接一次性清除即可。</p>
<p><img src="/img/loading.gif" data-original="/inori/4af053c8/mark_clean.png" alt="mark_clean"></p>
<p>虽然这样能保证内存空间充分使用，并且也没有标记复制算法那么繁杂，但是缺点是效率比前两者都低。甚至，由于需要修改对象在内存中的位置，此时程序必须要暂停才可以，在极端情况下，可能会导致整个程序发生停顿</p>
<p>一般将标记清除算法和标记整理算法混合使用，在内存空间还不是很凌乱的时候，采用标记清除算法，当内存空间凌乱到一定程度后，进行一次标记整理算法</p>
<h3 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h3><p>JVM将堆内存划分为<strong>新生代</strong>、<strong>老年代</strong>和<strong>永久代</strong>（其中永久代是HotSpot虚拟机特有的概念，在JDK8之前方法区实际上就是采用的永久代作为实现，而在JDK8之后，方法区由<strong>元空间</strong>实现，并且使用的是本地内存，容量大小取决于物理机实际大小）</p>
<p>不同的分代内存回收机制也存在一些不同之处，在HotSpot虚拟机中，新生代被划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1，老年代的GC评率相对较低，永久代一般存放类信息等（其实就是方法区的实现）</p>
<p><img src="/img/loading.gif" data-original="/inori/4af053c8/heap_memo.png" alt="heap_memo"></p>
<p>新生代</p>
<ul>
<li>存放新创建的对象</li>
<li>特点：<ul>
<li>大多数对象的生命周期很短，因此新生代是垃圾回收最频繁的区域</li>
<li>新生代采用<u>标记-复制算法</u>进行垃圾回收</li>
</ul>
</li>
<li>分区：<ul>
<li><strong>Eden区</strong>：新创建的对象首先分配到 Eden 区</li>
<li><strong>Survivor区</strong>：分为 <code>From</code> 区和 <code>To</code> 区，用于存放经过垃圾回收后仍然存活的对象</li>
</ul>
</li>
</ul>
<p>老年代</p>
<ul>
<li>存放生命周期较长的对象</li>
<li>特点：<ul>
<li>对象在新生代经过多次垃圾回收后仍然存活，会被晋升到老年代</li>
<li>老年代的垃圾回收频率较低，但每次回收的时间较长</li>
<li>老年代采用<u>标记-清除算法</u>或<u>标记-整理算法</u>进行垃圾回收</li>
</ul>
</li>
</ul>
<p>新生代的垃圾回收称为<strong>Minor GC</strong>：</p>
<p>首先，所有新创建的对象，在一开始都会进入到新生代的Eden区（如果是大对象会被直接丢进老年代），在进行新生代区域的垃圾回收时，首先会对所有新生代区域的对象进行扫描，并回收那些不再使用对象</p>
<p>接着，在一次垃圾回收之后，Eden区域没有被回收的对象，会进入到Survivor区。在一开始From和To都是空的，而GC之后，所有Eden区域存活的对象都会直接被放入到To区，最后From和To会发生一次交换，即From区是有数据的，To区是空的</p>
<p>下一次垃圾回收操作与上面是一样的，不过这时由于我们From区域中已经存在对象了，所有From区的对象会进行一次年龄判定（每经历一轮GC年龄<code>+1</code>，如果对象的年龄大于<code>默认值为15</code>，会直接进入到老年代），在Eden区和From区的存活对象复制到To区之后，清空Eden区和From区，交换From区和To区</p>
<p><strong>Major GC</strong>是针对老年代（Old Generation）的垃圾回收：</p>
<p>当老年代空间不足时，从GC Roots开始，标记老年代中的存活对象，使用标记-清除算法清除未标记的对象，再用整理算法将存活对象整理到内存的一端，避免内存碎片</p>
<p>Full GC 是对整个堆内存（包括新生代、老年代和元空间的垃圾回收：</p>
<p>触发条件：</p>
<ul>
<li><strong>老年代空间不足</strong>：当老年代无法容纳从新生代晋升的对象时，触发 Full GC。</li>
<li><strong>元空间空间不足</strong>：当元空间无法分配新的类元数据时，触发 Full GC。</li>
<li>**显式调用 System.gc()**：调用 <code>System.gc()</code> 可能触发 Full GC，但 JVM 不保证立即执行。</li>
</ul>
<p>过程：</p>
<ol>
<li>新生代回收<ul>
<li>执行 Minor GC，回收新生代中的垃圾</li>
</ul>
</li>
<li>老年代回收<ul>
<li>执行 Major GC，回收老年代中的垃圾</li>
</ul>
</li>
<li>元空间回收<ul>
<li>回收不再使用的类元数据</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>Minor GC</strong></th>
<th><strong>Major GC</strong></th>
<th><strong>Full GC</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>回收区域</strong></td>
<td>新生代（Eden 区、Survivor 区）。</td>
<td>老年代。</td>
<td>整个堆内存（新生代、老年代）和元空间。</td>
</tr>
<tr>
<td><strong>触发条件</strong></td>
<td>Eden 区空间不足。</td>
<td>老年代空间不足。</td>
<td>老年代空间不足、元空间空间不足、显式调用 <code>System.gc()</code>。</td>
</tr>
<tr>
<td><strong>频率</strong></td>
<td>高，因为大多数对象的生命周期很短。</td>
<td>低，因为老年代的对象生命周期较长。</td>
<td>低，触发条件较为严格。</td>
</tr>
<tr>
<td><strong>速度</strong></td>
<td>快，采用复制算法。</td>
<td>慢，采用标记-清除或标记-整理算法。</td>
<td>最慢，需要处理整个堆内存和元空间。</td>
</tr>
<tr>
<td><strong>暂停时间</strong></td>
<td>短，对应用程序的影响较小。</td>
<td>较长，对应用程序的影响较大。</td>
<td>最长，对应用程序的影响最大。</td>
</tr>
</tbody></table>
<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>思考一下，有没有这样一种极端情况（正常情况下新生代的回收率是很高的，所以说不用太担心会经常出现这种问题），在一次GC后，新生代Eden区仍然存在大量的对象超出Survivor区的容量，那么该怎么办？</p>
<p>这时就需要用到空间分配担保机制了，可以把Survivor区无法容纳的对象直接送到老年代，让老年代进行分配担保</p>
<p>要是老年代也装不下新生代的数据呢？</p>
<p>这样的话，首先会判断一下<u>之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间</u></p>
<ul>
<li>如果小于，那么说明<strong>也许</strong>可以放得下</li>
<li>否则，会先来一次Full GC，进行一次大规模垃圾回收，尝试腾出空间，再次判断老年代是否有空间存放</li>
<li>要是还是装不下，抛出Out Of Memory异常</li>
</ul>
<h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>JDK8之前，Hotspot虚拟机的方法区是永久代实现的。在JDK8之后不再使用永久代，而是采用了全新的元空间，元空间主要用于存储以下内容：</p>
<ol>
<li><strong>类的元数据</strong><ul>
<li>类的全限定名</li>
<li>类的父类、接口信息</li>
<li>类的字段、方法、字节码等</li>
</ul>
</li>
<li><strong>运行时常量池</strong><ul>
<li>字符串常量、数字常量等</li>
</ul>
</li>
<li><strong>方法区内容</strong></li>
</ol>
<p>元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。元空间中的类元数据在类卸载时会被垃圾回收，且垃圾回收效率比永久代更高</p>
<p><img src="/img/loading.gif" data-original="/inori/4af053c8/jvm2.png" alt="jvm2"></p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>这是一款单线程的垃圾收集器，也就是说，当开始进行垃圾回收时，需要暂停所有的线程，直到垃圾收集工作结束。它的新生代收集算法采用的是标记复制算法，老年代采用的是标记整理算法。</p>
<img src="/img/loading.gif" data-original="/inori/4af053c8/serial.png" alt="serial" style="zoom:50%;">

<p>这个收集器的缺点是当进入到垃圾回收阶段时，所有的用户线程必须等待GC线程完成工作</p>
<p>但是在用户的桌面应用场景中，内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的，所以，在客户端模式（一般用于一些桌面级图形化界面应用程序）下的新生代中，默认垃圾收集器至今依然是Serial收集器</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>这款垃圾收集器相当于是Serial收集器的多线程版本，它能够支持多线程垃圾收集</p>
<img src="/img/loading.gif" data-original="/inori/4af053c8/parnew.png" alt="parnew" style="zoom:50%;">

<p>除了多线程支持以外，其他内容基本与Serial收集器一致，目前某些JVM默认的服务端模式新生代收集器就是使用的ParNew收集器</p>
<h3 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge&#x2F;Parallel Old收集器"></a>Parallel Scavenge&#x2F;Parallel Old收集器</h3><p>与ParNew收集器不同的是，它会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间，这种自适应机制，能够很好地权衡当前机器的性能，根据性能选择最优方案</p>
<p>吞吐量&#x3D;应用程序运行时间&#x2F;总时间（应用程序运行时间 + 垃圾回收时间)×100%，目标是尽可能提高吞吐量，即让应用程序的运行时间占比最大化。</p>
<ul>
<li>垃圾回收器会监控应用程序的运行时间和垃圾回收时间。</li>
<li>如果垃圾回收时间占比超过目标值，垃圾回收器会调整垃圾回收的频率和每次回收的时间，以确保吞吐量目标</li>
<li>如果吞吐量低于目标值，垃圾回收器可能会减少垃圾回收的频率，延长每次垃圾回收的时间</li>
<li>如果吞吐量高于目标值，垃圾回收器可能会增加垃圾回收的频率，缩短每次垃圾回收的时间</li>
</ul>
<img src="/img/loading.gif" data-original="/inori/4af053c8/parallel.png" alt="parallel" style="zoom:50%;">

<p>目前JDK8采用的就是这种 Parallel Scavenge + Parallel Old的垃圾回收方案</p>
<h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是HotSpot虚拟机中第一款真正意义上的并发（注意这里的并发和之前的并行是有区别的，并发可以理解为同时运行用户线程和GC线程，而并行可以理解为多条GC线程同时工作）收集器，它第一次实现了让垃圾收集线程与用户线程同时工作，他主要采用标记清除算法。</p>
<img src="/img/loading.gif" data-original="/inori/4af053c8/cms.png" alt="cms" style="zoom:50%;">

<p>它的垃圾回收分为4个阶段：</p>
<ul>
<li>初始标记（需要暂停用户线程）：这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象，速度比较快，不用担心会停顿太长时间</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与应用程序并发运行</li>
<li>重新标记（需要暂停用户线程）：修正并发标记期间因应用程序运行而导致的标记变化</li>
<li>并发清除：最后就可以直接将所有标记好的无用对象进行删除，因为这些对象程序中也用不到了，所以可以与用户线程并发运行</li>
<li>并发重置：重置CMS收集器的内部状态，为下一次垃圾回收做准备</li>
</ul>
<p>虽然它的优点非常之大，但是缺点也是显而易见的，我们之前说过，标记清除算法会产生大量的内存碎片，导致可用连续空间逐渐变少，长期这样下来，会有更高的概率触发Full GC，并且在与用户线程并发执行的情况下，也会占用一部分的系统资源，导致用户线程的运行速度一定程度上减慢</p>
<p>从JDK9开始，CMS收集器被标记为弃用（Deprecated），在JDK14中完全移除</p>
<h3 id="Garbage-First-G1-收集器"><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First (G1) 收集器"></a>Garbage First (G1) 收集器</h3><p>它是一款主要面向于服务端的垃圾收集器，并且在JDK9时，取代了JDK8默认的Parallel Scavenge + Parallel Old的回收方案</p>
<p>垃圾回收分为<code>Minor GC</code>、<code>Major GC </code>和<code>Full GC</code>，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而G1收集器绕过了这些，它将整个Java堆划分成多个大小相同的独立<code>Region</code>块，每个<code>Region</code>块的大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且都为2的N次幂。所有的<code>Region</code>大小相同，且在JVM的整个生命周期内不会发生改变，G1优先回收垃圾最多的区域</p>
<p>每一个<code>Region</code>都可以根据需要，自由决定扮演哪个角色（Eden、Survivor和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1收集器还存在一个<code>Humongous</code>区域，它专门用于存放大对象（一般认为大小超过了Region容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的</p>
<img src="/img/loading.gif" data-original="/inori/4af053c8/g1.png" alt="g1" style="zoom:50%;">

<p>回收过程与CMS大体类似，分为以下四个步骤：</p>
<ul>
<li>初始标记（暂停用户线程）：仅仅只是标记GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿</li>
<li>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行</li>
<li>最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象</li>
<li>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的</li>
</ul>
<img src="/img/loading.gif" data-original="/inori/4af053c8/g1_process.png" alt="g1_process" style="zoom:50%;">



<h2 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h2><p>在Java中，如果变量是一个对象类型的，那么它实际上存放的是对象的引用，但是如果是一个基本类型，那么存放的就是基本类型的值。平时代码中类似于<code>Object o = new Object()</code>这样的的引用类型，细分之后可以称为<code>强引用</code>。</p>
<p>当JVM内存空间不足时，JVM宁愿抛出OutOfMemoryError使程序异常终止，也不会靠随意回收具有强引用的存活对象来解决内存不足的问题</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用不像强引用那样不可回收，当JVM认为内存不足时，会去试图回收软引用指向的对象，即JVM会确保在抛出<code>OutOfMemoryError</code>之前，清理软引用指向的对象。如果内存充足，是不会轻易被回收的</p>
<p>可以通过以下方式来创建一个软引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//强引用写法：Object obj = new Object();</span></span><br><span class="line">        <span class="comment">//软引用写法：</span></span><br><span class="line">        SoftReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        <span class="comment">//使用get方法就可以获取到软引用所指向的对象了</span></span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>软引用还存在一个带队列的构造方法，软引用可以和一个引用队列联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用本身加入到与之关联的引用队列中</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用比软引用的生命周期还要短，在进行垃圾回收时，不管当前内存空间是否充足，都会回收它的内存</p>
<p>创建一个弱引用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方法和软引用是差不多的，但是如果在这之前进行一次GC：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动GC</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;软引用对象：&quot;</span>+softReference.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;弱引用对象：&quot;</span>+weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>弱引用对象被回收了，而软引用对象没有被回收。同样的，它也支持ReferenceQueue，和软引用用法一致。</p>
<p><code>WeakHashMap</code>是一种类似于弱引用的HashMap类，如果Map中的Key没有其他引用那么此Map会自动丢弃此键值对：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        WeakHashMap&lt;Integer, String&gt; weakHashMap = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">        weakHashMap.put(a, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line"></span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当变量a的引用断开后，这时只有WeakHashMap本身对此对象存在引用，所以在GC之后，这个键值对就自动被舍弃了。</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用相当于没有引用，随时都有可能会被回收。虚引用是最弱的一种引用类型，主要用于跟踪对象被垃圾回收的时机，通常用于实现更精细的资源管理或清理机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个虚引用，指向 obj，并关联引用队列</span></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虚引用的 get() 方法始终返回 null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;PhantomRef.get(): &quot;</span> + phantomRef.get()); <span class="comment">// 输出 null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 obj 置为 null，使其成为垃圾</span></span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查引用队列</span></span><br><span class="line">        <span class="keyword">if</span> (queue.poll() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象已被回收，虚引用被加入队列&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象未被回收&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>虚引用的 <code>get()</code> 方法始终返回 <code>null</code>，因此无法通过虚引用访问对象</li>
<li>当对象被垃圾回收时，虚引用会被加入到引用队列中</li>
<li>通过检查引用队列，可以确定对象是否已被回收</li>
</ul>
<h3 id="四种引用对象对比"><a href="#四种引用对象对比" class="headerlink" title="四种引用对象对比"></a>四种引用对象对比</h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>强引用</strong></th>
<th><strong>软引用</strong></th>
<th><strong>弱引用</strong></th>
<th><strong>虚引用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>引用强度</strong></td>
<td>最强</td>
<td>较强</td>
<td>较弱</td>
<td>最弱</td>
</tr>
<tr>
<td><strong>回收时机</strong></td>
<td>不会被垃圾回收</td>
<td>内存不足时回收</td>
<td>下一次垃圾回收时回收</td>
<td>对象被回收后加入引用队列</td>
</tr>
<tr>
<td><strong><code>get()</code> 方法</strong></td>
<td>返回对象</td>
<td>返回对象（如果未被回收）</td>
<td>返回对象（如果未被回收）</td>
<td>始终返回 <code>null</code></td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>默认引用类型</td>
<td>缓存</td>
<td>缓存、监听器</td>
<td>对象回收的跟踪、资源管理</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://ltynote.cn">楪舞飞祈</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://ltynote.cn/inori/4af053c8.html">http://ltynote.cn/inori/4af053c8.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://ltynote.cn" target="_blank">楪祈のBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://imgapi.xl0408.top/index.php" data-sites="qq,wechat,twitter,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/inori/e45c1800.html" title="JVM类与类加载"><img class="cover" src="/img/loading.gif" data-original="https://api.suyanw.cn/api/comic3.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM类与类加载</div></div></a></div><div class="next-post pull-right"><a href="/inori/a89a12f2.html" title="JVM概述与内存管理"><img class="cover" src="/img/loading.gif" data-original="https://api.suyanw.cn/api/comic3.php" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM概述与内存管理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/inori/a774566a.html" title="SpringSecurity基础入门"><img class="cover" src="/img/loading.gif" data-original="https://api.suyanw.cn/api/comic3.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-22</div><div class="title">SpringSecurity基础入门</div></div></a></div><div><a href="/inori/a2118cb.html" title="JUnit与Mockito测试框架入门"><img class="cover" src="/img/loading.gif" data-original="https://imgapi.xl0408.top/index.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-21</div><div class="title">JUnit与Mockito测试框架入门</div></div></a></div><div><a href="/inori/fd4f4c4d.html" title="Java网络IO"><img class="cover" src="/img/loading.gif" data-original="https://imgapi.xl0408.top/index.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-09</div><div class="title">Java网络IO</div></div></a></div><div><a href="/inori/e590136b.html" title="JUC线程池"><img class="cover" src="/img/loading.gif" data-original="https://imgapi.xl0408.top/index.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-19</div><div class="title">JUC线程池</div></div></a></div><div><a href="/inori/db6966ce.html" title="JUC并发容器与并发工具"><img class="cover" src="/img/loading.gif" data-original="https://api.suyanw.cn/api/comic3.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-19</div><div class="title">JUC并发容器与并发工具</div></div></a></div><div><a href="/inori/4fdd9583.html" title="JUC锁类和原子类"><img class="cover" src="/img/loading.gif" data-original="https://api.suyanw.cn/api/comic3.php" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-17</div><div class="title">JUC锁类和原子类</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">楪舞飞祈</div><div class="author-info__description">星座になれたら。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/inori-320"><i class="fab fa-github"></i><span>My GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:719471785@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><p align="center" color="brown">多读书，多看报，少吃零食，多睡觉。</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AD%98%E6%B4%BB%E5%88%A4%E5%AE%9A%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">对象存活判定算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">可达性分析算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E5%88%A4%E5%AE%9A"><span class="toc-number">1.3.</span> <span class="toc-text">最终判定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">标记-复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">标记-整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">分代收集机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="toc-number">2.5.</span> <span class="toc-text">空间分配担保</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%A9%BA%E9%97%B4"><span class="toc-number">3.</span> <span class="toc-text">元空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">Serial收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">ParNew收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parallel-Scavenge-Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">Parallel Scavenge&#x2F;Parallel Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">CMS收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Garbage-First-G1-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">Garbage First (G1) 收集器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">其他引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">软引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">虚引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.</span> <span class="toc-text">四种引用对象对比</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/inori/a6efffa.html" title="手撕—实现JSON字符串解析"><img src="/img/loading.gif" data-original="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手撕—实现JSON字符串解析"/></a><div class="content"><a class="title" href="/inori/a6efffa.html" title="手撕—实现JSON字符串解析">手撕—实现JSON字符串解析</a><time datetime="2025-08-15T08:28:08.000Z" title="发表于 2025-08-15 16:28:08">2025-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/inori/17befa9.html" title="手撕—带过期时间的LRU"><img src="/img/loading.gif" data-original="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手撕—带过期时间的LRU"/></a><div class="content"><a class="title" href="/inori/17befa9.html" title="手撕—带过期时间的LRU">手撕—带过期时间的LRU</a><time datetime="2025-08-13T06:38:59.000Z" title="发表于 2025-08-13 14:38:59">2025-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/inori/c29b5d38.html" title="手撕—单例模式"><img src="/img/loading.gif" data-original="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="手撕—单例模式"/></a><div class="content"><a class="title" href="/inori/c29b5d38.html" title="手撕—单例模式">手撕—单例模式</a><time datetime="2025-08-13T06:16:41.000Z" title="发表于 2025-08-13 14:16:41">2025-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/inori/a774566a.html" title="SpringSecurity基础入门"><img src="/img/loading.gif" data-original="https://api.suyanw.cn/api/comic3.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringSecurity基础入门"/></a><div class="content"><a class="title" href="/inori/a774566a.html" title="SpringSecurity基础入门">SpringSecurity基础入门</a><time datetime="2025-07-22T06:08:57.000Z" title="发表于 2025-07-22 14:08:57">2025-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/inori/a2118cb.html" title="JUnit与Mockito测试框架入门"><img src="/img/loading.gif" data-original="https://imgapi.xl0408.top/index.php" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JUnit与Mockito测试框架入门"/></a><div class="content"><a class="title" href="/inori/a2118cb.html" title="JUnit与Mockito测试框架入门">JUnit与Mockito测试框架入门</a><time datetime="2025-07-21T02:02:43.000Z" title="发表于 2025-07-21 10:02:43">2025-07-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://imgapi.xl0408.top/index.php')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By 楪舞飞祈</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas id="snow"></canvas><script async src="/js/snow.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>