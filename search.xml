<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/inori/364ea8cc.html"/>
      <url>/inori/364ea8cc.html</url>
      
        <content type="html"><![CDATA[<p>待更新……</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis内存回收</title>
      <link href="/inori/228807ea.html"/>
      <url>/inori/228807ea.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis内存回收机制"><a href="#Redis内存回收机制" class="headerlink" title="Redis内存回收机制"></a>Redis内存回收机制</h1><p>Redis中的内存策略主要包含下列四点：</p><ol><li>内存清除策略（Eviction Policy）：当Redis内存空间不足时，会根据特定的算法删除一些key来释放内存。其中，常用的算法有LRU（最少最近使用）、LFU（最少使用频率）和随机算法</li><li>内存淘汰策略（Expiration）：在插入或更新key的时候，可以指定key的过期时间（expire）时间。过期后，Redis会自动将key删除，释放内存</li><li>内存回收策略（Memory Reclamation）：在使用Redis时，可能会因为未正确释放内存而导致内存泄漏。Redis针对这种情况实现了自动内存回收机制来防止内存泄漏的问题</li><li>内存优化策略（Memory Optimization）：Redis提供了各种内存优化策略，例如使用压缩（压缩整数值、压缩非常短的字符串）、使用哈希对象来优化内存使用等，以最大限度地减少内存使用。Redis也使用专门的数据结构来实现某些特定的数据类型，例如基数计数器和位数组，这些也是为了优化内存使用而设计的</li></ol><h2 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h2><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：Key过期策略.可以通过<code>expire key 5</code>命令（设置TTL为5秒）给Redis的key设置TTL（存活时间），当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。</p><h3 id="Redis如何Key是否过期"><a href="#Redis如何Key是否过期" class="headerlink" title="Redis如何Key是否过期"></a>Redis如何Key是否过期</h3><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在Dict结构中</p><p>Redis判断一个key是否过期：<strong>在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    dict *dict;<span class="comment">/*存放所有key及value，也被称为keyspace*/</span></span><br><span class="line">    dict *expires;<span class="comment">/*存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key*/</span></span><br><span class="line">    dict *blocking_keys;<span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;<span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;<span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="type">int</span> id;<span class="comment">/* Database ID, 0~15 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;<span class="comment">/*记录平均TTL时长*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires_cursor;<span class="comment">/*expire检查时在dict中抽样的索引|位置*/</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;<span class="comment">/*等待碎片整理的key列表*/</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h3 id="TTL到期后的删除策略"><a href="#TTL到期后的删除策略" class="headerlink" title="TTL到期后的删除策略"></a>TTL到期后的删除策略</h3><p><strong>惰性删除</strong>：并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。也就是在增删改查的时候才会去检查这个key去判断这个key是否有过期</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找一个key执行写操作</span></span><br><span class="line">robj *<span class="title function_">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span>&#123;</span><br><span class="line">    <span class="comment">// 检查key是否过期</span></span><br><span class="line">    expirelfNeeded(db, key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找一个key执行读操作</span></span><br><span class="line">robj *<span class="title function_">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    robj *val;</span><br><span class="line">    <span class="comment">// 检查key是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (expirelfNeeded(db,key) == <span class="number">1</span>) (</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expirelfNeeded</span><span class="params">(redisDb *db, robj *key)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否过期，如果未过期直接结束并返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!keylsExpired(db,key)) <span class="keyword">return</span> O;</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">    <span class="comment">// 删除过期key</span></span><br><span class="line">    deleteExpiredKeyAndPropagate(db,key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>周期删除</strong>：通过一个定时任务，周期性的抽样部分过期的key，执行删除，执行周期有两种：</p><ol><li>在Redis服务初始化函数initServer()中设置定时任务serverCron()，按照server.hz的频率来执行过期key清理，模式为SLOW</li><li>在Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</li></ol><p>SLOW模式：</p><ul><li>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</li><li>执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</li><li>逐个遍历db，逐个遍历db中的bucket（可以理解为hash列表中的每个下标），抽取20个key判断是否过期</li><li>如果没达到时间上限（25ms）并且过期key比例大于10%(就是过期的key和数据库中总的key进行对比)，再进行一次抽样，否则结束</li></ul><p>FAST模式规则（过期key比例小于10%不执行）：</p><ul><li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li><li>执行清理耗时不超过1ms</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期，如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果服务器设置了server.maxmemory属性，并且没有执行lua脚本</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="comment">//尝试进行内存淘汰performEvictions</span></span><br><span class="line">        <span class="type">int</span> out_of_memory = (performEvictions()) == EVICT_FAIL);</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis支持8种不同策略来选择要删除的key：</p><ol><li>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略</li><li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</li><li>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选</li><li>allkeys-lru： 对全体key，基于LRU算法进行淘汰</li><li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</li><li>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰。</li><li>LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高</li><li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高</li></ol><p>之前记录过的RedisObject：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type: <span class="number">4</span>;<span class="comment">//对象类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding: <span class="number">4</span>; <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">unsigned</span> lru: LRU_BITS;<span class="comment">//LRU:以秒为单位记录最近一次访问时间，长度24bit</span></span><br><span class="line">    <span class="comment">//LFU：高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数</span></span><br><span class="line">    <span class="type">int</span> refcount;<span class="comment">//引用计数，计数为0则可以回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;<span class="comment">//数据指针，指向真实数据</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p><ol><li>生成0~1之间的随机数R</li><li>计算旧次数*lfu_log_factor+1&#96;，记录为P</li><li>如果R&lt;P ，则计数器+1，且最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间每隔<code>lfu_decay_time</code>分钟，计数器-1</li></ol><blockquote><p>当Redis使用的内存超出maxmemory设置时，会根据指定的淘汰策略在键空间中选择要删除的键值对。在删除键值对时，Redis会先检查该键值对是否在使用中（例如，有没有客户端正在访问该键值对），然后再根据具体的淘汰策略选择一个待删除的键值对，并将其从缓存中清除。</p></blockquote><p><img src="D:\Blog\source\img\elimination.png" alt="elimination"></p><p>如果把redis全部的key都拿出来进行比较再淘汰，消耗的时间就会大大的增加。所以这里就引入了一个叫<code>eviction_pool</code>（驱逐池）它会抽取的一些样本，将样本放到池子里，再去比较看看谁应该被淘汰，这里<code>maxmemory_samples</code>默认值是5，但是策略不同淘汰的方式不同，这样实现就会比较麻烦所以这里进行了统一，就是按照key其中的某一个值的升序排列，值越大的优先淘汰</p><p>例如LFU最少频率使用，使用的越少就应该越早被淘汰，但是是升序排列的，那么就用255-LFU计算，LFU越少255-LFU就越大越应该被淘汰</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis网络模型</title>
      <link href="/inori/e34c024b.html"/>
      <url>/inori/e34c024b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux网络模型"><a href="#Linux网络模型" class="headerlink" title="Linux网络模型"></a>Linux网络模型</h1><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p><ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>信号驱动IO（Signal Driven IO）</li><li>异步IO（Asynchronous IO）</li></ul><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p><p><img src="D:\Blog\source\img\Blocking_IO.png" alt="Blocking_IO"></p><p>用户去读取数据时，会去先发起recvform一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO</p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程</p><p>阶段一：</p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户进程</li><li>用户进程拿到error后，再次尝试读取</li><li>循环往复，直到数据就绪</li></ul><p>阶段二：</p><ul><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li></ul><p>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增</p><p><img src="D:\Blog\source\img\Nonblocking_IO.png" alt="Nonblocking_IO"></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p><ul><li>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用</li><li>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</li></ul><p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能表现很差</p><p>想要提高IO事件效率，可以使用多线程，或者即时通知（哪个数据就绪，用户进程就读取这个数据）</p><p>那么用户进程如何知道内核中数据是否就绪呢？</p><p>这个问题的解决依赖于提出的文件描述符。</p><p>文件描述符（File Descriptor）：简称FD，是一个从0开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）</p><p>通过FD，我们的网络模型可以利用一个线程监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源</p><p>用IO复用模式，可以确保去读数据的时候，数据是一定存在的，他的效率比原来的阻塞IO和非阻塞IO性能都要高</p><p>IO多路复用即线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：</p><ol><li>select</li><li>poll</li><li>epoll</li></ol><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select是Linux最早是由的I&#x2F;O多路复用技术。</p><p>具体可以描述为：我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据</p><p>比如要监听的数据，是1,2,5三个数据，此时会执行select函数，然后将整个fd发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再将处理掉没有准备好的数据，最后再将这个FD集合写回到用户态中去，此时用户态就知道了，奥，有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点，再去发起读请求</p><p>seletc模式存在的问题：</p><ul><li>需要将整个fd_set用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</li><li>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</li><li>fd_set监听的fd数量不能超过1024</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll模式对select模式做了简单改进，但性能提升不明显，IO流程：</p><ol><li>创建pollfd数组，向其中添加关注的fd信息，<strong>数组大小自定义</strong></li><li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历fd，判断是否就绪</li><li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li><li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd</li></ol><p>与select对比：</p><ul><li><p>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</p></li><li><p>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</p></li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll模式是对select和poll的改进，它提供了三个函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span><span class="comment">// 一颗红黑树，记录要监听的FD</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span><span class="comment">// 一个链表，记录就绪的FD</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个epoll实例,内部是event poll，返回对应的句柄epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将一个FD添加到epoll的红黑树中，并设置ep_pollL_callback</span></span><br><span class="line"><span class="comment">// callback触发时，就把对应的FD加入到rdlist这个就绪列表中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd; <span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> op;<span class="comment">//要执行的操作，包括：ADD、MOD、DEL</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> fd; <span class="comment">//要监听的FD</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *event;<span class="comment">//要监听的事件类型:读、写、异常等</span></span></span><br><span class="line"><span class="params">&#125;;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 3.检查rdlist列表是否为空，不为空则返回就绪的FD的数量</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> epoll_wait(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd;<span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *events;<span class="comment">//空event数组，用于接收就绪的FD</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents;<span class="comment">//events数组的最大长度</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout;<span class="comment">// 超时时间，-1用不超时，0不阻塞；大于0为阻塞时间</span></span></span><br><span class="line"><span class="params">&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>使用epoll_create创建epoll实例</li><li>紧接着调用epoll_ctl操作，将要监听的数据添加到红黑树上去，并且给每个fd设置一个监听函数，这个函数会在fd数据就绪时触发，把fd数据添加到list_head中去，epoll_ctl中的epfd表明要将监听的fd添加到eventepoll中</li><li>使用epoll_wait等待fd就绪，在用户态创建一个空的events数组，当就绪之后，我们的回调函数会把数据添加到list_head中去，当调用这个函数的时候，会去检查list_head，如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将数据放入到events数组中，并且返回对应的操作的数量</li><li>用户态的此时收到响应后，从events中拿到对应准备好的数据的节点，再去调用方法去拿数据</li></ol><h4 id="epoll中的事件通知模式"><a href="#epoll中的事件通知模式" class="headerlink" title="epoll中的事件通知模式"></a>epoll中的事件通知模式</h4><p>当FD有数据可读时，我们调用epoll_wait可以得到通知。但是事件通知的模式有两种：</p><ul><li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li><li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li></ul><p>假设一个客户端socket对应的FD已经注册到了epoll实例中，客户端socket发送了2kb的数据，服务端调用epoll_wait，得到通知说FD就绪，服务端从FD读取了1kb数据</p><ul><li>如果我们采用LT模式，因为FD中仍有1kb数据，调用epoll_wait依然会返回结果，并且得到通知</li><li>如果我们采用ET模式，因为已经消费了FD可读事件，后续FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时</li></ul><table><thead><tr><th><strong>特性</strong></th><th><strong>LT 模式</strong></th><th><strong>ET 模式</strong></th></tr></thead><tbody><tr><td><strong>触发条件</strong></td><td>只要条件满足，持续通知。</td><td>只有状态变化时通知一次。</td></tr><tr><td><strong>通知频率</strong></td><td>高</td><td>低</td></tr><tr><td><strong>性能</strong></td><td>较低，适合低并发场景。</td><td>较高，适合高并发场景。</td></tr><tr><td><strong>编程复杂度</strong></td><td>简单，无需担心事件丢失。</td><td>复杂，需要确保一次性处理完数据。</td></tr><tr><td><strong>适用场景</strong></td><td>简单的 I&#x2F;O 操作或初学者。</td><td>高并发、高性能的网络服务器。</td></tr></tbody></table><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>流程：</p><ol><li>用户进程调用sigaction，注册信号处理函数</li><li>内核返回成功，开始监听FD</li><li>用户进程不阻塞等待，可以执行其它业务</li><li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li><li>收到SIGIO回调信号后，用户进程调用recvfrom，读取</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ol><p>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p><p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态</p><p><img src="D:\Blog\source\img\asyncIO.png" alt="asyncIO"></p><p>异步IO避免了同步I&#x2F;O中的等待时间，提高了CPU和I&#x2F;O设备的利用率，但是这种方式对内核的负载很大，在高并发场景下可能会因为内存占用过多出现崩溃现象。如果要使用必须要做并发访问的限流</p><h1 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h1><p><strong>Redis到底是单线程还是多线程？</strong></p><ul><li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li><li>如果是聊整个Redis，那么答案是多线程</li></ul><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redis v4.0：引入多线程异步处理一些耗时较久的任务，例如异步删除命令unlink</li><li>Redis v6.0 ：在核心网络模型中引入多线程，进一步提高对多核cpu的利用率</li></ul><p>因此，对于Redis的核心网络模型，在Redis6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况</p><p><strong>为什么Redis要选择单线程？</strong></p><ul><li>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能会降低</li></ul><h2 id="Redis单线程网络模型执行流程"><a href="#Redis单线程网络模型执行流程" class="headerlink" title="Redis单线程网络模型执行流程"></a>Redis单线程网络模型执行流程</h2><ol><li>监听端口：Redis服务器开始监听指定的端口，等待客户端连接。</li><li>接收客户端连接：当有客户端请求连接到Redis服务器时，服务器会接受连接请求，并创建一个客户端套接字，用于与客户端通信。</li><li>接收命令：一旦客户端与服务器建立连接，客户端可以发送命令请求到服务器。Redis服务器通过套接字接收到客户端发送的命令。</li><li>命令解析：服务器会对接收到的命令进行解析，以确定客户端请求的具体操作。</li><li>执行命令：根据解析的结果，服务器会执行相应的命令操作。由于Redis使用单线程模型，每个命令都会按顺序依次执行，不会并发执行。</li><li>数据读写：在执行命令期间，如果需要读取或修改数据，服务器会从内存中读取数据或将修改后的数据写回内存。</li><li>命令回复：执行完命令后，服务器会将执行结果封装为响应，并通过套接字发送回客户端。</li><li>关闭连接：命令执行完成后，服务器会关闭与客户端的连接，等待下一个连接请求</li></ol><p><img src="D:\Blog\source\img\redis_netModel.png" alt="redis_netModel"></p><h3 id="多线程改进"><a href="#多线程改进" class="headerlink" title="多线程改进"></a>多线程改进</h3><p>由于影响网络模型速率的是IO操作，所以可以在命令请求处理器的请求数据写入部分使用多线程和将数据写入buf或reply部分使用多线程来提高速度</p><h1 id="Redis通信协议"><a href="#Redis通信协议" class="headerlink" title="Redis通信协议"></a>Redis通信协议</h1><p>Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p><ol><li>客户端（client）向服务端（server）发送一条命令</li><li>服务端解析并执行命令，返回响应结果给客户端</li></ol><p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p><p>而在Redis中采用的是RESP（Redis Serialization Protocol）协议：</p><ol><li>Redis 1.2版本引入了RESP协议</li><li>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</li><li>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存</li></ol><p>但目前，默认使用的依然是RESP2协议。</p><p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p><ol><li>单行字符串：首字节是 <code>&#39;+&#39;</code> ，后面跟上单行字符串，以CRLF（ <code>&quot;\r\n&quot;</code> ）结尾。例如返回”OK”： <code>&quot;+OK\r\n&quot;</code></li><li>错误（Errors）：首字节是 <code>&#39;-&#39; </code>，与单行字符串格式一样，只是字符串是异常信息，例如：<code>&quot;-Error message\r\n&quot;</code></li><li>数值：首字节是 <code>&#39;:&#39; </code>，后面跟上数字格式的字符串，以CRLF结尾。例如：<code>&quot;:10\r\n&quot;</code></li><li>多行字符串：首字节是 <code>&#39;$&#39;</code> ，表示二进制安全的字符串，最大支持512MB：<ol><li>如果大小为0，则代表空字符串：<code>&quot;$0\r\n\r\n&quot;</code></li><li>如果大小为-1，则代表不存在：<code>&quot;$-1\r\n&quot;</code></li></ol></li><li>数组：首字节是 <code>&#39;*&#39;</code>， 后面跟上数组元素个数，再跟上元素，元素数据类型不限，如：</li></ol><blockquote><p>*3\r\n</p><p>:10\r\n</p><p>$5\r\nhello\r\n</p><p>*2\r\n$3\r\nage\r\n:10\r\n</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构</title>
      <link href="/inori/abcb1f8f.html"/>
      <url>/inori/abcb1f8f.html</url>
      
        <content type="html"><![CDATA[<h2 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h2><p>Redis中保存的key是字符串，value往往是字符串或者字符串的集合。可以说字符串是Redis中最常见的数据结构。</p><p>不过Redis中没有直接使用C语言中的字符串，而是构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String）。</p><p>比如我们执行命令<code>set name Jack</code>，那么Redis将在底层创建两个SDS，其中一个是包含<code>name</code>的SDS，另一个是包含<code>Jack</code>的SDS。</p><p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len;<span class="comment">// buf已保存的字符串字节数，不包含结束标示\0</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc;<span class="comment">// buf申请的总字节数，不包含结束标示\0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;<span class="comment">// 不同的SDS的头类型，用来控制SDS头大小</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>flag对应的种类有五五种</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_8 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_64 4</span></span><br></pre></td></tr></table></figure><p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如有一个内容为<code>abc</code>的SDS，其中<code>len=2,alloc=2,flag=1,h,i,\0</code>，我们要给他追加一段字符串<code>defgh</code>，首先会申请新的内存空间：</p><ul><li>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1</li><li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1</li></ul><p><strong>动态字符串优点</strong>：</p><ol><li>获取字符串长度的时间复杂度为0(1)[因为长度已经存在于结构体中]</li><li>支持动态扩容</li><li>减少内存分配次数</li><li>二进制安全（可以存储特殊字符，无需考虑结束符的问题）</li></ol><h2 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h2><p>Redis为了优化内存和性能，会根据Set中元素的特性自动选择底层实现：</p><ol><li>所有元素都是整数</li><li>元素数量不超过配置的阈值</li></ol><ul><li>Redis配置项<code>set-max-intset-entries</code>定义了IntSet的最大元素数量，默认值为512</li><li>如果元素数量超过该阈值，Redis 会将IntSet转换为HashTable</li></ul><p>IntSet基于整数数组来实现，具备长度可变，有序（便于查找）等特性。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding; <span class="comment">// 编码方式（int16_t、int32_t、int64_t）</span></span><br><span class="line">    <span class="type">uint32_t</span> length;   <span class="comment">// 集合中元素的数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];  <span class="comment">// 存储整数的数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>其中的encoding包含三种模式，表示存储的整数大小不同：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))<span class="comment">/*2字节整数,范围类似java的short */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))<span class="comment">/* 4字节整数,范围类似java的int */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))<span class="comment">/* 8字节整数,范围类似java的long */</span></span></span><br></pre></td></tr></table></figure><p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，内部结构类似于<code>encoding:INTSET_ENC_INT16,length:3,5,10,15</code>。</p><blockquote><p>寻址公式：startPtr【开始的起始地址为0】+（sizeof(int16) 【数据类型的字节大小】* index【它对应的下标】）就可以快速找到对应的数据</p></blockquote><h3 id="IntSet升级"><a href="#IntSet升级" class="headerlink" title="IntSet升级"></a>IntSet升级</h3><p>现在，假设有一个intset,元素为{5,10,20}，采用的编码为INTSET_ENC_INT16，则每个整数占2字节。如果现在我想添加50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。</p><p>以当前案例来说流程如下：</p><ol><li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li><li>倒序依次将数组中的元素拷贝到扩容后的正确位置（倒叙放是为了防止字节扩大时将后面的数据给覆盖掉）</li><li>将待添加的元素放入数组末尾</li><li>将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li></ol><p>如果插入的元素位于IntSet中间或者开头，底层会使用二分查找确定插入位置，然后再执行移动和插入操作。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>IntSet可以看做是特殊的整数数组</li></ul><ul><li>IntSet中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><p>Redis是一个键值型的数据库，我们可以根据键实现快速的增删改查，而键与值的映射关系正是通过Dict来实现的</p><p>Dict由三部分组成：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>每个哈希表由数个entry组成，每个桶是一个链表，用于解决哈希冲突</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      <span class="comment">// entry数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;     <span class="comment">// 哈希表的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">// 用于计算索引的掩码（size - 1）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;     <span class="comment">// 已使用的entry数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><h3 id="哈希节点"><a href="#哈希节点" class="headerlink" title="哈希节点"></a>哈希节点</h3><p>每个键值对存储在一个 <code>dictEntry</code> 结构中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;              <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;          <span class="comment">// 值</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个节点（解决哈希冲突）</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h3 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h3><p>Dict 包含两个哈希表（<code>ht[0]</code>和<code>ht[1]</code>），以及Rehash相关的状态信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;         <span class="comment">// dict类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;         <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht;          <span class="comment">// 两个哈希表，一个是当前数据，另一个一般是空，rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx;         <span class="comment">// Rehash 的进度（-1 表示未进行 Rehash）</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash;<span class="comment">// rehash是否暂停，1表示暂停，0则继续</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用<code>h&amp;sizemask</code>来计算元素应该存储到数组中的哪个索引位置。我们存储k1&#x3D;v1，假设k1的哈希值h&#x3D;1，则1&amp;3&#x3D;1，因此k1&#x3D;v1要存储到数组角标1位置，键值对内部结构使用的是链表，新插入的节点使用的是头插法。</p><h3 id="Dict的扩容和收缩"><a href="#Dict的扩容和收缩" class="headerlink" title="Dict的扩容和收缩"></a>Dict的扩容和收缩</h3><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p><p>Dict在每次新增键值对时都会检查负载因子（<code>LoadFactor = used/size</code>），满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的LoadFactor &gt;&#x3D; 1，并且服务器没有执行BGSAVE或者BGREWRITEAOF等后台进程（因为这种操作对性能要求高，如果我再进行rehash的操作就可能导致阻塞）</li><li>哈希表的LoadFactor &gt; 5</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 检查是否需要扩容 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d) &#123;</span><br><span class="line">    <span class="comment">// 如果正在进行 Rehash，则不需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    <span class="comment">// 如果哈希表为空，则初始化为默认大小（4）</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht.size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果负载因子超过1并且没有进行bgrewrite等子进程操作，则触发扩容</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht.used &gt;= d-&gt;ht.size &amp;&amp;</span><br><span class="line">        (dict_can_resize || d-&gt;ht.used/d-&gt;ht.size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当哈希表的负载因子低于<code>0.1</code>，并且<code>size &gt; 4</code>时，Redis会触发收缩操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 检查是否需要收缩 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正在进行 Rehash 或 dict_can_resize 为 0，则不能收缩</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取used，也就是entry个数</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="comment">// 如果used小于4，则重置为4</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 dictExpand 进行收缩，值为第一个大于等于minimal的2^n</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h3><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ul><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：<ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul></li><li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx &#x3D; 0，标示开始rehash</li><li>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将<code>dict.ht[0].table[rehashidx]</code>的entry链表rehash到dict.ht[1]，并且将<code>rehashidx ++</code>。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><h2 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h2><p>ZipList是一种特殊的“双端链表”（其实不是链表），由一系列特殊编码的连续内存块组成。可以在任意一端进行压入&#x2F;弹出操作, 并且该操作的时间复杂度为O(1)</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>Ziplist由三部分组成：</p><ol><li>头部</li></ol><ul><li><code>zlbytes</code>：Ziplist的总字节数（4字节）</li><li><code>zltail</code>：最后一个节点的偏移量（4字节），便于定位到最后一个entry节点</li><li><code>zllen</code>：entry节点的数量（2字节）</li></ul><ol start="2"><li>entry节点(长度不固定)</li></ol><ul><li>每个entry节点包含以下字段：<ul><li><code>previous_entry_len</code>：前一个节点的长度（1或5字节）<ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为<code>0xfe</code>，后四个字节才是真实长度数据</li></ul></li><li><code>encoding</code>：当前节点的编码方式（1、2或5字节）</li><li><code>content</code>：实际存储的数据（字符串或整数）</li></ul></li></ul><ol start="3"><li>尾部</li></ol><ul><li><code>zlend</code>：Ziplist的结束标志（1字节，固定值<code>0xff</code>）</li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p><h3 id="Encodeing编码"><a href="#Encodeing编码" class="headerlink" title="Encodeing编码"></a>Encodeing编码</h3><p>ZipListEntry中的encoding编码分为字符串和整数两种：<br>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p><table><thead><tr><th align="center">编码</th><th align="center">编码长度</th><th>字符串大小</th></tr></thead><tbody><tr><td align="center">|00pppppp|</td><td align="center">1 bytes</td><td>&lt;&#x3D; 63 bytes</td></tr><tr><td align="center">|01pppppp|qqqqqqqq|</td><td align="center">2 bytes</td><td>&lt;&#x3D; 16383 bytes</td></tr><tr><td align="center">|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td><td align="center">5 bytes</td><td>&lt;&#x3D; 4294967295 bytes</td></tr></tbody></table><p>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</p><table><thead><tr><th align="center">编码</th><th align="center">编码长度</th><th align="center">整数类型</th></tr></thead><tbody><tr><td align="center">11000000</td><td align="center">1</td><td align="center">int16_t（2 bytes）</td></tr><tr><td align="center">11010000</td><td align="center">1</td><td align="center">int32_t（4 bytes）</td></tr><tr><td align="center">11100000</td><td align="center">1</td><td align="center">int64_t（8 bytes）</td></tr><tr><td align="center">11110000</td><td align="center">1</td><td align="center">24位有符整数(3 bytes)</td></tr><tr><td align="center">11111110</td><td align="center">1</td><td align="center">8位有符整数(1 bytes)</td></tr><tr><td align="center">1111xxxx</td><td align="center">1</td><td align="center">直接在xxxx位置保存数值，范围从0001~1101，减1后结果为实际值</td></tr></tbody></table><h3 id="连锁更新问题"><a href="#连锁更新问题" class="headerlink" title="连锁更新问题"></a>连锁更新问题</h3><p>前面提到过，ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：</p><ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul><p>当插入或删除节点时，可能导致后续节点的<code>prevlen</code>字段发生变化。如果<code>prevlen</code>的长度从1字节变为5字节，则需要扩展当前节点的空间，这可能导致后续节点的<code>prevlen</code>字段也需要更新，从而引发连锁更新</p><p>不过发生的可能性较低，redis并没有解决这个问题</p><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，链表中的每个节点都是一个ZipList。可以用多个ZipList来分片存储数据</p><p><img src="D:\Blog\source\img\QuickList.png" alt="QuickList"></p><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：<code>list-max-ziplist-size</code></p><ul><li>如果值为正，则代表ZipList的允许的entry个数的最大值</li><li>如果值为负，则代表ZipList的最大内存大小，分5种情况：<ul><li>-1：每个ZipList的内存占用不能超过4kb</li><li>-2：每个ZipList的内存占用不能超过8kb（默认值）</li><li>-3：每个ZipList的内存占用不能超过16kb</li><li>-4：每个ZipList的内存占用不能超过32kb</li><li>-5：每个ZipList的内存占用不能超过64kb</li></ul></li></ul><p>QuickList源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头节点指针</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    <span class="comment">// 尾节点指针</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="comment">// 所有ziplist的entry的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">// ziplists总数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">// ziplist的entry上限，默认值 -2</span></span><br><span class="line">    <span class="type">int</span> fill: QL_FILL_BITS;</span><br><span class="line">    <span class="comment">// 首尾不压缩的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress:QL_COMP_BITS;</span><br><span class="line">    <span class="comment">// 内存重分配时的书签数量及数组，一般用不到</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><p>QuickListNode源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 下一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 当前节点的ZipList指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="comment">// 当前节点的Ziplist的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="comment">// 当前节点的ZipList的entry个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count: <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 编码方式:1.ZipList; 2.lzf压缩模式</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding: <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 数据容器类型(预留):1.其它; 2.ZipList</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container: <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 是否被解压缩。1说明被解压了，将来要重新压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress: <span class="number">1</span>; <span class="comment">//测试用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra: <span class="number">10</span>;<span class="comment">/*预留字段*/</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><p>ZipList的压缩可以选择头尾几个链表不压缩，一般crud都在头尾，只压缩中间的ZipList</p><p><img src="D:\Blog\source\img\quicklist_ziplist.png" alt="quicklist_ziplist"></p><h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>SkipList是链表，但是与传统链表有些差异，具有以下特点：</p><ul><li>节点按照score值排序，score值一样则按照ele字典排序</li><li>节点可能包含多个指针，指针跨度不同</li><li>查找、插入和删除操作的平均时间复杂度为O(logn)</li><li>SkipList的索引层级是动态调整的，插入新元素时会随机生成其层级</li><li>跳跃表是一个双向链表，每一个节点都包含score和ele值</li></ul><p>SkipList的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span><span class="comment">// 头尾节点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;<span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">int</span> level;<span class="comment">// 最大的索引层级，默认是1</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>SkipListNode的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;                      <span class="comment">// 元素值</span></span><br><span class="line">    <span class="type">double</span> score;                   <span class="comment">// 分值，排序、查找用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;             <span class="comment">// 索引跨度</span></span><br><span class="line">    &#125; level[];                        <span class="comment">// 多级索引数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><img src="D:\Blog\source\img\skiplist.png" alt="skiplist"></p><h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，它是Redis数据存储的基础，通过封装数据的类型、编码方式和实际值，提供了统一的接口来操作各种数据类型。源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type: <span class="number">4</span>;<span class="comment">// 5种数据结构类型，占4bit</span></span><br><span class="line">    <span class="type">unsigned</span> encoding: <span class="number">4</span>;<span class="comment">// 底层编码方式，共11种，占4bit</span></span><br><span class="line">    <span class="type">unsigned</span> lru： LRU_BITS;<span class="comment">// lru表示该对象最后一次被访问的时间，占24bit,便于判断空闲时间太久的key</span></span><br><span class="line">    <span class="type">int</span> refcount;<span class="comment">// 对象引用计数器，计数器为0则说明对象无人引用，可以被回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;<span class="comment">// 指针，指向存放实际数据的空间</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h3 id="Redis的编码方式"><a href="#Redis的编码方式" class="headerlink" title="Redis的编码方式"></a>Redis的编码方式</h3><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><table><thead><tr><th align="center">编号</th><th align="center">编码方式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OBJ_ENCODING_RAW</td><td align="center">raw编码动态字符串</td></tr><tr><td align="center">1</td><td align="center">OBJ_ENCODING_INT</td><td align="center">long类型的整数的字符串</td></tr><tr><td align="center">2</td><td align="center">OBJ_ENCODING_HT</td><td align="center">hash表（字典dict）</td></tr><tr><td align="center">3</td><td align="center">OBJ_ENCODING_ZIPMAP</td><td align="center">已废弃</td></tr><tr><td align="center">4</td><td align="center">OBJ_ENCODING_LINKEDLIST</td><td align="center">双端链表</td></tr><tr><td align="center">5</td><td align="center">OBJ_ENCODING_ZIPLIST</td><td align="center">压缩列表</td></tr><tr><td align="center">6</td><td align="center">OBJ_ENCODING_INTSET</td><td align="center">整数集合</td></tr><tr><td align="center">7</td><td align="center">OBJ_ENCODING_SKIPLIST</td><td align="center">跳表</td></tr><tr><td align="center">8</td><td align="center">OBJ_ENCODING_EMBSTR</td><td align="center">embstr的动态字符串</td></tr><tr><td align="center">9</td><td align="center">OBJ_ENCODING_QUICKLIST</td><td align="center">快速列表</td></tr><tr><td align="center">10</td><td align="center">OBJ_ENCODING_STREAM</td><td align="center">Stream流</td></tr></tbody></table><h3 id="五种数据结构对应的编码"><a href="#五种数据结构对应的编码" class="headerlink" title="五种数据结构对应的编码"></a>五种数据结构对应的编码</h3><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p><table><thead><tr><th align="center">数据类型</th><th align="center">编码方式</th></tr></thead><tbody><tr><td align="center">OBJ_STRING</td><td align="center">int、embstr、raw</td></tr><tr><td align="center">OBJ_LIST</td><td align="center">LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td></tr><tr><td align="center">OBJ_SET</td><td align="center">intset、HT</td></tr><tr><td align="center">OBJ_ZSET</td><td align="center">ZipList、HT、SkipList</td></tr><tr><td align="center">OBJ_HASH</td><td align="center">ZipList、HT</td></tr></tbody></table><h2 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String是Redis中最常见的数据存储类型</p><ul><li>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512MB</li><li>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高</li><li>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码，直接将数据保存在RedisObject的ptr指针位置(刚好8字节)，不需要SDS</li></ul><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p><code>OBJ_ENCODING_RAW</code>的实现就是<code>RedisObject</code>中的ptr指向一个SDS</p><p><img src="D:\Blog\source\img\raw.png" alt="raw"></p><p><code>EMBSTR</code>的形式为RedisObject后直接跟SDS，而不是两个分开的地址空间</p><p><img src="D:\Blog\source\img\embstr.png" alt="embstr"></p><p><code>INT</code>形式删除了SDS，直接把数据保存在ptr位置</p><p><img src="D:\Blog\source\img\INT.png" alt="INT"></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis的List类型可以从首、尾操作列表中的元素，哪一个数据结构能满足上述特征？</p><ul><li>LinkedList：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li><li>ZipList：压缩列表，可以从双端访问，内存占用低，存储上限低</li><li>QuickList：<code>LinkedList + ZipList</code>，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li></ul><p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量<code>&lt;512</code>并且元素大小<code>&lt;64字节</code>时使用ZipList编码，超过则采用LinkedList编码</p><p>在3.2版本之后，Redis统一采用QuickList来实现List</p><p>创建List：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushGenericCommand</span><span class="params">(client *c, <span class="type">int</span> where, <span class="type">int</span> xx)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">// 尝试找到KEY对应的list</span></span><br><span class="line">    robj *lobj= lookupKeyWrite(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 检查类型是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (checkType(c, lobj, OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) &#123;</span><br><span class="line">        addReply(c, shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为空，则创建新的QuickList</span></span><br><span class="line">        lobj= createQuicklistObject();</span><br><span class="line">        quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size, server.list_compress_depth);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Quicklist：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createQuicklistObject</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 申请内存并初始化QuickList</span></span><br><span class="line">    quicklist *l = quicklistCreate();</span><br><span class="line">    <span class="comment">// 创建RedisObject，type为OBJ_LIST</span></span><br><span class="line">    <span class="comment">// ptr指向QuickList</span></span><br><span class="line">    robj *o = createObject(OBJ_LIST,l);</span><br><span class="line">    <span class="comment">// 设置编码为 QuickList</span></span><br><span class="line">    <span class="number">0</span>-&gt;encoding = OBJ_ENCODING_QUICKLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="D:\Blog\source\img\redis_List.png" alt="redis_List"></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set是Redis中的单列集合，满足下列特点：</p><ul><li>不保证有序性</li><li>保证元素唯一</li><li>支持求交集、并集、差集</li></ul><p>可以看出，Set对查询元素的效率要求非常高，所以底层使用了IntSet和Dict实现。</p><p>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。</p><p>当存储的所有数据都是整数，并且元素数量不超过<code>set-max-intset-entries(默认512)</code>时，Set会采用IntSet编码，以节省内存</p><p>创建Set的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">setTypeCreate</span><span class="params">(sds value)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断value是否是数值类型long long</span></span><br><span class="line">    <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value, <span class="literal">NULL</span>)==C_OK)</span><br><span class="line">    <span class="comment">// 如果是数值类型，则采用IntSet编码</span></span><br><span class="line">    <span class="keyword">return</span> createIntsetObject();</span><br><span class="line">    <span class="comment">//否则采用默认编码，也就是HT</span></span><br><span class="line">    <span class="keyword">return</span> createSetObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是数值类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createIntsetobject</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 初始化INTSET并申请内存空间</span></span><br><span class="line">    intset *is= intsetNew();</span><br><span class="line">    <span class="comment">// 创建RedisObject</span></span><br><span class="line">    robj *o= createObject(OBJ_SET, is);</span><br><span class="line">    <span class="comment">// 指定编码为INTSET</span></span><br><span class="line">    <span class="number">0</span>-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认编码HT：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createSetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化Dict类型，并申请内存</span></span><br><span class="line">    dict *d = dictCreate(&amp;setDictType, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建RedisObject</span></span><br><span class="line">    robj *o= createObject(OBJ_SET, d);</span><br><span class="line">    <span class="comment">// 设置encoding为HT</span></span><br><span class="line">    <span class="number">0</span>-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果原本set中存储的元素使5,10,20，然后执行命令<code>sadd s1 m1</code>，因为新插入的元素是字符串，redis需要转换编码，会新建一个Dict，把原本IntSet中的元素和m1都存入Dict中，然后转换RedisObject中的ptr，指向Dict，最后更改encoding为<code>OBJ_ENCODING_HT</code></p><p><img src="D:\Blog\source\img\redis_set.png" alt="redis_set"></p><h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p><ul><li>可以根据score值排序后</li><li>member必须唯一</li><li>可以根据member查询分数</li></ul><p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。</p><ul><li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li><li>HT（Dict）：可以键值存储，并且可以根据key找value</li></ul><p>zset会同时使用两个结构，需要查找，维护键唯一时使用HT，需要排序时使用SkipList</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zset结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    <span class="comment">// Dict指针</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// SkipList指针</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createZsetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line"><span class="comment">// 创建Dict</span></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建SkipList</span></span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(OBJ_ZSET, zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="D:\Blog\source\img\zset.png" alt="zset"></p><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件:</p><ul><li>元素数量小于zset_max_ziplist_entries，默认值128</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64</li></ul><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry，element在前，score在后(当我们查询的时候就可以直接遍历即可，当我们要找m1的score，只需要找到m1在找下一个即可)</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash结构与Redis中的Zset非常类似：</p><ul><li>都是键值存储</li><li>都需求根据键获取值</li><li>键必须唯一</li></ul><p>区别：</p><ul><li>zset的键是member，值是score，hash的键和值都是任意值</li><li>zset要根据score排序；hash则无需排序</li></ul><p>Hash的底层实现也与zset类似，只不过不需要用于排序的SkipList。</p><p>Hash结构默认采用ZipList编码，用以节省内存。ZipList中相邻的两个entry分别保存key和value，随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下：</p><ul><li><code>hash-max-ziplist-entries &gt; 512</code></li><li><code>hash-max-ziplist-value &gt; 64</code></li></ul><p>当满足上面两个条件其中之一的时候，Redis就使用dict字典来实现hash。Redis的hash之所以这样设计，是因为当ziplist变得很大的时候，它有如下几个缺点：</p><ul><li>每次插入或修改引发的realloc操作会有更大的概率造成内存拷贝，从而降低性能</li><li>一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据</li><li>当ziplist数据项过多的时候，在它上面查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历</li></ul><p><img src="D:\Blog\source\img\redis_hash.png" alt="redis_hash"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis分布式缓存</title>
      <link href="/inori/1e2438b1.html"/>
      <url>/inori/1e2438b1.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>之前学的都是单点Redis，而这种单点Redis存在一些问题：</p><ul><li>数据丢失</li><li>并发能力差</li><li>存储量小</li><li>故障恢复能力弱</li></ul><p>我们可以使用Redis分布式缓存解决以上问题。</p><h2 id="Redis持久化解决数据丢失问题"><a href="#Redis持久化解决数据丢失问题" class="headerlink" title="Redis持久化解决数据丢失问题"></a>Redis持久化解决数据丢失问题</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB全称 <code>Redis Database Backup file</code>（Redis数据备份文件），也可以称为叫<strong>Redis数据快照</strong>。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为<strong>RDB文件</strong>，默认是保存在<strong>当前运行目录</strong>。</p><p>RDB持久化的执行条件有<strong>save命令</strong>、<strong>bfsave命令</strong>、<strong>Redis手动停机</strong>、<strong>触发系统内置RDB条件时</strong>。</p><h4 id="save命令"><a href="#save命令" class="headerlink" title="save命令"></a>save命令</h4><p>使用<code>redis-cli</code>链接到redis中后使用<code>save</code>命令可以立刻执行一次RDB。save命令会导致<strong>主进程执行RDB</strong>，这个过程中<strong>其它所有命令都会被阻塞</strong>。只有在数据迁移时可能用到。</p><h4 id="bgsave命令"><a href="#bgsave命令" class="headerlink" title="bgsave命令"></a>bgsave命令</h4><p>与<code>save</code>命令的执行步骤相同，但<code>bgsave</code>命令执行是异步的，执行后会<strong>开启独立进程完成RDB</strong>，主进程可以持续处理用户请求，不受影响。</p><h4 id="停机"><a href="#停机" class="headerlink" title="停机"></a>停机</h4><p>主动停机时会自动执行一次RDB</p><h4 id="Redis内置RDB条件"><a href="#Redis内置RDB条件" class="headerlink" title="Redis内置RDB条件"></a>Redis内置RDB条件</h4><p>Redis内部有触发RDB的机制，可以在<code>redis.conf</code>文件中找到（保持默认即可），格式如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">900秒内，如果至少有1个key被修改，则执行bgsave， 如果是save <span class="string">&quot;&quot;</span> 则表示禁用RDB</span></span><br><span class="line">save 900 1  </span><br><span class="line">save 300 10  </span><br><span class="line">save 60 10000 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否压缩,建议不开启</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RDB文件名称</span></span><br><span class="line">dbfilename dump.rdb  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件保存的路径目录</span></span><br><span class="line">dir ./ </span><br></pre></td></tr></table></figure><h4 id="RDB原理"><a href="#RDB原理" class="headerlink" title="RDB原理"></a>RDB原理</h4><p>当 bgsave 执行时，主进程会 fork（<u>fork()是unix和linux这种操作系统的一个api</u>）一个子进程，子进程共享主进程的内存数据，完成fork后子进程读取内存数据并写入 RDB 文件。</p><p>当子进程读取内存数据写入 RDB 文件时，主进程可以继续进行工作，依靠的是 <code>copy-on-write</code> 技术。</p><ul><li>当主进程执行读操作时，直接访问共享内存</li><li>当主进程执行写操作时，则会在内存中拷贝一份数据，对拷贝的数据执行写操作，这样不会影响到子进程读取的内存数据</li></ul><h4 id="如果不使用copy-on-write会怎么样？"><a href="#如果不使用copy-on-write会怎么样？" class="headerlink" title="如果不使用copy-on-write会怎么样？"></a>如果不使用copy-on-write会怎么样？</h4><p>不使用copy-on-write，就意味着子进程在进行写RDB文件时，主进程可以修改子进程要读取的内存数据，那么就无法保证某一时刻数据的一致性。</p><h4 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h4><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF全称为<code>Append Only File</code>（追加文件）。Redis处理的<strong>每一个写命令都会记录在AOF文件</strong>，可以看做是命令日志文件。（<strong>由主进程先写入到缓冲区，之后由后台线程将缓冲区中的数据写入到AOF文件</strong>）</p><h4 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h4><p>AOF在<code>redis.conf</code>中默认是关闭的，需要修改<code>redis.conf</code>配置文件开启AOF:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否开启AOF功能，默认是no</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件的名称</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line">appendfsync always </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line">appendfsync everysec </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><p><code>appendfsync</code>三种策略对比：</p><table><thead><tr><th align="center">配置项</th><th align="center">刷盘实机</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">同步刷盘</td><td align="center">可靠性高，几乎不丢失数据</td><td align="center">性能影响大</td></tr><tr><td align="center">everysec</td><td align="center">每秒刷盘</td><td align="center">性能适中</td><td align="center">可能会丢失1秒内的数据</td></tr><tr><td align="center">no</td><td align="center">操作系统控制</td><td align="center">性能最好</td><td align="center">可靠性较差，可能丢失大量数据</td></tr></tbody></table><h4 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h4><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对<strong>同一个key的多次写操作</strong>，但只有最后一次写操作才有意义。通过执行<code>bgrewriteaof</code>命令，可以<strong>让AOF文件执行重写功能</strong>，用最少的命令达到相同效果。</p><p>如果一直没执行此命令，Redis也会在触发阈值时自动重写AOF文件（<strong>异步执行</strong>）。阈值也可以在<code>redis.conf</code>中配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件体积最小多大以上才触发重写</span> </span><br><span class="line">auto-aof-rewrite-min-size 64mb </span><br></pre></td></tr></table></figure><h3 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h3><p>在实际开发中往往会结合两者来使用</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td>宕机恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，数据完整性不如AOF</td><td>高，因为数据完整性更高</td></tr><tr><td>系统资源占用</td><td>高，大量CUP和内存消耗</td><td>低，主要是磁盘IO占用，但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td>使用场景</td><td>可容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><ul><li>RDB是一种快照持久化方法，它会在指定的时间间隔内生成数据的完整快照</li><li>适合于灾难恢复，可以很方便的被迁移到另一个数据中心</li><li>RDB在保存快照时速度快，恢复时也非常迅速，适合用作备份</li><li>最后一次快照之后的数据可能会丢失，因为这部分数据还没有被写入快照</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><ul><li>AOF记录每一条写命令</li><li>AOF提供了更好的数据安全性，可以配置为每秒同步一次，或者每写入一条命令就同步一次</li><li>AOF文件通常会比RDB文件更大，且恢复速度可能会更慢，但可以通过AOF文件重写进行压缩</li><li>AOF在系统崩溃时能最大化数据恢复，最多只丢失几秒钟的数据</li></ul><p>如果需要<strong>快速恢复</strong>且可以<strong>接受少量数据丢失</strong>，RDB可能是更好的选择。如果<strong>注重数据完整性</strong>且<strong>可以接受较慢的恢复速度</strong>，则应该使用AOF。在很多场景下，结合使用RDB和AOF能提供更为可靠的数据保护机制。</p><h2 id="主从集群解决并发问题"><a href="#主从集群解决并发问题" class="headerlink" title="主从集群解决并发问题"></a>主从集群解决并发问题</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p>主从集群可以是一台Redis服务器作为主节点(master)，数台服务器作为从节点(slave)，主节点只负责写数据，从节点只负责读数据。</p><h3 id="数据同步原理"><a href="#数据同步原理" class="headerlink" title="数据同步原理"></a>数据同步原理</h3><p>主从之间的第一次同步<strong>全量同步</strong>，既要加载RDB文件，又要读取并执行repl_baklog中的命令。</p><p><img src="D:\Blog\source\img\master&slave.png" alt="master&amp;slave"></p><p><strong>如何判断是不是第一次同步？</strong></p><ul><li><strong>replication id</strong>：简称replid，数据集标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li><strong>offset</strong>：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id和offset，master才可以判断到底需要同步哪些数据</p><p>一般来讲，如果id能对上就不用做全量同步，但是<code>repl_baklog</code>大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法同步基于log做增量同步，只能再次做全量同步。</p><h3 id="优化主从集群性能"><a href="#优化主从集群性能" class="headerlink" title="优化主从集群性能"></a>优化主从集群性能</h3><ul><li>在master中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高<code>repl_baklog</code>的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><h2 id="Redis哨兵解决故障恢复问题"><a href="#Redis哨兵解决故障恢复问题" class="headerlink" title="Redis哨兵解决故障恢复问题"></a>Redis哨兵解决故障恢复问题</h2><p><code>slave</code>节点宕机恢复后可以找<code>master</code>节点同步数据，那<code>master</code>节点宕机怎么办?</p><p>这就需要指定一个<code>slave</code>节点为新的<code>master</code>，执行写操作。这个操作不需要人工手动执行，因为Redis提供了哨兵(Sentinel)机制来实现主从集群的自动故障恢复。<u>哨兵本身也是一个集群</u>。</p><h3 id="哨兵的结构和作用"><a href="#哨兵的结构和作用" class="headerlink" title="哨兵的结构和作用"></a>哨兵的结构和作用</h3><ul><li><strong>监控</strong>：Sentinel会不断检查master和slave是否按预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给Redis的客户端</li></ul><h3 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h3><p><code>Sentinel</code>基于心跳机制检测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果<code>Sentinel</code>节点发现某实例未在规定时间相应，则认为该实例主观下线</li><li>客观下线：若超过指定数量（<code>quorum</code>）的<code>Sentinel</code>都认为该实例主观下线，则该实例客观下线。<code>quorum</code>的取值最好超过<code>Sentinel</code>数量的一半</li></ul><h3 id="选举新的master"><a href="#选举新的master" class="headerlink" title="选举新的master"></a>选举新的master</h3><p>一旦发现<code>master</code>故障，<code>Sentinel</code>需要在<code>salve</code>中选择一个作为新的<code>master</code>，选择依据是这样的:</p><ul><li>首先会判断<code>slave</code>节点与<code>master</code>节点断开时间长短，如果超过指定值(down-after-miliseconds*10)则会排除该<code>slave</code>节点</li><li>然后判断<code>slave</code>节点的<code>slave-priority</code>值，越小优先级越高，如果是<u>0</u>则永不参与选举</li><li>如果<code>slave-prority</code>一样，则判断<code>slave</code>节点的<code>offset</code>值，越大说明数据越新，优先级越高</li><li>最后是判断<code>slave</code>节点的运行id大小，越小优先级越高</li></ul><h4 id="实现故障转移"><a href="#实现故障转移" class="headerlink" title="实现故障转移"></a>实现故障转移</h4><p>当选中了其中一个<code>slave</code>为新的<code>master</code>后：</p><ul><li><code>Sentinel</code>给备选的<code>slave</code>节点发送<code>slaveof no one</code>命令，让该节点成为<code>master</code></li><li><code>Sentinel</code>给所有其它<code>slave</code>发送<code>slaveof IP地址 端口</code>命令，让这些<code>slave</code>成为新<code>master</code>的从节点，开始从新的<code>master</code>上同步数据</li><li>最后，<code>Sentinel</code>将故障节点标记为<code>slave</code>，当故障节点恢复后会自动成为新的<code>master</code>的<code>slave</code>节点</li></ul><h3 id="Java中使用RedisTemplate配置哨兵集群"><a href="#Java中使用RedisTemplate配置哨兵集群" class="headerlink" title="Java中使用RedisTemplate配置哨兵集群"></a>Java中使用RedisTemplate配置哨兵集群</h3><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置Redis</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">io.lettuce.core:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">MM-dd</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口2</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口3</span></span><br></pre></td></tr></table></figure><p>配置主从读写分离</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDemoApplication</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RedisDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 配置主从读写分离</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">configurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.MASTER_PREFERRED);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReadForm</code>函数是配置Redis的读取策略，有以下选择：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可使用才读取slave</li><li>REPLICA：从slave节点读取</li><li>REPLICA_PREFERRED：优先从slave节点读取，所有的slave都不可用才读取master</li></ul><h2 id="Redis分片集群解决海量数据存储问题"><a href="#Redis分片集群解决海量数据存储问题" class="headerlink" title="Redis分片集群解决海量数据存储问题"></a>Redis分片集群解决海量数据存储问题</h2><p>分片集群特征：</p><ul><li>集群中有多个<code>master</code>，每个<code>master</code>保存不同数据</li><li>每个<code>master</code>都可以有多个<code>slave</code>节点</li><li><code>master</code>之间通过ping监测彼此健康状态</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><h3 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h3><p>Redis会把每一个master节点映射到<code>0~16384</code>个插槽上，通过查看集群信息时即可看到每个节点插槽的区间</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><h3 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h3><p>redis-cli –cluster提供很多操作集群的命令，可以通过下面的命令查看：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster help</span><br></pre></td></tr></table></figure><h3 id="故障迁移"><a href="#故障迁移" class="headerlink" title="故障迁移"></a>故障迁移</h3><p>如果集群中某个master宕机了，则该master下优先级最高的slave节点会变成master，选举出的新master会接管原master的槽位（slot）和数据，继续对外提供服务。其他节点会更新自己的路由表，将请求转发到新的master。如果原master重新上线，它会成为新master的slave节点，开始同步数据。</p><p><img src="D:\Blog\source\img\failover.png" alt="failover"></p><h3 id="Redis访问分片集群"><a href="#Redis访问分片集群" class="headerlink" title="Redis访问分片集群"></a>Redis访问分片集群</h3><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致:</p><ol><li>引入redis的starter依赖</li><li>配置分片集群地址</li><li>配置读写分离</li><li>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下:</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口2</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口3</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口5</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找算法入门</title>
      <link href="/inori/6b525bdc.html"/>
      <url>/inori/6b525bdc.html</url>
      
        <content type="html"><![CDATA[<p>二分查找可以有几种写法：</p><ul><li>闭区间</li><li>开区间</li><li>半开半闭区间（左开右闭&#x2F;左闭右开）</li></ul><p>所谓开闭区间，指的是二分查找中的<code>left</code>和<code>right</code>的值，如果取值在数组内部（大部分情况下），就可以成为闭区间，反之为开区间。</p><p>展示这三种写法，我们从一道<a href="https://leetcode.cn/problems/binary-search/description/">题目</a>开始：</p><hr><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><hr><p>这道题就是纯粹的二分查找板子题，数组有序，数组中无重复元素。</p><p>这里使用<code>Java</code>进行展示，首先是<code>闭区间</code>写法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);<span class="comment">// 防止爆int</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于全程需要<code>left</code>和<code>right</code>处于闭区间内，所以更新后的取值一定是<code>mid+1</code>或<code>mid-1</code>。<code>left=right</code>时，<code>mid</code>也等于<code>right</code>，会陷入死循环，所以要在边界条件的判断中加入<code>=</code>，即<code>while(l &lt;= r)</code>，最后<code>right+1</code>也就是<code>left</code>为所求答案。</p><p>然后是<code>半开半闭</code>区间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n;<span class="comment">// 左闭右开</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>半开半闭写法中，谁是开区间，谁更新后就要等于<code>mid</code>。结束时<code>left=right</code>，两者返回其一即可。</p><p>最后是<code>开区间</code>写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r == n) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// 由于是开区间，r有可能等于nums.length，所以要特判</span></span><br><span class="line">        <span class="keyword">return</span> nums[r] == target ? r : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种写法只有代码上的区别，最后答案都是一样的，选一个顺眼的写法就好。</p><p>我们来做几道扩展题，提升对二分查找的熟练度：</p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></p><hr><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><hr><p>这道题要求我们在数组中找到一段等于<code>target</code>的子数组，返回其起点和终点的下标，如果没有返回<code>[-1, -1]</code>。</p><p>起始位置很好找，套用二分模板即可。</p><p>终点如何找呢？</p><p>这就要讨论不同的要求了</p><ul><li>如果要求我们寻找<code>&gt;= x</code>时，就直接使用二分模板</li><li>如果要求我们寻找<code>&gt; x</code>时，可以将题目转化为<code>&gt;= x+1</code></li><li>如果要求我们寻找<code>&lt; x</code>时，可以将题目转化为<code>(&gt;= x) - 1</code></li><li>如果要求我们寻找<code>&lt;= x</code>某个值时，可以将题目转化为<code>(&gt; x) - 1</code> -》 <code>(&gt;= x + 1) - 1</code></li></ul><p>要寻找终点，也就是<code>&gt; x</code>的情况。</p><p>题解代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private int[] nums;</span><br><span class="line"></span><br><span class="line">    private int lowerBound(int target) &#123;</span><br><span class="line">        int l = 0, r = nums.length - 1;</span><br><span class="line">        while(l &lt;= r)&#123;</span><br><span class="line">            int mid = l + ((r - l) &gt;&gt; 1);</span><br><span class="line">            if(nums[mid] &lt; target) l = mid + 1;</span><br><span class="line">            else r = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        this.nums = nums;</span><br><span class="line">        int start = lowerBound(target);</span><br><span class="line">        if(start == nums.length || nums[start] != target) return new int[]&#123;-1, -1&#125;;</span><br><span class="line">        int end = lowerBound(target + 1) - 1;</span><br><span class="line">        return new int[]&#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分不止能用在有序数组中，也能用在部分有序的数组中。</p><p>比如<a href="https://leetcode.cn/problems/find-peak-element/solution/by-endlesscheng-9ass/">寻找峰值</a>：</p><hr><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><hr>这道题给定的数组是由很多部分有序的数组组成的，峰值可能有多个，我们只需要找到其中一个即可。<p>这道题为什么能够使用二分查找呢？</p><p>因为我们要找到一个峰值，而峰值是一定比周围两个值高的（如果是边界则为一个值），这里可以使用二分查找来逐渐逼近这个点。</p><p>由于要找峰值，<code>target</code>的选择可以是<code>nums[mid+1]</code>或<code>nums[mid-1]</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> == nums.length) <span class="keyword">return</span> mid;<span class="comment">// 特殊判断，防止越界</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>]) l = mid + <span class="number">1</span>;<span class="comment">// 如果mid的下一个比mid大，则峰值一定在mid后面，更新l</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>; <span class="comment">// 反之更新r</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></p><hr><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><hr><p>这道题给定是一个有序无重复数组经过数次旋转后得到的数组，要求我们在其中找到<code>target</code>并返回其下标，如果没有返回<code>-1</code>。</p><p>我们可以用两次二分来解决这道题，首先类似于上一道题的查找峰值，我们先使用二分找到数组中的最小值，也就是找到两段递增数组的分界点，然后比较<code>target</code>与数组中最后一位数<code>last</code>的大小，如果<code>target</code>比<code>last</code>小，则说明其在第二段递增数组中，否则在第一段。然后最相应的数组再做一次二分即可。</p><p>题解代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; last) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= last)&#123;</span><br><span class="line">            r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = l - <span class="number">1</span>;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在寻找低谷时，我们将比较对象定为<code>last</code>，这是因为我们要寻找最小值，如果<code>mid</code>比<code>last</code>要大，则说明数组一定被分割过并且<code>mid</code>在最小值左侧，移动<code>left</code>，反之移动<code>right</code>。并且由于我们的比较对象是<code>last</code>，所以二分时不需要考虑它，<code>r</code>直接定为<code>n-2</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习基础知识</title>
      <link href="/inori/64d6f53b.html"/>
      <url>/inori/64d6f53b.html</url>
      
        <content type="html"><![CDATA[<p>记录一些强化学习基础名词解释，理解的不深</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>强化学习（Reinforcement Learning，RL）是一种机器学习方法，旨在通过与环境的交互来学习如何采取行动以最大化累积奖励。与监督学习不同，强化学习没有预先标注的输入输出对，而是通过试错和从反馈中学习</p><p><code>Agent</code>：做出动作的角色，即智能体</p><p><code>state(状态)</code>：智能体当前所处的环境，包含环境当前的全部或部分信息，在玩游戏时，state就是当前的游戏画面，如果状态，动作，奖励等变量被观测到了，用s表示；没观测到就表示随机变量，用S表示</p><p><code>action(动作)</code>：智能体在每个时间步可以采取的操作</p><p><code>policy(决策)</code>：agent在当前做出的动作</p><p><code>policy function(策略函数)</code>：在某种state下，agent采取某种action的概率$\pi(s.a)$，函数值范围为[0,1]</p><p><code>Reward(奖励)</code>：是指采取动作后，环境给agent的奖励，它可能为正、负、0</p><p><code>state transition(状态转移)</code>：agent在某个状态采取某个动作后，可能发生的状态变化</p><p>强化学习是agent与环境互动的过程。我们观测到状态$s_t$，然后根据策略$\pi(a|s)$选择一个动作$a_t$并执行它，环境会给出一个新的状态$s_{t+1}$和奖励r</p><p><code>Return(回报)</code>：也叫做未来累计奖励，即$U_t&#x3D;R_t+R_{t+1}+R_{t+2}+…+R_n$</p><p>由于现在的奖励可能比未来的奖励更重要，所以定义<code>Discounted Return(折扣回报)</code>：$U_t&#x3D;R_t+\gamma R_{t+1}+\gamma^2 R_{t+2}+…+\gamma^n R_n$，$\gamma$意为折扣因子，是我们设定的超参数</p><p><code>Action-Value Function(动作值函数)</code>：用Q(s,a)表示，用于评估在给定状态s下采取某个动作a所能获得的累积奖励的期望值</p><p><code>State-Value Function(状态值函数)</code>：用V(s)表示，用于评估智能体在给定状态s下，从该状态开始到未来所能获得的累积奖励的期望值</p><p><code>Q值</code>：表示在状态s下采取动作a的return</p><p><code>model-based</code>：基于模型的方法涉及构建环境的模型，即尝试估计或学习环境的动态（状态转移概率和奖励函数）。这些方法可以在模型上进行规划，从而选择最佳行动。</p><p><code>model-free</code>：不直接构建环境的模型，而是通过与环境的交互来学习最优策略或价值函数，直接从经验中学习如何行动</p><p><code>policy-based</code>：利用策略梯度优化策略函数，来选择最优行动，直接学习映射状态到行动的策略函数。可以更自然地应用于连续动作空间问题。</p><p><code>value-based</code>：基于价值的方法对价值函数进行建模和优化。通过估计每个状态或状态-动作对的价值来选择最优行动。主要特点包括：</p><ul><li>优化价值函数：学习状态价值函数或动作价值函数。</li><li>间接确定策略：通过选择具有最大价值的动作来确定策略。</li><li>例子：Q-learning，SARSA，DQN</li></ul><h1 id="Value-Based-Reinforcement-Learning"><a href="#Value-Based-Reinforcement-Learning" class="headerlink" title="Value-Based Reinforcement Learning"></a>Value-Based Reinforcement Learning</h1><p>定义Optimal action-value function$Q^*(s_t,a_t)&#x3D;maxQ_\pi(s_t,a_t)$，$Q^*(s_t,a_t)$就是最优情况下的$U_t$</p><p>在价值学习中我们要训练的函数就是$Q(s_t,a_t)$，训练的目标是$Q^*(s_t,a_t)$，采取的最佳动作就是$a^*&#x3D;argmaxQ^*(s_t,a_t)$</p><h2 id="Temporal-Difference-Learning算法"><a href="#Temporal-Difference-Learning算法" class="headerlink" title="Temporal Difference Learning算法"></a>Temporal Difference Learning算法</h2><p>时序差分算法的思想为用局部基于真实观测的数据来更新全局预测的数据，因为它的可信度大于完全基于预测的数据</p><p>TD target：相比于当前估计来说更准确的估计，使用$V(s)←V(s)+α[r+γV(s^′)−V(s)]$更新</p><p>TD error：之前的估计与当前估计的损失值</p><h2 id="Deep-Q-Network"><a href="#Deep-Q-Network" class="headerlink" title="Deep Q Network"></a>Deep Q Network</h2><p>DQN是使用一个神经网络$Q(s,a;w)$来估计action-value function$Q(s,a)$，我们基于TD算法来训练这个神经网络，从而得到Optimal action-value function$Q^*(s_t,a_t)$的估计</p><p>由于$U_t&#x3D;R_t+\gamma R_{t+1}+\gamma^2 R_{t+2}+…+\gamma^n R_n&#x3D;R_t+\gamma U_{t+1}$</p><p>基于这种思想,做一下蒙特卡洛近似，得出DQN的更新公式为$Q(s_t,a_t;w)&#x3D;r_t+\gamma Q(s_{t+1},a_{t+1};w)$</p><p>Loss也与TD算法相似:$L_t&#x3D;\frac{1}{2}[Q(s_t,a_t;w)-y_t]^2 $</p><p>流程总结：</p><ul><li>从当前状态s中选择一个动作a</li><li>执行动作a，获得奖励r并转移到新状态s′</li><li>将经历（s,a,r,s′）存储到回放缓冲区</li><li>从回放缓冲区中随机抽取一个小批量样本</li><li>对每个样本，计算目标Q值(TD target)并更新Q网络参数</li><li>每隔一定步数，更新目标网络参数</li></ul><h1 id="Policy-Based-Reinforcement-Learning"><a href="#Policy-Based-Reinforcement-Learning" class="headerlink" title="Policy-Based Reinforcement Learning"></a>Policy-Based Reinforcement Learning</h1><h2 id="Policy-Function"><a href="#Policy-Function" class="headerlink" title="Policy Function"></a>Policy Function</h2><p>策略函数$π(a|s)$是一个概率密度函数，其输入是某个状态s，输出是在该状态下可能产生的动作a的概率值。假设在状态$s_t$下，Agent可能做出的动作$a_t$可能有n个，那么$π(a_t|s_t)$即输出一个n维向量，其元素对应每个可能做出动作at的概率值。有了这n个概率值，Agent就会在这个向量中做一次随机抽样并做出所得到的动作$a_i$</p><h2 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a>Policy Gradient</h2><p>定义状态值函数近似函数$V(s;\theta)&#x3D;\Sigma_a\pi(a|s;\theta)Q_\pi(s,a)$，其中$\theta$是神经网络中的参数。V可以评价状态s和策略网络$π(a|s_t;θ)$的好坏。若给定状态s，策略网络越好，那么V的值越大。因此，我们采用V关于$θ$的随机梯度上升的方法更新参数θ，即策略梯度就是函数V对$\theta$的导数</p><p>大致流程：</p><ul><li>观测状态s</li><li>根据策略函数$\pi$随机采样一个a</li><li>根据$Q(s_tr,a_t)$近似$q_t$</li><li>对策略网络求导</li><li>近似策略梯度$g(a_t,\theta_t)&#x3D;q_t*d_{\theta,t}$</li><li>更新策略网络参数</li></ul><p>那么我们如何估计动作价值函数Q？</p><p>这里有两种方法：</p><p><code>REINFORCE算法</code>：必须获取到一个完整的采样trajectory才能进行一次模型参数的更新，也就是蒙特卡罗方法（MC Method）来估计Q</p><p><code>Actor-Critic（AC）</code>：使用另一个神经网络来近似Qπ</p><h2 id="Actor-Critic-Method"><a href="#Actor-Critic-Method" class="headerlink" title="Actor-Critic Method"></a>Actor-Critic Method</h2><p>Actor-Critic方法，是策略学习和价值学习结合的一种方法</p><p>Actor是策略网络，用来控制Agent运动，可以看做“演员”</p><p>Critic是价值网络，用来给演员打分，可以看做“评论家”</p><h3 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h3><p>Actor网络的输入为状态s</p><p>价值网络中包含：卷积层，将画面变成特征向量；全连接层，将特征向量转变为相对于动作空间（Action Space）中元素个数对应的向量；再采用Softmax激活函数将其转换为一策略的概率密度</p><h3 id="Critic"><a href="#Critic" class="headerlink" title="Critic"></a>Critic</h3><p>Critic网络的输入为状态s和动作a</p><p>对于两个不同的输入，处理方法如下：</p><p>针对于状态s，从输入中提取特征，获得一个状态特征向量</p><p>针对于动作a，采用全连接层提取特征，获得一个动作特征向量</p><p>然后将两个特征向量进行concat，得到一个更高维的特征向量，再通过一个全连接层输出一个实数$q(s,a;w)$，即Critic对于Agent处于状态s下做出动作a的评价</p><h3 id="训练神经网络"><a href="#训练神经网络" class="headerlink" title="训练神经网络"></a>训练神经网络</h3><ul><li>观测状态s</li><li>根据策略函数$\pi$随机采样一个a</li><li>执行动作a，获取下一个状态$s_{t+1}$和奖励r</li><li>使用TD算法更新Critic网络的参数</li><li>使用策略梯度更新Actor的参数</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>观测旧状态$s_t$，用策略网络$\pi$计算概率分布，随机采样动作$a_t$</li><li>执行$a_t$，得到新状态$s_{t+1}$和奖励$r_t$</li><li>根据新状态，随机采样动作$a_{t+1}$(假想的动作，并不会真的做)</li><li>计算价值网络$q_t&#x3D;q(s_t,a_t;w_t)$和$q_{t+1}&#x3D;q(s_{t+1},a_{t+1};w_t)$</li><li>计算TD error：$\delta_t&#x3D;q_t-(r_t+\gamma q_{t+1})$</li><li>对Critic参数求导，更新其参数$w_{t+1}&#x3D;w_t-\alpha \delta_t d_{w,t}$</li><li>对Actor参数求导，更新其参数$\theta_{t+1}&#x3D;\theta_t-\beta q_t d_{\theta,t}$</li></ul><h1 id="Monte-Carlo方法"><a href="#Monte-Carlo方法" class="headerlink" title="Monte Carlo方法"></a>Monte Carlo方法</h1><p>蒙特卡洛是一类通过随机采样和统计分析来估计问题解的方法，在强化学习中用于评估策略和估计价值函数</p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>随机采样</strong>：通过从可能的结果中随机采样，来估计某个数量的期望值或概率分布。</p><p><strong>经验回报</strong>：在每个episode中，通过累积获得的实际回报来估计状态或状态-动作对的价值。</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><p><strong>生成轨迹</strong>：根据当前策略，从起始状态开始，生成多条轨迹，每条轨迹包含一系列状态、动作和奖励，直到达到终止状态</p><p><strong>计算回报</strong>：对每条轨迹，计算每个时间步Return</p><p><strong>更新价值估计</strong>：根据每个状态或状态-动作对的回报，更新价值函数或Q值函数</p><h1 id="Sarsa算法"><a href="#Sarsa算法" class="headerlink" title="Sarsa算法"></a>Sarsa算法</h1><p>SARSA（State-Action-Reward-State-Action）是一种基于TD方法的强化学习算法，用于学习状态-动作价值函数。SARSA是一个on-policy算法，直接使用当前策略选择的动作来更新Q值</p><h2 id="表格形式的Sarsa"><a href="#表格形式的Sarsa" class="headerlink" title="表格形式的Sarsa"></a>表格形式的Sarsa</h2><p>如果agent的状态和动作是有限的，那么可以画一个表格，一行对应一个状态$s_i$，一列对应一个动作$a_j$，那么表中的每个元素则对应着在该状态和该动作下的动作价值$Q_π(s_i,a_j)$。我们要做的就是用Sarsa算法去更新表格，每次更新一个元素。</p><p>当我们观测到一个四元组$（s_t,a_t,r_t,s_{t+1}）$，这样的一个四元组被称为transition。然后采用策略函数$π$去采样一个$a_{t+1}$，接着计算TD target $y_t&#x3D;r_t+\gamma Q(s_{t+1},a_{t+1})$，Q值可以直接通过查表获得。同时我们也能计算出TD error $δ_t$，然后利用$δ_t$更新$Q_π(st,at)$，其中α是学习率</p><h2 id="神经网络形式的Sarsa"><a href="#神经网络形式的Sarsa" class="headerlink" title="神经网络形式的Sarsa"></a>神经网络形式的Sarsa</h2><p>采用价值网络来近似$Q_π(s,a)$，记为$q(s,a;w)$。动作价值函数Qπ和价值网络q都与策略π有关，策略π的好坏会影响这两个函数</p><p>神经网络$q(s,a;w)$被称为价值网络，它的输入是一个状态s，输出是状态s下对应动作的价值。如果有n个动作，那么价值网络q就会输出一个n维向量，向量元素对应在状态s下，各动作a的价值</p><p>TD target就变成了$y_t&#x3D;r_t+\gamma q(s_{t+1},a_{t+1};w)$，TD error变成$δ_t&#x3D;q(s_t,a_t;w)-y_t$</p><p>然后计算Loss，求梯度，更新网络参数w即可</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Sarsa算法主要是用于学习动作价值函数$Q_π(s,a)$</p><ul><li>表格形式（直接学习Qπ）</li></ul><p>适合有限个状态和动作且数量不大的情况。通过一张表格记录每种状态和动作对应的$Q_π(s,a)$的值，通过采用TD算法更新表中Q值。</p><ul><li>神经网络形式（采用函数近似）</li></ul><p>这种形式并不是直接获取Q，而是通过价值网络q(s,a;w)来近似动作价值函数Q</p><h1 id="Q-Learning算法"><a href="#Q-Learning算法" class="headerlink" title="Q-Learning算法"></a>Q-Learning算法</h1><p>Q-Learning是用于学习最优动作价值函数$Q^*(s,a)$</p><p>TD target的更新函数为$y_t&#x3D;r_t+\gamma maxQ^*(s_{t+1},a)$，对Q*求最大化</p><p>其他部分与Sarsa相同，只是Sarsa算法是学习动作价值函数Qπ；而Q-Learning是学习最优动作价值函数Q*</p><h1 id="Experience-Replay"><a href="#Experience-Replay" class="headerlink" title="Experience Replay"></a>Experience Replay</h1><p>我们通常使用TD算法来训练DQN，回顾一下TD算法的步骤：</p><ul><li>Agent在t时刻观测到一个状态st并做出动作at</li><li>Agent与环境交互获得了一个新的状态st+1并且获得了一个奖励rt</li><li>得到TD Target yt</li><li>计算TD error δt</li></ul><p>我们的目标是让qt接近yt，即TD error δt尽量的小，因此TD算法就是寻找一个神经网络参数w使损失函数（Loss Function）L(w)尽可能的小</p><ul><li>采用梯度下降来使$w_t$不断逼近w*</li></ul><p>$（s_t,a_t,r_t,s_{t+1}）$是一个transition，可以认为是一条训练数据，传统算法在使用完该训练数据后就把它丢掉，不再使用，这种对于DQN的训练效果并不好</p><h2 id="Replay-Buffer"><a href="#Replay-Buffer" class="headerlink" title="Replay Buffer"></a>Replay Buffer</h2><p>我们在使用完一个transition时，会把一个transition放入一个队列里，这个队列被称之为回放缓冲区（Replay Buffer），它的容量是一个超参数n，Replay Buffer可以存储n条transitions。如果Replay Buffer满了，那么新来的transition会替代老的transition</p><h3 id="TD算法中经验回放"><a href="#TD算法中经验回放" class="headerlink" title="TD算法中经验回放"></a>TD算法中经验回放</h3><p>我们通过找到神经网络参数w来最小化损失函数Loss Function。</p><p>使用随机梯度下降（Stochastic Gradient Descent SGD）来最小化Loss Function：从buffer中随机抽取一批transition，计算TD error δi，再算出随机梯度gi，调整神经网络参数w</p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="Prioritized-Experience-Replay"><a href="#Prioritized-Experience-Replay" class="headerlink" title="Prioritized Experience Replay"></a>Prioritized Experience Replay</h2><p>对于Agent而言，并不是所有的transition都同等重要，有些state较难遇见，统一抽样的话难以抽到，训练出的DQN对于数量较少的场景不熟悉，所以预测就会偏离TD Target，因此产生的TD error就比较大，即|δt|就大。正因为DQN不熟悉数量较少的场景，所以要让DQN给这些场景更高的优先级，让它更好的应对这样的场景。</p><p>优先经验回放的核心在于：使用非均匀抽样代替均匀抽样</p><p>这里有两种抽样方式：</p><ul><li>抽样概率pt正比于|δt|+ε：即TD error越大，被抽到的概率就越大</li><li>对|δt|排序：|δt|越大越靠前，容易被抽到</li></ul><h3 id="学习率调整"><a href="#学习率调整" class="headerlink" title="学习率调整"></a>学习率调整</h3><p>TD算法采用SGD来更新神经网络参数w，α是学习率，如果做均匀抽样，所有的transitions的学习率α都相同；如果做非均匀抽样，那么就要根据每个transition的重要性来调整学习率。</p><p>如果一个transition有一个较大的抽样概率pt，那么对这个transition的学习率就应该调小，可以采用如下圈出的方法来自适应调整学习率的因子：如果pt很大，那么学习率就会变小，学习率减小可以减小训练过程中的波动，提高收敛速度和精度，设置学习率为$\alpha(np_t)^{-\beta}$</p><h3 id="更新TD-Error"><a href="#更新TD-Error" class="headerlink" title="更新TD Error"></a>更新TD Error</h3><p>为了做优先经验回放，我们要对每一个transition标记上TD error δt。δt决定了这条transition的重要性，决定了它被抽样的概率。</p><p>如果一个transition刚刚被收集到，我们并不知道它的δt，那么我们就直接把它的δt设置为最大值，让它有最高的优先级。</p><p>每次从buffer中抽取一个transition，都要对它的δt进行一次更新</p><h2 id="缓解高估问题"><a href="#缓解高估问题" class="headerlink" title="缓解高估问题"></a>缓解高估问题</h2><p>由于DQN选择的是$maxQ^*(s_{t+1},a)$，而且原始的DQN使用Bootstrapping方式更新自己的参数，会导致严重的非均匀高估问题。</p><p>这里有两种方法用于缓解高估问题：</p><ul><li><p>使用目标网络（Target Network）</p></li><li><p>Double DQN</p></li></ul><h3 id="Target-Network"><a href="#Target-Network" class="headerlink" title="Target Network"></a>Target Network</h3><p>相比于DQN，Target Network是独立于DQN的。它与DQN有着相同的神经网络结构，但有不同的参数，记作w-。</p><p>我们使用Q(s,a;w)来控制Agent并且收集transition</p><p>使用Q(s,q;w-)来选择动作和计算TD target。</p><p>以前使用DQN来计算yt，用yt来更新DQN的参数。这会产生自举。现在我们使用Target Network，用Target Network来计算yt。这样就可以缓解高估问题。</p><h3 id="Double-DQN"><a href="#Double-DQN" class="headerlink" title="Double DQN"></a>Double DQN</h3><p>DDQN在选择动作时使用的是DQN原始的网络，在计算TD target时使用的是target network，这样相比原始DQN和target network可以更加缓解高估问题</p><h1 id="离散动作空间与连续动作空间"><a href="#离散动作空间与连续动作空间" class="headerlink" title="离散动作空间与连续动作空间"></a>离散动作空间与连续动作空间</h1><p>离散动作空间是一个集合，其中包含有限个动作。比如在玩2D横版过关游戏时，agent的动作空间只能是上下左右四种动作。对于动作空间是离散的agent可以使用传统的SARSA、DQN算法进行训练</p><p>连续动作空间就像是gym的摆杆子环境，或者机械臂控制，由于可以[0,360]度旋转，所以有无穷多种动作空间。对于连续的动作空间，可以使用离散化将连续动作空间变成离散的，但是对于自由度很高的agent，离散化的点就会很多，这会导致维度灾难，离散化只适合较小的连续动作空间</p><h2 id="Deterministic-Policy-Gradient"><a href="#Deterministic-Policy-Gradient" class="headerlink" title="Deterministic Policy Gradient"></a>Deterministic Policy Gradient</h2><p>DPG是策略梯度的变体，专门用于处理确定性策略。与传统的基于随机策略的策略梯度方法不同，DPG直接优化确定性策略，可以处理连续动作空间的问题。</p><p>在DPG中，策略$\mu(s; \theta)$是确定性的，即给定一个状态s，策略直接输出一个具体的动作a：$a &#x3D; \mu(s; \theta))$</p><p>DPG是属于AC方法，有一个策略网络，有一个价值网络</p><p>策略网络是一个确定性的网络，它的输入是状态s，它的输出不是概率分布，而是一个确定性的动作。只要给定状态s，那么对应的动作a就是一个具体的动作</p><p>价值网络有两个输入，一个是状态s一个是动作a，基于状态s，Critic对a进行打分。</p><h3 id="DPG的更新策略"><a href="#DPG的更新策略" class="headerlink" title="DPG的更新策略"></a>DPG的更新策略</h3><p>训练策略网络需要价值网络的帮忙，改善策略网络的参数θ以至于动作a可以依靠策略网络变得更好，而更新参数θ是要根据价值网络q(s,a;w)&#x3D;q(s,π(s;θ);w)的增加而决定的。</p><p>因而我们训练策略网络的目标是让价值网络q的输出变的更大。价值网络的输入是状态s,a，对于确定的状态，确定性策略网络会输出对应的动作a。</p><p>如果输入的状态s是固定的，Critic也是固定的，那么唯一会影响q（Critic的打分）的因素，就是Actor的参数θ。我们想要更新θ，让q变大，那么就可以求取q对θ的梯度，然后使用梯度上升来更新参数θ，这样就可以让价值q变大。这个梯度就叫做确定策略梯度DPG，它是价值q关于Actor参数θ的梯度</p>]]></content>
      
      
      <categories>
          
          <category> ReinforceLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReinforceLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch基础入门</title>
      <link href="/inori/8f832495.html"/>
      <url>/inori/8f832495.html</url>
      
        <content type="html"><![CDATA[<h1 id="两个实用函数"><a href="#两个实用函数" class="headerlink" title="两个实用函数"></a>两个实用函数</h1><p>假如pytorch是一个大型工具箱，我们想查看工具箱中有什么工具，这时就可以使用<code>dir()</code>函数查看，如果我们想知道某一个工具是如何使用的，就可以使用<code>help()</code>函数查看</p><ul><li><code>dir()</code>：可以查看指定对象包含的全部内容，包括变量、方法、函数和类等。不仅包含可供我们调用的模块成员，还包含所有名称以双下划线“__”开头和结尾的“特殊”命名的私有成员，这些成员是在本模块中使用的，不能在类的外部调用。</li><li><code>help()</code>：查看指定对象（类型、模块、变量、方法等）的详细使用说明</li></ul><h1 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h1><p>在学习和使用pytorch时，要经常使用<a href="https://pytorch.org/docs/stable/index.html">官方文档</a>，里面有详细的使用说明</p><h2 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h2><h3 id="加载数据方法及label形式"><a href="#加载数据方法及label形式" class="headerlink" title="加载数据方法及label形式"></a>加载数据方法及label形式</h3><p>Pytorch中加载数据需要Dataset、Dataloader</p><ul><li>Dataset提供一种方式去获取每个数据及其对应的label和编号，以及总共有多少个数据</li><li>Dataloader为后面的网络提供不同的数据形式，可以将数据进行打包</li></ul><p>label形式</p><ul><li>文件夹名即为label。文件夹中存放若干条数据</li><li>一个文件夹存放数据，数据有编号，另一个文件夹存放数据对应编号的说明文本（txt），文本中有label</li><li>直接把label写在数据的名称上</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br></pre></td></tr></table></figure><h3 id="通过路径加载数据"><a href="#通过路径加载数据" class="headerlink" title="通过路径加载数据"></a>通过路径加载数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img_path = <span class="string">&quot;数据路径/train/ants/0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure><h3 id="python特殊方法补充"><a href="#python特殊方法补充" class="headerlink" title="python特殊方法补充"></a>python特殊方法补充</h3><p>Python中有很多特殊方法，这些特殊方法的命名都以双下划线 <code>__</code>开头和结尾，它们是Python中常用的特殊方法。通过定义这些方法，我们可以自定义对象的行为和操作，使得对象能够更好地适应我们的需求</p><ul><li><code>__init__(self[, args...])</code>: 构造函数，用于在创建对象时进行初始化。即Java中的构造器</li><li><code>__repr__(self)</code>: 用于定义对象的字符串表示形式，通常用于调试和记录日志</li><li><code>__str__(self)</code>: 用于定义对象的字符串表示形式，通常用于显示给终端用户。即Java中的toString</li><li><code>__len__(self)</code>: 用于返回对象的长度，通常在对像被视为序列或集合时使用</li><li><code>__getitem__(self, key)</code>: 用于实现索引操作，可以通过索引或切片访问对象中的元素</li><li><code>__setitem__(self, key, value)</code>: 用于实现索引赋值操作，可以通过索引或切片为对象中的元素赋值</li><li><code>__delitem__(self, key)</code>: 用于实现删除某个元素的操作，可以通过索引或切片删除对象中的元素</li><li><code>__contains__(self, item)</code>: 用于检查对象是否包含某个元素，可以通过 in 关键字使用</li><li><code>__enter__(self)</code>: 用于实现上下文管理器的进入操作，通常与 with 语句一起使用</li><li><code>__exit__(self, exc_type, exc_value, traceback)</code>: 用于实现上下文管理器的退出操作，通常与 with 语句一起使用</li><li><code>__call__(self[, args...])</code>: 用于使对象能够像函数一样被调用，通常在创建可调用的类时使用</li><li><code>__eq__(self, other)</code>: 用于定义对象相等的比较操作，可以通过 &#x3D;&#x3D; 运算符使用</li><li><code>__lt__(self, other)</code>: 用于定义对象小于的比较操作，可以通过 &lt; 运算符使用</li><li><code>__gt__(self, other)</code>: 用于定义对象大于的比较操作，可以通过 &gt; 运算符使用</li><li><code>__add__(self, other)</code>: 用于实现对象加法操作，可以通过 + 运算符使用</li><li><code>__sub__(self, other)</code>: 用于实现对象减法操作，可以通过 - 运算符使用</li><li><code>__mul__(self, other)</code>: 用于实现对象乘法操作，可以通过 * 运算符使用</li><li><code>__truediv__(self, other)</code>: 用于实现对象除法操作，可以通过 &#x2F; 运算符使用</li></ul><h3 id="Dataset加载数据示例"><a href="#Dataset加载数据示例" class="headerlink" title="Dataset加载数据示例"></a>Dataset加载数据示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义数据集类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir  <span class="comment"># 记录数据集根目录的路径</span></span><br><span class="line">        self.label_dir = label_dir  <span class="comment"># 记录数据集标签目录的名称</span></span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)  <span class="comment"># os.path.join可将两个字符串拼接成一个完整路径，以获取数据集标签目录的完整路径</span></span><br><span class="line">        self.img_path = os.listdir(self.path)  <span class="comment"># os.listdir() 函数用于获取指定目录下的所有文件和文件夹的名称列表，以获取数据集标签目录下所有图像文件的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):  <span class="comment"># 获取数据集中指定索引位置的数据项</span></span><br><span class="line">        img_name = self.img_path[idx]  <span class="comment"># 获取图像文件名</span></span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)  <span class="comment"># 获取该图像文件的完整路径</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)  <span class="comment"># 打开图像文件</span></span><br><span class="line">        label = self.label_dir  <span class="comment"># 获取该图像文件所属的标签</span></span><br><span class="line">        <span class="keyword">return</span> img, label  <span class="comment"># 返回图像和标签</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;data/train&quot;</span>   <span class="comment"># 数据集根目录的路径</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span>     <span class="comment"># 蚂蚁标签目录的名称</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span>     <span class="comment"># 蜜蜂标签目录的名称</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)  <span class="comment"># 创建蚂蚁数据集对象</span></span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)   <span class="comment"># 创建蜜蜂数据集对象</span></span><br><span class="line">train_dataset = ants_dataset + bees_dataset  <span class="comment"># 合并蚂蚁和蜜蜂数据集，得到训练集</span></span><br><span class="line">img, label = train_dataset[<span class="number">200</span>]  <span class="comment"># 自动调用__getitem__() 方法，获取训练集中第 200 个数据项的图像和标签 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;label：&quot;</span>, label)   <span class="comment"># 查看该数据项的标签</span></span><br><span class="line">img.show()   </span><br></pre></td></tr></table></figure><h2 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h2><p>Tensorboad可以用来查看loss是否按照预想的变化，或者查看训练到某一步输出的图像是什么样</p><h3 id="Tensorboard使用示例"><a href="#Tensorboard使用示例" class="headerlink" title="Tensorboard使用示例"></a>Tensorboard使用示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)<span class="comment"># 创建一个 SummaryWriter 对象，指定日志存储目录为 &quot;logs&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># 将 y=x 的函数值添加到 TensorBoard 中</span></span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=x&quot;</span>, i, i)</span><br><span class="line">writer.close()<span class="comment"># 关闭 SummaryWriter 对象</span></span><br></pre></td></tr></table></figure><p>运行完后会在当前目录下创建一个logs文件夹</p><p>在终端运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=logs --port=6007</span><br></pre></td></tr></table></figure><h2 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h2><p>Transforms当成工具箱的话，里面的class就是不同的工具。例如像totensor、resize这些工具。Transforms拿一些特定格式的图片，经过Transforms里面的工具，获得我们想要的结果</p><h3 id="transforms-Totensor"><a href="#transforms-Totensor" class="headerlink" title="transforms.Totensor"></a>transforms.Totensor</h3><p>Tensor包装了神经网络需要的一些属性，比如反向传播、梯度等属性</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;/bees/10870992_eebeeb3a12.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line">tensor_trans = transforms.ToTensor()  <span class="comment"># 创建 transforms.ToTensor类 的实例化对象</span></span><br><span class="line">tensor_img = tensor_trans(img)  <span class="comment"># 调用 transforms.ToTensor类的__call__方法   </span></span><br><span class="line"></span><br><span class="line">writer.add_image(<span class="string">&quot;Temsor_img&quot;</span>,tensor_img)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h3 id="transforms-Resize"><a href="#transforms-Resize" class="headerlink" title="transforms.Resize()"></a>transforms.Resize()</h3><p>调整图像的大小到指定的尺寸</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;data/Images/1.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图片转为totensor类型</span></span><br><span class="line">trans_totensor = transforms.ToTensor() </span><br><span class="line">img_tensor = trans_totensor(img)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># resize图片，PIL数据类型的 img -&gt; resize -&gt; PIL数据类型的 img_resize</span></span><br><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>,<span class="number">512</span>))  <span class="comment"># 调整尺寸为512*512</span></span><br><span class="line">img_resize = trans_resize(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL 数据类型的 PIL -&gt; totensor -&gt; img_resize tensor</span></span><br><span class="line">img_resize = trans_totensor(img_resize)</span><br><span class="line"><span class="built_in">print</span>(img_resize.size()) </span><br></pre></td></tr></table></figure><h4 id="transforms-Compose"><a href="#transforms-Compose" class="headerlink" title="transforms.Compose"></a>transforms.Compose</h4><p>transforms.Compose 的作用是将多个数据预处理操作组合在一起，方便地对数据进行一次性处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;data/Images/1.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line">tensor_trans = transforms.ToTensor() </span><br><span class="line">img_tensor = tensor_trans(img)  </span><br><span class="line"></span><br><span class="line">trans_resize_2 = transforms.Resize(<span class="number">512</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL —— resize -&gt; PIL ——  totensor -&gt; tensor</span></span><br><span class="line">trans_compose = transforms.Compose([trans_resize_2, trans_totensor]) <span class="comment"># Compose函数中前面一个参数的输出为后面一个参数的输入，即trans_resize_2输出了pil，作为trans_totensor的输入</span></span><br><span class="line">img_resize_2 = trans_compose(img)</span><br><span class="line"><span class="built_in">print</span>(img_resize_2.size()) </span><br></pre></td></tr></table></figure><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>DataLoader可以将数据集进行批量处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备的测试数据集</span></span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor())    </span><br><span class="line"></span><br><span class="line"><span class="comment"># batch_size=4 使得 img0, target0 = dataset[0]、img1, target1 = dataset[1]、img2, target2 = dataset[2]、img3, target3 = dataset[3]，然后这四个数据作为Dataloader的一个返回      </span></span><br><span class="line">test_loader = DataLoader(dataset=test_data,batch_size=<span class="number">4</span>,shuffle=<span class="literal">True</span>,num_workers=<span class="number">0</span>,drop_last=<span class="literal">True</span>)      </span><br><span class="line"><span class="comment"># 用for循环取出DataLoader打包好的四个数据</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">        imgs, targets = data <span class="comment"># 每个data都是由4张图片组成，imgs.size 为 [4,3,32,32]，四张32×32图片三通道，targets由四个标签组成             </span></span><br><span class="line">        writer.add_images(<span class="string">&quot;Epoch：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch), imgs, step) <span class="comment"># 注意是images</span></span><br><span class="line">        step = step + <span class="number">1</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="nn-Module"><a href="#nn-Module" class="headerlink" title="nn.Module"></a>nn.Module</h3><p>orch.nn.Module是所有神经网络基本骨架，需要重写<code>__init__</code>和forward（前向传播）函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()  <span class="comment"># 继承</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):           <span class="comment"># 前向传播</span></span><br><span class="line">        output = <span class="built_in">input</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line">m = Module()</span><br><span class="line">x = torch.tensor(<span class="number">1.0</span>)  <span class="comment"># 创建一个值为 1.0 的tensor</span></span><br><span class="line">output = m(x)</span><br><span class="line"><span class="built_in">print</span>(output) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h3 id="卷积函数"><a href="#卷积函数" class="headerlink" title="卷积函数"></a>卷积函数</h3><p>convolution卷积，conv2d表示二维</p><p>weight卷积核的大小，bias偏置，stride步长，padding填充，group是分组卷积，对不同的通道使用不同的卷积核，言外之意一般是对每个通道使用相同卷积核</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()</span><br><span class="line">        self.conv1 = Conv2d(in_channels=<span class="number">3</span>,out_channels=<span class="number">6</span>,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">0</span>) <span class="comment"># 彩色图像输入为3层，我们想让它的输出为6层，选3 * 3 的卷积                </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">m = Module()</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = m(imgs)</span><br><span class="line">    <span class="built_in">print</span>(imgs.shape)   <span class="comment"># 输入为3通道32×32的64张图片</span></span><br><span class="line">    <span class="built_in">print</span>(output.shape) <span class="comment"># 输出为6通道30×30的64张图片</span></span><br></pre></td></tr></table></figure><h3 id="最大池化"><a href="#最大池化" class="headerlink" title="最大池化"></a>最大池化</h3><p>nn.MaxPool2d最大池化（下采样，最常用），nn.MaxUnpool2d（上采样），nn.AdaptiveMaxPool2d（自适应最大池化），ceil_mode&#x3D;True表示进位，默认为False，写论文会用到公式可以在官网查阅</p><p>最大池化的作用：保留输入的特征，同时把数据量减少，比如视频变720P</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn </span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> MaxPool2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()</span><br><span class="line">        self.maxpool = MaxPool2d(kernel_size=<span class="number">3</span>, ceil_mode=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        output = self.maxpool(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">m = Module()  <span class="comment"># 即调用forward()</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    output = m(imgs)</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step = step + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="非线性激活"><a href="#非线性激活" class="headerlink" title="非线性激活"></a>非线性激活</h3><p>作用：神经网络中引入非线性的特质，才能训练出符合各种特征的模型</p><p>nn.ReLU()小于0进行截断，大于0不变，nn.Sigmoid非线性缩放到[0,1]，1&#x2F;1+exp-x，inplace&#x3D;True表示把原来的值也改变（本来是通过返回值获取值）</p><h3 id="线性层及其它层"><a href="#线性层及其它层" class="headerlink" title="线性层及其它层"></a>线性层及其它层</h3><ul><li>Normalization Layers正则化层：加快神经网络的训练速度</li><li>Recurrent Layers用于文字识别，特定的网络结构，用的不多</li><li>Linear Layers：全连接层，用的较多</li><li>Dropout Layers随机将一些数设为0，防止过拟合</li><li>Distance Functions计算两个值之间的误差，常用余弦相似度</li><li>Loss Functions损失函数，常用值nn.MSELoss，nn.CrossEntropyLoss，nn.BCELoss，分布nn.NLLLoss，nn.KLDivLoss</li><li>torch.flatten()把输入展成一行，与reshape不同</li></ul><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><ul><li>Loss损失函数一方面计算实际输出和目标之间的差距</li><li>Loss损失函数另一方面为我们更新输出提供一定的依据(反向传播)</li></ul><p><strong>L1loss</strong>:差值的绝对值之和，再求平均值</p><p><strong>MSE</strong>:平方差</p><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度下降是一种优化算法，用于最小化损失函数（Loss Function）。神经网络的训练目标是通过不断调整网络的参数（即权重和偏置）来最小化损失函数的值。梯度下降算法通过计算损失函数相对于网络参数的梯度来指导参数更新的方向和步幅。</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>反向传播是一种高效计算梯度的方法，适用于多层神经网络。反向传播算法通过链式法则（Chain Rule）逐层计算损失函数对每个参数的梯度。</p><p><strong>反向传播和梯度下降的关系</strong></p><ol><li><strong>目标一致</strong>：两者的目标都是通过调整神经网络的参数来最小化损失函数</li><li><strong>互补</strong>：反向传播计算损失函数对参数的梯度，而梯度下降利用这些梯度更新参数</li><li><strong>训练过程</strong>：在神经网络的训练过程中，反向传播和梯度下降是交替进行的。首先进行前向传播，计算损失并通过反向传播计算梯度，然后使用梯度下降更新参数</li></ol><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>使用优化器时，首先需要optim.zero_grad()，把上一步的梯度清零，否则会累加，然后进行反向传播，再optimizer.step()，对weight参数进行更新</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear, Sequential</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                       download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loss = nn.CrossEntropyLoss()  <span class="comment"># 交叉熵</span></span><br><span class="line">m = Module()</span><br><span class="line">optim = torch.optim.SGD(tudui.parameters(), lr=<span class="number">0.01</span>)  <span class="comment"># 随机梯度下降优化器 lr为学习率,学习率太大不稳定,太小收敛慢</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化20轮</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        outputs = m(imgs)</span><br><span class="line">        result_loss = loss(outputs, targets) <span class="comment"># 计算实际输出与目标输出的差距</span></span><br><span class="line">        optim.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">        result_loss.backward() <span class="comment"># 反向传播，计算损失函数的梯度</span></span><br><span class="line">        optim.step()   <span class="comment"># 根据梯度，对网络的参数进行调优</span></span><br><span class="line">        running_loss = running_loss + result_loss</span><br><span class="line">    <span class="built_in">print</span>(running_loss) <span class="comment"># 每轮误差的总和</span></span><br></pre></td></tr></table></figure><h3 id="train-和tudui-eval-方法"><a href="#train-和tudui-eval-方法" class="headerlink" title="train()和tudui.eval()方法"></a>train()和tudui.eval()方法</h3><p>分别用于训练步骤和测试步骤，对特定层起作用，最好可以在训练和评估之前加上这个方法</p><h2 id="网络模型的保存和读取"><a href="#网络模型的保存和读取" class="headerlink" title="网络模型的保存和读取"></a>网络模型的保存和读取</h2><p>使用<code>save</code>方法保存网络模型的结构和参数，<code>load</code>加载时候要把模型定义给复制过来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(SimpleModel, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.fc(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">model = SimpleModel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存权重</span></span><br><span class="line">torch.save(model.state_dict(), <span class="string">&#x27;model_weights.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载权重</span></span><br><span class="line">loaded_model = SimpleModel()</span><br><span class="line">loaded_model.load_state_dict(torch.load(<span class="string">&#x27;model_weights.pth&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保模型和加载的权重一致</span></span><br><span class="line">loaded_model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以继续使用加载的模型进行预测等操作</span></span><br></pre></td></tr></table></figure><h2 id="利用GPU训练"><a href="#利用GPU训练" class="headerlink" title="利用GPU训练"></a>利用GPU训练</h2><p>在程序之前定义:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后找到</p><ul><li>网络模型</li><li>数据（输入、标注）</li><li>损失函数</li></ul><p>后面加上<code>to(device)</code>即可转到GPU训练</p><h2 id="完整版实战"><a href="#完整版实战" class="headerlink" title="完整版实战"></a>完整版实战</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义训练的设备</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()        </span><br><span class="line">        self.model1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),  <span class="comment"># 输入通道3，输出通道32，卷积核尺寸5×5，步长1，填充2    </span></span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Flatten(),  <span class="comment"># 展平后变成 64*4*4 了</span></span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>,<span class="number">64</span>),</span><br><span class="line">            nn.Linear(<span class="number">64</span>,<span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据集</span></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">True</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line"></span><br><span class="line"><span class="comment"># length 长度</span></span><br><span class="line">train_data_size = <span class="built_in">len</span>(train_data)</span><br><span class="line">test_data_size = <span class="built_in">len</span>(test_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 Dataloader 来加载数据集</span></span><br><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>)        </span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网络模型</span></span><br><span class="line">m = Module() </span><br><span class="line">m = m.to(device) <span class="comment"># 也可以不赋值，直接m.to(device) </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss() <span class="comment"># 交叉熵</span></span><br><span class="line">loss_fn = loss_fn.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化器</span></span><br><span class="line">learning = <span class="number">0.01</span></span><br><span class="line">optimizer = torch.optim.SGD(tudui.parameters(),learning)   <span class="comment"># 随机梯度下降优化器  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置网络的一些参数</span></span><br><span class="line"><span class="comment"># 记录训练的次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 记录测试的次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练的轮次</span></span><br><span class="line">epoch = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 tensorboard</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----第 &#123;&#125; 轮训练开始-----&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练步骤开始</span></span><br><span class="line">    tudui.train() <span class="comment"># 当网络中有dropout层、batchnorm层时，这些层能起作用</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, targets = data            </span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        targets = targets.to(device)</span><br><span class="line">        outputs = tudui(imgs)</span><br><span class="line">        loss = loss_fn(outputs, targets) <span class="comment"># 计算实际输出与目标输出的差距</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 优化器对模型调优</span></span><br><span class="line">        optimizer.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">        loss.backward() <span class="comment"># 反向传播，计算损失函数的梯度</span></span><br><span class="line">        optimizer.step()   <span class="comment"># 根据梯度，对网络的参数进行调优</span></span><br><span class="line">        </span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            <span class="built_in">print</span>(end_time - start_time) <span class="comment"># 运行训练一百次后的时间间隔</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;训练次数：&#123;&#125;，Loss：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_train_step,loss.item()))  <span class="comment"># 方式二：获得loss值</span></span><br><span class="line">            writer.add_scalar(<span class="string">&quot;train_loss&quot;</span>,loss.item(),total_train_step)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试步骤开始（每一轮训练后都查看在测试数据集上的loss情况）</span></span><br><span class="line">    tudui.<span class="built_in">eval</span>()  <span class="comment"># 当网络中有dropout层、batchnorm层时，这些层不能起作用</span></span><br><span class="line">    total_test_loss = <span class="number">0</span></span><br><span class="line">    total_accuracy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 没有梯度了</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader: <span class="comment"># 测试数据集提取数据</span></span><br><span class="line">            imgs, targets = data <span class="comment"># 数据放到cuda上</span></span><br><span class="line">            imgs = imgs.to(device) <span class="comment"># 也可以不赋值，直接 imgs.to(device)</span></span><br><span class="line">            targets = targets.to(device) <span class="comment"># 也可以不赋值，直接 targets.to(device)</span></span><br><span class="line">            outputs = tudui(imgs)</span><br><span class="line">            loss = loss_fn(outputs, targets) <span class="comment"># 仅data数据在网络模型上的损失</span></span><br><span class="line">            total_test_loss = total_test_loss + loss.item() <span class="comment"># 所有loss</span></span><br><span class="line">            accuracy = (outputs.argmax(<span class="number">1</span>) == targets).<span class="built_in">sum</span>()</span><br><span class="line">            total_accuracy = total_accuracy + accuracy</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的Loss：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_test_loss))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的正确率：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_accuracy/test_data_size))</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_loss&quot;</span>,total_test_loss,total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_accuracy&quot;</span>,total_accuracy/test_data_size,total_test_step)  </span><br><span class="line">    total_test_step = total_test_step + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    torch.save(m, <span class="string">&quot;./model/m_&#123;&#125;.pth&quot;</span>.<span class="built_in">format</span>(i)) <span class="comment"># 保存每一轮训练后的结果</span></span><br><span class="line">    <span class="comment">#torch.save(m.state_dict(),&quot;m_&#123;&#125;.path&quot;.format(i)) # 保存方式二         </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型已保存&quot;</span>)</span><br><span class="line">    </span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><p>**with torch.no_grad()**表示在训练数据集的同时进行验证，可以让之后的代码不影响目前的梯度</p>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy常用api</title>
      <link href="/inori/e0d16fd2.html"/>
      <url>/inori/e0d16fd2.html</url>
      
        <content type="html"><![CDATA[<p>NumPy，全称Numerical Python，是一个开源的Python库，它为Python提供了强大的多维数组对象和用于处理这些数组的函数。NumPy的核心是ndarray，它是一个高效的多维数组容器，用于存储和处理大规模的数据。NumPy还提供了许多数学函数，用于数组之间的操作，以及用于线性代数、傅立叶变换和随机数生成等功能。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h3><p><code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p><p>上面的构造器接受以下参数：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">object</td><td align="left">返回一个数组或任何（嵌套）序列</td></tr><tr><td align="left">dtype</td><td align="left">数组的所需数据类型，可选</td></tr><tr><td align="left">copy</td><td align="left">可选，默认为<code>true</code>，对象是否被复制</td></tr><tr><td align="left">order</td><td align="left"><code>C</code>（按行）、<code>F</code>（按列）或<code>A</code>（任意，默认）</td></tr><tr><td align="left">subok</td><td align="left">默认情况下，返回的数组被强制为基类数组。 如果为<code>true</code>，则返回子类</td></tr><tr><td align="left">ndmin</td><td align="left">指定返回数组的最小维数</td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  </span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">c = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], ndmin =  <span class="number">2</span>) </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a = [1, 2, 3]</span></span><br><span class="line"><span class="string">b = [[1, 2] ,[3, 4]]</span></span><br><span class="line"><span class="string">c = [[1,2,3,4,5]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><p>创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组</p><p><code>numpy.empty(shape, dtype = float, order = &#39;C&#39;)</code></p><h3 id="zeros"><a href="#zeros" class="headerlink" title="zeros"></a>zeros</h3><p>创建指定大小的数组，数组元素以 0 来填充：</p><p><code>numpy.zeros(shape, dtype = float, order = &#39;C&#39;)</code></p><h3 id="ones"><a href="#ones" class="headerlink" title="ones"></a>ones</h3><p>创建指定形状的数组，数组元素以 1 来填充：</p><p><code>numpy.ones(shape, dtype = None, order = &#39;C&#39;)</code></p><h3 id="zeros-like"><a href="#zeros-like" class="headerlink" title="zeros_like"></a>zeros_like</h3><p>创建一个与给定数组具有相同形状的数组，数组元素以 0 来填充</p><p><code>numpy.zeros_like(a, dtype=None, order=&#39;K&#39;, subok=True, shape=None)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个 3x3 的二维数组</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个与 arr 形状相同的，所有元素都为 0 的数组</span></span><br><span class="line">zeros_arr = np.zeros_like(arr)</span><br><span class="line"><span class="built_in">print</span>(zeros_arr)</span><br></pre></td></tr></table></figure><h3 id="asarray"><a href="#asarray" class="headerlink" title="asarray"></a>asarray</h3><p>类似numpy.array，但参数只有三个</p><p><code>numpy.asarray(a, dtype = None, order = None)</code></p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line">a = np.asarray(x)  <span class="comment"># [1,2,3] </span></span><br><span class="line"></span><br><span class="line">x =  (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line">a = np.asarray(x) <span class="comment"># [1,2,3]</span></span><br><span class="line"></span><br><span class="line">x =  [(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>)] </span><br><span class="line">a = np.asarray(x) <span class="comment"># [1,2,3] </span></span><br></pre></td></tr></table></figure><h3 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h3><p>创建数值范围并返回ndarray对象</p><p><code>numpy.arange(start, stop, step, dtype)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">起始值，默认为<code>0</code></td></tr><tr><td align="left"><code>stop</code></td><td align="left">终止值（不包含）</td></tr><tr><td align="left"><code>step</code></td><td align="left">步长，默认为<code>1</code></td></tr><tr><td align="left"><code>dtype</code></td><td align="left">返回<code>ndarray</code>的数据类型，如果没有提供，则会使用输入数据的类型。</td></tr></tbody></table><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(x)<span class="comment"># [10  12  14  16  18]</span></span><br></pre></td></tr></table></figure><h3 id="linspace"><a href="#linspace" class="headerlink" title="linspace"></a>linspace</h3><p>用于创建一个一维数组，数组是一个等差数列构成的</p><p><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">序列的起始值</td></tr><tr><td align="left"><code>stop</code></td><td align="left">序列的终止值，如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td align="left"><code>num</code></td><td align="left">要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td align="left"><code>endpoint</code></td><td align="left">该值为<code>true</code>时，数列中包含<code>stop</code>值，反之不包含，默认是True</td></tr><tr><td align="left"><code>retstep</code></td><td align="left">如果为<code>true</code>时，生成的数组中会显示间距，反之不显示</td></tr><tr><td align="left"><code>dtype</code></td><td align="left">数据类型</td></tr></tbody></table><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 设置起始点为 1 ，终止点为 10，数列个数为 10</span></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># [ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]</span></span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">10</span>, <span class="number">20</span>,  <span class="number">5</span>, endpoint =  <span class="literal">False</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># [10. 12. 14. 16. 18.]</span></span><br></pre></td></tr></table></figure><h3 id="logspace"><a href="#logspace" class="headerlink" title="logspace"></a>logspace</h3><p>用于创建一个等比数列</p><p><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">序列的起始值为：$base^{start}$</td></tr><tr><td align="left"><code>stop</code></td><td align="left">序列的终止值为：$base^{stop}$。如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td align="left"><code>num</code></td><td align="left">要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td align="left"><code>endpoint</code></td><td align="left">该值为 <code>true</code> 时，数列中中包含<code>stop</code>值，反之不包含，默认是<code>true</code></td></tr><tr><td align="left"><code>base</code></td><td align="left">对数 log 的底数，默认底数是 10</td></tr><tr><td align="left"><code>dtype</code></td><td align="left">数据类型</td></tr></tbody></table><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 默认底数是 10</span></span><br><span class="line">a = np.logspace(<span class="number">1.0</span>,  <span class="number">2.0</span>, num =  <span class="number">10</span>)  </span><br><span class="line"><span class="built_in">print</span> (a)<span class="comment"># [ 10. 12.91549665 16.68100537 21.5443469  27.82559402 35.93813664  46.41588834  59.94842503  77.42636827  100.]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数的底数设置为 2 </span></span><br><span class="line">a = np.logspace(<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,base=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (a)<span class="comment"># [  1.   2.   4.   8.  16.  32.  64. 128. 256. 512.]</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>NumPy支持比Python更多种类的数值类型</p><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bool_</code></td><td align="left">存储为一个字节的布尔值（真或假）</td></tr><tr><td align="left"><code>int_</code></td><td align="left">默认整数，相当于 C 的<code>long</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left"><code>intc</code></td><td align="left">相当于 C 的<code>int</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left"><code>intp</code></td><td align="left">用于索引的整数，相当于 C 的<code>size_t</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left"><code>int8</code></td><td align="left">字节（-128 ~ 127）</td></tr><tr><td align="left"><code>int16</code></td><td align="left">16 位整数（-32768 ~ 32767）</td></tr><tr><td align="left"><code>int32</code></td><td align="left">32 位整数（-2147483648 ~ 2147483647）</td></tr><tr><td align="left"><code>int64</code></td><td align="left">64 位整数（-9223372036854775808 ~ 9223372036854775807）</td></tr><tr><td align="left"><code>uint8</code></td><td align="left">8 位无符号整数（0 ~ 255）</td></tr><tr><td align="left"><code>uint16</code></td><td align="left">16 位无符号整数（0 ~ 65535）</td></tr><tr><td align="left"><code>uint32</code></td><td align="left">32 位无符号整数（0 ~ 4294967295）</td></tr><tr><td align="left"><code>uint64</code></td><td align="left">64 位无符号整数（0 ~ 18446744073709551615）</td></tr><tr><td align="left"><code>float_</code></td><td align="left"><code>float64</code>的简写</td></tr><tr><td align="left"><code>float16</code></td><td align="left">半精度浮点：符号位，5 位指数，10 位尾数</td></tr><tr><td align="left"><code>float32</code></td><td align="left">单精度浮点：符号位，8 位指数，23 位尾数</td></tr><tr><td align="left"><code>float64</code></td><td align="left">双精度浮点：符号位，11 位指数，52 位尾数</td></tr><tr><td align="left"><code>complex_</code></td><td align="left"><code>complex128</code>的简写</td></tr><tr><td align="left"><code>complex64</code></td><td align="left">复数，由两个 32 位浮点表示（实部和虚部）</td></tr><tr><td align="left"><code>complex128</code></td><td align="left">复数，由两个 64 位浮点表示（实部和虚部）</td></tr></tbody></table><p>NumPy数字类型是<code>dtype</code>（数据类型）对象的实例，每个对象具有唯一的特征。这些类型可以是<code>np.bool_</code>，<code>np.float32</code>等。</p><p>数据类型对象描述了对应于数组的固定内存块的解释，取决于以下方面：</p><ul><li>数据类型（整数、浮点或者Python对象）</li><li>数据大小</li><li>字节序（小端或大端）</li><li>在结构化类型的情况下，字段的名称，每个字段的数据类型，和每个字段占用的内存块部分</li><li>如果数据类型是子序列，它的形状和数据类型</li></ul><p>字节顺序取决于数据类型的前缀<code>&lt;</code>或<code>&gt;</code>。 <code>&lt;</code>意味着编码是小端（最小有效字节存储在最小地址中）。 <code>&gt;</code>意味着编码是大端（最大有效字节存储在最小地址中）。</p><p><code>dtype</code>可由以下语法构造：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br></pre></td></tr></table></figure><ul><li><code>Object</code>：被转换为数据类型的对象</li><li><code>align</code>：向字段添加间隔，填充字段使其类似结构体</li><li><code>copy</code>：生成<code>dtype</code>对象的新副本，如果为<code>false</code>，结果是内建数据类型对象的引用</li></ul><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 使用标量类型</span></span><br><span class="line">dt = np.dtype(np.int32)</span><br><span class="line"><span class="comment"># int8, int16, int32, int64 四种数据类型可以使用字符串 &#x27;i1&#x27;, &#x27;i2&#x27;,&#x27;i4&#x27;,&#x27;i8&#x27; 代替</span></span><br><span class="line">dt = np.dtype(<span class="string">&#x27;i4&#x27;</span>)</span><br><span class="line"><span class="comment"># 将数据类型应用于 ndarray 对象</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype = dt) </span><br><span class="line"></span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]) </span><br><span class="line">a = np.array([(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="comment"># [(&#x27;abc&#x27;, 21, 50.0), (&#x27;xyz&#x27;, 18, 75.0)]</span></span><br></pre></td></tr></table></figure><h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><p>数组的维数称为秩（rank），秩就是轴的数量，一维数组的秩为1，二维数组的秩为2</p><p>在NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是NumPy中的轴，第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量秩，就是数组的维数。</p><p>很多时候可以声明axis。axis&#x3D;0，表示沿着第0轴进行操作，即对每一列进行操作；axis&#x3D;1，表示沿着第1轴进行操作，即对每一行进行操作</p><p>NumPy的数组中比较重要ndarray对象属性有：</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.ndim</td><td align="left">秩，即轴的数量或维度的数量</td></tr><tr><td align="left">ndarray.shape</td><td align="left">数组的维度，对于矩阵，n行m列</td></tr><tr><td align="left">ndarray.size</td><td align="left">数组元素的总个数，相当于<code>.shape</code>中n*m的值</td></tr><tr><td align="left">ndarray.dtype</td><td align="left">元素类型</td></tr><tr><td align="left">ndarray.itemsize</td><td align="left">每个元素的大小，以字节为单位</td></tr><tr><td align="left">ndarray.flags</td><td align="left">内存信息</td></tr><tr><td align="left">ndarray.real</td><td align="left">实部</td></tr><tr><td align="left">ndarray.imag</td><td align="left">虚部</td></tr></tbody></table><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">24</span>)  </span><br><span class="line"><span class="built_in">print</span> (a.ndim)<span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整大小</span></span><br><span class="line">b = a.reshape(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span> (b.ndim)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span> (a.shape)<span class="comment"># (2, 3)</span></span><br><span class="line"><span class="comment"># 调整数组大小</span></span><br><span class="line">a.shape =  (<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span> (a)<span class="comment"># [[1 2],[3 4],[5 6]]</span></span><br></pre></td></tr></table></figure><h2 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h2><p>ndarray对象的内容可以通过索引或切片来访问和修改，与Python中list的切片操作一样。</p><p>ndarray数组可以基于0-n的下标进行索引，切片对象可以通过内置的slice函数，并设置start, stop及step参数进行，从原数组中切割出一个新数组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)   <span class="comment"># 从索引 2 开始到索引 7 停止，间隔为2</span></span><br><span class="line"><span class="built_in">print</span> (a[s])<span class="comment"># [2  4  6]</span></span><br><span class="line"></span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>]   <span class="comment"># 从索引 2 开始到索引 7 停止，间隔为 2</span></span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment"># [2  4  6]</span></span><br></pre></td></tr></table></figure><p>多维数组同样适用上述索引提取方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 从某个索引处开始切割</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;从数组索引 a[1:] 处开始切割&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    [[1 2 3]</span></span><br><span class="line"><span class="string">     [3 4 5]</span></span><br><span class="line"><span class="string">     [4 5 6]]</span></span><br><span class="line"><span class="string">    从数组索引 a[1:] 处开始切割</span></span><br><span class="line"><span class="string">    [[3 4 5]</span></span><br><span class="line"><span class="string">     [4 5 6]]</span></span><br><span class="line"><span class="string"> &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>切片还可以包括省略号<code>**…**</code>，如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>])   <span class="comment"># 第2列元素</span></span><br><span class="line"><span class="built_in">print</span> (a[<span class="number">1</span>,...])   <span class="comment"># 第2行元素</span></span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>:])  <span class="comment"># 第2列及剩下的所有元素</span></span><br></pre></td></tr></table></figure><ul><li><code>a[..., 1]</code> 的意思是：选择数组 <code>a</code> 的所有行，并选取每行的第2个元素（索引1处的元素）</li><li><code>a[1, ...]</code> 的意思是：选取数组 <code>a</code> 的第2行（索引1处的整行），并保留该行的所有列</li><li><code>...</code> 表示取所有剩余维度</li></ul><h3 id="高级索引"><a href="#高级索引" class="headerlink" title="高级索引"></a>高级索引</h3><h4 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h4><p>整数数组索引是指使用一个数组来访问另一个数组的元素。这个数组中的每个元素都是目标数组中某个维度上的索引值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([[<span class="number">1</span>,  <span class="number">2</span>],  [<span class="number">3</span>,  <span class="number">4</span>],  [<span class="number">5</span>,  <span class="number">6</span>]]) </span><br><span class="line"><span class="comment"># 获取数组中 (0,0)、(1,1)和(2,0)位置处的元素</span></span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]  </span><br><span class="line"><span class="built_in">print</span> (y)</span><br></pre></td></tr></table></figure><p><code>x[[0, 1, 2], [0, 1, 0]]</code>的意思是：</p><ul><li>选取<code>x</code>中的元素，其行索引由第一个数组 <code>[0, 1, 2]</code> 指定</li><li>列索引由第二个数组 <code>[0, 1, 0]</code> 指定</li></ul><p>具体选取的元素为：</p><ul><li><code>x[0, 0]</code> -&gt; 第0行第0列的元素，值为1</li><li><code>x[1, 1]</code> -&gt; 第1行第1列的元素，值为4</li><li><code>x[2, 0]</code> -&gt; 第2行第0列的元素，值为5</li></ul><h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h4><p>可以通过一个布尔数组来索引目标数组，布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([[  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],[  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],[  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],[  <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span> (x)</span><br><span class="line"><span class="comment"># 打印出大于5的元素  </span></span><br><span class="line"><span class="built_in">print</span>  (<span class="string">&#x27;大于 5 的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (x[x &gt;  <span class="number">5</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[ 0  1  2]</span></span><br><span class="line"><span class="string"> [ 3  4  5]</span></span><br><span class="line"><span class="string"> [ 6  7  8]</span></span><br><span class="line"><span class="string"> [ 9 10 11]]</span></span><br><span class="line"><span class="string">大于 5 的元素是：</span></span><br><span class="line"><span class="string">[ 6  7  8  9 10 11]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播(Broadcast)是numpy对不同形状(shape)的数组（a.shape !&#x3D; b.shape）进行数值计算的方式，对数组的算术运算通常在相应的元素上进行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[ 0  1  2]</span></span><br><span class="line"><span class="string"> [10 11 12]</span></span><br><span class="line"><span class="string"> [20 21 22]</span></span><br><span class="line"><span class="string"> [30 31 32]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>3x3的二维数组与长为3的一维数组相加，等效于把一维数组在二维上重复3次再运算</p><h3 id="广播规则"><a href="#广播规则" class="headerlink" title="广播规则"></a>广播规则</h3><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加1补齐</li><li>输出数组的形状是输入数组形状的各个维度上的最大值</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为1时，这个数组能够用来计算，否则出错</li><li>当输入数组的某个维度的长度为1时，沿着此维度运算时都用此维度上的第一组值</li></ul><p><strong>简单理解：</strong></p><p>对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li>数组拥有相同形状</li><li>当前维度的值相等</li><li>当前维度的值有一个是 1</li></ul><p>若条件不满足，抛出 <strong>“ValueError: frames are not aligned”</strong> 异常</p><h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><p>NumPy提供了很多统计函数，用于从数组中查找最小元素，最大元素，百分位标准差和方差等</p><h3 id="numpy-amin-和-numpy-amax"><a href="#numpy-amin-和-numpy-amax" class="headerlink" title="numpy.amin() 和 numpy.amax()"></a>numpy.amin() 和 numpy.amax()</h3><p>用于计算数组中的元素沿指定轴的最小值</p><p><code>numpy.(amin|amax)(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></p><ul><li><code>a</code>: 输入的数组，可以是一个NumPy数组或类似数组的对象</li><li><code>axis</code>: 可选参数，用于指定在哪个轴上计算最值。如果不提供此参数，则返回整个数组的最小值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴</li><li><code>out</code>: 可选参数，用于指定结果的存储位置</li><li><code>keepdims</code>: 可选参数，如果为True，将保持结果数组的维度数目与输入数组相同。如果为False（默认值），则会去除计算后维度为1的轴</li><li><code>initial</code>: 可选参数，用于指定一个初始值，然后在数组的元素上计算最值</li><li><code>where</code>: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素</li></ul><h3 id="numpy-ptp"><a href="#numpy-ptp" class="headerlink" title="numpy.ptp()"></a>numpy.ptp()</h3><p>计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><p><code>numpy.ptp(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></p><ul><li><code>axis</code>: 可选参数，用于指定在哪个轴上计算峰值。如果不提供此参数，则返回整个数组的峰值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴</li><li><code>initial</code>: 可选参数，用于指定一个初始值，然后在数组的元素上计算峰值</li></ul><h3 id="numpy-percentile"><a href="#numpy-percentile" class="headerlink" title="numpy.percentile()"></a>numpy.percentile()</h3><p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比</p><p><code>numpy.percentile(a, q, axis)</code></p><ul><li>a: 输入数组</li><li>q: 要计算的百分位数，在0~100之间</li><li>axis: 沿着它计算百分位数的轴</li></ul><p><strong>百分位数：</strong></p><p>第p个百分位数是这样一个值，它使得至少有p%的数据项小于或等于这个值，且至少有(100-p)%的数据项大于或等于这个值</p><h3 id="numpy-median"><a href="#numpy-median" class="headerlink" title="numpy.median()"></a>numpy.median()</h3><p>用于计算数组a中元素的中位数（中值）</p><p><code>numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=&lt;no value&gt;)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line">wt = np.array([<span class="number">3</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span> (np.average(a, axis =  <span class="number">1</span>, weights = wt))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (np.average(a, axis =  <span class="number">1</span>, weights = wt, returned =  <span class="literal">True</span>))</span><br></pre></td></tr></table></figure><h3 id="numpy-mean"><a href="#numpy-mean" class="headerlink" title="numpy.mean()"></a>numpy.mean()</h3><p>返回数组中元素的平均值，如果提供了轴，则沿其计算，算术平均值是沿轴的元素的总和除以元素的数量</p><p><code>numpy.mean(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)</code></p><h3 id="numpy-average"><a href="#numpy-average" class="headerlink" title="numpy.average()"></a>numpy.average()</h3><p>根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值，该函数可以接受一个轴参数。如果没有指定轴，则数组会被展开</p><p><code>numpy.average(a, axis=None, weights=None, returned=False)</code></p><p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数</p><p>考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值</p><p><code>加权平均值 = (1*4+2*3+3*2+4*1)/(4+3+2+1)</code></p><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方的平均数</p><p><code>numpy.var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;, *, where=&lt;no value&gt;, mean=&lt;no value&gt;)</code></p><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h3><p>标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。</p><p><code>numpy.std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></p><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>NumPy 提供了标准的三角函数：sin()、cos()、tan()</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">0</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">60</span>,<span class="number">90</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;含有正弦值的数组：&#x27;</span>)</span><br><span class="line">sin = np.sin(a*np.pi/<span class="number">180</span>)</span><br><span class="line"><span class="built_in">print</span>(sin)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;计算角度的反正弦，返回值以弧度为单位：&#x27;</span>)</span><br><span class="line">inv = np.arcsin(sin)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;通过转化为角度制来检查结果：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arccos 和 arctan 函数行为类似：&#x27;</span>)</span><br><span class="line">cos = np.cos(a*np.pi/<span class="number">180</span>)  </span><br><span class="line"><span class="built_in">print</span>(cos)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;反余弦：&#x27;</span>)</span><br><span class="line">inv = np.arccos(cos)  </span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;角度制单位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;tan 函数：&#x27;</span>)</span><br><span class="line">tan = np.tan(a*np.pi/<span class="number">180</span>)  </span><br><span class="line"><span class="built_in">print</span>(tan)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;反正切：&#x27;</span>)</span><br><span class="line">inv = np.arctan(tan)  </span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;角度制单位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br></pre></td></tr></table></figure><h3 id="舍入函数"><a href="#舍入函数" class="headerlink" title="舍入函数"></a>舍入函数</h3><p>返回指定数字的四舍五入值</p><p><code>numpy.around(a,decimals)</code></p><ul><li>a: 数组</li><li>decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1.0</span>,<span class="number">5.55</span>,  <span class="number">123</span>,  <span class="number">0.567</span>,  <span class="number">25.532</span>])  </span><br><span class="line"><span class="built_in">print</span>  (<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;舍入后：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (np.around(a))</span><br><span class="line"><span class="built_in">print</span> (np.around(a, decimals =  <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span> (np.around(a, decimals =  -<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">原数组：</span></span><br><span class="line"><span class="string">[  1.      5.55  123.      0.567  25.532]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">舍入后：</span></span><br><span class="line"><span class="string">[  1.   6. 123.   1.  26.]</span></span><br><span class="line"><span class="string">[  1.    5.6 123.    0.6  25.5]</span></span><br><span class="line"><span class="string">[  0.  10. 120.   0.  30.]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="矩阵库"><a href="#矩阵库" class="headerlink" title="矩阵库"></a>矩阵库</h2><p>NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象</p><p>一个<code>m*n</code>的矩阵是一个由m行n列元素排列成的矩形阵列,矩阵里的元素可以是数字、符号或数学式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;转置数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a.T)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">原数组：</span></span><br><span class="line"><span class="string">[[ 0  1  2  3]</span></span><br><span class="line"><span class="string"> [ 4  5  6  7]</span></span><br><span class="line"><span class="string"> [ 8  9 10 11]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">转置数组：</span></span><br><span class="line"><span class="string">[[ 0  4  8]</span></span><br><span class="line"><span class="string"> [ 1  5  9]</span></span><br><span class="line"><span class="string"> [ 2  6 10]</span></span><br><span class="line"><span class="string"> [ 3  7 11]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="matlib-empty"><a href="#matlib-empty" class="headerlink" title="matlib.empty()"></a>matlib.empty()</h3><p>返回一个新的矩阵，矩阵内的元素为未初始化的值:</p><p><code>numpy.matlib.empty(shape, dtype, order)</code></p><ul><li><strong>shape</strong>: 定义新矩阵形状的整数或整数元组</li><li><strong>Dtype</strong>: 可选，数据类型</li><li><strong>order</strong>: C（行序优先） 或者 F（列序优先）</li></ul><h3 id="matlib-zeros"><a href="#matlib-zeros" class="headerlink" title="matlib.zeros()"></a>matlib.zeros()</h3><p>创建一个以 0 填充的矩阵</p><h3 id="matlib-ones"><a href="#matlib-ones" class="headerlink" title="matlib.ones()"></a>matlib.ones()</h3><p>创建一个以 1 填充的矩阵</p><h3 id="matlib-eye"><a href="#matlib-eye" class="headerlink" title="matlib.eye()"></a>matlib.eye()</h3><p>返回一个矩阵，对角线元素为1，其他位置为零</p><p><code>numpy.matlib.eye(n, M,k, dtype)</code></p><ul><li><strong>n</strong>: 返回矩阵的行数</li><li><strong>M</strong>: 返回矩阵的列数，默认为 n</li><li><strong>k</strong>: 对角线的索引</li><li><strong>dtype</strong>: 数据类型</li></ul><h3 id="matlib-identity"><a href="#matlib-identity" class="headerlink" title="matlib.identity()"></a>matlib.identity()</h3><p>返回给定大小的单位矩阵</p><h3 id="matlib-rand"><a href="#matlib-rand" class="headerlink" title="matlib.rand()"></a>matlib.rand()</h3><p>创建一个给定大小的矩阵，数据是随机填充的</p><h2 id="numpy线性代数"><a href="#numpy线性代数" class="headerlink" title="numpy线性代数"></a>numpy线性代数</h2><p>NumPy 提供了线性代数函数库 <strong>linalg</strong>，该库包含了线性代数所需的所有功能</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>dot</code></td><td align="left">两个数组的点积，即元素对应相乘。</td></tr><tr><td align="left"><code>vdot</code></td><td align="left">两个向量的点积</td></tr><tr><td align="left"><code>inner</code></td><td align="left">两个数组的内积</td></tr><tr><td align="left"><code>matmul</code></td><td align="left">两个数组的矩阵积</td></tr><tr><td align="left"><code>determinant</code></td><td align="left">数组的行列式</td></tr><tr><td align="left"><code>solve</code></td><td align="left">求解线性矩阵方程</td></tr><tr><td align="left"><code>inv</code></td><td align="left">计算矩阵的乘法逆矩阵</td></tr></tbody></table><h3 id="numpy-dot"><a href="#numpy-dot" class="headerlink" title="numpy.dot()"></a>numpy.dot()</h3><p>对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为向量点积)；</p><p>对于二维数组，计算的是两个数组的矩阵乘积；</p><p>对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是数组a的最后一维上的所有元素与数组b的倒数第二维上的所有元素的乘积和：<code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] \* b[k,:,m])</code></p><p><code>numpy.dot(a, b, out=None) </code></p><ul><li><strong>a</strong>:ndarray 数组</li><li><strong>b</strong>:ndarray 数组</li><li><strong>out</strong>:ndarray, 可选，用来保存dot()的计算结果</li></ul><h3 id="numpy-vdot"><a href="#numpy-vdot" class="headerlink" title="numpy.vdot()"></a>numpy.vdot()</h3><p>计算两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]]) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># vdot 将数组展开计算内积</span></span><br><span class="line"><span class="built_in">print</span> (np.vdot(a,b))</span><br><span class="line"><span class="comment"># 1*11 + 2*12 + 3*13 + 4*14 = 130</span></span><br></pre></td></tr></table></figure><h3 id="numpy-inner"><a href="#numpy-inner" class="headerlink" title="numpy.inner()"></a>numpy.inner()</h3><p>numpy.inner() 函数返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p><h3 id="numpy-matmul"><a href="#numpy-matmul" class="headerlink" title="numpy.matmul"></a>numpy.matmul</h3><p>返回两个数组的矩阵乘积。 </p><p>虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。</p><p>另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。</p><p>对于二维数组，它就是矩阵乘法</p><h3 id="numpy-linalg-det"><a href="#numpy-linalg-det" class="headerlink" title="numpy.linalg.det()"></a>numpy.linalg.det()</h3><p>计算输入矩阵的行列式</p><h3 id="numpy-linalg-solve"><a href="#numpy-linalg-solve" class="headerlink" title="numpy.linalg.solve()"></a>numpy.linalg.solve()</h3><p>矩阵形式的线性方程的解。</p><p>考虑以下线性方程：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">x + y + z = 6</span><br><span class="line"></span><br><span class="line">2y + 5z = -4</span><br><span class="line"></span><br><span class="line">2x + 5y - z = 27</span><br></pre></td></tr></table></figure><p>可以使用矩阵表示为：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1  1  1   x      6</span><br><span class="line">0  2  5   y  =  -4</span><br><span class="line">2  5 -1   z   27</span><br></pre></td></tr></table></figure><p>如果矩阵成为A、X和B，方程变为：<code>AX = B</code>或<code>X = A^(-1)B</code></p><h3 id="numpy-linalg-inv"><a href="#numpy-linalg-inv" class="headerlink" title="numpy.linalg.inv()"></a>numpy.linalg.inv()</h3><p>计算矩阵的逆矩阵。</p><p><strong>逆矩阵（inverse matrix）</strong>：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得：AB&#x3D;BA&#x3D;E，则我们称B是A的逆矩阵，而A则被称为可逆矩阵</p>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基础知识</title>
      <link href="/inori/54da7039.html"/>
      <url>/inori/54da7039.html</url>
      
        <content type="html"><![CDATA[<p>机器学习是人工智能的重要技术基础，涉及的内容十分广泛。由于我是以发强化学习方向论文为导向，所以机器学习部分知识点不做深入学习，了解为主，本文主要涵盖机器学习入门的基础知识。</p><p>机器学习的核心元素：<strong>数据、模型、算法</strong></p><p>机器学习工作流程一般为数据预处理（Processing）、模型学习（Learning）、模型评估（Evaluation）、新样本预测（Prediction）几个步骤</p><p><strong>数据预处理：</strong>输入（未处理的数据 + 标签）-&gt; 处理过程 -&gt;（特征处理+幅度缩放、特征选择、维度约减、采样）-&gt; 输出（测试集 + 训练集）</p><p><strong>模型学习：</strong>模型选择、交叉验证、结果评估、超参选择。</p><p><strong>模型评估：</strong>了解模型对于数据集测试的得分。</p><p><strong>新样本预测：</strong>预测测试集</p><h1 id="基本名词"><a href="#基本名词" class="headerlink" title="基本名词"></a>基本名词</h1><p><strong>示例&#x2F;样本：</strong>一条数据集中的一条数据</p><p><strong>属性&#x2F;特征：</strong>判断样本好坏的根据，如「色泽」「根蒂」</p><p><strong>属性空间&#x2F;样本空间&#x2F;输入空间X：</strong>由全部属性张成的空间</p><p><strong>特征向量：</strong>空间中每个点对应的一个坐标向量</p><p><strong>标记：</strong>关于示例结果的信息，如（（色泽&#x3D;青绿，根蒂&#x3D;蜷缩，敲声&#x3D;浊响），好瓜），其中「好瓜」称为标记</p><p><strong>分类：</strong>若要预测的是离散值，如「好瓜」，「坏瓜」，此类学习任务称为分类</p><p><strong>假设：</strong>学得模型对应了关于数据的某种潜在规律</p><p><strong>真相：</strong>潜在规律自身</p><p><strong>学习过程：</strong>是为了找出或逼近真相</p><p><strong>泛化能力：</strong>学得模型适用于新样本的能力。一般来说，训练样本越大，越有可能通过学习来获得具有强泛化能力的模型</p><p><strong>训练集</strong>：帮助训练模型，简单的说就是通过训练集的数据让确定拟合曲线的参数</p><p><strong>测试集</strong>：为了测试已经训练好的模型的精确度</p><p><strong>过拟合</strong>：模型在训练集上表现的很好，但是在交叉验证集合测试集上表现一般，也就是说模型对未知样本的预测表现一般，泛化能力较差</p><p><strong>经验误差</strong>：模型在训练集上的误差称为「经验误差」（Empirical Error），经验误差并不是越小越好，因为我们希望在新的没有见过的数据上，也能有好的预估结果</p><p><strong>偏差</strong>：模型拟合的偏差程度。给定无数套训练集而期望拟合出来的模型就是平均模型，偏差就是真实模型和平均模型的差异</p><p><strong>二分类</strong>：类别中只有两个类，是 or 否，且只有一个类别，即一个label为0或者1</p><h1 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h1><p>机器学习算法有：监督学习，无监督学习，半监督学习，强化学习</p><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习是从标记的训练数据中学习并建立模型，然后基于该模型预测未知的样本。其中，模型的输入是某个样本数据的特征，而函数的输出是与该样本相对应的标签。</p><p>常见的监督学习算法：回归分析、分类预测</p><ul><li>回归分析：线性回归，决策树，随机森林等</li><li>分类预测：逻辑回归，KNN，支持向量机，朴素贝叶斯等</li></ul><h3 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h3><p>KNN算法即K最近邻近算法。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。KNN的输入基于实例的学习（instance-based learning），没有显式的学习过程，也就是说没有训练阶段，数据集事先已有了分类和特征值，待收到新样本后直接进行处理，<strong>KNN通过测量不同特征值之间的距离进行分类</strong></p><p>思路：如果一个样本在特征空间中的k个最邻近的样本中的大多数属于某一个类别，则该样本也划分为这个类别。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ol><li>计算测试数据与各个训练数据之间的距离</li><li>按照距离的递增关系进行排序</li><li>选取距离最小的K个点</li><li>确定前K个点所在类别的出现频率</li><li>返回前K个点中出现频率最高的类别作为测试数据的预测分类</li></ol><h4 id="K的取值"><a href="#K的取值" class="headerlink" title="K的取值"></a>K的取值</h4><p>K：临近数，即在预测目标点时取几个临近的点来预测。</p><p>K值得选取非常重要：</p><ul><li>如果K的取值过小，一旦有噪声存在将会对预测产生比较大影响，例如取K值为1时，一旦最近的一个点是噪声，那么就会出现偏差</li><li>如果K的取值过大，就相当于用较大邻域中的训练实例进行预测，学习的近似误差会增大。这时与输入目标点较远实例也会对预测起作用，使预测发生错误</li></ul><p>K的取值尽量要取<strong>奇数</strong>，以保证在计算结果最后会产生一个较多的类别，如果取偶数可能会产生相等的情况，不利于预测。</p><p>常用的方法是从k&#x3D;1开始，使用检验集估计分类器的误差率。重复该过程，每次K增值1，允许增加一个近邻。选取产生最小误差率的K。一般k的取值不超过20，上限是n的开方，随着数据集的增大，K的值也要增大</p><h3 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h3><p>朴素贝叶斯算法是一种基于概率论和统计学的算法。它的核心思想是概率，通过计算条件概率来预测或分类数据</p><h4 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h4><p>贝叶斯定理是朴素贝叶斯算法的核心，它是一个概率公式，用于计算一个事件的后验概率。根据贝叶斯定理，事件 A 的后验概率等于先验概率 P(A)，与另一个事件 B 发生的联合概率 P(B|A) 乘以一个正则因子，即：<br>$$<br>P(Y|X) &#x3D; \frac{P(X|Y)P(Y)}{P(X)}<br>（X：特征向量， Y：类别）<br>$$<br>**先验概率P(X)**：先验概率是指根据以往经验和分析得到的概率</p><p>**后验概率P(Y|X)**：事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，后验分布P(Y|X)表示事件X已经发生的前提下，事件Y发生的概率，叫做事件X发生下事件Y的条件概率</p><p>**后验概率P(X|Y)**：在已知Y发生后X的条件概率，也由于知道Y的取值而被称为X的后验概率</p><h4 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h4><p>朴素贝叶斯算法是假设各个特征之间相互独立，也是朴素这词的意思，那么贝叶斯公式中的P(X|Y)可写成：<br>$$<br>P(X|Y)&#x3D;P(x_1|Y)P(x_2|Y)…P(x_n|Y)<br>$$<br>即朴素贝叶斯公式：<br>$$<br>P(Y|X) &#x3D; \frac{P(x_1|Y)P(x_2|Y)…P(x_n|Y)P(Y)}{P(X)}<br>$$</p><h4 id="贝叶斯算法"><a href="#贝叶斯算法" class="headerlink" title="贝叶斯算法"></a>贝叶斯算法</h4><p>贝叶斯方法源于决一个“逆概”问题：</p><p><strong>正向概率</strong>：假设袋子里面有N个白球，M个黑球，伸手进去摸一把，摸出黑球的概率是多大</p><p><strong>逆向概率</strong>：如果事先不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或者几个）球，观察这些取出来的球的颜色之后，那么可以就此对袋子里面的黑白球的比例做出什么样的推测</p><p>什么是贝叶斯？</p><ul><li>现实世界本身就是不确定的，人类的观察能力是有局限性的</li><li>我们日常观察到的只是事物表明上的结果，因此我们需要提供一个猜测</li></ul><p>朴素贝叶斯算法的朴素：特征条件独立；贝叶斯：基于贝叶斯定理。属于监督学习的生成模型，实现监督，没有迭代，并有坚实的数学理论（即贝叶斯定理）作为支撑。在大量样本下会有较好的表现，不适用于输入向量的特征条件有关联的场景</p><p>朴素贝叶斯会单独考量每一维独立特征被分类的条件概率，进而综合这些概率并对其所在的特征向量做出分类预测。因此，朴素贝叶斯的基本数据假设是：各个维度上的特征被分类的条件概率之间是相互独立的。它经常被用于文本分类中，包括互联网新闻的分类，垃圾邮件的筛选</p><p>朴素贝叶斯的思想：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，即认为此待分类项属于哪个类别</p><h3 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h3><p>决策树算法是一种逼近离散函数值的方法。它是一种典型的分类方法，首先对数据进行处理，利用归纳算法生成可读的规则和决策树，然后使用决策对新数据进行分析。本质上决策树是通过一系列规则对数据进行分类的过程，适用于类别和连续输入（特征）和输出（预测）变量。基于树的方法把特征空间划分成一系列矩形，然后给每一个矩形安置一个简单的模型（像一个常数）</p><p>决策树构造可以分两步进行：</p><ol><li>生成：由训练样本集生成决策树的过程。一般情况下，训练样本数据集是根据实际需要有历史的、有一定综合程度的，用于数据分析处理的数据集</li><li>剪枝：对上一阶段生成的决策树进行检验和校正，主要是用新的样本数据集（测试数据集）中的数据校验决策树生成过程中产生的初步规则，将那些影响预衡准确性的分枝剪除</li></ol><p>决策树学习的算法通常是一个递归地决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。包含特征选择、决策树的生成和决策树的剪枝过程。选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。包含特征选择、决策树的生成和决策树的剪枝过程。</p><p><strong>剪枝：</strong>将树变得更简单，从而使它具有更好的泛化能力。</p><p>步骤：去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。</p><p>决策树的生成对应模型的局部选择，决策树的剪枝对应于模型的全局选择。决策树的生成只考虑局部最优，决策树的剪枝则考虑全局最优。</p><p><strong>特征选择：</strong>如果特征数量很多，在决策树学习开始时对特征进行选择，只留下对训练数据有足够分类能力的特征</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>树以代表训练样本的单个结点开始</li><li>如果样本都在同一类．则该结点成为树叶，并用该类标记</li><li>否则，算法选择最有分类能力的属性作为决策树的当前结点</li><li>根据当前决策结点属性取值的不同，将训练样本数据集分为若干子集，每个取值形成一个分枝，有几个取值形成几个分枝。针对上一步得到的一个子集，重复进行先前步骤，递归形成每个划分样本上的决策树。一旦一个属性出现在一个结点上，就不必在该结点的任何后代考虑它</li><li>递归划分步骤仅当下列条件之一成立时停止：<ul><li>给定结点的所有样本属于同一类</li><li>没有剩余属性可以用来进一步划分样本．在这种情况下．使用多数表决，将给定的结点转换成树叶，并以样本中元组个数最多的类别作为类别标记，同时也可以存放该结点样本的类别分布</li><li>如果某一分枝tc，没有满足该分支中已有分类的样本，则以样本的多数类创建一个树叶</li></ul></li></ol><h3 id="SVM算法"><a href="#SVM算法" class="headerlink" title="SVM算法"></a>SVM算法</h3><p>SVM即支持向量机（support vector machine，SVM），支持向量机是一种二分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。支持向量机的学习算法是求解凸二次规划的最优化算法。基础的SVM算法是一个二分类算法，至于多分类任务，可以通过多次使用SVM进行解决</p><h4 id="线性可分"><a href="#线性可分" class="headerlink" title="线性可分"></a>线性可分</h4><p>对于一个数据集合可以画一条直线将两组数据点分开，这样的数据成为线性可分（linearly separable）</p><p><img src="D:\Blog\source\img\smv_linearly_separable.png" alt="smv_linearly_separable"></p><ul><li>分割超平面：将上述数据集分隔开来的直线成为分隔超平面。对于二维平面来说，分隔超平面就是一条直线。对于三维及三维以上的数据来说，分隔数据的是个平面，称为超平面，也就是分类的决策边界</li><li>间隔：点到分割面的距离，称为点相对于分割面的间隔。数据集所有点到分隔面的最小间隔的2倍，称为分类器或数据集的间隔。论文中提到的间隔多指这个间隔。SVM分类器就是要找最大的数据集间隔</li><li>支持向量：离分隔超平面最近的那些点</li></ul><p>SVM所做的工作就是找这样的超平面，能够将两个不同类别的样本划分开来，但是这种平面是不唯一的，即可能存在无数个超平面都可以将两种样本分开，那么我们如何才能确定一个分类效果最好的超平面呢？<br>对每一种可能的超平面，我们将它进行平移，直到它与空间中的样本向量相交。我们称这两个向量为支持向量，之后我们计算支持向量到该超平面的距离d，分类效果最好的超平面应该使d最大</p><p>支持向量机的核心思想：最大间隔化，最不受到噪声的干扰</p><h4 id="优缺点及应用场景"><a href="#优缺点及应用场景" class="headerlink" title="优缺点及应用场景"></a>优缺点及应用场景</h4><ol><li>SVM的优点：</li></ol><ul><li>高效的处理高维特征空间：SVM通过将数据映射到高维空间中，可以处理高维特征，并在低维空间中进行计算，从而有效地处理高维数据</li><li>适用于小样本数据集：SVM是一种基于边界的算法，它依赖于少数支持向量，因此对于小样本数据集具有较好的泛化能力</li><li>可以处理非线性问题：SVM使用核函数将输入数据映射到高维空间，从而可以解决非线性问题。常用的核函数包括线性核、多项式核和径向基函数（RBF）核</li><li>避免局部最优解：SVM的优化目标是最大化间隔，而不是仅仅最小化误分类点。这使得SVM在解决复杂问题时能够避免陷入局部最优解</li><li>对于噪声数据的鲁棒性：SVM通过使用支持向量来定义决策边界，这使得它对于噪声数据具有一定的鲁棒性</li></ul><ol start="2"><li>SVM的缺点：</li></ol><ul><li>对大规模数据集的计算开销较大：SVM的计算复杂度随着样本数量的增加而增加，特别是在大规模数据集上的训练时间较长</li><li>对于非线性问题选择合适的核函数和参数较为困难：在处理非线性问题时，选择适当的核函数和相应的参数需要一定的经验和领域知识</li><li>对缺失数据敏感：SVM在处理含有缺失数据的情况下表现不佳，因为它依赖于支持向量的定义</li><li>难以解释模型结果：SVM生成的模型通常是黑盒模型，难以直观地解释模型的决策过程和结果</li></ul><ol start="3"><li>SVM主要应用场景：</li></ol><ul><li>文本分类：如垃圾邮件分类、情感分析和文档分类等</li><li>图像识别：可用于图像分类、目标识别和人脸识别等任务。它可以通过提取图像的特征向量，并将其作为输入来训练SVM模型</li><li>金融领域：可用于信用评分、风险评估和股票市场预测等金融任务</li><li>医学诊断：可以应用于医学图像分析，如疾病检测、癌症诊断和医学影像分类等</li><li>视频分类：可以用于视频分类、行为识别和运动检测等任务，通过提取视频帧的特征并将其输入SVM模型进行分类</li><li>推荐系统：可以用于个性化推荐和用户分类等推荐系统任务，通过分析用户行为和特征来预测用户的兴趣和偏好</li></ul><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>逻辑回归虽然名字中带有回归，其实是分类模型，主要用于二分类问题，通过给定的n组数据（训练集）来训练模型，并在训练结束后对给定的一组或多组数据（测试集）进行分类。其中每一组数据都是由p个指标构成。</p><p>由于二分类问题分成两类，可以让其中一类标签为0，另一类为1。我们需要一个函数，对于输入的每一组数据，都能映射成0~1之间的数。并且如果函数值大于0.5，就判定属于1，否则属于0。而且函数中需要待定参数，通过利用样本训练，使得这个参数能够对训练集中的数据有很准确的预测。</p><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><p>逻辑回归的模型包含两个模块：线性部分和激活函数</p><p>线性部分的数学模型写为<code>h(x)=wx+b</code>，x表示样本的输入特征向量，w是权重，b是偏置</p><p>激活函数是sigmoid函数：<br>$$<br>\sigma(h(x))&#x3D; \frac{1}{1+e^{−h(x)}}<br>&#x3D; \frac{1}{1+e^{−(wx+b)}}<br>$$</p><p>这个函数的曲线是一条值域为(0,1)的曲线，当输入值趋近于无穷大时，输出结果会趋近于1，输入值趋近于无穷小时，输出结果会趋近于-1</p><p>逻辑回归不仅是一个二分类模型，也是一个线性分类模型，h(x)作为决策函数，通过判断样本落在决策函数的哪一边，区分出不同的类别</p><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>该类算法的输入样本不需要标记，而是自动地从样本中学习这种特征以实现预测。</p><p>常见的非监督学习算法：聚类和降维</p><ul><li>聚类：Kmeans、Apriori、DBSCAN等</li><li>降维：主成分分析(PCA)等</li></ul><h3 id="Kmeans算法"><a href="#Kmeans算法" class="headerlink" title="Kmeans算法"></a>Kmeans算法</h3><p>k均值聚类算法（k-means）是一种迭代求解的聚类分析算法，其步骤是，预将数据分为K组，则随机选取K个对象作为初始的聚类中心，然后计算每个对象与各个种子聚类中心之间的距离，把每个对象分配给距离它最近的聚类中心。聚类中心以及分配给它们的对象就代表一个聚类。每分配一个样本，聚类的聚类中心会根据聚类中现有的对象被重新计算。这个过程将不断重复直到满足某个终止条件。终止条件可以是没有（或最小数目）对象被重新分配给不同的聚类，没有（或最小数目）聚类中心再发生变化，误差平方和局部最小。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li>从N个数据文档（样本）随机选取K个数据文档作为质心（聚类中心）。</li><li>对每个数据文档测量其到每个质心的距离，并把它归到最近的质心的类。</li><li>重新计算已经得到的各个类的质心。</li><li>迭代2~3步直至新的质心与原质心相等或小于指定阈值，算法结束。 本文采用所有样本所属的质心都不再变化时，算法收敛。</li></ol><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p>每一个样本经过模型后会得到一个预测值，然后得到的预测值和真实值的差值就成为损失（损失值越小证明模型越成功），有许多不同种类的损失函数，这些函数<strong>本质上就是计算预测值和真实值的差距的一类型函数</strong>，经过库的封装形成了有具体名字的函数</p><p>输入的feature（或称为x）需要通过模型（model）预测出y，此过程称为向前传播（forward pass），而要将预测与真实值的差值减小需要更新模型中的参数，这个过程称为向后传播（backward pass），其中损失函数（lossfunction）就基于这两种传播之间，起到一种有点像<strong>承上启下</strong>的作用，<strong>承上指：接収模型的预测值，启下指：计算预测值和真实值的差值，为下面反向传播提供输入数据</strong></p><p>常用的损失函数有：均方误差(MSE)、平均绝对误差(MAE)、均方根误差(RMSE)、平均偏差误差(MBE)、Huber损失、最大似然损失(Likelihood Loss&#x2F;LHL)、二元交叉熵（BCE）、交叉熵（CE）、Kullback-Leibler 散度 (KLD)等</p>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL运维篇</title>
      <link href="/inori/592cf81.html"/>
      <url>/inori/592cf81.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志记录了当mysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，应当首先查看此日志</p><p>该日志默认开启，默认存放目录<code>/var/log/</code>，默认的日志文件名为<code>mysqld.log</code>，查看日志位置:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志（BINLOG）记录了所有的 DDL和 DML语句，不包括数据查询（SELECT、SHOW）语句</p><p>作用：</p><ul><li>灾难时的数据恢复</li><li>MySQL的主从复制</li></ul><p>在MySQL8中，默认二进制日志是开启的，查看日志参数：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>log_bin_basename</code>：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文件名需要在该basename的基础上加上编号(编号从000001开始)</li><li><code>log_bin_index</code>：binlog的索引文件，记录了当前服务器关联的binlog文件有哪些</li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录SQL语句，对数据进行修改的SQL都会记录在日志文件中</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录每一行的数据变更</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录</td></tr></tbody></table><p>可以使用命令查看格式：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果需要配置二进制日志的格式，要在<code>/etc/my.cnf</code>中配置<code>binlog_format</code>参数</p><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具<code>mysqlbinlog</code>来查看，详情查看进阶篇中此部分</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志：</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>reset master</td><td>删除全部 binlog日志，删除之后，日志编号，将从<code>binlog.000001</code>重新开始</td></tr><tr><td>purge master logs to ‘binlog.*’</td><td>删除 * 编号之前的所有日志</td></tr><tr><td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’</td><td>删除日志为<code>yyyy-mm-dd hh24:mi:ss</code>之前产生的所有日志</td></tr></tbody></table><p>也可以在mysql的配置文件中配置二进制日志的过期时间，设置后二进制日志过期会自动删除:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_expire_logs_seconds%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志中记录了客户端的所有操作语句。如果需要开启查询日志，可以修改MySQL的配置文件<code>/etc/my.cnf</code>文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#该选项用来开启查询日志 ， 可选值：0或者1，0代表关闭，1代表开启</span><br><span class="line">general_log=1</span><br><span class="line">#设置日志的文件名，如果没有指定，默认的文件名为host_name.log</span><br><span class="line">general_log_file=mysql_query.log</span><br></pre></td></tr></table></figure><p>开启了查询日志之后，在MySQL的数据存放目录，也就是 <code>/var/lib/mysql/</code>目录下就会出现mysql_query.log文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运行后，日志文件将会非常大。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过参数<code>long_query_time</code>设置值并且扫描记录数不小于<code>min_examined_row_limit</code>的所有的SQL语句的日志，默认未开启。<code>long_query_time</code>默认为10秒，最小为0，精度可以到微秒。</p><p>如果需要开启慢查询日志，需要在MySQL的配置文件<code>/etc/my.cnf</code>中配置如下参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#慢查询日志</span><br><span class="line">slow_query_log=1</span><br><span class="line">#执行时间参数</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用<code>log_slow_admin_statements</code>和更改此行为<code>log_queries_not_using_indexes</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements = 1</span><br><span class="line">#记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes = 1</span><br></pre></td></tr></table></figure><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制，MySQL复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务</li><li>实现读写分离，降低主库的访问压力</li><li>可以在从库中执行备份，以避免备份期间影响主库服务</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MySQL主从复制的核心为bin log，具体的过程如下：</p><p><img src="D:\Blog\source\img\mysql_master&slave.png" alt="mysql_master&amp;slave"></p><p>复制分成三步：</p><ol><li><p>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</p></li><li><p>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</p></li><li><p>slave重做中继日志中的事件，将改变反映它自己的数据</p></li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="主库"><a href="#主库" class="headerlink" title="主库"></a>主库</h4><p>修改配置文件<code>/etc/my.cnf</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1</span><br><span class="line">server-id=1</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=0</span><br><span class="line">#忽略的数据, 指不需要同步的数据库</span><br><span class="line">#binlog-ignore-db=mysql</span><br><span class="line">#指定同步的数据库</span><br><span class="line">#binlog-do-db=db01</span><br></pre></td></tr></table></figure><p>重启mysql服务器后，登录并创建远程连接的账号，授予主从复制权限：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br><span class="line">#为 <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> 用户分配主从复制权限</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查看二进制坐标：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p>字段含义说明：</p><ul><li><code>file</code>:从哪个日志文件开始推送日志文件</li><li><code>position</code>:从哪个位置开始推送日志</li><li><code>binlog_ignore_db</code>:指定不需要同步的数据库</li></ul><h4 id="从库"><a href="#从库" class="headerlink" title="从库"></a>从库</h4><p>修改配置文件<code>/etc/my.cnf</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure><p>重启mysql服务器后，登录设置主库配置：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE <span class="keyword">TO</span> SOURCE_HOST<span class="operator">=</span><span class="string">&#x27;IP地址&#x27;</span>, SOURCE_USER<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">SOURCE_PASSWORD<span class="operator">=</span><span class="string">&#x27;Root@123456&#x27;</span>, SOURCE_LOG_FILE<span class="operator">=</span><span class="string">&#x27;binlog.000004&#x27;</span>, SOURCE_LOG_POS<span class="operator">=</span><span class="number">663</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>含义</th><th>老版本参数</th></tr></thead><tbody><tr><td>SOURCE_HOST</td><td>主库IP地址</td><td>MASTER_HOST</td></tr><tr><td>SOURCE_USER</td><td>连接主库的用户名</td><td>MASTER_USER</td></tr><tr><td>SOURCE_PASSWORD</td><td>连接主库的密码</td><td>MASTER_PASSWORD</td></tr><tr><td>SOURCE_LOG_FILE</td><td>binlog日志文件名</td><td>MASTER_LOG_FILE</td></tr><tr><td>SOURCE_LOG_POS</td><td>binlog日志文件位置</td><td>MASTER_LOG_POS</td></tr></tbody></table><p>开启同步：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> replica;</span><br></pre></td></tr></table></figure><p>查看同步状态：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status;</span><br></pre></td></tr></table></figure><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p><ul><li>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多，带宽不够，网络IO瓶颈</li><li>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈</li></ul><p>为了解决上述问题，需要对数据库进行分库分表处理</p><p>分库分表的中心思想都是将<strong>数据分散存储</strong>，使得单一数据库&#x2F;表的数据量变小来缓解单一数据库的性能问题，从而提升数据库性能</p><h3 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h3><p>分库分表的形式，主要是两种：垂直拆分和水平拆分。按照拆分粒度又分为分库和分表。</p><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p><strong>垂直分库</strong>：以表为依据，根据业务将不同表拆分到不同库中。</p><p>特点：</p><ul><li>每个库的表结构都不一样</li><li>每个库的数据也不一样</li><li>所有库的并集是全量数据</li></ul><p><strong>垂直分表</strong>：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p>特点：</p><ul><li>每个表的结构都不一样</li><li>每个表的数据也不一样，一般通过一列（主键&#x2F;外键）关联</li><li>所有表的并集是全量数据</li></ul><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p><strong>水平分库</strong>：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中</p><p>特点：</p><ul><li>每个库的表结构都一样</li><li>每个库的数据都不一样</li><li>所有库的并集是全量数据</li></ul><p><strong>水平分表</strong>：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中</p><p>特点：</p><ul><li>每个表的表结构都一样</li><li>每个表的数据都不一样</li><li>所有表的并集是全量数据</li></ul><h3 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h3><ul><li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言</li><li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言</li></ul><h3 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h3><p>Mycat是开源的基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat。开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数据，都无需关心。具体的分库分表的策略，只需要在MyCat中配置即可。</p><p>在MyCat的整体结构中，分为两个部分：上面的逻辑结构、下面的物理结构</p><p><img src="D:\Blog\source\img\mysql_mycat.png" alt="mysql_mycat"></p><p>在MyCat的逻辑结构主要负责逻辑库、逻辑表、分片规则、分片节点等逻辑结构的处理，而具体的数据存储还是在物理结构，也就是数据库服务器中存储的</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><h5 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h5><p>配置逻辑库、逻辑表、数据节点、节点主机等相关信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;DB01&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;TB_ORDER&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址1:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址2:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址3:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要包含以下三组标签：</p><ul><li>schema标签</li><li>datanode标签</li><li>datahost标签</li></ul><h6 id="schema标签"><a href="#schema标签" class="headerlink" title="schema标签"></a>schema标签</h6><p>用于定义MyCat实例中的逻辑库,一个MyCat实例中,可以有多个逻辑库,可以通过schema标签来划分不同的逻辑库。MyCat中的逻辑库的概念，等同于MySQL中的database概念, 需要操作某个逻辑库下的表时, 也需要切换逻辑库(use xxx)。</p><p>核心属性：</p><ul><li>name：指定自定义的逻辑库库名</li><li>checkSQLschema：在SQL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去除，false：不自动去除</li><li>sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录</li></ul><p><strong>table标签</strong></p><p>定义了MyCat中逻辑库schema下的逻辑表,所有需要拆分的表都需要在table标签中定义。核心属性：</p><ul><li>name：定义逻辑表表名，在该逻辑库下唯一</li><li>dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔</li><li>rule：分片规则的名字，分片规则名字是在rule.xml中定义的</li><li>primaryKey：逻辑表对应真实表的主键</li><li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表，全局表需要配置为global</li></ul><h6 id="datanode标签"><a href="#datanode标签" class="headerlink" title="datanode标签"></a>datanode标签</h6><p>核心属性：</p><ul><li>name：定义数据节点名称</li><li>dataHost：数据库实例主机名称，引用自 dataHost 标签中name属性</li><li>database：定义分片所属数据库</li></ul><h6 id="datahost标签"><a href="#datahost标签" class="headerlink" title="datahost标签"></a>datahost标签</h6><p>该标签在MyCat逻辑库中作为底层标签, 定义了具体的数据库实例、读写分离、心跳语句。核心属性：</p><ul><li>name：唯一标识，供上层标签使用</li><li>maxCon&#x2F;minCon：最大连接数&#x2F;最小连接数</li><li>balance：负载均衡策略，取值 0,1,2,3</li><li>writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）</li><li>dbDriver：数据库驱动，支持 native、jdbc</li></ul><h5 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h5><p>rule.xml中定义所有拆分表的规则, 在使用过程中可以灵活的使用分片算法, 或者对同一个分片算法使用不同的参数, 它让分片过程可配置化。主要包含两类标签：tableRule、Function</p><h5 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h5><p>配置用户名、密码，以及用户的访问权限信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表级 DML 权限设置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;privileges check=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;</span></span><br><span class="line"><span class="comment">                &lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;# 对应IUSD为增改查删</span></span><br><span class="line"><span class="comment">            &lt;/schema&gt;</span></span><br><span class="line"><span class="comment">        &lt;/privileges&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述的配置表示，定义了两个用户root和user，两个用户都可以访问DB01逻辑库，访问密码都是123456，但是root用户访问DB01逻辑库，既可以读，又可以写，但是user用户访问逻辑库是只读的</p><p>主要有两个标签：system、user</p><h6 id="system标签"><a href="#system标签" class="headerlink" title="system标签"></a>system标签</h6><p>主要配置MyCat中的系统配置信息，对应的系统配置项及其含义</p><table><thead><tr><th>属性</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>charset</td><td>utf8</td><td>设置Mycat的字符集, 字符集需要与MySQL的字符集保持一致</td></tr><tr><td>nonePasswordLogin</td><td>0,1</td><td>0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户</td></tr><tr><td>useSqlStat</td><td>0,1</td><td>开启SQL实时统计,1 为开启,0 为关闭；开启之后, MyCat会自动统计SQL语句的执行情况</td></tr><tr><td>useGlobleTableCheck</td><td>0,1</td><td>是否开启全局表的一致性检测。1为开启，0为关闭</td></tr><tr><td>sequnceHandlerType</td><td>0,1,2</td><td>用来指定Mycat全局序列类型，0 为本地文件，1 为数据库方式，2 为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试</td></tr><tr><td>idleTimeout</td><td>30</td><td>指定连接的空闲时间的超时长度;如果超时,将关闭资源并回收, 默认30分钟</td></tr><tr><td>serverPort</td><td>8066</td><td>定义MyCat的管理端口, 默认8066</td></tr><tr><td>managerPort</td><td>9066</td><td>定义MyCat的管理端口, 默认9066</td></tr><tr><td>sqlExecuteTimeout</td><td>300</td><td>执行SQL的超时时间, 如果SQL语句执行超时,将关闭连接; 默认300秒;</td></tr></tbody></table><h6 id="user标签"><a href="#user标签" class="headerlink" title="user标签"></a>user标签</h6><p>配置MyCat中的用户、访问密码，以及用户针对于逻辑库、逻辑表的权限信息</p><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>切换到Mycat的安装目录，执行指令启动Mycat：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">bin/mycat start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止</span></span><br><span class="line">bin/mycat stop</span><br></pre></td></tr></table></figure><p>Mycat启动之后，占用端口号8066</p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h IP地址 <span class="operator">-</span>P <span class="number">8066</span> <span class="operator">-</span>uroot <span class="operator">-</span>p123456</span><br></pre></td></tr></table></figure><p>通过MySQL的指令来连接的MyCat，因为MyCat在底层实际上是模拟了MySQL的协议</p><h4 id="MyCat管理"><a href="#MyCat管理" class="headerlink" title="MyCat管理"></a>MyCat管理</h4><p>在MyCat中，当执行一条SQL语句时，MyCat需要进行SQL解析、分片分析、路由分析、读写分离分析等操作，最终经过一系列的分析决定将当前的SQL语句到底路由到那几个(或哪一个)节点数据库，数据库将数据执行完毕后，如果有返回的结果，则将结果返回给MyCat，最终还需要在MyCat中进行结果合并、聚合处理、排序处理、分页处理等操作，最终再将结果返回给客户端。</p><p><img src="D:\Blog\source\img\mysql_mycat_frame.png" alt="mysql_mycat_frame"></p><p>Mycat默认开通2个端口，可以在server.xml中进行修改。</p><ul><li>8066 数据访问端口，即进行 DML 和 DDL 操作。</li><li>9066 数据库管理端口，即 mycat 服务管理控制功能，用于管理mycat的整个集群状态</li></ul><p>连接MyCat的管理控制台：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h IP地址 <span class="operator">-</span>p <span class="number">9066</span> <span class="operator">-</span>uroot <span class="operator">-</span>p123456</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>show @@help</td><td>查看Mycat管理工具帮助文档</td></tr><tr><td>show @@version</td><td>查看Mycat的版本</td></tr><tr><td>reload @@config</td><td>重新加载Mycat的配置文件</td></tr><tr><td>show @@datasource</td><td>查看Mycat的数据源信息</td></tr><tr><td>show @@datanode</td><td>查看MyCat现有的分片节点信息</td></tr><tr><td>show @@threadpool</td><td>查看Mycat的线程池信息</td></tr><tr><td>show @@sql</td><td>查看执行的SQL</td></tr><tr><td>show @@sql.sum</td><td>查看执行的SQL统计</td></tr></tbody></table><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</p><p>通过MyCat可实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</p><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><p><img src="D:\Blog\source\img\mysql_1m1s.png" alt="mysql_1m1s"></p><p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控制。</p><p>schema.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置逻辑库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;RW&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn7&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn7&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">database</span>=<span class="string">&quot;itcast&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p>writeHost代表的是写操作对应的数据库，readHost代表的是读操作对应的数据库。所以我们要想实现读写分离，就得配置writeHost关联的是主库，readHost关联的是从库。</p><p>而仅仅配置好了writeHost以及readHost还不能完成读写分离，还需要配置一个负责均衡的参数balance，取值有4种，具体含义如下：</p><table><thead><tr><th>参数值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>不开启读写分离机制,所有读操作都发送到当前可用的writeHost上</td></tr><tr><td>1</td><td>全部的readHost与备用的writeHost都参与select语句的负载均衡（主要针对于双主双从模式）</td></tr><tr><td>2</td><td>所有的读写操作都随机在writeHost,readHost上分发</td></tr><tr><td>3</td><td>所有的读请求随机分发到writeHost对应的readHost上执行,writeHost不负担读压力</td></tr></tbody></table><p>在一主一从模式的读写分离中，balance配置1或3都是可以完成读写分离的。</p><h3 id="双主双从"><a href="#双主双从" class="headerlink" title="双主双从"></a>双主双从</h3><p>一个主机Master1用于处理所有写请求，它的从机Slave1和另一台主机Master2还有它的从机Slave2负责所有读请求。当Master1主机宕机后，Master2主机负责写请求，Master1、Master2互为备机</p><p><img src="D:\Blog\source\img\mysql_2m2s.png" alt="mysql_2m2s"></p><p>schema.xml配置</p><p>配置逻辑库</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;RW2&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn7&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置数据节点</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn7&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>配置节点主机</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址1:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址2:3306? useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址3:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址4:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性说明：</p><ul><li><p>balance&#x3D;”1”：代表全部的readHost与stand by writeHost参与 select 语句的负载均衡，简单的说，当双主双从模式(M1 -&gt; S1，M2-&gt; S2，并且M1与M2互为主备)，正常情况下，M2,S1,S2都参与select语句的负载均衡</p></li><li><p>writeType</p><ul><li>0:写操作都转发到第1台writeHost, writeHost1挂了, 会切换到writeHost2上</li><li>1:所有的写操作都随机地发送到配置的writeHost上</li></ul></li><li><p>switchType</p><ul><li>-1:不自动切换</li><li>1:自动切换</li></ul></li></ul><p>user.xml配置：配置root用户可以访问到逻辑库RW2</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>SHOPPING,TEST,RW2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch基础入门(二)</title>
      <link href="/inori/65068962.html"/>
      <url>/inori/65068962.html</url>
      
        <content type="html"><![CDATA[<h1 id="DSL语句"><a href="#DSL语句" class="headerlink" title="DSL语句"></a>DSL语句</h1><p>DSL(Domain Specific Language)，中文翻译为特定领域语言，在这里代表ES中的查询语言。</p><p>Elasticsearch的查询可以分为两大类：</p><ul><li><strong>叶子查询（Leaf</strong> <strong>query</strong> <strong>clauses）</strong>：一般是在特定的字段里查询特定值，属于简单查询，很少单独使用。</li><li><strong>复合查询（Compound</strong> <strong>query</strong> <strong>clauses）</strong>：以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式。</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>语法结构：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// .. 查询条件</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>GET /索引库名/_search</code>：其中的<code>_search</code>是固定路径，不能修改</li></ul><p>以最简单的无条件查询为例，无条件查询的类型是：match_all，因此其查询语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>虽然是match_all，但是响应结果中并不会包含索引库中的所有文档，而是仅有10条。这是因为处于安全考虑，elasticsearch设置了默认的查询页数。</p><h2 id="叶子查询"><a href="#叶子查询" class="headerlink" title="叶子查询"></a>叶子查询</h2><p>叶子查询的类型也可以做进一步细分，详情可以查看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/query-dsl.html">官方文档</a></p><p>这里列举一些常见的：</p><ul><li><strong>全文检索查询（Full Text Queries）</strong>：利用分词器对用户输入搜索条件先分词，得到词条，然后再利用倒排索引搜索词条。例如：<ul><li><code>match</code>：</li><li><code>multi_match</code></li></ul></li><li><strong>精确查询（Term-level queries）</strong>：不对用户输入搜索条件分词，根据字段内容精确值匹配。但只能查找keyword、数值、日期、boolean类型的字段。例如：<ul><li><code>ids</code></li><li><code>term</code></li><li><code>range</code></li></ul></li><li><strong>地理坐标查询：</strong>用于搜索地理位置，搜索方式很多，例如：<ul><li><code>geo_bounding_box</code>：按矩形搜索</li><li><code>geo_distance</code>：按点和半径搜索</li></ul></li></ul><h2 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询</h2><p>全文检索的种类也很多，详情可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/full-text-queries.html">官方文档</a></p><p>以全文检索中的<code>match</code>为例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与<code>match</code>类似的还有<code>multi_match</code>，区别在于可以同时对多个字段搜索，而且多个字段都要满足，语法示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;字段1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;字段2&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p>精确查询，英文是<code>Term-level query</code>，顾名思义，词条级别的查询。也就是说不会对用户输入的搜索条件再分词，而是作为一个词条，与搜索的字段内容精确值匹配。因此推荐查找<code>keyword</code>、数值、日期、<code>boolean</code>类型的字段。例如：</p><ul><li>id</li><li>price</li><li>城市</li><li>地名</li><li>人名</li></ul><p>详情可以查看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/term-level-queries.html">官方文档</a></p><p>以<code>term</code>查询为例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>range</code>查询：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>最小值<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>最大值<span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>range</code>是范围查询，对于范围筛选的关键字有：</p><ul><li><code>gte</code>：大于等于</li><li><code>gt</code>：大于</li><li><code>lte</code>：小于等于</li><li><code>lt</code>：小于</li></ul><h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><p>复合查询大致可以分为两类：</p><ul><li>第一类：基于逻辑运算组合叶子查询，实现组合条件，例如<ul><li>bool</li></ul></li><li>第二类：基于某种算法修改查询时的文档相关性算分，从而改变文档排名。例如：<ul><li>function_score</li><li>dis_max</li></ul></li></ul><p>其它复合查询及相关语法可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/compound-queries.html">官方文档</a></p><h3 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h3><p>bool查询，即布尔查询。就是利用逻辑运算来组合一个或多个查询子句的组合。bool查询支持的逻辑运算有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>bool查询的语法例如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vivo&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小米&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span> <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">10000</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与搜索关键字无关的查询尽量采用must_not或filter逻辑运算，避免参与相关性算分。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>elasticsearch默认是根据相关度算分（<code>_score</code>）来排序，但是也支持自定义方式对搜索结果排序。不过分词字段无法排序，能参与排序字段类型有：<code>keyword</code>类型、数值类型、地理坐标类型、日期类型等。</p><p>语法说明：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;排序字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;排序方式asc和desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。</p><h3 id="基础分页"><a href="#基础分页" class="headerlink" title="基础分页"></a>基础分页</h3><p>elasticsearch中通过修改<code>from</code>、<code>size</code>参数来控制要返回的分页结果：</p><ul><li><code>from</code>：从第几个文档开始</li><li><code>size</code>：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span>  <span class="comment">// 每页文档数量，默认10</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h3><p>elasticsearch的数据一般会采用分片存储，也就是把一个索引中的数据分成N份，存储到不同节点上。这种存储方式比较有利于数据扩展，但给分页带来了一些麻烦。</p><p>比如一个索引库中有100000条数据，分别存储到4个分片，每个分片25000条数据。现在每页查询10条，查询第99页。那么分页查询的条件如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">990</span><span class="punctuation">,</span> <span class="comment">// 从第990条开始查询</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 每页查询10条</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>从语句来分析，要查询第990~1000名的数据。</p><p>从实现思路来分析，肯定是将所有数据排序，找出前1000名，截取其中的990~1000的部分。但问题来了，我们如何才能找到所有数据中的前1000名呢？</p><p>要知道每一片的数据都不一样，第1片上的第900-1000，在另1个节点上并不一定依然是900-1000名。所以我们只能在每一个分片上都找出排名前1000的数据，然后汇总到一起，重新排序，才能找出整个索引库中真正的前1000名，此时截取990-1000的数据即可。假如我们现在要查询的是第999页数据呢，是不是要找第9990~10000的数据，那岂不是需要把每个分片中的前10000名数据都查询出来，汇总在一起，在内存中排序？</p><p>由此可知，当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力。</p><p><strong>因此elasticsearch会禁止<code>from+ size </code>超过10000的请求。</strong></p><p>针对深度分页，elasticsearch提供了两种解决方案：</p><ul><li><code>search after</code>：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li><code>scroll</code>：原理将排序后的文档id形成快照，保存下来，基于快照做分页。官方已经不推荐使用。</li></ul><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/paginate-search-results.html">详情见文档</a></p><p>大多数情况下，我们采用普通分页就可以了。一般我们采用限制分页深度的方式即可，无需实现深度分页。</p><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><p>实现高亮的思路为：</p><ul><li>用户输入搜索关键字搜索数据</li><li>服务端根据搜索关键字到elasticsearch搜索，并给搜索结果中的关键字词条添加<code>html</code>标签</li><li>前端提前给约定好的<code>html</code>标签添加<code>CSS</code>样式</li></ul><p>elasticsearch已经提供了给搜索关键字加标签的语法。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;搜索字段&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索关键字&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;高亮字段名称&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;em&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/em&gt;&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>搜索必须有查询条件，而且是全文检索类型的查询条件，例如<code>match</code></li><li>参与高亮的字段必须是<code>text</code>类型的字段</li><li>默认情况下参与高亮的字段要与搜索字段一致，除非添加：<code>required_field_match=false</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p><ul><li><code>query</code>：查询条件</li><li><code>from</code>和<code>size</code>：分页条件</li><li><code>sort</code>：排序条件</li><li><code>highlight</code>：高亮条件</li></ul><h1 id="RestClient查询"><a href="#RestClient查询" class="headerlink" title="RestClient查询"></a>RestClient查询</h1><p>查询的基本步骤如为：</p><p>1）创建<code>request</code>对象，这次是搜索，所以是<code>SearchRequest</code></p><p>2）准备请求参数，查询DSL对应的JSON参数</p><p>3）发起请求</p><p>4）解析响应，响应结果相对复杂，需要逐层解析</p><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><p>之前说过，由于Elasticsearch对外暴露的接口都是Restful风格的接口，因此JavaAPI调用就是在发送Http请求。而我们核心要做的就是利用<strong>利用Java代码组织请求参数</strong>，<strong>解析响应结果</strong>。</p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名 </p><p>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等 </p><ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个<code>match_all</code>查询的DSL</li></ul><p>第三步，利用<code>client.search()</code>发送请求，得到响应 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关键的API有两个，一个是<code>request.source()</code>，它构建的就是DSL中的完整JSON参数。其中包含<code>query</code>、<code>sort</code>、<code>from</code>、<code>size</code>、<code>highlight</code>等所有功能</p><p><img src="D:\Blog\source\img\request_source.png" alt="request_source"></p><p>另一个是<code>QueryBuilders</code>，其中包含各种<strong>叶子查询</strong>、<strong>复合查询</strong></p><p><img src="D:\Blog\source\img\querybuilders.png" alt="querybuilders"></p><h3 id="解析响应结果"><a href="#解析响应结果" class="headerlink" title="解析响应结果"></a>解析响应结果</h3><p>在发送请求以后，得到了响应结果<code>SearchResponse</code>，这个类的结构与kibana中看到的响应结果JSON结构完全一致</p><p>解析<code>SearchResponse</code>的代码就是在解析这个JSON结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.遍历结果数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 3.得到_source，也就是原始json文档</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 4.反序列化并打印</span></span><br><span class="line">        <span class="type">ItemDoc</span> <span class="variable">item</span> <span class="operator">=</span> JSONUtil.toBean(source, ItemDoc.class);</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过<code>response.getHits()</code>获取，就是JSON中的最外层的<code>hits</code>，代表命中的结果 <ul><li><code>SearchHits.getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits.getHits()</code>：获取<code>SearchHit</code>数组，也就是文档数组 <ul><li><code>SearchHit.getSourceAsString()</code>：获取文档结果中的<code>_source</code>，也就是原始的<code>json</code>文档数据</li></ul></li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>文档搜索的基本步骤是：</p><ol><li>创建<code>SearchRequest</code>对象</li><li>准备<code>request.source()</code>，也就是DSL<ol><li><code>QueryBuilders</code>来构建查询条件</li><li>传入<code>request.source()</code> 的<code>query()</code>方法</li></ol></li><li>发送请求，得到结果</li><li>解析结果</li></ol><h2 id="叶子查询-1"><a href="#叶子查询-1" class="headerlink" title="叶子查询"></a>叶子查询</h2><p>所有的查询条件都是由QueryBuilders来构建的，叶子查询也不例外</p><p>例如<code>match</code>查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRange</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">10000</span>).lte(<span class="number">30000</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>term</code>查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testTerm</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;华为&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合查询-1"><a href="#复合查询-1" class="headerlink" title="复合查询"></a>复合查询</h2><p>复合查询也是由<code>QueryBuilders</code>来构建，我们以<code>bool</code>查询为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.准备bool查询</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">bool</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.关键字搜索</span></span><br><span class="line">    bool.must(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.3.品牌过滤</span></span><br><span class="line">    bool.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;德亚&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.4.价格过滤</span></span><br><span class="line">    bool.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">300</span>));</span><br><span class="line">    request.source().query(bool);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.搜索条件参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.排序参数</span></span><br><span class="line">    request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页参数</span></span><br><span class="line">    request.source().from((pageNo - <span class="number">1</span>) * pageSize).size(pageSize);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高亮-1"><a href="#高亮-1" class="headerlink" title="高亮"></a>高亮</h2><ul><li>条件同样是在<code>request.source()</code>中指定，高亮条件要基于<code>HighlightBuilder</code>来构造</li><li>高亮响应结果与搜索的文档结果不在一起，需要单独解析</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.query条件</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮条件</span></span><br><span class="line">    request.source().highlighter(</span><br><span class="line">            SearchSourceBuilder.highlight()</span><br><span class="line">                    .field(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                    .preTags(<span class="string">&quot;&lt;em&gt;&quot;</span>)</span><br><span class="line">                    .postTags(<span class="string">&quot;&lt;/em&gt;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果解析部分，文档解析不变，主要是高亮内容需要单独解析出来:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.遍历结果数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 3.得到_source，也就是原始json文档</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 4.反序列化</span></span><br><span class="line">        <span class="type">ItemDoc</span> <span class="variable">item</span> <span class="operator">=</span> JSONUtil.toBean(source, ItemDoc.class);</span><br><span class="line">        <span class="comment">// 5.获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; hfs = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isNotEmpty(hfs)) &#123;</span><br><span class="line">            <span class="comment">// 5.1.有高亮结果，获取name的高亮结果</span></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">hf</span> <span class="operator">=</span> hfs.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (hf != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 5.2.获取第一个高亮结果片段，就是商品名称的高亮值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">hfName</span> <span class="operator">=</span> hf.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                item.setName(hfName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第<code>3、4</code>步：从结果中获取<code>_source</code>。<code>hit.getSourceAsString()</code>，这部分是非高亮结果，json字符串。还需要反序列为<code>ItemDoc</code>对象</li><li>第<code>5</code>步：获取高亮结果。<code>hit.getHighlightFields()</code>，返回值是一个<code>Map</code>，key是高亮字段名称，值是<code>HighlightField</code>对象，代表高亮值</li><li>第<code>5.1</code>步：从<code>Map</code>中根据高亮字段名称，获取高亮字段值对象<code>HighlightField</code></li><li>第<code>5.2</code>步：从<code>HighlightField</code>中获取<code>Fragments</code>，并且转为字符串。这部分就是真正的高亮字符串了</li><li>最后：用高亮的结果替换<code>ItemDoc</code>中的非高亮结果</li></ul><h1 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h1><p>聚合（<code>aggregations</code>）可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><p>聚合常见的有三类：</p><ul><li>桶（<code>Bucket</code>）聚合：用来对文档做分组 <ul><li><code>TermAggregation</code>：按照文档字段值分组，例如按照品牌值分组</li><li><code>Date Histogram</code>：按照日期阶梯分组，例如一周为一组</li></ul></li><li>度量（<code>Metric</code>）聚合：用以计算一些值<ul><li><code>Avg</code>：求平均值</li><li><code>Max</code>：求最大值</li><li><code>Min</code>：求最小值</li><li><code>Stats</code>：同时求<code>max</code>、<code>min</code>、<code>avg</code>、<code>sum</code>等</li></ul></li><li>管道（<code>pipeline</code>）聚合：其它聚合的结果为基础做进一步运算</li></ul><p><strong>参加聚合的字段必须是keyword、日期、数值、布尔类型</strong></p><h2 id="DSL实现聚合"><a href="#DSL实现聚合" class="headerlink" title="DSL实现聚合"></a>DSL实现聚合</h2><h3 id="Bucket聚合"><a href="#Bucket聚合" class="headerlink" title="Bucket聚合"></a>Bucket聚合</h3><p>例如我们要统计所有商品中共有哪些商品分类，其实就是以分类（category）字段对数据分组。category值一样的放在同一组，属于<code>Bucket</code>聚合中的<code>Term</code>聚合。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;category_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;category&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>语法说明：</p><ul><li><code>size</code>：设置<code>size</code>为0，就是每页查0条，则结果中就不包含文档，只包含聚合</li><li><code>aggs</code>：定义聚合<ul><li><code>category_agg</code>：聚合名称，自定义，不能重复<ul><li><code>terms</code>：聚合的类型，按分类聚合，所以用<code>term</code><ul><li><code>field</code>：参与聚合的字段名称</li><li><code>size</code>：希望返回的聚合结果的最大数量</li></ul></li></ul></li></ul></li></ul><h3 id="带条件聚合"><a href="#带条件聚合" class="headerlink" title="带条件聚合"></a>带条件聚合</h3><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>例如，我想知道价格高于3000元的手机品牌有哪些，该怎么统计呢？</p><p>我们需要从需求中分析出搜索查询的条件和聚合的目标：</p><ul><li>搜索查询条件：<ul><li>价格高于3000</li><li>必须是手机</li></ul></li><li>聚合目标：统计的是品牌，肯定是对brand字段做term聚合</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">300000</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brand_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Metric聚合"><a href="#Metric聚合" class="headerlink" title="Metric聚合"></a>Metric聚合</h3><p>上节课，我们统计了价格高于3000的手机品牌，形成了一个个桶。现在我们需要对桶内的商品做运算，获取每个品牌价格的最小值、最大值、平均值。</p><p>这就要用到<code>Metric</code>聚合了，例如<code>stat</code>聚合，就可以同时获取<code>min</code>、<code>max</code>、<code>avg</code>等结果</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">300000</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brand_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;stats_meric&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到我们在<code>brand_agg</code>聚合的内部，我们新加了一个<code>aggs</code>参数。这个聚合就是<code>brand_agg</code>的子聚合，会对<code>brand_agg</code>形成的每个桶中的文档分别统计。</p><ul><li><code>stats_meric</code>：聚合名称<ul><li><code>stats</code>：聚合类型，stats是<code>metric</code>聚合的一种<ul><li><code>field</code>：聚合字段，这里选择<code>price</code>，统计价格</li></ul></li></ul></li></ul><p>由于stats是对brand_agg形成的每个品牌桶内文档分别做统计，因此每个品牌都会统计出自己的价格最小、最大、平均值。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>aggs代表聚合，与query同级，此时query的作用是？</p><ul><li>限定聚合的的文档范围</li></ul><p>聚合必须的三要素：</p><ul><li>聚合名称</li><li>聚合类型</li><li>聚合字段</li></ul><p>聚合可配置属性有：</p><ul><li>size：指定聚合结果数量</li><li>order：指定聚合结果排序方式</li><li>field：指定聚合字段</li></ul><h2 id="RestClient实现聚合"><a href="#RestClient实现聚合" class="headerlink" title="RestClient实现聚合"></a>RestClient实现聚合</h2><p>在DSL中，<code>aggs</code>聚合条件与<code>query</code>条件是同一级别，都属于查询JSON参数，因此依然是利用<code>request.source()</code>方法来设置。</p><p>聚合条件的要利用<code>AggregationBuilders</code>这个工具类来构造，聚合结果与搜索文档同一级别，需要单独获取和解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAgg</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">bool</span> <span class="operator">=</span> QueryBuilders.boolQuery()</span><br><span class="line">            .filter(QueryBuilders.termQuery(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;手机&quot;</span>))</span><br><span class="line">            .filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">3000</span>));</span><br><span class="line">    request.source().query(bool).size(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3.聚合参数</span></span><br><span class="line">    request.source().aggregation(</span><br><span class="line">            AggregationBuilders.terms(<span class="string">&quot;brand_agg&quot;</span>).field(<span class="string">&quot;brand&quot;</span>).size(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 4.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 5.解析聚合结果</span></span><br><span class="line">    <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">    <span class="comment">// 5.1.获取品牌聚合</span></span><br><span class="line">    <span class="type">Terms</span> <span class="variable">brandTerms</span> <span class="operator">=</span> aggregations.get(<span class="string">&quot;brand_agg&quot;</span>);</span><br><span class="line">    <span class="comment">// 5.2.获取聚合中的桶</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();</span><br><span class="line">    <span class="comment">// 5.3.遍历桶内数据</span></span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 5.4.获取桶内key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">brand</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">        System.out.print(<span class="string">&quot;brand = &quot;</span> + brand);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> bucket.getDocCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;; count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务入门(二)</title>
      <link href="/inori/98835b85.html"/>
      <url>/inori/98835b85.html</url>
      
        <content type="html"><![CDATA[<p>在微服务远程调用的过程中，还存在几个问题需要解决。</p><p>首先是<strong>业务健壮性</strong>问题：</p><p>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服 务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息。</p><p>还有级联失败问题：</p><p>还是查询购物车的业务，假如商品服务业务并发较高，占用过多Tomcat连接。可能会导致商品服务的所有接口响应时间增加，延迟变高，甚至是长时间阻塞直至查询失败。</p><p>此时查询购物车业务需要查询并等待商品查询结果，从而导致查询购物车列表业务的响应时间也变长，甚至也阻塞直至无法访问。而此时如果查询购物车的请求较多，可能导致购物车服务的Tomcat连接占用较多，所有接口的响应时间都会增加，整个服务性能很差， 甚至不可用。</p><p>暂时无法在飞书文档外展示此内容</p><p>依次类推，整个微服务群中与购物车服务、商品服务等有调用关系的服务可能都会出现问题，最终导致整个集群不可用。</p><p>暂时无法在飞书文档外展示此内容</p><p>这就是级联失败问题，或者叫雪崩问题。</p><h1 id="微服务保护"><a href="#微服务保护" class="headerlink" title="微服务保护"></a>微服务保护</h1><p>保证服务运行的健壮性，避免级联失败导致的雪崩问题（整个微服务群中有调用关系的服务出现问题，最终导致整个集群不可用），就属于微服务保护</p><h2 id="服务保护方案"><a href="#服务保护方案" class="headerlink" title="服务保护方案"></a>服务保护方案</h2><p>微服务保护的方案有很多，比如：</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul><p>这些方案或多或少都会导致服务的体验上略有下降，比如请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。因此这些方案都属于服务<strong>降级</strong>的方案。但通过这些方案，服务的健壮性得到了提升，</p><h3 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h3><p>服务故障最重要原因，就是并发太高。解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是<strong>限制或控制</strong>接口访问的并发流量，避免服务因流量激增而出现故障。</p><p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。</p><h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以必须把这种影响降低，或者缩减影响的范围，线程隔离正是解决这个问题的好办法。</p><p>其原理就是为了避免某个接口故障或压力过大导致整个服务不可用，限定每个接口可以使用的资源范围，也就是将其“隔离”起来。</p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>线程隔离虽然避免了雪崩问题，但故障服务依然会拖慢服务调用方的接口响应速度，而且其故障可能会导致接下来要调用的其他服务也变得不可用。</p><p>所以要做两件事情：</p><ul><li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li><li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li></ul><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><a href="https://sentinelguard.io/zh-cn/">Sentinel</a>是阿里巴巴开源的一款服务保护框架，目前已经加入SpringCloudAlibaba中</p><p>Sentinel的使用可以分为两个部分:</p><ul><li><strong>核心库</strong>（Jar包）：不依赖任何框架&#x2F;库，能够运行于 ava8及以上的版本的运行时环境，同时对Dubbo&#x2F;Spring Cloud等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</li><li><strong>控制台</strong>（Dashboard）：Dashboard主要负责管理推送规则、监控、管理机器信息等。</li></ul><p>为了方便监控微服务，需要先把Sentinel的控制台搭建出来。</p><p>1）<a href="https://github.com/alibaba/Sentinel/releases">下载jar包</a></p><p>2）运行</p><p>将jar包放在任意非中文、不包含特殊字符的目录下,运行如下命令启动控制台：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</span><br></pre></td></tr></table></figure><p>其它启动时可配置参数可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9">官方文档</a></p><p>3）访问</p><p>访问<a href="http://localhost:8080/">http://localhost:8090</a>页面，就可以看到sentinel的控制台了，需要输入账号和密码，默认都是：sentinel，登录后，即可看到控制台，默认会监控sentinel-dashboard服务本身</p><h3 id="微服务整合"><a href="#微服务整合" class="headerlink" title="微服务整合"></a>微服务整合</h3><p>想要在微服务连接<code>sentinel-dashboard</code>控制台，步骤如下： </p><p>1）引入sentinel依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置控制台</p><p>修改application.yaml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br></pre></td></tr></table></figure><p>3）访问微服务任意端点</p><p>重启微服务，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到<code>sentinel-dashboard</code>控制台。并展示出统计信息</p><p>点击簇点链路菜单，会看到下面的页面：</p><p><img src="/%5Cimg%5Csentinel_service_control.png" alt="sentinel_service_control"></p><p>簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被Sentinel监控的资源。默认情况下，<code>Sentinel</code>会监控<code>SpringMVC</code>的每一个<code>Endpoint</code>（接口）</p><p><code>/carts</code>这个接口路径就是其中一个簇点，我们可以对其进行限流、熔断、隔离等保护措施。</p><p>默认情况下Sentinel会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。</p><p>所以可以选择打开Sentinel的请求方式前缀，把<code>请求方式 + 请求路径</code>作为簇点资源名：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><h3 id="请求限流-1"><a href="#请求限流-1" class="headerlink" title="请求限流"></a>请求限流</h3><p>在簇点链路后面点击流控按钮，即可对其做限流配置</p><h3 id="线程隔离-1"><a href="#线程隔离-1" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。所以要对查询商品的FeignClient接口做线程隔离。</p><h4 id="OpenFeign整合Sentinel"><a href="#OpenFeign整合Sentinel" class="headerlink" title="OpenFeign整合Sentinel"></a>OpenFeign整合Sentinel</h4><p>开启Feign的sentinel功能：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure><p>然后重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源</p><h4 id="配置线程隔离"><a href="#配置线程隔离" class="headerlink" title="配置线程隔离"></a>配置线程隔离</h4><p>点击查询商品的FeignClient对应的簇点资源后面的流控按钮：</p><p><img src="D:\Blog\source\img\thread_division.png" alt="thread_division"></p><p>这里勾选的是并发线程数限制，也就是说这个查询功能最多使用5个线程，而不是5QPS。如果查询商品的接口每秒处理2个请求，则5个线程的实际QPS在10左右，而超出的请求自然会被拒绝。</p><h3 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>通常来说，业务不能只配置线程隔离，还需要搭配服务熔断一起，因为：</p><ul><li>超出的QPS上限的请求就只能抛出异常，会损失用户体验。需要给查询失败设置一个<strong>降级处理</strong>逻辑</li><li>由于查询商品的延迟较高，从而导致其他相关联的业务响应时间也变的很长。对于这种不太健康的接口，应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。</li></ul><h4 id="编写降级逻辑"><a href="#编写降级逻辑" class="headerlink" title="编写降级逻辑"></a>编写降级逻辑</h4><p>触发限流或熔断后的请求不一定要直接报错，也可以返回一些默认数据或者友好提示，用户体验会更好。</p><p>给FeignClient编写失败后的降级逻辑有两种方式：</p><ul><li>FallbackClass，无法对远程调用的异常做处理</li><li>FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式。</li></ul><p>定义降级处理类，实现<code>FallbackFactory</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(Collection&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;远程调用queryItemByIds方法出现异常，参数：&#123;&#125;&quot;</span>, ids, cause);</span><br><span class="line">                <span class="comment">// 查询购物车允许失败，查询失败，返回空集合</span></span><br><span class="line">                <span class="keyword">return</span> CollUtils.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;</span><br><span class="line">                <span class="comment">// 库存扣减业务需要触发事务回滚，查询失败，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>ItemClientFallback</code>注册为一个<code>Bean</code></p><p>在接口中使用<code>ItemClientFallbackFactory</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class,fallbackFactory = ItemClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; items)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/stock/add&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetail&gt; items)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务熔断-2"><a href="#服务熔断-2" class="headerlink" title="服务熔断"></a>服务熔断</h4><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</p><p>断路器的工作状态切换有一个状态机来控制：</p><p><img src="D:\Blog\source\img\sentinel_stop.png" alt="sentinel_stop"></p><p>状态机包括三个状态：</p><ul><li><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 <ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p>我们可以在控制台通过点击簇点后的<strong>熔断</strong>按钮来配置熔断策略，这种是按照慢调用比例来做熔断，上述配置的含义是：</p><ul><li>RT超过200毫秒的请求调用就是慢调用</li><li>统计最近1000ms内的最少5次请求，如果慢调用比例不低于0.5，则触发熔断</li><li>熔断持续时长20s</li></ul><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为<strong>分支事务</strong>。多个有关联的分支事务一起就组成了<strong>全局事务</strong>。必须保证整个全局事务同时成功或失败。</p><p>我们知道每一个分支事务就是传统的<strong>单体事务</strong>，都可以满足ACID(原子性，一致性，隔离性，持久性)，但全局事务跨越多个服务、多个数据库，如何满足ACID呢？</p><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此一般会使用开源的框架来解决分布式事务问题。</p><p>在众多的开源分布式事务框架中，功能最完善、使用最多的是<a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">Seata</a>。</p><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。</p><p>因此解决分布式事务的思想为：就是找一个统一的<strong>事务协调者</strong>，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。</p><p>在Seata的事务管理中有三个重要的角色：</p><ul><li>TC (Transaction Coordinator) - <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚</li><li>TM (Transaction Manager) - <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务</li><li>RM (Resource Manager) - <strong>资源管理器：</strong>管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li></ul><p>Seata的工作架构为：</p><p><img src="D:\Blog\source\img\seata_frame.png" alt="seata_frame"></p><p>其中，<strong>TM</strong>和<strong>RM</strong>可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来<strong>TM</strong>和<strong>RM</strong>就会协助微服务，实现本地分支事务与<strong>TC</strong>之间交互，实现事务的提交或回滚。</p><p>而<strong>TC</strong>服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p><h3 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h3><p>需要准备数据库表、导入配置文件、使用Docker命令部署，详见<a href="https://blog.csdn.net/studio_1/article/details/135650319">这篇博客</a></p><h4 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h4><p>需要注意，要确保nacos、mysql都在同一网络中。如果某个容器不在同一网络，可以参考下面的命令将某容器加入指定网络：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network connect [网络名] [容器名]</span><br></pre></td></tr></table></figure><h3 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata</h3><p>参与分布式事务的每一个微服务都需要集成Seata，我们以<code>trade-service</code>为例。</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>为了方便各个微服务集成seata，我们需要把seata配置共享到nacos，因此不仅仅要引入seata依赖，还要引入nacos依赖:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">hmall</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与tc集群的映射关系</span></span><br><span class="line">      <span class="attr">hmall:</span> <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure><h4 id="添加数据库表"><a href="#添加数据库表" class="headerlink" title="添加数据库表"></a>添加数据库表</h4><p>seata的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。加入到需要分布式事务的微服务的数据库中：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `undo_log`</span><br><span class="line">(</span><br><span class="line">    `branch_id`     <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    `xid`           <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    `context`       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    `rollback_info` LONGBLOB     <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    `log_status`    <span class="type">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    `log_created`   DATETIME(<span class="number">6</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    `log_modified`  DATETIME(<span class="number">6</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4 COMMENT <span class="operator">=</span><span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure><p>至此为止，微服务整合的工作就完成了</p><p>那么，Seata是如何解决分布式事务的呢？</p><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><p>Seata支持四种不同的分布式事务解决方案：</p><ul><li><strong>XA</strong></li><li><strong>TCC</strong></li><li><strong>AT</strong></li><li><strong>SAGA</strong></li></ul><p><code>XA</code> 规范是<code> X/Open</code> 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA规范描述了全局的<code>TM</code>与局部的<code>RM</code>之间的接口，几乎所有主流的数据库都对XA规范提供了支持。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>正常情况：</p><p><img src="D:\Blog\source\img\xa_normal.png" alt="xa_normal"></p><p>异常情况：</p><p><img src="D:\Blog\source\img\xa_nonomal.png" alt="xa_nonomal"></p><p>一阶段：</p><ul><li>事务协调者通知每个事务参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作</li><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul><h4 id="Seata的XA模型"><a href="#Seata的XA模型" class="headerlink" title="Seata的XA模型"></a>Seata的XA模型</h4><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><p><img src="D:\Blog\source\img\xa_model.png" alt="xa_model"></p><p><code>RM</code>一阶段的工作：</p><ol><li>注册分支事务到<code>TC</code></li><li>执行分支业务sql但不提交</li><li>报告执行状态到<code>TC</code></li></ol><p><code>TC</code>二阶段的工作：</p><ol><li><code>TC</code>检测各分支事务执行状态</li><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ol><p><code>RM</code>二阶段的工作：</p><ul><li>接收<code>TC</code>指令，提交或回滚事务</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><code>XA</code>模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p><code>XA</code>模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>首先，在配置文件中设置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure><p>其次，我们要利用<code>@GlobalTransactional</code>标记分布式事务的入口方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">createOrder</span><span class="params">(OrderFormDTO orderFormDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p><code>AT</code>模式同样是分阶段提交的事务模型，不过缺弥补了<code>XA</code>模型中资源锁定周期过长的缺陷。</p><h4 id="Seata的AT模型"><a href="#Seata的AT模型" class="headerlink" title="Seata的AT模型"></a>Seata的AT模型</h4><p><img src="D:\Blog\source\img\at_model.png" alt="at_model"></p><p>阶段一<code>RM</code>的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时<code>RM</code>的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时<code>RM</code>的工作：</p><ul><li>根据undo-log恢复数据到更新前</li></ul><h4 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h4><p>我们用一个真实的业务来梳理下AT模式的原理。</p><p>比如，现在有一个数据库表，记录用户余额：</p><table><thead><tr><th align="left"><strong>id</strong></th><th align="left"><strong>money</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">100</td></tr></tbody></table><p>其中一个分支业务要执行的SQL为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>AT模式下，当前分支事务执行流程如下：</p><p><strong>一阶段</strong>：</p><ol><li><code>TM</code>发起并注册全局事务到<code>TC</code></li><li><code>TM</code>调用分支事务</li><li>分支事务准备执行业务SQL</li><li><code>RM</code>拦截业务SQL，根据where条件查询原始数据，形成快照。</li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;money&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol><li><code>RM</code>执行业务SQL，提交本地事务，释放数据库锁。此时 money &#x3D; 90</li><li><code>RM</code>报告本地事务状态给<code>TC</code></li></ol><p><strong>二阶段</strong>：</p><ol><li><code>TM</code>通知<code>TC</code>事务结束</li><li><code>TC</code>检查分支事务状态<ol><li>如果都成功，则删除快照</li><li>如果有分支事务失败，需要回滚。读取快照数据（{“id”: 1, “money”: 100}），将快照恢复到数据库。此时数据库再次恢复为100</li></ol></li></ol><h4 id="AT模式的脏写问题"><a href="#AT模式的脏写问题" class="headerlink" title="AT模式的脏写问题"></a>AT模式的脏写问题</h4><p>在极端情况下，特别是多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，比如一个事物A获取DB锁，保存快照，执行<code>set money = 90</code>然后提交事务，释放DB锁，但是这是有另一个事务B接着获取DB锁，保存快照后执行<code>set money = 80</code>然后提交事务，释放DB锁。但是这时事务A需要回滚，事务A的快照保存的<code>money=100</code>，这就造成了脏写。</p><p>解决思路就是引入了全局锁的概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p><h3 id="AT与XA的区别"><a href="#AT与XA的区别" class="headerlink" title="AT与XA的区别"></a>AT与XA的区别</h3><p>简述<code>AT</code>模式与<code>XA</code>模式最大的区别是什么？</p><ul><li><code>XA</code>模式一阶段不提交事务，锁定资源；<code>AT</code>模式一阶段直接提交，不锁定资源。</li><li><code>XA</code>模式依赖数据库机制实现回滚；<code>AT</code>模式利用数据快照实现数据回滚。</li><li><code>XA</code>模式强一致；<code>AT</code>模式最终一致</li></ul><p>可见，AT模式使用起来更加简单，无业务侵入，性能更好。</p><h3 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h3><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li><code>try</code>：资源的检测和预留</li><li><code>confirm</code>：完成资源操作业务；要求 <code>try</code> 成功 <code>confirm</code> 一定要能成功 </li><li><code>cancel</code>：预留资源释放，可以理解为try的反向操作</li></ul><p>举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。</p><p><strong>阶段一（ Try ）</strong>：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30，此时，<code>总金额 = 冻结金额 + 可用金额</code>，数量依然是100不变。事务直接提交无需等待其它事务</p><p>**阶段二（Confirm)**：假如要提交（Confirm），之前可用金额已经扣减，并转移到冻结金额。因此可用金额不变，直接冻结金额扣减30即可。此时，<code>总金额 = 冻结金额 + 可用金额 = 0 + 70  = 70元</code></p><p>**阶段三(Canncel)**：<u>如果</u>要回滚（Cancel），则释放之前冻结的金额，也就是冻结金额扣减30，可用余额增加30</p><p>假如一个分布式事务中包含两个分支事务，try阶段，一个分支成功执行，另一个分支事务阻塞</p><h4 id="事务悬挂和空回滚"><a href="#事务悬挂和空回滚" class="headerlink" title="事务悬挂和空回滚"></a>事务悬挂和空回滚</h4><p>假如一个分布式事务中包含两个分支事务，try阶段，一个分支成功执行，另一个分支事务阻塞</p><p><img src="D:\Blog\source\img\tcc_1.png" alt="tcc_1"></p><p>如果阻塞时间太长，可能导致全局事务超时而触发二阶段的<code>cancel</code>操作。两个分支事务都会执行cancel操作</p><p><img src="D:\Blog\source\img\tcc_2.png" alt="tcc_2"></p><p>要知道，其中一个分支是未执行<code>try</code>操作的，直接执行了<code>cancel</code>操作，反而会导致数据错误。因此，这种情况下，尽管<code>cancel</code>方法要执行，但其中不能做任何回滚操作，这就是<strong>空回滚</strong></p><p>对于整个空回滚的分支事务，将来try方法阻塞结束依然会执行。但是整个全局事务其实已经结束了，因此永远不会再有confirm或cancel，也就是说这个事务执行了一半，处于<strong>悬挂状态</strong>，这就是业务悬挂问题</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>TCC模式的每个阶段</p><ul><li>Try：资源检查和预留</li><li>Confirm：业务执行和提交</li><li>Cancel：预留资源的释放</li></ul><p>TCC的优点</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模型，无需生成快照，无需使用全局锁，性能最强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul><p>TCC的缺点</p><ul><li>有代码侵入，需要人为编写try、Confirm和Cancel接口</li><li>软状态，事务是最终一致</li><li>需要考虑Confirm和Cancel的失败情况，做好幂等处理、事务悬挂和空回滚处理</li></ul><h2 id="CAP与BASE理论"><a href="#CAP与BASE理论" class="headerlink" title="CAP与BASE理论"></a>CAP与BASE理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导，首先就是CAP定理</p><ul><li>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致</li><li><strong>A</strong>vailability（可用性）：用户访问分布式系统时，读或写操作总能成功</li><li><strong>P</strong>artition tolerance （分区容错性）：即便是系统出现网络分区，整个系统也要持续对外提供服务</li></ul><p>它们的第一个字母分别是 <code>C</code>、<code>A</code>、<code>P</code>。开发者认为任何分布式系统架构方案都不可能同时满足这3个目标，这个结论就叫做CAP定理</p><p>在分布式系统中，网络不能100%保证畅通，也就是说网络分区的情况一定会存在。而我们的系统必须要持续运行，对外提供服务。所以分区容错性（<code>P</code>）是硬性指标，所有分布式系统都要满足。而在设计分布式系统时要取舍的就是一致性（<code>C</code>）和可用性（<code>A</code>）了。</p><p>假设有三个node节点，由于网络故障，当我们把数据写入node01时，可以与node02完成数据同步，但是无法同步给node03。现在有两种选择：</p><ul><li>允许用户任意读写，保证可用性。但由于node03无法完成同步，就会出现数据不一致的情况。满足AP</li><li>不允许用户写，可以读，直到网络恢复，分区消失。这样就确保了一致性，但牺牲了可用性。满足CP</li></ul><p>可见，在分布式系统中，<code>A</code>和<code>C</code>之间只能满足一个</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>既然分布式系统要遵循CAP定理，那么问题来了，我到底是该牺牲一致性还是可用性呢？如果牺牲了一致性，出现数据不一致该怎么处理？</p><p>人们在总结系统设计经验时，最终得到了一些心得：</p><ul><li><strong>B</strong>asically <strong>A</strong>vailable（基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用</li><li><strong>S</strong>oft State<strong>（</strong>软状态<strong>）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态</li><li><strong>Ev</strong>entually Consistent<strong>（</strong>最终一致性<strong>）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</li></ul><p>简单来说，BASE理论就是一种取舍的方案，不再追求完美，而是最终达成目标。因此解决分布式事务的思想也是这样，有两个方向：</p><ul><li>AP思想：各个子事务分别执行和提交，无需锁定数据。允许出现结果不一致，然后采用弥补措施恢复，实现最终一致即可。例如<code>AT</code>模式就是如此</li><li>CP思想：各个子事务执行后不要提交，而是等待彼此结果，然后同时提交或回滚。在这个过程中锁定资源，不允许其它人访问，数据处于不可用状态，但能保证一致性。例如<code>XA</code>模式</li></ul><h2 id="服务保护"><a href="#服务保护" class="headerlink" title="服务保护"></a>服务保护</h2><p>在SpringCloud的早期版本中采用的服务保护技术叫做<code>Hystix</code>，不过后来被淘汰，替换为<code>Spring Cloud Circuit Breaker</code>，其底层实现可以是<code>Spring Retry</code>和<code>Resilience4J</code></p><p>不过在国内使用较多还是<code>SpringCloudAlibaba</code>中的<code>Sentinel</code>组件</p><h3 id="线程隔离-2"><a href="#线程隔离-2" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>首先我们来看下线程隔离功能，无论是Hystix还是Sentinel都支持线程隔离。不过其实现方式不同。</p><p>线程隔离有两种方式实现：</p><ul><li>线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果，优点是支持主动超时和异步调用，缺点是线程额外开销大</li><li>信号量隔离：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求，优点是无额外开销，缺点是不支持主动超时和异步调用</li></ul><p>Sentinel的线程隔离就是基于信号量隔离实现的，而Hystix两种都支持，但默认是基于线程池隔离</p><h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>在熔断功能中，需要统计异常请求或慢请求比例，也就是计数。在限流的时候，要统计每秒钟的QPS，同样是计数。可见计数算法在熔断限流中的应用非常多。sentinel中采用的计数器算法就是滑动窗口计数算法</p><h4 id="固定窗口计数"><a href="#固定窗口计数" class="headerlink" title="固定窗口计数"></a>固定窗口计数</h4><p>固定窗口计数法基本原理是：</p><ul><li>将时间划分为多个窗口，窗口时间跨度称为<code>Interval</code></li><li>每个窗口维护1个计数器，每有1次请求就将计数器<code>+1</code>。限流就是设置计数器阈值</li><li>如果计数器超过了限流阈值，则超出阈值的请求都被丢弃</li></ul><p>但是有一种特殊场景，假设<code>Interval</code>为1s：</p><ul><li>假如在第5、6秒，请求数量都为3，没有超过阈值，全部放行</li><li>但是，如果第5秒的三次请求都是在4.5<del>5秒之间进来；第6秒的请求是在5</del>5.5之间进来。那么从第4.5~5.5之间就有6次请求！也就是说每秒的QPS达到了6，远超阈值</li></ul><h4 id="滑动窗口计数"><a href="#滑动窗口计数" class="headerlink" title="滑动窗口计数"></a>滑动窗口计数</h4><p>固定时间窗口算法中窗口有很多，其跨度和位置是与时间区间绑定，因此是很多固定不动的窗口。而滑动时间窗口算法中只包含1个固定跨度的窗口，但窗口是可移动的，与时间区间无关</p><ul><li>窗口时间跨度<code>Interval</code>大小固定，例如1秒</li><li>时间区间跨度为<code>Interval / n</code> ，例如n&#x3D;2，则时间区间跨度为500ms</li><li>窗口会随着当前请求所在时间<code>currentTime</code>移动，窗口范围从<code>currentTime-Interval</code>时刻之后的第一个时区开始，到<code>currentTime</code>所在时区结束</li></ul><p>滑动窗口内划分的时区越多，这种统计就越准确。</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>漏桶算法可以解释为请求到达后不是直接处理，而是先放入一个队列。而后以固定的速率从队列中取出并处理请求。之所以叫漏桶算法，就是把请求看做水，队列看做是一个漏了的桶，设计上更适合应对并发波动较大的场景</p><ul><li>将每个请求视作”水滴”放入”漏桶”进行存储</li><li>“漏桶”以固定速率向外”漏”出请求来执行，如果”漏桶”空了则停止”漏水”</li><li>如果”漏桶”满了则多余的”水滴”会被直接丢弃</li></ul><p>漏桶的优势就是<strong>流量整型</strong>，桶就像是一个大坝，请求就是水。并发量不断波动，就如图水流时大时小，但都会被大坝拦住。而后大坝按照固定的速度放水，避免下游被洪水淹没。</p><p>因此，不管并发量如何波动，经过漏桶处理后的请求一定是相对平滑的曲线</p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>限流的另一种常见算法是令牌桶算法。Sentinel中的<strong>热点参数限流</strong>正是基于令牌桶算法实现的。</p><p>说明：</p><ul><li>以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，多余令牌丢弃</li><li>请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理</li><li>如果令牌桶中没有令牌，则请求等待或丢弃</li></ul><p>基于令牌桶算法，每秒产生的令牌数量基本就是QPS上限</p><p>当然也有例外情况，例如：</p><ul><li>某一秒令牌桶中产生了很多令牌，达到令牌桶上限N，缓存在令牌桶中，但是这一秒没有请求进入。</li><li>下一秒的前半秒涌入了超过2N个请求，之前缓存的令牌桶的令牌耗尽，同时这一秒又生成了N个令牌，于是总共放行了2N个请求。超出了我们设定的QPS阈值。</li></ul><p>因此，在使用令牌桶算法时，尽量不要将令牌上限设定到服务能承受的QPS上限。而是预留一定的波动空间，这样我们才能应对突发流量。</p><p>什么是热点参数限流？</p><ul><li><p>商品ID为参数，统计一段时间内最常购买的商品ID并进行限制</p></li><li><p>用户ID为参数，针对一段时间内频繁访问的用户ID进行限制</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch基础入门</title>
      <link href="/inori/d672aa30.html"/>
      <url>/inori/d672aa30.html</url>
      
        <content type="html"><![CDATA[<p>在某些数据量非常大的项目中，一定会提供搜索功能。如果搜索功能仅仅使用数据库模糊查询实现，就会带来很多问题：</p><ol><li>效率低。由于数据库模糊查询不走索引，在数据量较大的时候，查询性能很差。数据库模糊查询随着表数据量的增多，查询性能的下降会非常明显，</li><li>功能单一。数据库的模糊搜索功能单一，匹配条件非常苛刻，必须恰好包含用户搜索的关键字。</li></ol><p>而使用搜索引擎就没有上述问题。</p><h1 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h1><p><a href="https://www.elastic.co/cn/elasticsearch/">ElasticSearch</a>是一款非常强大的开源搜索引擎，支持的功能非常多</p><h2 id="认识和安装"><a href="#认识和安装" class="headerlink" title="认识和安装"></a>认识和安装</h2><p>Elasticsearch是elastic技术栈中的一部分。完整的技术栈包括：</p><ul><li>Elasticsearch：用于数据存储、计算和搜索</li><li>Logstash&#x2F;Beats：用于数据收集</li><li>Kibana：用于数据可视化</li></ul><p>整套技术栈被称为ELK，经常用来做日志收集、系统监控和状态分析等等，其核心就是用来<strong>存储</strong>、<strong>搜索</strong>、<strong>计算</strong>的Elasticsearch</p><p>需要安装的内容有：</p><ul><li>Elasticsearch：提供核心的数据存储、搜索、分析功能。</li><li>Kibana：Elasticsearch对外提供的是Restful风格的API，任何操作都可以通过发送http请求来完成。不过http请求的方式、路径、还有请求参数的格式都有严格的规范。要借助于Kibana服务</li></ul><p>而且，Kibana的功能非常强大，包括：</p><ul><li>对Elasticsearch数据的搜索、展示</li><li>对Elasticsearch数据的统计、聚合，并形成图形化报表、图形</li><li>对Elasticsearch的集群状态监控</li><li>它还提供了一个开发控制台（DevTools），在其中对Elasticsearch的Restful的API接口提供了<strong>语法提示</strong></li></ul><h3 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h3><p>通过Docker命令安装单机版本的elasticsearch，这里采用的是elasticsearch7版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name es \</span><br><span class="line">  -e <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">  -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">  -v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">  --privileged \</span><br><span class="line">  --network test-net \</span><br><span class="line">  -p 9200:9200 \</span><br><span class="line">  -p 9300:9300 \</span><br><span class="line">  elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><p>安装完成后，访问9200端口，即可看到响应的Elasticsearch服务的基本信息。</p><h3 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h3><p>通过Docker命令部署Kibana：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=test-net \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure><p>安装完成后，直接访问5601端口，即可看到控制台页面，选择<code>Explore on my own</code>之后，进入主页面，然后选中<code>Dev tools</code>，进入开发工具页面，之后主要在这里预先输入ES查询语句。</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>ES之所以有如此高性能的搜索表现，正是得益于底层的倒排索引技术。倒排索引的概念是基于MySQL这样的正向索引而言的。</p><h3 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h3><p>例如有一张名为<code>tb_goods</code>的表：</p><table><thead><tr><th align="left"><strong>id</strong></th><th align="left"><strong>title</strong></th><th align="left"><strong>price</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">小米手机</td><td align="left">3499</td></tr><tr><td align="left">2</td><td align="left">华为手机</td><td align="left">4999</td></tr><tr><td align="left">3</td><td align="left">华为小米充电器</td><td align="left">49</td></tr><tr><td align="left">4</td><td align="left">小米手环</td><td align="left">49</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>其中的<code>id</code>字段已经创建了索引，由于索引底层采用了B+树结构，因此我们根据id搜索的速度会非常快。但是其他字段例如<code>title</code>，只在叶子节点上存在。</p><p>因此要根据<code>title</code>搜索的时候只能遍历树中的每一个叶子节点，判断title数据是否符合要求。</p><p>比如用户的SQL语句为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_goods <span class="keyword">where</span> title <span class="keyword">like</span> <span class="string">&#x27;%手机%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>那搜索的大概流程为：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjM0NTE1OWFhNmQ1ZDc2NTY1OGRhYzA1OTkyYmU5MzZfeXQ4YmlybEFRa3BzQVF6N3NyaDBnSkV6aENkUWVWdzBfVG9rZW46UFlDRGJlNVNub1VHaVV4TFRLTGMwOEJLbkRiXzE3MTU1MTEyMTg6MTcxNTUxNDgxOF9WNA" alt="img"></p><ul><li>1）检查到搜索条件为<code>like &#39;%手机%&#39;</code>，需要找到<code>title</code>中包含<code>手机</code>的数据</li><li>2）逐条遍历每行数据（每个叶子节点），比如第1次拿到<code>id</code>为1的数据</li><li>3）判断数据中的<code>title</code>字段值是否符合条件</li><li>4）如果符合则放入结果集，不符合则丢弃</li><li>5）回到步骤1</li></ul><p>当搜索条件为模糊匹配时，由于索引无法生效，导致从索引查询退化为全表扫描，效率很差。因此，正向索引适合于根据索引字段的精确搜索，不适合基于部分词条的模糊匹配。而倒排索引恰好解决的就是根据部分词条模糊匹配的问题。</p><h3 id="倒排索引-1"><a href="#倒排索引-1" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引中有两个概念：</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条</li></ul><p>创建倒排索引是对正向索引的一种特殊处理和应用，流程为：</p><ul><li>将每一个文档的数据利用<strong>分词算法</strong>根据语义拆分，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建<strong>正向</strong>索引</li></ul><p>此时形成的这张以词条为索引的表，就是倒排索引表，两者对比如下：</p><p><strong>正向索引</strong></p><table><thead><tr><th align="left"><strong>id（索引）</strong></th><th align="left"><strong>title</strong></th><th align="left"><strong>price</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">小米手机</td><td align="left">3499</td></tr><tr><td align="left">2</td><td align="left">华为手机</td><td align="left">4999</td></tr><tr><td align="left">3</td><td align="left">华为小米充电器</td><td align="left">49</td></tr><tr><td align="left">4</td><td align="left">小米手环</td><td align="left">49</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p><strong>倒排索引</strong></p><table><thead><tr><th align="left"><strong>词条（索引）</strong></th><th align="left"><strong>文档id</strong></th></tr></thead><tbody><tr><td align="left">小米</td><td align="left">1，3，4</td></tr><tr><td align="left">手机</td><td align="left">1，2</td></tr><tr><td align="left">华为</td><td align="left">2，3</td></tr><tr><td align="left">充电器</td><td align="left">3</td></tr><tr><td align="left">手环</td><td align="left">4</td></tr></tbody></table><p>倒排索引的<strong>搜索流程</strong>如下为：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=Njk5OTBlZWJhMDg1MDNlODc5NWRmYzQ3ZjdlZjZkZjZfWlZkRUxXbDJmYjdQSjhDVjN0Q29NMnpOWFB4UURNRDFfVG9rZW46UUZiQWJEdlZHb3c5RVd4RGFkOWNvc1lFbjhmXzE3MTU1MTEyMTg6MTcxNTUxNDgxOF9WNA" alt="img"></p><p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p><p>2）对用户输入条件分词，得到词条：<code>华为</code>、<code>手机</code></p><p>3）拿着词条在倒排索引中查找（由于词条有索引，查询效率很高），即可得到包含词条的文档id：<code>1、2、3</code></p><p>4）拿着文档<code>id</code>到正向索引中查找具体文档即可（由于<code>id</code>也有索引，查询效率也很高）</p><h3 id="正向和倒排的优缺点"><a href="#正向和倒排的优缺点" class="headerlink" title="正向和倒排的优缺点"></a>正向和倒排的优缺点</h3><p><strong>正向索引</strong>：</p><ul><li>优点： <ul><li>可以给多个字段创建索引</li><li>根据索引字段搜索、排序速度非常快</li></ul></li><li>缺点： <ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul></li></ul><p><strong>倒排索引</strong>：</p><ul><li>优点： <ul><li>根据词条搜索、模糊搜索时，速度非常快</li></ul></li><li>缺点： <ul><li>只能给词条创建索引，而不是字段</li><li>无法根据字段做排序</li></ul></li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p><h3 id="文档和字段"><a href="#文档和字段" class="headerlink" title="文档和字段"></a>文档和字段</h3><p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为<code>json</code>格式后存储在<code>elasticsearch</code>中：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小米手机&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">3499</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华为手机&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华为小米充电器&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">49</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小米手环&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">299</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>因此，原本数据库中的一行数据就是ES中的一个JSON文档；而数据库中每行数据都包含很多列，这些列就转换为JSON文档中的<strong>字段（Field）</strong>。</p><h3 id="索引和映射"><a href="#索引和映射" class="headerlink" title="索引和映射"></a>索引和映射</h3><p>随着业务发展，需要在es中存储的文档也会越来越多，比如有商品的文档、用户的文档、订单文档等等，后期将类型相同的文档集中在一起管理，称为<strong>索引（Index）</strong>。</p><p>例如：</p><ul><li>所有用户文档，就可以组织在一起，称为用户的索引</li><li>所有商品的文档，可以组织在一起，称为商品的索引</li><li>所有订单的文档，可以组织在一起，称为订单的索引</li></ul><p>可以把索引当做是数据库中的表。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p><h3 id="mysql与elasticsearch"><a href="#mysql与elasticsearch" class="headerlink" title="mysql与elasticsearch"></a>mysql与elasticsearch</h3><table><thead><tr><th align="left"><strong>MySQL</strong></th><th align="left"><strong>Elasticsearch</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Table</td><td align="left">Index</td><td align="left">索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td align="left">Row</td><td align="left">Document</td><td align="left">文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td align="left">Column</td><td align="left">Field</td><td align="left">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td align="left">Schema</td><td align="left">Mapping</td><td align="left">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td align="left">SQL</td><td align="left">DSL</td><td align="left">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><ul><li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性 </li><li>Elasticsearch：擅长海量数据的搜索、分析、计算</li></ul><p>项目中往往两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><p>Elasticsearch的关键就是倒排索引，而倒排索引依赖于对文档内容的分词，而分词则需要高效、精准的分词算法，IK分词器就是这样的中文分词算法。</p><h3 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h3><p>运行命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it es ./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span><br></pre></td></tr></table></figure><p>重启es容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><h3 id="使用IK分词器"><a href="#使用IK分词器" class="headerlink" title="使用IK分词器"></a>使用IK分词器</h3><p>IK分词器包含两种模式：</p><ul><li><code>ik_smart</code>——智能语义切分：可以在词典库中识别词语，将句子分成一个个词语</li><li><code>ik_max_word</code>——最细粒度切分：除了将句子分成一个个词语之外，还分出一个个字，便于精确查找</li></ul><h3 id="拓展词典"><a href="#拓展词典" class="headerlink" title="拓展词典"></a>拓展词典</h3><p>互联网发展伴随着越来越多的新词语，而这些新词语在ik分词器的原始词典中并不存在，所以要想正确分词，词库也需要不断的更新，所以分词器提供了扩展词汇的功能。</p><p>1）打开IK分词器config目录</p><p>注意：如果ik插件下没有config目录，要么自己手动创建<code>config目录</code>和<code>IKAnalyzer.cfg.xml</code>文件，要么<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">需要下载复制到服务器中</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-v7.12.1.zip</span><br></pre></td></tr></table></figure><p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）在IK分词器的config目录新建一个 <code>ext.dic</code>，在其中写入想要扩展的词汇</p><p>4）重启elasticsearch</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart es</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure><h1 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h1><p>Index就类似数据库表，Mapping映射就类似表的结构。我们要向es中存储数据，必须先创建Index和Mapping</p><h2 id="Mapping映射属性"><a href="#Mapping映射属性" class="headerlink" title="Mapping映射属性"></a>Mapping映射属性</h2><p>Mapping是对索引库中文档的约束，常见的Mapping属性包括：</p><ul><li><code>type</code>：字段数据类型，常见的简单类型有： <ul><li>字符串：<code>text</code>（可分词的文本）、<code>keyword</code>（精确值，例如：品牌、国家、ip地址）</li><li>数值：<code>long</code>、<code>integer</code>、<code>short</code>、<code>byte</code>、<code>double</code>、<code>float</code>、</li><li>布尔：<code>boolean</code></li><li>日期：<code>date</code></li><li>对象：<code>object</code></li></ul></li><li><code>index</code>：是否创建索引，默认为<code>true</code></li><li><code>analyzer</code>：使用哪种分词器</li><li><code>properties</code>：该字段的子字段</li></ul><p>例如下面的json文档：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">52.1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isMarried&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;某某高校某某年级学生&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxx111@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">99.1</span><span class="punctuation">,</span> <span class="number">99.5</span><span class="punctuation">,</span> <span class="number">98.9</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;祈&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;楪&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对应的每个字段映射（Mapping）：</p><table><thead><tr><th align="left">字段名</th><th align="left">字段类型</th><th align="left">类型说明</th><th align="left">是否参与搜索</th><th align="left">是否参与分词</th><th align="left">分词器</th></tr></thead><tbody><tr><td align="left">age</td><td align="left"><code>integer</code></td><td align="left">整数</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">weight</td><td align="left"><code>float</code></td><td align="left">浮点数</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">isMarried</td><td align="left"><code>boolean</code></td><td align="left">布尔</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">info</td><td align="left"><code>text</code></td><td align="left">字符串，需要分词</td><td align="left">是</td><td align="left">是</td><td align="left">IK</td></tr><tr><td align="left">email</td><td align="left"><code>keyword</code></td><td align="left">字符串，但是不分词</td><td align="left">否</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">score</td><td align="left"><code>float</code></td><td align="left">只看数组中元素类型</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">firstName</td><td align="left"><code>keyword</code></td><td align="left">字符串，但是不分词</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">lastName</td><td align="left"><code>keyword</code></td><td align="left">字符串，但是不分词</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr></tbody></table><h2 id="索引库的CRUD"><a href="#索引库的CRUD" class="headerlink" title="索引库的CRUD"></a>索引库的CRUD</h2><p>由于Elasticsearch采用的是Restful风格的API，因此其请求方式和路径相对都比较规范，而且请求参数也都采用JSON风格。</p><h3 id="创建索引库和映射"><a href="#创建索引库和映射" class="headerlink" title="创建索引库和映射"></a>创建索引库和映射</h3><p><strong>基本语法</strong>：</p><ul><li>请求方式：<code>PUT</code></li><li>请求路径：<code>/索引库名</code>，可以自定义</li><li>请求参数：<code>mapping</code>映射</li></ul><p><strong>格式</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;子字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><p><strong>基本语法</strong>：</p><ul><li>请求方式：GET </li><li>请求路径：&#x2F;索引库名 </li><li>请求参数：无</li></ul><p><strong>格式</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p><p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。因此修改索引库能做的就是向索引库中添加新字段，或者更新索引库的基础属性。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><p><strong>语法：</strong></p><ul><li>请求方式：DELETE </li><li>请求路径：&#x2F;索引库名 </li><li>请求参数：无</li></ul><p><strong>格式：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure><h1 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h1><h2 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h2><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p>根据rest风格，新增是post，查询是get，需在后面加上文档id。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_doc/id</span><br></pre></td></tr></table></figure><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><p><strong>语法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DELETE</span> /索引库名/_doc/id</span><br></pre></td></tr></table></figure><h2 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h2><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>局部修改：修改文档中的部分字段</li></ul><h3 id="全量修改"><a href="#全量修改" class="headerlink" title="全量修改"></a>全量修改</h3><p>语法与新增文档相同，全量修改是覆盖原来的文档，其本质是两步操作：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="局部修改"><a href="#局部修改" class="headerlink" title="局部修改"></a>局部修改</h3><p>局部修改是只修改指定id匹配的文档中的部分字段。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;新的值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>批处理采用POST请求，基本语法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; <span class="string">&quot;index&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value1&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;delete&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;create&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value3&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;update&quot;</span> : &#123;<span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>, <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>&#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;doc&quot;</span> : &#123;<span class="string">&quot;field2&quot;</span> : <span class="string">&quot;value2&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>index</code>代表新增操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li><li><code>&#123; &quot;field1&quot; : &quot;value1&quot; &#125;</code>：则是要新增的文档内容</li></ul></li><li><code>delete</code>代表删除操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li></ul></li><li><code>update</code>代表更新操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li><li><code>&#123; &quot;doc&quot; : &#123;&quot;field2&quot; : &quot;value2&quot;&#125; &#125;</code>：要更新的文档字段</li></ul></li></ul><h1 id="RestAPI"><a href="#RestAPI" class="headerlink" title="RestAPI"></a>RestAPI</h1><p><a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">ES官方</a>提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES</p><h2 id="初始化RestClient"><a href="#初始化RestClient" class="headerlink" title="初始化RestClient"></a>初始化RestClient</h2><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为<code>RestHighLevelClient</code>的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接</p><p>1）引入<code>es</code>的<code>RestHighLevelClient</code>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）因为SpringBoot默认的ES版本是<code>7.17.10</code>，需要覆盖默认的ES版本：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）初始化RestHighLevelClient：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://ip地址:9200&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>这里为了单元测试方便，我们创建一个测试类<code>IndexTest</code>，然后将初始化的代码编写在<code>@BeforeEach</code>方法中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.145.128:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h2><p>由于要实现对商品搜索，所以需要将商品添加到Elasticsearch中，不过需要根据搜索业务的需求来设定索引库结构，而不是一股脑的把MySQL数据写入Elasticsearch</p><h3 id="Mapping映射"><a href="#Mapping映射" class="headerlink" title="Mapping映射"></a>Mapping映射</h3><p>实现搜索功能需要的字段包括三大部分：</p><ul><li>搜索过滤字段<ul><li>分类</li><li>品牌</li><li>价格</li></ul></li><li>排序字段<ul><li>默认：按照更新时间降序排序</li><li>销量</li><li>价格</li></ul></li><li>展示字段<ul><li>商品id：用于点击后跳转</li><li>图片地址</li><li>是否是广告推广商品</li><li>名称</li><li>价格</li><li>评价数量</li><li>销量</li></ul></li></ul><p>结合数据库表结构，以上字段对应的mapping映射属性如下：</p><table><thead><tr><th>字段名</th><th>字段类型</th><th>类型说明</th><th>是否参与搜索</th><th>是否参与分词</th><th>分词器</th></tr></thead><tbody><tr><td>id</td><td><code>long</code></td><td>长整数</td><td>是</td><td>否</td><td>——</td></tr><tr><td>name</td><td><code>text</code></td><td>字符串，参与分词搜索</td><td>是</td><td>是</td><td>IK</td></tr><tr><td>price</td><td><code>integer</code></td><td>以分为单位，所以是整数</td><td>是</td><td>否</td><td>——</td></tr><tr><td>stock</td><td><code>integer</code></td><td>字符串，但需要分词</td><td>是</td><td>否</td><td>——</td></tr><tr><td>image</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>否</td><td>否</td><td>——</td></tr><tr><td>category</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>是</td><td>否</td><td>——</td></tr><tr><td>brand</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>是</td><td>否</td><td>——</td></tr><tr><td>sold</td><td><code>integer</code></td><td>销量，整数</td><td>是</td><td>否</td><td>——</td></tr><tr><td>commentCount</td><td><code>integer</code></td><td>评价，整数</td><td>否</td><td>否</td><td>——</td></tr><tr><td>isAD</td><td><code>boolean</code></td><td>布尔类型</td><td>是</td><td>否</td><td>——</td></tr><tr><td>updateTime</td><td><code>Date</code></td><td>更新时间</td><td>是</td><td>否</td><td>——</td></tr></tbody></table><p>最终索引库文档结构应该是这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /items</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sold&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;commentCount&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isAD&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;boolean&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>分为三步：</p><p>1）创建Request对象。因为是创建索引库的操作，因此Request是<code>CreateIndexRequest</code></p><p>2）添加请求参数。Json格式的Mapping映射参数</p><p>3）发送请求。<code>client.indices()</code>方法的返回值是<code>IndicesClient</code>类型，封装了所有与索引库操作有关的方法。例如创建索引、删除索引、判断索引是否存在等</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPING_TEMPLATE</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;stock\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;image\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;category\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;sold\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;commentCount\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;isAD\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;boolean\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;updateTime\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;date\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h2><p>与创建索引库相比：</p><ul><li>请求方式从PUT变为DELTE</li><li>请求路径不变</li><li>无请求参数</li></ul><p>所以代码的差异，注意体现在Request对象上。流程如下：</p><p>1）创建Request对象。DeleteIndexRequest对象</p><p>2）准备参数。省略</p><p>3）发送请求。delete方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断索引库是否存在"><a href="#判断索引库是否存在" class="headerlink" title="判断索引库是否存在"></a>判断索引库是否存在</h2><p>判断索引库是否存在，本质就是查询，对应的请求语句是：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel</span><br></pre></td></tr></table></figure><p>因此与删除的Java代码流程是类似的，流程如下：</p><p>1）创建Request对象。GetIndexRequest对象</p><p>2）准备参数。省略</p><p>3）发送请求。exists方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistsIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    System.err.println(exists ? <span class="string">&quot;索引库已经存在！&quot;</span> : <span class="string">&quot;索引库不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaRestClient操作elasticsearch的流程基本类似。核心是<code>client.indices()</code>方法来获取索引库的操作对象。</p><p>索引库操作的基本步骤：</p><ul><li>初始化<code>RestHighLevelClient</code></li><li>创建XxxIndexRequest。XXX是<code>Create</code>、<code>Get</code>、<code>Delete</code></li><li>准备请求参数（<code>Create</code>时需要，其它是无参，可以省略）</li><li>发送请求。调用<code>RestHighLevelClient#indices().xxx()</code>方法，xxx是<code>create</code>、<code>exists</code>、<code>delete</code></li></ul><h1 id="RestClient操作文档"><a href="#RestClient操作文档" class="headerlink" title="RestClient操作文档"></a>RestClient操作文档</h1><h2 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h2><p>新增文档的请求语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>1）创建Request对象，这里是<code>IndexRequest</code>，因为添加文档就是创建倒排索引的过程</p><p>2）准备请求参数，本例中就是Json文档</p><p>3）发送请求</p><p>这里直接使用<code>client.xxx()</code>的API</p><p>整体步骤为：</p><ul><li>1）根据id查询商品数据<code>Item</code></li><li>2）将<code>Item</code>封装为<code>ItemDoc</code></li><li>3）将<code>ItemDoc</code>序列化为JSON</li><li>4）创建IndexRequest，指定索引库名和id</li><li>5）准备请求参数，也就是JSON文档</li><li>6）发送请求</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.根据id查询商品数据</span></span><br><span class="line">    <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getById(<span class="number">100002644680L</span>);</span><br><span class="line">    <span class="comment">// 2.转换为文档类型</span></span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class);</span><br><span class="line">    <span class="comment">// 3.将ItemDTO转json</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">doc</span> <span class="operator">=</span> JSONUtil.toJsonStr(itemDoc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(itemDoc.getId());</span><br><span class="line">    <span class="comment">// 2.准备Json文档</span></span><br><span class="line">    request.source(doc, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h2><p>查询的请求语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_doc/id</span><br></pre></td></tr></table></figure><ul><li>创建Request对象</li><li>发送请求</li></ul><p>流程如下：</p><p>1）准备Request对象。这次是查询，所以是<code>GetRequest</code></p><p>2）发送请求，得到结果。因为是查询，这里调用<code>client.get()</code>方法</p><p>3）解析结果，对JSON做反序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.获取响应结果中的source</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.getSourceAsString();</span><br><span class="line">    </span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> JSONUtil.toBean(json, ItemDoc.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;itemDoc= &quot;</span> + ItemDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h2><p>删除的请求语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /hotel/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与查询相比，仅仅是请求方式从<code>DELETE</code>变成<code>GET</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request，两个参数，第一个是索引库名，第二个是文档id</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;item&quot;</span>, <span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h2><p>有两种方式：</p><ul><li>全量修改：本质是先根据id删除，再新增</li><li>局部修改：修改文档中的指定字段值</li></ul><p>在RestClient的API中，全量修改与新增的API完全一致。</p><p>局部修改的请求语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_update/id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;字段值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;字段值&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>1）准备<code>Request</code>对象。这次是修改，所以是<code>UpdateRequest</code></p><p>2）准备参数。也就是JSON文档，里面包含要修改的字段</p><p>3）更新文档。这里调用<code>client.update()</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;items&quot;</span>, <span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">            <span class="string">&quot;price&quot;</span>, <span class="number">58800</span>,</span><br><span class="line">            <span class="string">&quot;commentCount&quot;</span>, <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批量导入文档"><a href="#批量导入文档" class="headerlink" title="批量导入文档"></a>批量导入文档</h2><p>如果要将大量数据导入索引库，肯定不能逐条导入，而是采用批处理方案。常见的方案有：</p><ul><li>利用Logstash批量导入<ul><li>需要安装Logstash</li><li>对数据的再加工能力较弱</li><li>无需编码</li></ul></li><li>利用JavaAPI批量导入<ul><li>需要编码，但基于JavaAPI，学习成本低</li><li>更加灵活，可以任意对数据做再加工处理后写入索引库</li></ul></li></ul><p>在这里使用JavaAPI导入。</p><h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><p>批处理与前面讲的文档的CRUD步骤基本一致：</p><ul><li>创建Request，这次用的是<code>BulkRequest</code></li><li>准备请求参数</li><li>发送请求，用到<code>client.bulk()</code>方法</li></ul><p><code>BulkRequest</code>本身其实并没有请求参数，其本质就是将多个普通的CRUD请求组合在一起发送。例如：</p><ul><li>批量新增文档，就是给每个文档创建一个<code>IndexRequest</code>请求，然后封装到<code>BulkRequest</code>中，一起发出。</li><li>批量删除，就是创建N个<code>DeleteRequest</code>请求，然后封装到<code>BulkRequest</code>，一起发出</li></ul><p>因此<code>BulkRequest</code>中提供了<code>add</code>方法，用以添加其它CRUD的请求：</p><p><img src="D:\Blog\source\img\es_bulk.png" alt="es_bulk"></p><p>能添加的请求有：</p><ul><li><code>IndexRequest</code></li><li><code>UpdateRequest</code></li><li><code>DeleteRequest</code></li></ul><p>因此Bulk中添加了多个<code>IndexRequest</code>，就是批量新增功能了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulk</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;1&quot;</span>).source(<span class="string">&quot;json doc1&quot;</span>, XContentType.JSON));</span><br><span class="line">    request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;2&quot;</span>).source(<span class="string">&quot;json doc2&quot;</span>, XContentType.JSON));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>文档操作的基本步骤：</p><ul><li>初始化<code>RestHighLevelClient</code></li><li>创建XxxRequest。<ul><li>XXX是<code>Index</code>、<code>Get</code>、<code>Update</code>、<code>Delete</code>、<code>Bulk</code></li></ul></li><li>准备参数（<code>Index</code>、<code>Update</code>、<code>Bulk</code>时需要）</li><li>发送请求。<ul><li>调用<code>RestHighLevelClient#.xxx()</code>方法，xxx是<code>index</code>、<code>get</code>、<code>update</code>、<code>delete</code>、<code>bulk</code></li></ul></li><li>解析结果（<code>Get</code>时需要）</li></ul>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务入门(一)</title>
      <link href="/inori/37b2c0e7.html"/>
      <url>/inori/37b2c0e7.html</url>
      
        <content type="html"><![CDATA[<h1 id="微服务基础知识"><a href="#微服务基础知识" class="headerlink" title="微服务基础知识"></a>微服务基础知识</h1><h2 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h2><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>单体架构（monolithic structure）即整个项目中所有功能模块都在一个工程中开发。项目部署时需要对所有模块一起编译、打包。项目的架构设计、开发模式都相对简单。</p><p>当项目规模较小时，这种模式上手快，部署、运维也都很方便，因此早期很多小型项目都采用这种模式。</p><p>但随着项目的业务规模越来越大，团队开发人员也不断增加，单体架构就呈现出越来越多的问题：</p><ul><li><strong>团队协作成本高</strong>：团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊。</li><li><strong>系统发布效率低</strong>：任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时。</li><li><strong>系统可用性差</strong>：单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用。</li></ul><p>要想解决这些问题，就需要使用微服务架构。</p><h3 id="从单体架构到微服务"><a href="#从单体架构到微服务" class="headerlink" title="从单体架构到微服务"></a>从单体架构到微服务</h3><p>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。同时要满足下面的一些特点：</p><ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模较小</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li></ul><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud框架是目前Java领域最全面的微服务组件的集合。它依托于SpringBoot的自动装配能力，降低了其项目搭建、组件使用的成本。</p><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>不同的微服务虽然功能不同，但因为还是同一个项目，或多或少会出现互相调用的情况。但不同的微服务都是不同的项目，不能使用Spring的自动装配，这时就需要服务之间发送Http请求去获取数据。</p><h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><p>Spring提供了一个RestTemplate的API，可以方便的实现Http请求的发送。其中提供了大量的方法，方便发送Http请求</p><p><img src="D:\Blog\source\img\resttemplate.png" alt="resttemplate"></p><p>常见的Get、Post、Put、Delete请求都支持，如果请求参数比较复杂，还可以使用exchange方法来构造请求。</p><h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>先将RestTemplate注册为一个Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用RestTemplate发送请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取商品id</span></span><br><span class="line">    Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">// 2.查询商品</span></span><br><span class="line">    <span class="comment">// 利用RestTemplate发起http请求，得到http的响应</span></span><br><span class="line">    ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">            <span class="string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>,<span class="comment">// 请求路径</span></span><br><span class="line">            HttpMethod.GET,<span class="comment">// 请求方式</span></span><br><span class="line">            <span class="literal">null</span>, <span class="comment">// 请求实体</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;,<span class="comment">// 返回值类型</span></span><br><span class="line">            Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))<span class="comment">// 请求参数</span></span><br><span class="line">    );</span><br><span class="line">    List&lt;ItemDTO&gt; items = response.getBody();<span class="comment">// 获取返回值</span></span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，利用RestTemplate发送http请求与前端ajax发送请求非常相似，都包含四部分信息：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>在这个过程中，<code>item-service</code>提供了查询接口，<code>cart-service</code>利用Http请求调用该接口。因此<code>item-service</code>可以称为服务的提供者，而<code>cart-service</code>则称为服务的消费者或服务调用者。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>服务拆分之后，不可避免的会出现跨微服务的业务，此时微服务之间就需要进行远程调用。微服务之间的远程调用被称为RPC，即远程过程调用。RPC的实现方式有很多，比如：</p><ul><li>基于Http协议</li><li>基于Dubbo协议</li></ul><p>这里使用的是Http方式，这种方式不关心服务提供者的具体技术实现，只要对外暴露Http接口即可。</p><p>Java发送http请求可以使用Spring提供的RestTemplate，使用的基本步骤如下：</p><ul><li>注册RestTemplate到Spring容器</li><li>调用RestTemplate的API发送请求，常见方法有：<ul><li>getForObject：发送Get请求并返回指定类型对象</li><li>PostForObject：发送Post请求并返回指定类型对象</li><li>put：发送PUT请求</li><li>delete：发送Delete请求</li><li>exchange：发送任意类型请求，返回ResponseEntity</li></ul></li></ul><h2 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h2><p>上面通过Http请求实现了跨微服务的远程调用，不过这种手动发送Http请求的方式存在一些问题。</p><p>试想一下，假如商品微服务被调用较多，为了应对更高的并发，进行了多实例部署，一个微服务对应多个ip地址或端口</p><p>此时，每个service的实例其IP或端口不同，问题来了：</p><ul><li>service这么多实例，其他服务如何知道每一个实例的地址？</li><li>http请求要写url地址，其他服务到底该调用哪个实例？</li><li>如果在运行过程中，该服务实例宕机，其他服务依然在调用该怎么办？</li><li>如果并发太高，该服务临时多部署了N台实例，其他服务如何知道新实例的地址？</li></ul><p>为了解决上述问题，就必须引入注册中心的概念。</p><p>为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。</p><h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><p>在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问</li><li>服务消费者：调用其它微服务提供的接口</li></ul><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><p><img src="D:\Blog\source\img\log_center.jpg" alt="log_center"></p><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h3 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h3><p>目前开源的注册中心框架有很多，比较常见的有：</p><ul><li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</li><li>Consul：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</li></ul><p>以上几种注册中心都遵循SpringCloud中的API规范，因此在业务开发使用上没有太大差异，这里学习<a href="https://nacos.io/">Nacos</a></p><h4 id="安装nacos"><a href="#安装nacos" class="headerlink" title="安装nacos"></a>安装nacos</h4><p>首先要准备MySQL数据库表，用来存储Nacos的数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导出 nacos 的数据库结构</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `nacos`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `nacos` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */</span> <span class="comment">/*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */</span>;</span><br><span class="line">USE `nacos`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_aggr 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_aggr`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_aggr 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_aggr`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_beta 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_beta`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_beta 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_beta`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_tag 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_tag`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_tag 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_tag`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_tags_relation 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_tags_relation`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_tags_relation 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_tags_relation`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.group_capacity 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `group_capacity`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.group_capacity 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `group_capacity`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.his_config_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `his_config_info`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.his_config_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `his_config_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.permissions 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `permissions`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `permissions` (</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.permissions 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `permissions`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.roles 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `roles`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `roles` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_user_role` (`username`,`role`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.roles 的数据：~1 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `roles`;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `roles` (`username`, `role`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.tenant_capacity 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tenant_capacity`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.tenant_capacity 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `tenant_capacity`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.tenant_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tenant_info`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.tenant_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `tenant_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.users 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `users`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `enabled` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.users 的数据：~1 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `users`;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `users` (`username`, `password`, `enabled`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>然后需要配置环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PREFER_HOST_MODE=hostname</span><br><span class="line">MODE=standalone</span><br><span class="line">SPRING_DATASOURCE_PLATFORM=mysql</span><br><span class="line">MYSQL_SERVICE_HOST=192.168.145.128# 改成自己的IP地址</span><br><span class="line">MYSQL_SERVICE_DB_NAME=nacos</span><br><span class="line">MYSQL_SERVICE_PORT=3306</span><br><span class="line">MYSQL_SERVICE_USER=root</span><br><span class="line">MYSQL_SERVICE_PASSWORD=123</span><br><span class="line">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><p>进入root目录，执行docker命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line"><span class="literal">--name</span> nacos \</span><br><span class="line"><span class="literal">--env-file</span> ./nacos/custom.env \</span><br><span class="line"><span class="literal">-p</span> <span class="number">8848</span>:<span class="number">8848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9848</span>:<span class="number">9848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9849</span>:<span class="number">9849</span> \</span><br><span class="line"><span class="literal">--restart</span>=always \</span><br><span class="line">nacos/nacos<span class="literal">-server</span>:v2.<span class="number">1.0</span><span class="literal">-slim</span></span><br></pre></td></tr></table></figure><p>启动完成后，访问下面地址：<code>http://ip地址/nacos/</code></p><p>首次访问会跳转到登录页，账号密码都是nacos</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>接下来，把service注册到Nacos</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在<code>pom.xml</code>中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置Nacos"><a href="#配置Nacos" class="headerlink" title="配置Nacos"></a>配置Nacos</h4><p>在<code>application.yml</code>中添加nacos地址配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><p>启动服务实例后访问nacos控制台，可以发现服务注册成功</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。</p><p>在<code>pom.xml</code>中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现，这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</p><h4 id="配置Nacos地址"><a href="#配置Nacos地址" class="headerlink" title="配置Nacos地址"></a>配置Nacos地址</h4><p>在<code>application.yml</code>中添加nacos地址配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><p>####发现并调用服务</p><p>接下来，服务调用者就可以去订阅已经在Nacos注册过的服务了。不过因为服务可能有多个实例，而真正发起调用时只需要知道一个实例的地址。</p><p>因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：</p><ul><li>随机</li><li>轮询</li><li>IPHash</li><li>最近最少访问</li><li>…</li></ul><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>Eureka是Netflix公司开源的一个服务注册中心组件，早期版本的SpringCloud都是使用Eureka作为注册中心。由于Eureka和Nacos的starter中提供的功能都是基于SpringCloudCommon规范，因此两者使用起来差别不大。</p><h4 id="Eureka和Nacos对比"><a href="#Eureka和Nacos对比" class="headerlink" title="Eureka和Nacos对比"></a>Eureka和Nacos对比</h4><p>Eureka和Nacos都能起到注册中心的作用，用法基本类似。但还是有一些区别的，例如：</p><ul><li>Nacos支持配置管理，而Eureka则不支持</li></ul><p>服务注册发现上也有区别，在Eureka中，健康检测的原理如下：</p><ul><li>微服务启动时注册信息到Eureka，这点与Nacos一致</li><li>微服务每隔30秒向Eureka发送心跳请求，报告自己的健康状态。Nacos中默认是5秒一次</li><li>Eureka如果90秒未收到心跳，则认为服务疑似故障，可能被剔除。Nacos中则是15秒超时，30秒剔除</li><li>Eureka如果发现超过85%比例的服务都心跳异常，会认为是自己的网络异常，暂停剔除服务的功能</li><li>Eureka每隔60秒执行一次服务检测和清理任务；Nacos是每隔5秒执行一次</li></ul><p>综上，你会发现Eureka是尽量不剔除服务，这就导致当服务真的出现故障时，迟迟不会被剔除，给服务的调用者带来困扰</p><p>不仅如此，当Eureka发现服务宕机并从服务列表中剔除以后，并不会将服务列表的变更消息推送给所有微服务。而是等待微服务自己来拉取时发现服务列表的变化。而微服务每隔30秒才会去Eureka更新一次服务列表，进一步推迟了服务宕机时被发现的时间。</p><p>而Nacos中微服务除了自己定时去Nacos中拉取服务列表以外，Nacos还会在服务列表变更时主动推送最新的服务列表给所有的订阅者</p><p>综上，Eureka和Nacos的相似点有：</p><ul><li>都支持服务注册发现功能</li><li>都有基于心跳的健康监测功能</li><li>都支持集群，集群间数据同步默认是AP模式，即最全高可用性</li></ul><p>Eureka和Nacos的区别有：</p><ul><li>Eureka的心跳是30秒一次，Nacos则是5秒一次</li><li>Eureka如果90秒未收到心跳，则认为服务疑似故障，可能被剔除。Nacos中则是15秒超时，30秒剔除。</li><li>Eureka每隔60秒执行一次服务检测和清理任务；Nacos是每隔5秒执行一次。</li><li>Eureka只能等微服务自己每隔30秒更新一次服务列表；Nacos即有定时更新，也有在服务变更时的广播推送</li><li>Eureka仅有注册中心功能，而Nacos同时支持注册中心、配置管理</li><li>Eureka和Nacos都支持集群，而且默认都是AP模式</li></ul><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><p>上面利用Nacos实现了服务的治理，利用RestTemplate实现了服务的远程调用。但是远程调用的代码太复杂了。</p><p>而且这种调用方式，与原本的本地方法调用差异太大，编程时的体验也不统一，一会儿远程调用，一会儿本地调用。</p><p>因此，必须想办法改变远程调用的开发模式，让<strong>远程调用像本地方法调用一样简单</strong>。而这就要用到OpenFeign组件了。</p><p>其实远程调用的关键点就在于四个：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>所以，OpenFeign就利用SpringMVC的相关注解来声明上述4个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在服务调用者的<code>pom.xml</code>中引入<code>OpenFeign</code>的依赖和<code>loadBalancer</code>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="启用OpenFeign"><a href="#启用OpenFeign" class="headerlink" title="启用OpenFeign"></a>启用OpenFeign</h4><p>在启动类上添加注解，启动OpenFeign功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span><span class="comment">// 启动OpenFeign</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;...&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        SpringApplication.run(CartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写OpenFeign客户端"><a href="#编写OpenFeign客户端" class="headerlink" title="编写OpenFeign客户端"></a>编写OpenFeign客户端</h4><p>定义一个新的接口，编写Feign客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要声明接口，无需实现方法。接口中的几个关键信息：</p><ul><li><code>@FeignClient(&quot;&quot;)</code> ：声明服务名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping(&quot;&quot;)</code> ：声明请求路径</li><li><code>@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul><p>有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向<code>http://item-service/items</code>发送一个<code>GET</code>请求，携带ids为请求参数，并自动将返回值处理为<code>List&lt;ItemDTO&gt;</code>。</p><p>我们只需要直接调用这个方法，即可实现远程调用了。</p><h4 id="使用FeignClient"><a href="#使用FeignClient" class="headerlink" title="使用FeignClient"></a>使用FeignClient</h4><p>最后在服务调用者的调用<code>ItemClient</code>的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;CartMapper, Cart&gt; <span class="keyword">implements</span> <span class="title class_">ICartService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ItemClient itemClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取商品id</span></span><br><span class="line">        Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());</span><br><span class="line">        <span class="comment">// 2.查询商品: 使用feign远程调用</span></span><br><span class="line">        List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>feign完成了服务拉取、负载均衡、发送http请求的所有工作，不再需要RestTemplate了，还省去了RestTemplate的注册</p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</p><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，使用OKHttp</p><h4 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开启连接池"><a href="#开启连接池" class="headerlink" title="开启连接池"></a>开启连接池</h4><p>在<code>application.yml</code>中开启Feign的连接池功能：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure><p>重启服务，连接池就生效了。</p><h3 id="负载均衡原理"><a href="#负载均衡原理" class="headerlink" title="负载均衡原理"></a>负载均衡原理</h3><p>在SpringCloud的早期版本中，负载均衡都是有Netflix公司开源的Ribbon组件来实现的，甚至Ribbon被直接集成到了Eureka-client和Nacos-Discovery中。</p><p>但是自SpringCloud2020版本开始，已经弃用Ribbon，改用Spring自己开源的Spring Cloud LoadBalancer了，我们使用的OpenFeign的也已经与其整合。</p><p>Spring在整合OpenFeign的时候，实现了<code>org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient</code>类，其中定义了OpenFeign发起远程调用的核心流程。也就是四步：</p><ul><li>获取请求中的<code>serviceId</code></li><li>根据<code>serviceId</code>负载均衡，找出一个可用的服务实例</li><li>利用服务实例的<code>ip</code>和<code>port</code>信息重构url</li><li>向真正的url发起请求</li></ul><p>而具体的负载均衡则是不是由<code>OpenFeign</code>组件负责。而是分成了<strong>负载均衡的接口规范</strong>，以及<strong>负载均衡的具体实现</strong>两部分。</p><p>负载均衡的接口规范是定义在<code>Spring-Cloud-Common</code>模块中，包含下面的接口：</p><ul><li><code>LoadBalancerClient</code>：负载均衡客户端，职责是根据serviceId最终负载均衡，选出一个服务实例</li><li><code>ReactiveLoadBalancer</code>：负载均衡器，负责具体的负载均衡算法</li></ul><p>OpenFeign的负载均衡是基于<code>Spring-Cloud-Common</code>模块中的负载均衡规则接口，并没有写死具体实现。这就意味着以后还可以拓展其它各种负载均衡的实现。</p><p>不过目前<code>SpringCloud</code>中只有<code>Spring-Cloud-Loadbalancer</code>这一种实现。</p><p><code>Spring-Cloud-Loadbalancer</code>模块中，实现了<code>Spring-Cloud-Common</code>模块的相关接口，具体如下：</p><ul><li><code>BlockingLoadBalancerClient</code>：实现了<code>LoadBalancerClient</code>，会根据serviceId选出负载均衡器并调用其算法实现负载均衡。</li><li><code>RoundRobinLoadBalancer</code>：基于轮询算法实现了<code>ReactiveLoadBalancer</code></li><li><code>RandomLoadBalancer</code>：基于随机算法实现了<code>ReactiveLoadBalancer</code></li><li><code>NacosLoadBalancer</code>：基于集群优先+实例权重+随机的方式实现<code>ReactiveLoadBalancer</code></li></ul><p><img src="D:\Blog\source\img\OpenFeign.png" alt="OpenFeign"></p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>单体架构时只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，这就存在一些问题：</p><ul><li>每个微服务都需要编写登录校验、用户信息获取的功能吗？</li><li>当微服务之间调用时，该如何传递用户信息？</li></ul><p>这些问题都可以通过<strong>网关</strong>技术解决。</p><h2 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h2><p>网关就是网络的关口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的路由和转发以及数据安全的校验。微服务网关起到同样的作用。前端请求不能直接访问微服务，而是要请求网关：</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFiODMyMWU3MTdmZjczN2Y1MmZjYzg1ZTE1ZDc4YTdfNHhLNkZzcWZoaEN0T0JFNEhSYWNuRmRxR3pLTUJRYXdfVG9rZW46WFdmaWJuMUpKb0loM0x4V21SdGNneHVsbm9lXzE3MTU0OTI0MTc6MTcxNTQ5NjAxN19WNA" alt="img"></p><p>在SpringCloud当中，提供了两种网关实现方案：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li></ul><p>这里学习SpringCloudGateway</p><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：</p><ul><li>创建网关微服务</li><li>引入SpringCloudGateway、NacosDiscovery依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><h4 id="引入依赖-3"><a href="#引入依赖-3" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>创建微服务后，在<code>pom.xml</code>文件中引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><p>在<code>application.yaml</code>文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br></pre></td></tr></table></figure><h3 id="路由过滤"><a href="#路由过滤" class="headerlink" title="路由过滤"></a>路由过滤</h3><p>路由规则的定义语法如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><p>其中routes对应的类型为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="meta">@Valid</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RouteDefinition&gt; routes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>是一个集合，也就是说可以定义很多路由规则。集合中的<code>RouteDefinition</code>就是具体的路由规则定义，其中常见的属性如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteDefinition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@NotEmpty</span> <span class="meta">@Valid</span> List&lt;PredicateDefinition&gt; predicates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Valid</span> List&lt;FilterDefinition&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@NotNull</span> URI uri;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>id</code>：路由的唯一标示</li><li><code>predicates</code>：路由断言，其实就是匹配条件</li><li><code>filters</code>：路由过滤条件，后面讲</li><li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li></ul><p>这里重点关注<code>predicates</code>，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">- Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method&#x3D;GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query&#x3D;name, Jack或者- Query&#x3D;name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td align="left">weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table><h2 id="网关登录校验"><a href="#网关登录校验" class="headerlink" title="网关登录校验"></a>网关登录校验</h2><p>单体架构时只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取。</p><h3 id="网关过滤器"><a href="#网关过滤器" class="headerlink" title="网关过滤器"></a>网关过滤器</h3><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理。</p><p><img src="D:\Blog\source\img\gateway_filter.png" alt="gateway_filter"></p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理。</li><li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）。</li><li><code>Filter</code>被分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</li><li>最终把响应结果返回。</li></ol><p>最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。如果能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<code>NettyRoutingFilter</code>之前，这就符合需求了</p><p>网关过滤器链中的过滤器有两种：</p><ul><li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code>.</li><li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由，不可配置</li></ul><p><code>FilteringWebHandler</code>在处理请求时，会将<code>GlobalFilter</code>装饰为<code>GatewayFilter</code>，然后放到同一个过滤器链中，排序以后依次执行。</p><p><code>Gateway</code>中内置了很多的<code>GatewayFilter</code>，详情可以参考<a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories">官方文档</a></p><p><code>Gateway</code>内置的<code>GatewayFilter</code>过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个<code>Route</code>下，就作用于哪个<code>Route</code></p><p>例如，有一个过滤器叫做<code>AddRequestHeaderGatewayFilterFacotry</code>，即添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。只需要在application.yaml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://test-service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="string">-Path=/test/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">AddRequestHeader=key,</span> <span class="string">value</span> <span class="comment"># 逗号之前是请求头的key，逗号之后是value</span></span><br></pre></td></tr></table></figure><p>如果想要让过滤器作用于所有的路由，则可以这样配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># default-filters下的过滤器可以作用于所有路由</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=key,</span> <span class="string">value</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://test-service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="string">-Path=/test/**</span></span><br></pre></td></tr></table></figure><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p><code>GatewayFilter</code>和<code>GlobalFilter</code>都支持自定义，只不过<strong>编码</strong>方式、<strong>使用</strong>方式略有差别</p><h4 id="自定义GatewayFilter"><a href="#自定义GatewayFilter" class="headerlink" title="自定义GatewayFilter"></a>自定义GatewayFilter</h4><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求</span></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;过滤器执行&quot;</span>);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：该类的名称一定要以<code>GatewayFilterFactory</code>为后缀</p><p>然后在yaml配置中这样使用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny</span> <span class="comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></span><br></pre></td></tr></table></figure><p>另外，这种过滤器还可以支持动态配置参数，不过实现起来比较复杂：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="comment">// 父类泛型是内部类的Config类型</span></span><br><span class="line">                <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;PrintAnyGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span></span><br><span class="line">        <span class="comment">// - GatewayFilter：过滤器</span></span><br><span class="line">        <span class="comment">// - int order值：值越小，过滤器执行优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取config值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> config.getA();</span><br><span class="line">                <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> config.getB();</span><br><span class="line">                <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> config.getC();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">                System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">                System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义配置属性，成员变量名称很重要，下面会用到</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 返回当前配置类的类型，也就是内部的Config</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;Config&gt; <span class="title function_">getConfigClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Config.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在yaml文件中使用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny=1,2,3</span> <span class="comment"># 注意，这里多个参数以&quot;,&quot;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span></span><br></pre></td></tr></table></figure><p>上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。</p><p>还有一种用法，无需按照这个顺序，就是手动指定参数名：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PrintAny</span></span><br><span class="line">              <span class="attr">args:</span> <span class="comment"># 手动指定参数名，无需按照参数顺序</span></span><br><span class="line">                <span class="attr">a:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">b:</span> <span class="number">2</span></span><br><span class="line">                <span class="attr">c:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="自定义GlobalFilter"><a href="#自定义GlobalFilter" class="headerlink" title="自定义GlobalFilter"></a>自定义GlobalFilter</h4><p>自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，无法设置动态参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;未登录，无法访问&quot;</span>);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="comment">// return chain.filter(exchange);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤器执行顺序，值越小，优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="微服务获取用户"><a href="#微服务获取用户" class="headerlink" title="微服务获取用户"></a>微服务获取用户</h2><p>当网关将请求转发到微服务时，微服务又该如何获取用户身份呢？</p><p>由于网关发送请求到微服务依然采用的是<code>Http</code>请求，因此可以将用户信息以请求头的方式传递到微服务。然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先，我们修改登录校验拦截器的处理逻辑，保存用户信息到请求头中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> userId.toString();</span><br><span class="line"><span class="type">ServerWebExchange</span> <span class="variable">ex</span> <span class="operator">=</span> exchange.mutate().request(b -&gt; b.header(<span class="string">&quot;user-info&quot;</span>, userInfo)).build();</span><br></pre></td></tr></table></figure><h4 id="拦截器获取用户"><a href="#拦截器获取用户" class="headerlink" title="拦截器获取用户"></a>拦截器获取用户</h4><p>定义拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(userInfo)) &#123;</span><br><span class="line">            <span class="comment">// 不为空，保存到ThreadLocal</span></span><br><span class="line">                UserContext.setUser(Long.valueOf(userInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置登录拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInfoInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OpenFeign传递用户"><a href="#OpenFeign传递用户" class="headerlink" title="OpenFeign传递用户"></a>OpenFeign传递用户</h2><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p><p>但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，购物车服务无法知道当前用户是谁</p><p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong>。</p><p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？</p><p>这里要借助Feign中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called for every request. </span></span><br><span class="line"><span class="comment">   * Add data using methods on the supplied &#123;<span class="doctag">@link</span> RequestTemplate&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要实现这个接口，然后实现apply方法，利用<code>RequestTemplate</code>类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoRequestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取登录用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">            <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果为空则直接跳过</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不为空则放入请求头中，传递给下游微服务</span></span><br><span class="line">            template.header(<span class="string">&quot;user-info&quot;</span>, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>现在依然还有几个问题需要解决：</p><ul><li>网关路由在配置文件中写死了，如果变更必须重启微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要重启服务</li><li>每个微服务都有很多重复的配置，维护成本高</li></ul><p>这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src="D:\Blog\source\img\gateway_set_control.jpg" alt="gateway_set_control"></p><p>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。</p><p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p><h3 id="共享配置"><a href="#共享配置" class="headerlink" title="共享配置"></a>共享配置</h3><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li>在Nacos中添加共享配置</li><li>微服务拉取配置</li></ul><h4 id="添加共享配置"><a href="#添加共享配置" class="headerlink" title="添加共享配置"></a>添加共享配置</h4><p>在nacos控制台分别添加这些配置。</p><p>首先是jdbc相关配置，在<code>配置管理</code>-&gt;<code>配置列表</code>中点击<code>+</code>新建一个配置：</p><p><img src="D:\Blog\source\img\nacos_add_set_1.png" alt="nacos_add_set_1"></p><p>在弹出的表单中填写信息：</p><p><img src="D:\Blog\source\img\nacos_add_set_2.png" alt="nacos_add_set_2"></p><p>jdbc的相关参数并没有写死，例如：</p><ul><li><code>数据库ip</code>：通过<code>$&#123;hm.db.host:192.168.145.128&#125;</code>配置了默认值为，同时允许通过<code>$&#123;hm.db.host&#125;</code>来覆盖默认值</li><li><code>数据库端口</code>：通过<code>$&#123;hm.db.port:3306&#125;</code>配置了默认值为<code>3306</code>，同时允许通过<code>$&#123;hm.db.port&#125;</code>来覆盖默认值</li><li><code>数据库database</code>：可以通过<code>$&#123;hm.db.database&#125;</code>来设定</li></ul><h4 id="拉取共享配置"><a href="#拉取共享配置" class="headerlink" title="拉取共享配置"></a>拉取共享配置</h4><p>接下来要在微服务拉取共享配置。将拉取到的共享配置与本地的<code>application.yaml</code>配置合并，完成项目上下文的初始化。</p><p>不过，需要注意的是，读取Nacos配置是SpringCloud上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取<code>application.yaml</code>。</p><p>也就是说引导阶段，<code>application.yaml</code>文件尚未读取，根本不知道nacos地址，该如何去加载nacos中的配置文件呢？</p><p>SpringCloud在初始化上下文的时候会先读取一个名为<code>bootstrap.yaml</code>(或者<code>bootstrap.properties</code>)的文件，如果我们将nacos地址配置到<code>bootstrap.yaml</code>中，那么在项目引导阶段就可以读取nacos中的配置了</p><p><img src="D:\Blog\source\img\bootstrap.jpg" alt="bootstrap"></p><p>因此，微服务整合Nacos配置管理的步骤如下：</p><p>1）引入依赖：</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）新建bootstrap.yaml</p><p>在的resources目录新建一个bootstrap.yaml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure><p>3）修改application.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp连接池支持</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">swagger:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">购物车服务接口文档</span></span><br><span class="line">    <span class="attr">package:</span> <span class="string">com.hmall.cart.controller</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">hm-cart</span></span><br></pre></td></tr></table></figure><p>重启服务，使配置生效</p><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><p>目前的项目修改了配置需要重新打包、重启服务才能生效。能不能不用重启，直接生效呢？</p><p>这就要用到Nacos的配置热更新能力了，分为两步：</p><ul><li>在Nacos中添加配置</li><li>在微服务读取配置</li></ul><h4 id="添加配置到Nacos"><a href="#添加配置到Nacos" class="headerlink" title="添加配置到Nacos"></a>添加配置到Nacos</h4><p>首先在nacos中添加一个配置文件，注意文件的dataId格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[服务名]-[spring.active.profile].[后缀名]</span><br></pre></td></tr></table></figure><p>文件名称由三部分组成：</p><ul><li><strong><code>服务名</code></strong></li><li>**<code>spring.active.profile</code>**：就是spring boot中的<code>spring.active.profile</code>，可以省略，则所有profile共享该配置</li><li><strong><code>后缀名</code></strong></li></ul><h4 id="配置热更新-1"><a href="#配置热更新-1" class="headerlink" title="配置热更新"></a>配置热更新</h4><p>接着，我们在微服务中读取配置，实现配置热更新。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;test.cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer maxAmount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>网关的路由配置全部是在项目启动时由<code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code>在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更</p><p>因此，我们必须监听Nacos的配置变更，然后手动把最新的路由更新到路由表中。这里有两个难点：</p><ul><li>如何监听Nacos配置变更？</li><li>如何把路由信息更新到路由表？</li></ul><h3 id="监听Nacos配置变更"><a href="#监听Nacos配置变更" class="headerlink" title="监听Nacos配置变更"></a>监听Nacos配置变更</h3><p>在Nacos官网中给出了<a href="https://nacos.io/zh-cn/docs/sdk.html">手动监听Nacos配置变更的SDK</a></p><p>如果希望Nacos推送配置变更，可以使用Nacos动态监听配置接口来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(String dataId, String group, Listener listener)</span></span><br></pre></td></tr></table></figure><p>请求参数说明：</p><table><thead><tr><th align="left"><strong>参数名</strong></th><th align="left"><strong>参数类型</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">dataId</td><td align="left">string</td><td align="left">配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（”.”、”:”、”-“、”_”）。不超过 256 字节</td></tr><tr><td align="left">group</td><td align="left">string</td><td align="left">配置分组，一般是默认的DEFAULT_GROUP</td></tr><tr><td align="left">listener</td><td align="left">Listener</td><td align="left">监听器，配置变更进入监听器的回调函数</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;&#123;serverAddr&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;&#123;dataId&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;&#123;group&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// 1.创建ConfigService，连接Nacos</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;serverAddr&quot;</span>, serverAddr);</span><br><span class="line"><span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> NacosFactory.createConfigService(properties);</span><br><span class="line"><span class="comment">// 2.读取配置</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> configService.getConfig(dataId, group, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 3.添加配置监听器</span></span><br><span class="line">configService.addListener(dataId, group, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置变更的通知处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;recieve1:&quot;</span> + configInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里核心的步骤有2步：</p><ul><li>创建ConfigService，目的是连接到Nacos</li><li>添加配置监听器，编写配置变更的通知处理逻辑</li></ul><p>这里采用了<code>spring-cloud-starter-alibaba-nacos-config</code>自动装配，因此<code>ConfigService</code>已经在<code>com.alibaba.cloud.nacos.NacosConfigAutoConfiguration</code>中自动创建好了</p><p>因此只要拿到<code>NacosConfigManager</code>就等于拿到了<code>ConfigService</code>，第一步就实现了。</p><p>第二步，编写监听器。虽然官方提供的SDK是ConfigService中的addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的API是这个：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getConfigAndSignListener</span><span class="params">(</span></span><br><span class="line"><span class="params">    String dataId, // 配置文件id</span></span><br><span class="line"><span class="params">    String group, // 配置组，走默认</span></span><br><span class="line"><span class="params">    <span class="type">long</span> timeoutMs, // 读取配置的超时时间</span></span><br><span class="line"><span class="params">    Listener listener // 监听器</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> NacosException;</span><br></pre></td></tr></table></figure><p>既可以配置监听器，并且会根据dataId和group读取配置并返回。我们就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新。</p><h3 id="更新路由"><a href="#更新路由" class="headerlink" title="更新路由"></a>更新路由</h3><p>更新路由要用到<code>org.springframework.cloud.gateway.route.RouteDefinitionWriter</code>接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RouteDefinitionWriter</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">save</span><span class="params">(Mono&lt;RouteDefinition&gt; route)</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据路由id删除某个路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">delete</span><span class="params">(Mono&lt;String&gt; routeId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新的路由，也就是RouteDefinition，包含下列常见字段：</p><ul><li>id：路由id</li><li>predicates：路由匹配规则</li><li>filters：路由过滤器</li><li>uri：路由目的地</li></ul><p>将来我们保存到Nacos的配置也要符合这个对象结构，将来我们以JSON来保存，格式如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以上JSON配置就等同于：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><h3 id="实现动态路由"><a href="#实现动态路由" class="headerlink" title="实现动态路由"></a>实现动态路由</h3><p>在网关gateway引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加载bootstrap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在网关<code>gateway</code>的<code>resources</code>目录创建<code>bootstrap.yaml</code>文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure><p>接着，修改<code>gateway</code>的<code>resources</code>目录下的<code>application.yml</code>，把之前的路由移除，最终内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">location:</span>  <span class="comment"># 秘钥地址</span></span><br><span class="line">    <span class="attr">alias:</span>  <span class="comment"># 秘钥别名</span></span><br><span class="line">    <span class="attr">password:</span>  <span class="comment"># 秘钥文件密码</span></span><br><span class="line">    <span class="attr">tokenTTL:</span> <span class="string">30m</span> <span class="comment"># 登录有效期</span></span><br><span class="line">  <span class="attr">auth:</span></span><br><span class="line">    <span class="attr">excludePaths:</span> <span class="comment"># 无需登录校验的路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/search/**</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/users/login</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/items/**</span></span><br></pre></td></tr></table></figure><p>然后，在<code>gateway</code>中定义配置监听器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRouteLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteDefinitionWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NacosConfigManager nacosConfigManager;</span><br><span class="line">    <span class="comment">// 路由配置文件的id和分组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;gateway-routes.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">    <span class="comment">// 保存更新过的路由id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; routeIds = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRouteConfigListener</span><span class="params">()</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 1.注册监听器并首次拉取配置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configInfo</span> <span class="operator">=</span> nacosConfigManager.getConfigService()</span><br><span class="line">                .getConfigAndSignListener(dataId, group, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">                        updateConfigInfo(configInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 2.首次启动时，更新一次配置</span></span><br><span class="line">        updateConfigInfo(configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;监听到路由配置变更，&#123;&#125;&quot;</span>, configInfo);</span><br><span class="line">        <span class="comment">// 1.反序列化</span></span><br><span class="line">        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);</span><br><span class="line">        <span class="comment">// 2.更新前先清空旧路由</span></span><br><span class="line">        <span class="comment">// 2.1.清除旧路由</span></span><br><span class="line">        <span class="keyword">for</span> (String routeId : routeIds) &#123;</span><br><span class="line">            writer.delete(Mono.just(routeId)).subscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        routeIds.clear();</span><br><span class="line">        <span class="comment">// 2.2.判断是否有新的路由要更新</span></span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(routeDefinitions)) &#123;</span><br><span class="line">            <span class="comment">// 无新路由配置，直接结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.更新路由</span></span><br><span class="line">        routeDefinitions.forEach(routeDefinition -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3.1.更新路由</span></span><br><span class="line">            writer.save(Mono.just(routeDefinition)).subscribe();</span><br><span class="line">            <span class="comment">// 3.2.记录路由id，方便将来删除</span></span><br><span class="line">            routeIds.add(routeDefinition.getId());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在Nacos控制台添加路由，即可实现动态配置路由。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ基础入门</title>
      <link href="/inori/1567c610.html"/>
      <url>/inori/1567c610.html</url>
      
        <content type="html"><![CDATA[<p>在微服务中，必然会涉及到服务之间的调用，基于OpenFeign的调用需要调用者发起请求后等待服务提供者执行业务返回结果后，才能执行后续的操作，即调用者在调用过程中处于阻塞状态，这种调用方式为<strong>同步调用</strong>。但在很多场景下，我们可能需要采用<strong>异步调用</strong>的方式，将与业务关系不大的微服务与主干业务剥离开，以提升整体效率。目前常见的实现方案就是基于MQ实现。</p><h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p>MQ即消息队列(MessageQueue)，目前比较常见的MQ有：</p><ul><li><p>ActiveMQ</p></li><li><p>RabbitMQ</p></li><li><p>RocketMQ</p></li><li><p>Kafka</p></li></ul><table><thead><tr><th></th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><p>综合考虑，<a href="https://www.rabbitmq.com/">RabbitMQ</a>更加均衡，这里对RabbitMQ进行学习。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用docker命令进行安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -e RABBITMQ_DEFAULT_USER=inori -e RABBITMQ_DEFAULT_PASS=123456 -v mq-plugins:/plugins --name mq --hostname mq -p 15672:15672 -p 5672:5672 --network test-net -d rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问<u>服务器地址:15672</u>即可看到管理控制台。在控制台中，可以进行创建和查看交换机、队列中的已有信息，发送消息等步骤，不过开发业务时，一般不会在控制台收发消息，而是基于编程的方式。</p><h3 id="RabbitMQ架构"><a href="#RabbitMQ架构" class="headerlink" title="RabbitMQ架构"></a>RabbitMQ架构</h3><p><img src="D:\Blog\source\img\rabbitmq_frame.png" alt="rabbitmq_frame"></p><ul><li>**<code>publisher</code>**：生产者，发送消息的一方</li><li>**<code>consumer</code>**：消费者，获取消息的一方</li><li>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列，没有存储功能</li><li>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue，不同的虚拟主机内的交换机和队列可以重名</li></ul><h2 id="WorkQueues模型"><a href="#WorkQueues模型" class="headerlink" title="WorkQueues模型"></a>WorkQueues模型</h2><p>WorkQueues模型就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong></p><p>适用场景：当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用此模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>WorkQueue默认的处理方式是消息平均分配给每个消费者，并没有考虑到消费者的处理能力，即没有充分利用每一个消费者的能力，这样显然是有问题的。</p><h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><p>在spring中进行配置，可以解决这个问题。添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>添加这个配置后，处理速度较快的消费者就可以处理更多的数据。</p><h2 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h2><p>在之前的测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：</p><p><img src="D:\Blog\source\img\add_exchange.png" alt="add_exchange"></p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p>交换机只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失</p><p>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><h3 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h3><p>可以理解为广播交换机。即当该交换机收到消息后，会转发给所有绑定到该交换机上的队列</p><p>1）可以有多个队列</p><p>2）每个队列都要绑定到Exchange</p><p>3）生产者发送的消息，只能发送到交换机</p><p>4）交换机把消息发送给绑定过的所有队列</p><p>5）订阅队列的消费者都能拿到消息</p><h3 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h3><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="D:\Blog\source\img\direct_exchange.png" alt="direct_exchange"></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code></li><li>消息的发送方在向Exchange发送消息时，也必须指定消息的<code>RoutingKey</code></li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的<code>Routing key</code>相同才会接收到消息</li></ul><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);<span class="comment">// 需要在参数中指定RoutingKey</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h3><p><code>Topic</code>类型与<code>Direct</code>类似，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。</p><p>只不过<code>Topic</code>类型可以让队列在绑定<code>BindingKey</code> 的时候使用通配符</p><p><code>BindingKey</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如：item.insert</p><p>通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.cpu.insert</code> 或者 <code>item.cpu</code></li><li><code>item.*</code>：只能匹配<code>item.cpu</code></li></ul><h2 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span> <span class="comment"># 虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/test</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><h3 id="简单消息的发送和接收"><a href="#简单消息的发送和接收" class="headerlink" title="简单消息的发送和接收"></a>简单消息的发送和接收</h3><p>消息发送：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用RabbitListener来声明要监听的队列信息，一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringAMQP声明队列和交换机"><a href="#SpringAMQP声明队列和交换机" class="headerlink" title="SpringAMQP声明队列和交换机"></a>SpringAMQP声明队列和交换机</h3><h4 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h4><p>SpringAMQP提供了一个Queue类，用来创建队列,还提供了一个Exchange接口，来表示所有不同类型的交换机，我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：</p><p><img src="D:\Blog\source\img\AMQPApi1.png" alt="AMQPApi1"></p><p>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：</p><p><img src="D:\Blog\source\img\AMQPApi2.png" alt="AMQPApi2"></p><h4 id="基于Bean声明Fanout示例"><a href="#基于Bean声明Fanout示例" class="headerlink" title="基于Bean声明Fanout示例"></a>基于Bean声明Fanout示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;test.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于注解声明"><a href="#基于注解声明" class="headerlink" title="基于注解声明"></a>基于注解声明</h4><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>例如声明Direct模式的交换机和队列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;test.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;test.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>Spring的消息发送代码接收的消息体是一个Object，而在数据传输时，它会把发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。而JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><h4 id="配置JSON转换器"><a href="#配置JSON转换器" class="headerlink" title="配置JSON转换器"></a>配置JSON转换器</h4><p>如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。如果没有则需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置消息转换器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转换器中添加的messageId可以便于将来做幂等性判断</p><h4 id="消费者接收Object"><a href="#消费者接收Object" class="headerlink" title="消费者接收Object"></a>消费者接收Object</h4><p>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Map&lt;String, Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到object.queue消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MQ消息的可靠性"><a href="#MQ消息的可靠性" class="headerlink" title="MQ消息的可靠性"></a>MQ消息的可靠性</h1><p>在大多数异步调用业务场景下，必须确保MQ消息的可靠性，即：消息应该至少被消费者处理1次</p><ul><li>我们该如何确保MQ消息的可靠性？</li><li>如果真的发送失败，有没有其它方案？</li></ul><h2 id="可靠性分析"><a href="#可靠性分析" class="headerlink" title="可靠性分析"></a>可靠性分析</h2><p>消息从发送者发送消息，到消费者处理消息，需要经过发送者发送消息到交换机，交换机转发消息到队列，队列发送到消费者，消费者消费数据。</p><p>其中每一步都可能导致消息丢失：</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：</p><ul><li>确保生产者一定把消息发送到MQ</li><li>确保MQ不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><h2 id="生产者的可靠性"><a href="#生产者的可靠性" class="headerlink" title="生产者的可靠性"></a>生产者的可靠性</h2><h3 id="生产者重试机制"><a href="#生产者重试机制" class="headerlink" title="生产者重试机制"></a>生产者重试机制</h3><p>SpringAMQP提供的消息发送时的重试机制。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。</p><p>修改<code>publisher</code>模块的<code>application.yaml</code>文件，添加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。</p><p>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h3 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h3><p>一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况。</p><p>不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：</p><ul><li>MQ内部处理消息的进程发生了异常</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code>，因此无法路由</li></ul><p>针对上述情况，RabbitMQ提供了生产者消息确认机制，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的<strong>回执</strong>。</p><p><img src="D:\Blog\source\img\mq_publisher_return.png" alt="mq_publisher_return"></p><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回Ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>其中<code>ack</code>和<code>nack</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于<strong>Publisher Return</strong>机制。</p><p>默认两种机制都是关闭状态，需要通过配置文件来开启。</p><h4 id="实现生产者确认"><a href="#实现生产者确认" class="headerlink" title="实现生产者确认"></a>实现生产者确认</h4><p>在publisher模块的<code>application.yaml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><p>一般我们推荐使用<code>correlated</code>，回调机制。</p><h4 id="定义ReturnCallback"><a href="#定义ReturnCallback" class="headerlink" title="定义ReturnCallback"></a>定义ReturnCallback</h4><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在publisher模块定义一个配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h4><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数：CorrelationData</p><p>这里的CorrelationData中包含两个核心的东西：</p><ul><li><code>id</code>：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的Future对象</li></ul><p>将来MQ的回执就会通过这个<code>Future</code>来返回，可以提前给<code>CorrelationData</code>中的<code>Future</code>添加回调函数来处理消息回执</p><p>新建一个测试，向系统自带的交换机发送消息，并且添加<code>ConfirmCallback</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">&quot;send message fail&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123; <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>开启生产者确认比较消耗MQ性能，一般不建议开启。而且大家思考一下触发确认的几种情况：</p><ul><li>路由失败：一般是因为RoutingKey错误导致，往往是编程导致</li><li>交换机名称错误：同样是编程错误导致</li><li>MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了。</li></ul><h2 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h2><p>消息到达MQ以后，如果MQ不能及时保存，也会导致消息丢失，所以MQ的可靠性也非常重要。</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化：在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数：设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</li><li>队列持久化：在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数</li><li>消息持久化：在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code></li></ul><p><strong>说明</strong>：在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。</p><p>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。</p><h3 id="LazyQueue"><a href="#LazyQueue" class="headerlink" title="LazyQueue"></a>LazyQueue</h3><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为称为<code>PageOut</code>。</p><p><code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从RabbitMQ的3.6版本开始，就增加了LazyQueues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。</p><h4 id="代码配置Lazy模式"><a href="#代码配置Lazy模式" class="headerlink" title="代码配置Lazy模式"></a>代码配置Lazy模式</h4><p>在利用SpringAMQP声明队列的时候，添加<code>x-queue-mod=lazy</code>参数可以设置队列为Lazy模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以基于注解来声明队列并设置为Lazy模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新已有队列为lazy模式"><a href="#更新已有队列为lazy模式" class="headerlink" title="更新已有队列为lazy模式"></a>更新已有队列为lazy模式</h4><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。</p><p>可以基于命令行设置policy：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues  </span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置：</p><p><img src="D:\Blog\source\img\lazyqueue_set_in_window.png" alt="lazyqueue_set_in_window"></p><h2 id="消费者的可靠性"><a href="#消费者的可靠性" class="headerlink" title="消费者的可靠性"></a>消费者的可靠性</h2><p>当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li></ul><p>一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。</p><h3 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h3><p>为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）即：当消费者处理消息结束后，向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>一般reject方式用的较少，除非是消息格式有问题。因此大多数情况下我们需要将消息处理的代码通过<code>try catch</code>机制捕获，消息处理成功时返回ack，处理失败时返回nack.</p><p>由于消息回执的处理代码比较统一，SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li>**<code>none</code>**：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。不建议使用</li><li>**<code>manual</code>**：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵（在当前业务中插入与当前业务无关的其他逻辑），但更灵活</li><li>**<code>auto</code>**：自动模式。SpringAMQP利用AOP对消息处理逻辑做了环绕增强，当业务正常执行时则自动返回<code>ack</code>.当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是<strong>业务异常</strong>，会自动返回<code>nack</code></li><li>如果是<strong>消息处理或校验异常</strong>，自动返回<code>reject</code></li></ul></li></ul><p>通过下面的配置可以修改SpringAMQP的ACK处理方式：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动模式</span></span><br></pre></td></tr></table></figure><h3 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h3><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。</p><p>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力，为了应对该情况，Spring提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列</p><p>修改consumer服务的application.yml文件，添加内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态，false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><ul><li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是<code>reject</code></li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃</li></ul><h3 id="失败处理策略"><a href="#失败处理策略" class="headerlink" title="失败处理策略"></a>失败处理策略</h3><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适</p><p>因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。默认就是这种方式 </li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较推荐的是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续集中处理</p><p>1）定义处理失败消息的交换机和队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）定义RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h3><p><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。</p><p>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。</p><p>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><h4 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h4><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。</p><p>以Jackson的消息转换器为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h4><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样，大体思路为在获取到MQ的消息后，先判断当前数据库中的数据的某些状态是否与要修改之前的数据的状态保持一致，若一致则修改。</p><p>相比较而言，消息ID的方案需要改造原有的数据库，所以更推荐使用业务判断的方案。</p><h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><p>在某些业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p><p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易</p><p>通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。</p><p>像这种在一段时间以后才执行的任务称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案是利用MQ的延迟消息。</p><p>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><h3 id="死信交换机和延迟消息"><a href="#死信交换机和延迟消息" class="headerlink" title="死信交换机和延迟消息"></a>死信交换机和延迟消息</h3><h4 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h4><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或<code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过**<code>dead-letter-exchange</code><strong>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为</strong>死信交换机**（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试的<code>RepublishMessageRecoverer</code>作用类似。</p><p>而最后一种场景，可以作为延迟消息的实现方式</p><h3 id="延迟消息-1"><a href="#延迟消息-1" class="headerlink" title="延迟消息"></a>延迟消息</h3><p>假设有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是<code>ttl.queue</code>没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>，而队列<code>direct.queue1</code>则与死信交换机绑定，RoutingKey是blue</p><p><img src="D:\Blog\source\img\mq_delayMessage.png" alt="mq_delayMessage"></p><ol><li>假如我们现在发送一条消息到<code>ttl.fanout</code>，RoutingKey为blue，并设置消息的有效期。尽管这里的<code>ttl.fanout</code>不需要RoutingKey，但是当消息变为死信并投递到死信交换机时，会沿用之前的RoutingKey，这样<code>hmall.direct</code>才能正确路由消息，消息肯定会被投递到<code>ttl.queue</code>之后，由于没有消费者，消息无人消费</li><li>5秒之后，消息的有效期到期，成为死信</li><li>死信被再次投递到死信交换机<code>hmall.direct</code>，并沿用之前的RoutingKey，也就是<code>blue</code></li><li>由于<code>direct.queue1</code>与<code>hmall.direct</code>绑定的key是blue，因此最终消息被成功路由到<code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code>绑定， 也就能成功消费消息了。但此时已经是5秒钟以后了</li></ol><p>也就是说，publisher发送了一条消息，但最终consumer在5秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><p><strong>注意：</strong></p><p>RabbitMQ的消息过期是基于追溯方式来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。</p><p>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此设置的TTL时间不一定准确。</p><h3 id="DelayExchange插件"><a href="#DelayExchange插件" class="headerlink" title="DelayExchange插件"></a>DelayExchange插件</h3><p>基于死信队列虽然可以实现延迟消息，但是太麻烦。因此RabbitMQ社区提供了一个<a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">延迟消息插件</a>来实现相同的效果。</p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">插件下载</a>后，因为mq是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p>插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，我们上传插件到该目录下。</p><p>接下来执行命令，安装插件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><h4 id="声明延迟交换机"><a href="#声明延迟交换机" class="headerlink" title="声明延迟交换机"></a>声明延迟交换机</h4><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于<code>@Bean</code>的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送延迟消息"><a href="#发送延迟消息" class="headerlink" title="发送延迟消息"></a>发送延迟消息</h4><p>必须通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。</p><p>因此不建议设置延迟时间过长的延迟消息</p>]]></content>
      
      
      <categories>
          
          <category> rabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（五）</title>
      <link href="/inori/4a863c41.html"/>
      <url>/inori/4a863c41.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java新特性介绍（9-17）"><a href="#Java新特性介绍（9-17）" class="headerlink" title="Java新特性介绍（9~17）"></a>Java新特性介绍（9~17）</h1><h2 id="Java-9新特性"><a href="#Java-9新特性" class="headerlink" title="Java 9新特性"></a>Java 9新特性</h2><p>Java9的主要特性有JShell、接口的private方法等。</p><h3 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h3><p>Java 9为提供一种交互式编程工具JShell，类似于Python的Shell，安装java并完成环境配置后，只需要输入<code>jshell</code>命令即可开启交互式编程</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\71947&gt;jshell</span><br><span class="line">|  欢迎使用 JShell -- 版本 17.0.9</span><br><span class="line">|  要大致了解该版本, 请键入: /help intro</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int a = 10</span></span><br><span class="line">a ==&gt; 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int b = 15</span></span><br><span class="line">b ==&gt; 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int c = a + b</span></span><br><span class="line">c ==&gt; 25</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">public int max(int a, int b)&#123;</span></span><br><span class="line">   ...&gt;     return a &gt;= b ? a : b;</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  已创建 方法 max(int,int)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int d = max(a, b)</span></span><br><span class="line">d ==&gt; 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">/vars</span></span><br><span class="line">|    int a = 10</span><br><span class="line">|    int b = 15</span><br><span class="line">|    int c = 25</span><br><span class="line">|    int d = 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">/exit</span></span><br><span class="line">|  再见</span><br></pre></td></tr></table></figure><p>更多口令可以通过输入<code>/help</code>了解</p><h3 id="在接口内定义private方法"><a href="#在接口内定义private方法" class="headerlink" title="在接口内定义private方法"></a>在接口内定义private方法</h3><p>在Jdk8中，接口中方法支持添加<code>default</code>关键字来默认实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java9中，接口中可以存在私有方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;默认实现&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.inner();   <span class="comment">//接口中方法的默认实现可以直接调用接口中的私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span>&#123;   <span class="comment">//声明一个私有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;私有方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有方法和默认方法一样，要提供方法体，并且此方法只能被接口中的其他私有方法或是默认实现调用</p><h3 id="集合类新增工厂方法"><a href="#集合类新增工厂方法" class="headerlink" title="集合类新增工厂方法"></a>集合类新增工厂方法</h3><p>如果我们想要快速创建一个Map：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;AAA&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&quot;BBB&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java 9之后，可以通过<code>of</code>方法快速创建：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;AAA&quot;</span>, <span class="number">1</span>, <span class="string">&quot;BBB&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>通过这种方式创建的Map和通过Arrays创建的List类似，无法进行修改。</u></p><p>除了Map之外，其他的集合类都有相应的<code>of</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = Set.of(<span class="string">&quot;A&quot;</span>， <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进的Stream"><a href="#改进的Stream" class="headerlink" title="改进的Stream"></a>改进的Stream</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)   <span class="comment">//将一些元素封装到Stream中</span></span><br><span class="line">        .filter(s -&gt; s.equals(<span class="string">&quot;B&quot;</span>))   <span class="comment">//通过过滤器过滤</span></span><br><span class="line">        .distinct()   <span class="comment">//去重</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stream在Java9得到了进一步的增强：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.of(<span class="literal">null</span>)   <span class="comment">//如果传入null会报错</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Stream.ofNullable(<span class="literal">null</span>) <span class="comment">//使用新增的ofNullable方法，不会报错</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过迭代快速生成一组数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, i -&gt; i &lt; <span class="number">20</span>, i -&gt; i + <span class="number">1</span>)  <span class="comment">//快速生成一组0~19的int数据，中间可以添加一个断言，表示什么时候结束生成</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stream还新增了对数据的截断操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .takeWhile(i -&gt; i &lt; <span class="number">10</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dropWhile和takeWhile相反，满足条件的才会通过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .dropWhile(i -&gt; i &lt; <span class="number">10</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-10新特性"><a href="#Java-10新特性" class="headerlink" title="Java 10新特性"></a>Java 10新特性</h2><p>Java 10的改变不是很多，比较突出的是局部变量类型推断</p><h3 id="局部变量类型推断var"><a href="#局部变量类型推断var" class="headerlink" title="局部变量类型推断var"></a>局部变量类型推断var</h3><p>在Java10中，可以使用自动类型推断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// String a = &quot;Hello World!&quot;;   //之前定义变量必须指定类型</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;   <span class="comment">//现在使用var关键字来自动进行类型推断，因为完全可以从后面的值来判断是什么类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>var</code>关键字必须位于有初始值设定的变量上,且仅适用于局部变量，没办法在其他地方使用</p><h2 id="Java-11新特性"><a href="#Java-11新特性" class="headerlink" title="Java 11新特性"></a>Java 11新特性</h2><p>Java 11中比较关键的是用于Lambda的形参局部变量语法。</p><h3 id="用于Lambda的形参局部变量语法"><a href="#用于Lambda的形参局部变量语法" class="headerlink" title="用于Lambda的形参局部变量语法"></a>用于Lambda的形参局部变量语法</h3><p>在Java 11中支持了在Lambda中使用<code>var</code>关键字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; consumer = (<span class="keyword">var</span> str) -&gt; &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对于String类的方法增强"><a href="#针对于String类的方法增强" class="headerlink" title="针对于String类的方法增强"></a>针对于String类的方法增强</h3><p>在Java 11为String新增一些更加方便的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;A\nB\nD&quot;</span>;</span><br><span class="line">    System.out.println(str.isBlank());    <span class="comment">//isBlank方法用于判断是否字符串为空或者是仅包含空格</span></span><br><span class="line">    str.lines()   <span class="comment">//根据字符串中的\n换行符进行切割，分为多个字符串，并转换为Stream进行操作</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以快速地进行空格去除操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot; A B C D &quot;</span>;</span><br><span class="line">    System.out.println(str.strip());   <span class="comment">//去除首尾空格</span></span><br><span class="line">    System.out.println(str.stripLeading());  <span class="comment">//去除首部空格</span></span><br><span class="line">    System.out.println(str.stripTrailing());   <span class="comment">//去除尾部空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-12-16-新特性"><a href="#Java-12-16-新特性" class="headerlink" title="Java 12~16 新特性"></a>Java 12~16 新特性</h2><p>Java12-16并非长期支持版本，很多特性都是实验性的功能。</p><h3 id="改进的switch语法"><a href="#改进的switch语法" class="headerlink" title="改进的switch语法"></a>改进的switch语法</h3><p>Java 12中引入改进的switch语法，之前的switch写法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">grade</span><span class="params">(<span class="type">int</span> score)</span>&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            res =  <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            res = <span class="string">&quot;良好&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            res = <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            res = <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用新特性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">grade</span><span class="params">(<span class="type">int</span> score)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (score) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>, <span class="number">9</span> -&gt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>, <span class="number">7</span> -&gt; <span class="string">&quot;良好&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种全新的switch语法称为<code>switch表达式</code>，具体语法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> ...</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>case后添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -&gt; 来返回如果匹配此case语句的结果</li><li>根据不同的分支，可以存在多个case</li></ul><p>那么如果我们并不是能够马上返回，而是需要做点什么其他的工作才能返回结果呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;   <span class="comment">//使用花括号来将整套逻辑括起来</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">yield</span>  <span class="string">&quot;不及格&quot;</span>;  <span class="comment">//注意处理完成后使用yield关键字返回最终结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>Java 13引入文本块，通过三引号将字符串括起来，在其中不需要使用转义字符</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                weriodfghhj</span></span><br><span class="line"><span class="string">                fgghjkkkkwjdjwid</span></span><br><span class="line"><span class="string">                &lt;h1&gt;</span></span><br><span class="line"><span class="string">                &lt;div class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">             &quot;&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新instanceof语法"><a href="#新instanceof语法" class="headerlink" title="新instanceof语法"></a>新instanceof语法</h3><p>我们之前要重写一个类的equals方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但instanceof加强之后，可以直接将student替换为模式变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student student) &#123;</span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-17新特性"><a href="#Java-17新特性" class="headerlink" title="Java 17新特性"></a>Java 17新特性</h2><h3 id="密封类型"><a href="#密封类型" class="headerlink" title="密封类型"></a>密封类型</h3><p>在Java中，可以通过继承（extends关键字）来实现类的能力复用、扩展与增强。但有的时候，可能并不是所有的类我们都希望能够被继承。所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是<strong>限制类的继承</strong>。</p><p>实际上在之前我们如果不希望别人继承我们的类，可以直接添加<code>final</code>关键字：<code>public final class A&#123;&#125;</code></p><p>这样有一个缺点，如果添加了<code>final</code>关键字，那么无论是谁，包括我们自己也是没办法实现继承的，但是现在我们有一个需求，只允许我们自己写的类继承A，但是不允许别人写的类继承A，就可以使用密封类型来实现这个功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">permits</span> B&#123;&#125;   <span class="comment">//在class关键字前添加sealed关键字，表示此类为密封类型，permits后面跟上允许继承的类型，多个子类使用逗号隔开</span></span><br></pre></td></tr></table></figure><p>密封类型有以下要求：</p><ul><li>可以基于普通类、抽象类、接口，也可以是继承自其他接抽象类的子类或是实现其他接口的类等。</li><li>必须有子类继承，且不能是匿名内部类或是lambda的形式。</li><li><code>sealed</code>写在原来<code>final</code>的位置，但是不能和<code>final</code>、<code>non-sealed</code>关键字同时出现，只能选择其一。</li><li>继承的子类必须显式标记为<code>final</code>、<code>sealed</code>或是<code>non-sealed</code>类型。</li></ul><p>标准的声明格式为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> [<span class="keyword">abstract</span>] [class/interface] 类名 [extends 父类] [implements 接口, ...] <span class="keyword">permits</span> [子类, ...]&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类格式为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> [<span class="keyword">final</span>/<span class="keyword">sealed</span>/<span class="keyword">non-sealed</span>] class 子类 extends 父类 &#123;   <span class="comment">//必须继承自父类</span></span><br><span class="line"><span class="comment">//final类型：任何类不能再继承当前类</span></span><br><span class="line">  <span class="comment">//sealed类型：同父类，需要指定由哪些类继承</span></span><br><span class="line">  <span class="comment">//non-sealed类型：解封，重新开放为普通类，任何类都可以继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过反射来获取类是否为密封类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;A&gt; a = A.class;</span><br><span class="line">    System.out.println(a.isSealed());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（四）</title>
      <link href="/inori/2518f906.html"/>
      <url>/inori/2518f906.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><p>Java8中经常使用的有Lambda表达式、Stream流、日期与时间API</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ol><li>无参数和返回值的Lambda</li></ol><p>需要启动一个线程去完成某些任务时，通常会通过Runnable接口来定义任务内容，使用Thread类启动线程。</p><p>传统写法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() (</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(<span class="string">&quot;新线程任务执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda是一个<strong>匿名函数</strong>，可以理解为一段可以传递的代码。使用Java8的写法，上述写法可以重写为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;新线程任务执行&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lambda表达式可以简化匿名内部类的使用，使语法更加简洁。</p><ol start="2"><li>有参数和返回值的Lambda</li></ol><p>当需要对一个对象集合进行排序时，传统写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Person&gt; persons;<span class="comment">// 假设里面已经有很多数据</span></span><br><span class="line">        Collections.sort(persons, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lambda后的写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Person&gt; persons;<span class="comment">// 假设里面已经有很多数据</span></span><br><span class="line">        Collections.sort(persons, (o1, o2) -&gt; &#123;o1.getAge() - o2.getAge()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h4><p>Lambda由3部分组成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123;</span><br><span class="line">代码体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h4><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li><p>小括号内参数的类型可以省略</p></li><li><p>如果小括号内<strong>有且仅有一个参数</strong>，则小括号可以省略</p></li><li><p>如果大括号内<strong>有且仅有一个语句</strong>，可以同时省略大括号、return关键字及语句分号</p></li></ol><h4 id="使用Lambda的前提"><a href="#使用Lambda的前提" class="headerlink" title="使用Lambda的前提"></a>使用Lambda的前提</h4><p>Lambda表达式不是随便使用的，使用时有几个条件要特别注意：</p><ol><li><p>方法的参数或局部变量类型必须为接口才能使用Lambda</p></li><li><p>接口中有且仅有一个抽象方法</p></li></ol><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong>。</p><p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p><h5 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="FunctionalInterface注解"></a>FunctionalInterface注解</h5><p>与<code>@Override</code>注解的作用类似，Java8中专门为函数式接口引入了一个新的注解：<code>@FunctionalInterface</code>。该注解可用于一个接口的定义上：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。不过，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><h5 id="常用的函数式接口"><a href="#常用的函数式接口" class="headerlink" title="常用的函数式接口"></a>常用的函数式接口</h5><p>Lambda表达式的前提是需要有函数式接口。而Lambda使用时不关心接口名，抽象方法名，只关心抽象方法的参数列表和返回值类型。因此为了让我们使用Lambda方便，JDK提供了大量常用的函数式接口。</p><ol><li>Supplier接口</li></ol><p>java.util.function.Supplier<T>接口，它意味着”供给”,对应的Lambda表达式需要“<strong>对外提供</strong>”一个符合泛型类型的对象数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Consumer接口</li></ol><p><strong>消费</strong>一个数据，其数据类型由泛型参数决定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Function接口</li></ol><p>java.util.function.Function&lt;T,R&gt;接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。有参数有返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Predicate接口</li></ol><p>java.util.function.Predicate<T> 接口用于做判断,返回boolean类型的值，有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>如果在Lambda中所指定的功能，已经有其他方法存在相同方案，则没有必要再写重复逻辑，可以直接“引用”过去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n: arr) &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printMax(Test::getMax);<span class="comment">// 方法引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(Consumer&lt;<span class="type">int</span>[]&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        consumer.accept(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法引用的格式"><a href="#方法引用的格式" class="headerlink" title="方法引用的格式"></a>方法引用的格式</h5><p><strong>符号表示</strong>：<code>::</code></p><p><strong>符号说明</strong>: 双冒号为方法引用运算符，而它所在的表达式被称为<strong>方法引用</strong></p><p><strong>应用场景</strong>: 如果Lambda所要实现的方案, 已经有其他方法存在相同方案，那么则可以使用方法引用</p><h5 id="常用引用方式"><a href="#常用引用方式" class="headerlink" title="常用引用方式"></a>常用引用方式</h5><p>方法引用在JDK8中使用方式相当灵活，有以下几种形式：</p><ol><li><p><code>instanceName::methodName</code> 对象::方法名</p></li><li><p><code>ClassName::staticMethodName</code> 类名::静态方法</p></li><li><p><code>ClassName::methodName</code> 类名::普通方法</p></li><li><p><code>ClassName::new</code> 类名::new 调用的构造器</p></li><li><p><code>TypeName[]::new String[]::new</code> 调用数组的构造器</p></li></ol><h5 id="常用格式解析"><a href="#常用格式解析" class="headerlink" title="常用格式解析"></a>常用格式解析</h5><ol><li>对象::方法名</li></ol><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法，则可以通过对象名引用成员方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    Supplier&lt;Long&gt; supp = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> now.getTime();</span><br><span class="line">&#125;;</span><br><span class="line">    System.out.println(supp.get());</span><br><span class="line">    </span><br><span class="line">    Supplier&lt;Long&gt; supp2 = now::getTime;</span><br><span class="line">    System.out.println(supp2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法引用的注意事项</p><ul><li><p>被引用的方法，参数要和接口中抽象方法的参数一样</p></li><li><p>当接口抽象方法有返回值时，被引用的方法也必须有返回值</p></li></ul><ol start="2"><li>类名::静态方法</li></ol><p>由于在<code>java.lang.System</code>类中已经存在了静态方法<code>currentTimeMillis</code>，要通过Lambda来调用该方法时,可以使用方法引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Supplier&lt;Long&gt; supp = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">&#125;;</span><br><span class="line">    System.out.println(supp.get());</span><br><span class="line">    </span><br><span class="line">    Supplier&lt;Long&gt; supp2 = System::currentTimeMillis;</span><br><span class="line">    System.out.println(supp2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>类名::普通方法</li></ol><p>由于构造器的名称与类名完全一样。所以构造器引用使用类名称::new的格式表示。</p><p>首先是一个Person类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用这个函数式接口，可以通过方法引用传递：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Supplier&lt;Person&gt; sup = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line">    </span><br><span class="line">    Supplier&lt;Person&gt; sup2 = Person::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">    </span><br><span class="line">    BiFunction&lt;String, Integer, Person&gt; fun2 = Person::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(fun2.apply(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>类名::new调用的构造器</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Function&lt;Integer, String[]&gt; fun = (len) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[len];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    String[] arr1 = fun.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(arr1 + <span class="string">&quot;, &quot;</span> + arr1.length);</span><br><span class="line">    </span><br><span class="line">    Function&lt;Integer, String[]&gt; fun2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    String[] arr2 = fun.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(arr2 + <span class="string">&quot;, &quot;</span> + arr2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>Stream流式思想类似于工厂车间的“<strong>生产流水线</strong>”，Stream流不是一种数据结构，不保存数据，而是对数据进行加工处理。Stream可以看作是流水线上的一个工序。在流水线上，通过多个工序让一个原材料加工成一个商品。</p><p>Stream API能让我们快速完成许多复杂的操作，如筛选、切片、映射、查找、去除重复，统计，匹配和归约。</p><h3 id="获取Stream流"><a href="#获取Stream流" class="headerlink" title="获取Stream流"></a>获取Stream流</h3><h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><p><code>java.util.Collection</code>接口中加入了default stream方法用来获取流，所以其所有实现类均可获取流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 集合获取流</span></span><br><span class="line">        <span class="comment">// Collection接口中的方法: default Stream&lt;E&gt; stream() 获取流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream3 = vector.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map不是 Collection的子接口，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Map获取流</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">        Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream中的静态方法of获取流"><a href="#Stream中的静态方法of获取流" class="headerlink" title="Stream中的静态方法of获取流"></a>Stream中的静态方法of获取流</h4><p>由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Stream中的静态方法: static Stream of(T... values)</span></span><br><span class="line">        Stream&lt;String&gt; stream6 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream7 = Stream.of(arr);</span><br><span class="line">        Integer[] arr2 = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream8 = Stream.of(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream常用方法"><a href="#Stream常用方法" class="headerlink" title="Stream常用方法"></a>Stream常用方法</h3><ul><li><p><strong>终结方法</strong>：返回值类型不再是 Stream 类型的方法，不再支持链式调用。</p></li><li><p><strong>非终结方法</strong>：返回值类型仍然是 Stream 类型的方法，支持链式调用。</p></li></ul><table><thead><tr><th><strong>方法名</strong></th><th><strong>方法作用</strong></th><th><strong>返回值类型</strong></th><th><strong>方法种类</strong></th></tr></thead><tbody><tr><td>count</td><td>统计个数</td><td>long</td><td>终结</td></tr><tr><td>forEach</td><td>逐一处理</td><td>void</td><td>终结</td></tr><tr><td>filter</td><td>过滤</td><td>Stream</td><td>函数拼接</td></tr><tr><td>limit</td><td>取用前几个</td><td>Stream</td><td>函数拼接</td></tr><tr><td>skip</td><td>跳过前几个</td><td>Stream</td><td>函数拼接</td></tr><tr><td>map</td><td>映射</td><td>Stream</td><td>函数拼接</td></tr><tr><td>concat</td><td>组合</td><td>Stream</td><td>函数拼接</td></tr></tbody></table><p>注意：</p><ol><li><p>Stream只能操作一次</p></li><li><p>Stream方法返回的是新的流</p></li><li><p>Stream不调用终结方法，中间的操作不会执行</p></li></ol><h4 id="count方法"><a href="#count方法" class="headerlink" title="count方法"></a>count方法</h4><p>count方法可以统计其中的元素个数，该方法返回一个long值代表元素个数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCount</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    System.out.println(one.stream().count());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h4><p>forEach用来遍历流中的数据，该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForEach</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Filter方法"><a href="#Filter方法" class="headerlink" title="Filter方法"></a>Filter方法</h4><p>filter用于过滤数据，返回符合过滤条件的数据，可以将一个流转换成另一个子集流。需要接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().filter(s -&gt; s.length() == <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="limit方法"><a href="#limit方法" class="headerlink" title="limit方法"></a>limit方法</h4><p>limit方法可以对流进行截取，只取用前n个。参数是一个long型，如果集合当前长度大于参数则进行截取。否则不进行操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLimit</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="skip方法"><a href="#skip方法" class="headerlink" title="skip方法"></a>skip方法</h4><p>如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流。如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSkip</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h4><p>map方法可以将流中的元素映射到另一个流中，该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;33&quot;</span>);</span><br><span class="line">    Stream&lt;Integer&gt; result = original.map(Integer::parseInt);</span><br><span class="line">    result.forEach(s -&gt; System.out.println(s + <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="distinct方法"><a href="#distinct方法" class="headerlink" title="distinct方法"></a>distinct方法</h4><p>distinct方法可以去除重复数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDistinct</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream.of(<span class="number">22</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">33</span>)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h4><p>如果需要判断数据是否匹配指定的条件，可以使用 Match 相关方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Stream.of(<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// .allMatch(e -&gt; e &gt; 0); // allMatch: 元素是否全部满足条件</span></span><br><span class="line">    <span class="comment">// .anyMatch(e -&gt; e &gt; 5); // anyMatch: 元素是否任意有一个满足条件</span></span><br><span class="line">    .noneMatch(e -&gt; e &lt; <span class="number">0</span>); <span class="comment">// noneMatch: 元素是否全部不满足条件</span></span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="concat方法"><a href="#concat方法" class="headerlink" title="concat方法"></a>concat方法</h4><p>有两个流需要合并成为一个流，可以使用 Stream 接口的静态方法 concat</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testContact</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">    result.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream流中的结果到集合中"><a href="#Stream流中的结果到集合中" class="headerlink" title="Stream流中的结果到集合中"></a>Stream流中的结果到集合中</h4><p>Stream流提供collect方法，其参数需要一个java.util.stream.Collector&lt;T, A, R&gt;接口对象来指定收集到哪种集合中。java.util.stream.Collectors类提供一些方法，可以作为Collector接口的实例：</p><p><code>public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</code>：转换为 List 集合。</p><p><code>public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</code>：转换为 Set 集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStreamToCollection</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    <span class="comment">// List&lt;String&gt; list = stream.collect(Collectors.toList());</span></span><br><span class="line">    <span class="comment">// Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span></span><br><span class="line">    ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">    HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream流中的结果到数组中"><a href="#Stream流中的结果到数组中" class="headerlink" title="Stream流中的结果到数组中"></a>Stream流中的结果到数组中</h4><p>Stream提供toArray方法来将结果放到一个数组中，返回值类型为Object[]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStreamToArray</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    String[] strings = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : strings) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对流中数据进行拼接"><a href="#对流中数据进行拼接" class="headerlink" title="对流中数据进行拼接"></a>对流中数据进行拼接</h4><p>Collectors.joining会根据指定的连接符，将所有元素连接成一个字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJoining</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;Student&gt; studentStream = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a&quot;</span>, <span class="number">52</span>, <span class="number">95</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;b&quot;</span>, <span class="number">56</span>, <span class="number">88</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;c&quot;</span>, <span class="number">56</span>, <span class="number">99</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d&quot;</span>, <span class="number">52</span>, <span class="number">77</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> studentStream</span><br><span class="line">        .map(Student::getName)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;&gt;_&lt;&quot;</span>, <span class="string">&quot;^_^&quot;</span>, <span class="string">&quot;^v^&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行的Stream流"><a href="#并行的Stream流" class="headerlink" title="并行的Stream流"></a>并行的Stream流</h3><p>parallelStream是一个并行执行的流。它通过默认的ForkJoinPool，可能提高多线程任务的速度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testgetParallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 直接获取并行的流</span></span><br><span class="line">    Stream&lt;Integer&gt; stream1 = list.parallelStream();</span><br><span class="line">    <span class="comment">// 将串行流转成并行流</span></span><br><span class="line">    Stream&lt;Integer&gt; stream2 = list.stream().parallel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行操作代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test0Parallel</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line">        .parallel() <span class="comment">// 将流转成并发流,Stream处理的时候将才去</span></span><br><span class="line">        .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;, s = &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">    .count();</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p>Optional是一个没有子类的工具类，是一个可以为null的容器对象。它的作用主要就是为了解决避免Null检查，防止NullPointerException。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>创建方式：</p><p><code>Optional.of(T t)</code>: 创建一个Optional实例</p><p><code>Optional.empty()</code>: 创建一个空的Optional实例</p><p><code>Optional.ofNullable(T t)</code>:若t不为null,创建Optional实例,否则创建空实例</p><p>常用方法：</p><p><code>isPresent()</code>: 判断是否包含值,包含值返回true，不包含值返回false</p><p><code>get()</code>: 如果Optional有值则将其返回，否则抛出NoSuchElementException</p><p><code>orElse(T t)</code>: 如果调用对象包含值，返回该值，否则返回参数t</p><p><code>orElseGet(Supplier s)</code>:如果调用对象包含值，返回该值，否则返回s获取的值</p><p><code>map(Function f)</code>: 如果有值对其处理，并返回处理后的Optional，否则返回Optional.empty()</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Optional&lt;String&gt; userName = Optional.empty();</span><br><span class="line">    <span class="keyword">if</span> (userNameO.isPresent()) &#123;</span><br><span class="line">        <span class="comment">// get() : 如果Optional有值则将其返回，否则抛出NoSuchElementException。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> userName.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名为:&quot;</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日期和时间API"><a href="#日期和时间API" class="headerlink" title="日期和时间API"></a>日期和时间API</h2><p>JDK 8中增加了一套全新的日期时间API，这套API设计合理，是线程安全的。新的日期及时间API位于<code>java.time</code>包中，下面是一些关键类。</p><p><code>LocalDate</code>：表示日期，包含年月日，格式为 2019-10-16</p><p><code>LocalTime</code>：表示时间，包含时分秒，格式为 16:38:54.158549300</p><p><code>LocalDateTime</code>：表示日期时间，包含年月日，时分秒，格式为 2018-09-06T15:33:56.750</p><p><code>DateTimeFormatter</code>：日期时间格式化类。</p><p><code>Instant</code>：时间戳，表示一个特定的时间瞬间。</p><p><code>Duration</code>：用于计算2个时间(LocalTime，时分秒)的距离</p><p><code>Period</code>：用于计算2个日期(LocalDate，年月日)的距离</p><p><code>ZonedDateTime</code>：包含时区的时间</p><p>LocalDate、LocalTime、LocalDateTime类的实例是不可变的对象，分别表示使用 ISO-8601 日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建指定日期</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">fj</span> <span class="operator">=</span> LocalDate.of(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;fj = &quot;</span> + fj); <span class="comment">// 1985-09-23</span></span><br><span class="line">    <span class="comment">// 得到当前日期</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nowDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;nowDate = &quot;</span> + nowDate);</span><br><span class="line">    <span class="comment">// 获取日期信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;年: &quot;</span> + nowDate.getYear());</span><br><span class="line">    System.out.println(<span class="string">&quot;月: &quot;</span> + nowDate.getMonthValue());</span><br><span class="line">    System.out.println(<span class="string">&quot;日: &quot;</span> + nowDate.getDayOfMonth());</span><br><span class="line">    System.out.println(<span class="string">&quot;星期: &quot;</span> + nowDate.getDayOfWeek());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 得到指定的时间</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>,<span class="number">15</span>, <span class="number">28</span>, <span class="number">129_900_000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + time);</span><br><span class="line">    <span class="comment">// 得到当前时间</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">nowTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;nowTime = &quot;</span> + nowTime);</span><br><span class="line">    <span class="comment">// 获取时间信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;小时: &quot;</span> + nowTime.getHour());</span><br><span class="line">    System.out.println(<span class="string">&quot;分钟: &quot;</span> + nowTime.getMinute());</span><br><span class="line">    System.out.println(<span class="string">&quot;秒: &quot;</span> + nowTime.getSecond());</span><br><span class="line">    System.out.println(<span class="string">&quot;纳秒: &quot;</span> + nowTime.getNano());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">fj</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;fj = &quot;</span> + fj);</span><br><span class="line">    <span class="comment">// 得到当前日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;now = &quot;</span> + now);</span><br><span class="line">    System.out.println(now.getYear());</span><br><span class="line">    System.out.println(now.getMonthValue());</span><br><span class="line">    System.out.println(now.getDayOfMonth());</span><br><span class="line">    System.out.println(now.getHour());</span><br><span class="line">System.out.println(now.getMinute());</span><br><span class="line">System.out.println(now.getSecond());</span><br><span class="line">System.out.println(now.getNano());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对日期时间的修改，对已存在的LocalDate对象，创建它的修改版，最简单的方式是使用withAttribute方法。withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。以下所有的方法都返回了一个修改属性的对象，他们不会影响原来的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LocalDateTime类: 对日期时间的修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;now = &quot;</span> + now);</span><br><span class="line">    <span class="comment">// 修改日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">setYear</span> <span class="operator">=</span> now.withYear(<span class="number">2077</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改年份: &quot;</span> + setYear);</span><br><span class="line">    System.out.println(<span class="string">&quot;now == setYear: &quot;</span> + (now == setYear));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改月份: &quot;</span> + now.withMonth(<span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改小时: &quot;</span> + now.withHour(<span class="number">9</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改分钟: &quot;</span> + now.withMinute(<span class="number">11</span>));</span><br><span class="line">    <span class="comment">// 再当前对象的基础上加上或减去指定的时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> now.plusDays(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;5天后: &quot;</span> + localDateTime);</span><br><span class="line">    System.out.println(<span class="string">&quot;now == localDateTime: &quot;</span> + (now == localDateTime));</span><br><span class="line">    System.out.println(<span class="string">&quot;10年后: &quot;</span> + now.plusYears(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;20月后: &quot;</span> + now.plusMonths(<span class="number">20</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;20年前: &quot;</span> + now.minusYears(<span class="number">20</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;5月前: &quot;</span> + now.minusMonths(<span class="number">5</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;100天前: &quot;</span> + now.minusDays(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日期的比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在JDK8中，LocalDate类中使用isBefore()、isAfter()、equals()方法来比较两个日期，可直接进行比较。</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">    System.out.println(now.isBefore(date)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(now.isAfter(date)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间格式化与解析"><a href="#时间格式化与解析" class="headerlink" title="时间格式化与解析"></a>时间格式化与解析</h3><p>通过<code>java.time.format.DateTimeFormatter</code>类可以进行日期时间解析与格式化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 得到当前日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="comment">// 将日期时间格式化为字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> now.format(formatter);</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);</span><br><span class="line">    <span class="comment">// 将字符串解析为日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;1970-01-01 12:12:12&quot;</span>, formatter);</span><br><span class="line">    System.out.println(<span class="string">&quot;parse = &quot;</span> + parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB基础入门</title>
      <link href="/inori/623bd2ca.html"/>
      <url>/inori/623bd2ca.html</url>
      
        <content type="html"><![CDATA[<p>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB是介于<strong>关系数据库</strong>和<strong>非关系数据库</strong>之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p><p>Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>MongoDB相较于传统的关系型数据库，可应对“三高“需求</p><ul><li>High performance：对数据库高并发读写的需求</li><li>Huge Storage：对海量数据的高效率存储和访问的需求</li><li>High Scalability &amp;&amp; High Availability：对数据库的高可扩展性和高可用性的需求</li></ul><h3 id="什么时候选择MongoDB"><a href="#什么时候选择MongoDB" class="headerlink" title="什么时候选择MongoDB"></a>什么时候选择MongoDB</h3><ul><li>新应用，需求会变，数据模型无法确定，想快速迭代开发</li><li>应用需要2000-3000以上的读写QPS（更高也可以）</li><li>应用需要TB甚至PB级别数据存储</li><li>应用要求存储的数据不丢失</li><li>应用需要99.999%高可用</li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><table><thead><tr><th>SQL术语&#x2F;概念</th><th>MongoDB术语&#x2F;概念</th><th>说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表&#x2F;集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行&#x2F;文档</td></tr><tr><td>column</td><td>field</td><td>数据字段&#x2F;域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>primary key</td><td>primary key</td><td>主键</td></tr></tbody></table><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>MongoDB的最小存储单位是文档(document)对象。数据在MongoDB中以BSON（Binary-JSON）文档的格式存储在磁盘上。</p><p>BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON。BSON和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。</p><p>BSON采用了类似于C语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p>Bson中，除了基本的JSON类型：string,integer,boolean,double,null,array和object，mongo还使用了特殊的数据类型。这些类型包括date,object id,binary data,regular expression和code。</p><h2 id="MongoDB优点"><a href="#MongoDB优点" class="headerlink" title="MongoDB优点"></a>MongoDB优点</h2><ol><li>高性能</li></ol><p>​MongoDB提供高性能的数据持久性。特别是对嵌入式数据模型的支持减少了数据库系统上I&#x2F;O活动。索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。</p><ol start="2"><li><p>高可用性<br>MongoDB的复制工具称为副本集（replica set），它可提供自动故障转移和数据冗余</p></li><li><p>高扩展性<br>MongoDB提供了水平可扩展性作为其核心功能的一部分。分片将数据分布在一组集群的机器上。（海量数据存储，服务能力水平扩展）</p><p>从3.4开始，MoηgoDB支持基于片键创建数据区域。在一个平衡的集群中， MongoDB将一个区域所覆盖的读写只定向到该区域内的那些片。</p></li><li><p>丰富的查询支持<br>MongoDB支持丰富的査询语言，支持读和写操作（CRUD），比如数据聚合、文本搜索和地理空间查询等</p></li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>需要用到的时候可以查阅<a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/create-index/">MongoDB官方文档</a>，在此列举常用命令</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p><code>mongosh</code>:打开一个连接到本地实例的MongoShell。所有其他命令都需要在mongosh中执行</p><p><code>show databases\show dbs</code>:显示当前MongoDB实例中的所有数据库</p><p><code>use &lt;dbname&gt;</code>:切换到dbname数据库</p><p><code>cls</code>: 清屏</p><p><code>show collections</code>: 显示数据库中的所有集合</p><p><code>db.dropDatabase()</code>:删除当前数据库</p><p><code>exit</code>: 退出</p><h3 id="创建、插入"><a href="#创建、插入" class="headerlink" title="创建、插入"></a>创建、插入</h3><p><code>insertOne</code>:在集合中插入一个新的文档，如果集合存在，那么直接插入数据。如果集合不存在，那么会隐式创建。</p><ul><li><code>db.test.insertOne(&#123;name: &quot;Jack&quot;, age: 18&#125;)</code>:向test数据库中插入一条数据</li></ul><p><code>insertMany</code>:批量插入文档</p><h4 id="快速插入"><a href="#快速插入" class="headerlink" title="快速插入"></a>快速插入</h4><p>由于<code>mongodb</code>底层使用<code>JS</code>引擎实现的，所以支持部分<code>Js</code>语法。因此可以写<code>for</code>循环</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (var i=1; i&lt;=10; i++) &#123; db.c2.insertOne(&#123;uanme: &quot;a&quot;+i, age: i&#125;) &#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>delectOne</code>:删除满足条件的第一个文档</p><p><code>delectMany</code>:删除满足条件的所有文档</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><code>updateOne</code>:更新满足条件的第一个文档</p><p><code>updateMany</code>:更新满足条件的所有文档</p><p><code>replaceone</code>:替换满足条件的第一个文档</p><p><code>save</code>:通过传入的文档替换已有文档或插入一个新的文档</p><p><code>$set</code>:只更新文档中$set指定的字段</p><ul><li><code>db.test.update(&#123;name:&quot;Jack&quot;&#125;,&#123;$set:&#123;uname:&quot;Candy&quot;&#125;&#125;)</code>:把jack改成Candy</li></ul><p><code>$inc</code>:用于递增&#x2F;递减文档中指定字段值的操作符</p><p><code>$rename</code>:更新某个字段的名称</p><p><code>$unset</code>:删除一个字段</p><p><code>$push</code>:将值加入一个数组中，不会判断是否有重复的值</p><p><code>$pull</code>:将值从一个数组中移除</p><p><code>$addToSet</code>:将值加入一个数组中，如果数组中有重复的值则不会加入</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><code>find</code>:查询所有文档</p><p><code>find(&lt;filterObject&gt;)</code>:查询所有满足参数对象<code>&lt;filterObject&gt;</code>中指定过滤条件的数据</p><ul><li><code>db.test.find(&#123;age: 18&#125;)</code>:查询所有年龄为18岁的文档</li></ul><p><code>db.find(&lt;filterObject&gt;, &lt;selectObject&gt;)</code>:查询所有满足参数对象<code>&lt;filterObject&gt;</code>中指定过滤条件的数据，并且只返回或者不返回<code>&lt;selectObject&gt;</code>中指定的字段</p><ul><li><code>db.test.find(&#123;&#125;, &#123;name:1&#125;)</code>:只看name列</li><li><code>db.test.find(&#123;&#125;, &#123;name:0&#125;)</code>:除了name列都看</li></ul><p><code>findOne</code>:与find用法相同，但是只返回1条</p><p><code>countDocuments</code>:返回满足条件的记录的数量</p><p><code>sort</code>:使用给定的字段按照升序或降序排序</p><ul><li><code>db.test.find().sort(&#123;age:1&#125;)</code>:按照年龄升序排序（传入-1是降序排序）</li></ul><p><code>limit</code>:限定只返回给定数量的文档</p><ul><li><code>db.test.find().limit(1)</code>:只返回一条数据</li></ul><p><code>skip</code>:从头开始跳过给定数值的文档</p><ul><li><code>db.test.find().limit(x).skip(y*x)</code>:实现翻页效果，一页x个内容，翻y页</li></ul><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><code>$sum</code>:计算总和</p><p><code>$avg</code>:计算平均值</p><p><code>$min</code>:计算最小值</p><p><code>$max</code>:计算最大值</p><p><code>$first</code>:获取第一个文档数据</p><p><code>$last</code>:获取最后一个文档数据</p><h3 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h3><p><code>$eq</code>:等于</p><p><code>$ne</code>:不等于</p><p><code>$gt\$get</code>:大于\大于等于</p><ul><li><code>db.c1.find(&#123;age:&#123;$gt:5&#125;&#125;)</code>:查询age大于5的数据</li></ul><p><code>$lt\$lte</code>:小于\小于等于</p><p><code>$in</code>:值在指定列表中就返回文档</p><ul><li><code>db.c2.find(&#123;age:&#123;$in:[5,8,10]&#125;&#125;)</code>:查询年龄是5,8,10的数据</li></ul><p><code>$nin</code>:值不在指定列表中就返回文档</p><p><code>$and</code>:检查复数条件是否均为真，可以理解为“并且”</p><ul><li><code>db.test.find(&#123;$and:[&#123;age:&#123;$gte:10&#125;&#125;, &#123;age:&#123;$lte:20&#125;&#125;&#125;]&#125;)</code>:返回年龄在10-20岁之间的文档</li></ul><p><code>$or</code>:检查复试条件是否有一个为真，可以理解为“或者”</p><p><code>$not</code>:逻辑区取反</p><p><code>$exists</code>:检查一个字段是否存在</p><p><code>$expr</code>:在不同的字段中作比较</p><h2 id="Java中操作MongoDB"><a href="#Java中操作MongoDB" class="headerlink" title="Java中操作MongoDB"></a>Java中操作MongoDB</h2><p>首先需要导入mongodb驱动包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mongodb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-java-driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建链接对象"><a href="#创建链接对象" class="headerlink" title="创建链接对象"></a>创建链接对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MongoClient mongoclient= <span class="keyword">new</span> <span class="title class_">MongoClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>);</span><br></pre></td></tr></table></figure><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取库对象，参数为库名</span></span><br><span class="line"><span class="type">MongoDatabase</span> <span class="variable">db</span> <span class="operator">=</span> mongoclient.getDatabase(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//获取当前库对象的所有集合名的迭代器</span></span><br><span class="line">MongoIterable&lt;String&gt; list = db.getlistCollectionNames();</span><br><span class="line"><span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">    System.out.println(str);<span class="comment">//获取所有表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取集合对象，参数为集合名</span></span><br><span class="line">MongoCollention&lt;Document&gt; collection = db.getCollection(<span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="对数据库进行增删改查"><a href="#对数据库进行增删改查" class="headerlink" title="对数据库进行增删改查"></a>对数据库进行增删改查</h3><h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取集合对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = db.getCollection(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//新增时创建一个Docuement对象，以键值对的形式传入内容</span></span><br><span class="line"><span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">document.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">document.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">document.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="comment">//添加一条数据，没有返回值</span></span><br><span class="line">collection.insertOne(document);</span><br><span class="line"><span class="comment">//新增多条数据,传入一个document集合</span></span><br><span class="line">collection.insertMany(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><p>删除，修改，查询时传入的筛选条件，比如<code>Bson eq = Filters.eq(&quot;name&quot;,&quot;张三&quot;);</code></p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Filters.eq()</td><td>等值</td></tr><tr><td>Filters.gt()</td><td>大于指定值(gte大于等于)</td></tr><tr><td>Filters.lt()</td><td>小于指定值(lte小于等于)</td></tr><tr><td>Filters.ne()</td><td>不等于指定</td></tr><tr><td>Filters.nin()</td><td>不等于数组中的值</td></tr><tr><td>Filters.and()</td><td>传入多个Bson对象，and连接</td></tr><tr><td>Filters.regex()</td><td>模糊查询</td></tr><tr><td>Filters.exists()</td><td>存在改字段</td></tr></tbody></table><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件</span></span><br><span class="line"><span class="type">Bson</span> <span class="variable">eq</span> <span class="operator">=</span> Filters.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//删除一条符合的</span></span><br><span class="line"><span class="type">DeleteResult</span> <span class="variable">deleteOne</span> <span class="operator">=</span> collection.deleteOne(eq);</span><br><span class="line"><span class="comment">//删除 所有符合条件的</span></span><br><span class="line"><span class="type">DeleteResult</span> <span class="variable">deleteMany</span> <span class="operator">=</span> collection.deleteMany(eq);</span><br></pre></td></tr></table></figure><p>修改的返回值内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AcknowledgedDeleteResult&#123;deletedCount=<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p><code>deletedCount</code>:被删除的文档数</p><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改条件</span></span><br><span class="line"><span class="type">Bson</span> <span class="variable">eq</span> <span class="operator">=</span> Filters.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//修改匹配到的第一条</span></span><br><span class="line"><span class="type">UpdateResult</span> <span class="variable">updateOne</span> <span class="operator">=</span> collection.updateOne(</span><br><span class="line">    eq, <span class="keyword">new</span> <span class="title class_">Document</span>(<span class="string">&quot;$set&quot;</span>,<span class="keyword">new</span> <span class="title class_">Document</span>(<span class="string">&quot;age&quot;</span>,<span class="number">50</span>)));</span><br><span class="line"><span class="comment">//修改匹配的多条</span></span><br><span class="line">collection.updateMany(eq, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>修改的返回值内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AcknowledgedUpdateResult&#123;matchedCount=<span class="number">0</span>, modifiedCount=<span class="number">0</span>, upsertedId=<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><p><code>matchedCount</code>:代表匹配到的文档数</p><p><code>modifiedCount</code>:代表被修改的文档数</p><p><code>upsertedId</code>:代表修改的文档id(主键)</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无条件全查</span></span><br><span class="line">FindIterable&lt;Document&gt; find = collection.find();</span><br><span class="line"><span class="comment">//带条件查询</span></span><br><span class="line"><span class="type">Bson</span> <span class="variable">eq</span> <span class="operator">=</span> Filters.regex(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张&quot;</span>);</span><br><span class="line">FindIterable&lt;Document&gt; find = collection.find(eq);</span><br></pre></td></tr></table></figure><p>查询的结果集映射,这种解析方式我们必须知道文档中的各个字段名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询</span></span><br><span class="line">FindIterable&lt;Document&gt; find = collection.find();</span><br><span class="line"><span class="comment">//创建一个实体类集合准备接收结果</span></span><br><span class="line">List&lt;Student&gt; slist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"><span class="comment">//获取结果集迭代器对象</span></span><br><span class="line">MongoCursor&lt;Document&gt; iterator = find.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Document</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">s.setSname(next.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">s.setSex(next.getString(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">s.setAge(next.getInteger(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">    <span class="comment">//将结果添加至实体类集合</span></span><br><span class="line">slist.add(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mongoclient.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的基本使用</title>
      <link href="/inori/ca4a993b.html"/>
      <url>/inori/ca4a993b.html</url>
      
        <content type="html"><![CDATA[<p>Docker使用Google推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><p>Docker在容器的基础上进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得Docker技术比虚拟机技术更为轻便、快捷。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像：一个特殊的文件系统"><a href="#镜像：一个特殊的文件系统" class="headerlink" title="镜像：一个特殊的文件系统"></a><strong>镜像：一个特殊的文件系统</strong></h3><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。</p><p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker设计时，就将其设计为分层存储的架构，镜像实际是由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p><p>在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><p>因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h3 id="容器：镜像运行时的实体"><a href="#容器：镜像运行时的实体" class="headerlink" title="容器：镜像运行时的实体"></a><strong>容器：镜像运行时的实体</strong></h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。</p><p>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新start，数据不会丢失。</p><h3 id="仓库：集中存放镜像文件的地方"><a href="#仓库：集中存放镜像文件的地方" class="headerlink" title="仓库：集中存放镜像文件的地方"></a><strong>仓库：集中存放镜像文件的地方</strong></h3><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</p><p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。</p><p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><p>这里补充一下 Docker Registry 公开服务和私有 Docker Registry 的概念：</p><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。</p><p>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的<a href="https://hub.docker.com/">Docker Hub</a>，这也是默认的Registry，并拥有大量的高质量的镜像。</p><p>在国内访问可能会比较慢，国内也有一些云服务商提供类似于Docker Hub的公开服务。</p><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 Docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><p><img src="D:\Blog\source\img\img_con.png" alt="img_con"></p><h2 id="初步配置Docker"><a href="#初步配置Docker" class="headerlink" title="初步配置Docker"></a>初步配置Docker</h2><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker容器开机自启</span></span><br><span class="line">docker update <span class="literal">--restart</span>=always [容器名/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p>给常用Docker命令起别名，方便访问：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br></pre></td></tr></table></figure><p>执行命令使修改生效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p><img src="D:\Blog\source\img\docker_control.png" alt="docker_control"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    <span class="number">605</span>c77e624dd   <span class="number">16</span> months ago   <span class="number">141</span>MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步，创建并允许Nginx容器</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第5步，查看运行中容器</span></span><br><span class="line">docker <span class="built_in">ps</span></span><br><span class="line"><span class="comment"># 也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第8步，查看所有容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第9步，再次启动nginx容器</span></span><br><span class="line">docker <span class="built_in">start</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第10步，再次查看容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br><span class="line"><span class="comment"># 或者，可以进入MySQL</span></span><br><span class="line">docker exec <span class="literal">-it</span> mysql mysql <span class="literal">-uroot</span> <span class="literal">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第13步，删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br><span class="line"><span class="comment"># 发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> nginx</span><br></pre></td></tr></table></figure><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷（volume）是一个虚拟目录，是<strong>容器内</strong>目录与<strong>宿主机</strong>目录之间映射的桥梁。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     <span class="number">29524</span>ff09715htrhfhthfhta2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-04-24T09:50:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html</span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br></pre></td></tr></table></figure><h3 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h3><p>数据卷的目录结构较深，去操作数据卷目录会不太方便。在很多情况下会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><p>本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>如果想要部署我们自己的项目，需要将其打包为一个镜像。</p><p>打包镜像分成如下步骤：</p><ul><li>准备Linux运行环境</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。记录镜像结构的文件就称为<a href="https://docs.docker.com/engine/reference/builder/"><strong>Dockerfile</strong></a></p><h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>通常在其他人提供好的基础镜像之上制作镜像</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像</p><p>首先将本地打包好的jar包和Dockerfile传入linux服务器，然后执行命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/image</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><p><code>docker build </code>: 构建一个docker镜像</p></li><li><p><code>-t demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</p></li><li><p><code>.</code> : 指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接指定Dockerfile目录</span></span><br><span class="line">docker build -t docker-demo:1.0 /root/image</span><br></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>项目往往需要访问其它各种中间件，例如MySQL、Redis等。但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p><p>所以，我们必须借助于<a href="https://docs.docker.com/engine/reference/commandline/network/">docker的网络功能</a>来解决这个问题</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   demo      bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了demo以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect demo mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect demo <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>只是部署一个简单的java项目，会包含以下3个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了</p><p>DockerCompose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的docker-compose.yml模板文件（YAML格式）来定义一组相关联的应用容器。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">docker-compose.yml文件的基本语法</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数很相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network demo</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th align="left"><strong>docker run 参数</strong></th><th align="left"><strong>docker compose 指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">–name</td><td align="left">container_name</td><td align="left">容器名称</td></tr><tr><td align="left">-p</td><td align="left">ports</td><td align="left">端口映射</td></tr><tr><td align="left">-e</td><td align="left">environment</td><td align="left">环境变量</td></tr><tr><td align="left">-v</td><td align="left">volumes</td><td align="left">数据卷配置</td></tr><tr><td align="left">–network</td><td align="left">networks</td><td align="left">网络</td></tr></tbody></table><h3 id="项目部署示例"><a href="#项目部署示例" class="headerlink" title="项目部署示例"></a>项目部署示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">project:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">demo:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">net</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以<a href="https://docs.docker.com/compose/reference/">部署项目</a>了</p><p>基本语法：<code>docker compose [OPTIONS] [COMMAND]</code></p><p>OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td><td align="left"></td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left">down</td><td align="left">停止并移除所有容器、网络</td><td align="left"></td></tr><tr><td align="left">ps</td><td align="left">列出所有启动的容器</td><td align="left"></td></tr><tr><td align="left">logs</td><td align="left">查看指定容器的日志</td><td align="left"></td></tr><tr><td align="left">stop</td><td align="left">停止容器</td><td align="left"></td></tr><tr><td align="left">start</td><td align="left">启动容器</td><td align="left"></td></tr><tr><td align="left">restart</td><td align="left">重启容器</td><td align="left"></td></tr><tr><td align="left">top</td><td align="left">查看运行的进程</td><td align="left"></td></tr><tr><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td><td align="left"></td></tr></tbody></table><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除镜像</span></span><br><span class="line">docker rmi demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY demo-service.jar /app.jar                                         0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root                                                 0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network net      Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container demo   Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis进阶篇</title>
      <link href="/inori/a9e82450.html"/>
      <url>/inori/a9e82450.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便继续使用缓存</p><p><strong>主动更新：</strong>手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="D:\Blog\source\img\redis_cacheUpdate.png" alt="redis_cacheUpdate"></p><h3 id="数据库缓存不一致解决方案"><a href="#数据库缓存不一致解决方案" class="headerlink" title="数据库缓存不一致解决方案"></a>数据库缓存不一致解决方案</h3><p>由于缓存的数据源来自于数据库,而数据库的数据是会发生变化的,因此,如果当数据库中数据发生变化,而缓存却没有同步,此时就会有一致性问题存在,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern: 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><h3 id="缓存穿透问题的解决思路"><a href="#缓存穿透问题的解决思路" class="headerlink" title="缓存穿透问题的解决思路"></a>缓存穿透问题的解决思路</h3><p><strong>缓存穿透</strong>：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器使用的是哈希思想，而哈希思想可能存在哈希冲突</p><h3 id="缓存雪崩问题及解决思路"><a href="#缓存雪崩问题及解决思路" class="headerlink" title="缓存雪崩问题及解决思路"></a>缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h3 id="缓存击穿问题及解决思路"><a href="#缓存击穿问题及解决思路" class="headerlink" title="缓存击穿问题及解决思路"></a>缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="D:\Blog\source\img\redisThrough.png" alt="redisThrough"></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><h3 id="分布式锁应该满足的条件"><a href="#分布式锁应该满足的条件" class="headerlink" title="分布式锁应该满足的条件"></a>分布式锁应该满足的条件</h3><ul><li>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li><li>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</li><li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li><li>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全也是程序中必不可少的一环</li></ul><h3 id="常见的分布式锁"><a href="#常见的分布式锁" class="headerlink" title="常见的分布式锁"></a>常见的分布式锁</h3><p><img src="D:\Blog\source\img\common_lock.png" alt="common_lock"></p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><h4 id="Redisson简介"><a href="#Redisson简介" class="headerlink" title="Redisson简介"></a>Redisson简介</h4><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="D:\Blog\source\img\redisson_type.png" alt="redisson_type"></p><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://IP地址:端口号&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Redission的分布式锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redission可重入锁原理"><a href="#redission可重入锁原理" class="headerlink" title="redission可重入锁原理"></a>redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0时，表示当前这把锁没有被人持有。</p><p>在redission中也支持支持可重入锁</p><p>在分布式锁中，采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，小key表示当前这把锁被哪个线程持有，分析一下当前的这个lua表达式:</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure><p>此处一共有3个参数：</p><p><strong>KEYS[1]：锁名称</strong></p><p><strong>ARGV[1]：锁失效时间</strong></p><p><strong>ARGV[2]：id + “:” + threadId；锁的小key</strong></p><p>exists: 判断数据是否存在</p><p>name：是lock是否存在,如果&#x3D;&#x3D;0，就表示当前这把锁不存在</p><p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p><p>Lock{</p><p>​    id + <strong>“:”</strong> + threadId :  1</p><p>}</p><p>如果当前这把锁存在，则第一个条件不满足，再判断</p><p>redis.call(‘hexists’, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1</p><p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p><p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p><p>将当前这个锁的value进行+1</p><p>redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p><p>他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p><p><img src="D:\Blog\source\img\getLock.png" alt="getLock"></p><h3 id="锁重试和WatchDog机制"><a href="#锁重试和WatchDog机制" class="headerlink" title="锁重试和WatchDog机制"></a>锁重试和WatchDog机制</h3><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前该线程已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，存在一个while(true) 进行tryAcquire抢锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br></pre></td></tr></table></figure><p>如果是没有传入时间，则此时也会进行抢锁，而且抢锁时间是默认看门狗时间<code>commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</code></p><p><code>ttlRemainingFuture.onComplete((ttlRemaining, e)</code>相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure><p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（）方法Method(<strong>new</strong> TimerTask(){}, 参数2, 参数3)</p><p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MutiLock原理"><a href="#MutiLock原理" class="headerlink" title="MutiLock原理"></a>MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="D:\Blog\source\img\mutilock_1.png" alt="mutilock_1"></p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功，那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试</p><p><img src="D:\Blog\source\img\mutilock_2.png" alt="mutilock_2"></p><h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><p>消息队列的字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>使用队列的好处在于 <strong>解耦：</strong>生产者不必等待消费者，生产出来的东西可以直接放到队列中，消费者也不必等待生产者，直接从队列中获得所需的消息，二者异步执行，增加效率。</p><h3 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a>基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h3 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream是Redis 5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="D:\Blog\source\img\stream_1.png" alt="stream_1"></p><p>例如：</p><p><code>XADD user * name jack age 18</code>:创建名为users的队列，并向其中发送一个消息，内容为{name&#x3D;jack,age&#x3D;18},使用Redis自动生成ID</p><p>读取消息的方式之一：XREAD</p><p><img src="D:\Blog\source\img\stream_xread.png" alt="stream_xread"></p><p>例如，使用XREAD读取第一个消息：<code>XREAD COUNT 1 STREAMS users 0</code></p><p>XREAD阻塞方式，读取最新的消息：<code>XREAD COUNT 1 BLOCK 1000 STREAMS user $</code></p><p>可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 尝试读取队列中的消息，最多阻塞2秒</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.execute(<span class="string">&quot;XREAD COUNT 1 BLOCK 2000 STREAMS user $&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    handleMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p><img src="D:\Blog\source\img\user_group.png" alt="user_group"></p><p>创建消费者组：<code>XGROUP CREATE key gruopName ID [MKSTREAM]</code><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><h2 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，根据经纬度来检索数据。</p><p>常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li></ul><p><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></p><ul><li>GEODIST：计算指定的两个点之间的距离并返回</li></ul><p><code>GEODIST key member1 member2 [m|km|ft|mi]</code></p><ul><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li></ul><p><code>GEOHASH key member [member ...]</code></p><ul><li>GEOPOS：返回指定member的坐标</li></ul><p><code>GEOPOS key member [member ...]</code></p><ul><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。(已废弃)</li></ul><p><code>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></p><ul><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。</li></ul><p><code>GEOSEARCH key [FROMMEMBER member] [FROMCOORD longitude latitude] [BYRADIUS radius unit] [BYBOX width height unit] [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count] [STORE key] [STOREDIST key]</code></p><p>其中，<code>key</code>是指定的键，可选的查询参数包括：</p><p>​<code>FROMMEMBER member</code>：从指定的位置成员开始搜索。</p><p>​<code>FROMCOORD longitude latitude</code>：从指定的经度和纬度开始搜索。</p><p>​<code>BYRADIUS radius unit</code>：根据半径进行搜索。</p><p>​<code>BYBOX width height unit</code>：根据矩形区域进行搜索。</p><p>​<code>WITHCOORD</code>：返回位置的经度和纬度。</p><p>​<code>WITHDIST</code>：返回位置与查询点的距离。</p><p>​<code>ASC|DESC</code>：按距离升序或降序排序。</p><p>​<code>COUNT count</code>：返回最多指定数量的结果。</p><p>​<code>STORE key</code>：将结果存储到指定的键中。</p><p>​<code>STOREDIST key</code>：将结果存储到指定的键中，并同时存储位置与查询点的距离。</p><ul><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个新的key中。</li></ul><p><code>GEOSEARCHSTORE destkey key [FROMMEMBER member] [FROMCOORD longitude latitude] [BYRADIUS radius unit] [BYBOX width height unit] [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count] [STOREDIST key]</code></p><h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>Bitmap并不是实际的数据类型，而是定义在String类型上的一个面向字节操作的集合。因为字符串是二进制安全的块，他们的最大长度是512M，最适合设置成2^32个不同字节。Bitmap的最大优势之一在存储信息时极其节约空间。</p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT：获取指定位置（offset）的bit值</li><li>BITCOUNT：统计BitMap中值为1的bit位的数量</li><li>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门</title>
      <link href="/inori/8e7db504.html"/>
      <url>/inori/8e7db504.html</url>
      
        <content type="html"><![CDATA[<p>Git是一个分布式的版本控制系统，可以管理应用开发版本，同样可以作为部署工具使用。</p><p>常用的git平台：<a href="https://github.com/">GitHub</a>、<a href="https://gitee.com/">Gitee</a>、<a href="https://gitlab.com/">GitLab</a>等</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>工作区：仓库的目录。工作区是独立于各个分支的。</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本。</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在<del>&#x2F;.gitconfig文件中<br><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在</del>&#x2F;.gitconfig文件中<br><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中<br><code>git add XX</code>：将XX文件添加到暂存区</p><ul><li><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</li></ul><p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉<br><code>git commit -m &quot;备注信息&quot;</code>：将暂存区的内容提交到当前分支<br><code>git status</code>：查看仓库状态<br><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容<br><code>git log</code>：查看当前分支的所有版本<br><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）<br><code>git reset --hard HEAD^ 或 git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><ul><li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li><li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li><li><code>git reset --hard 版本号</code>：回滚到某一特定版本</li></ul><p><code>git checkout — XX或git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销<br><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库<br><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库</p><ul><li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li></ul><p><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下<br><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支<br><code>git branch</code>：查看所有分支和当前所处分支<br><code>git checkout branch_name</code>：切换到branch_name这个分支<br><code>git merge branch_name</code>：将分支branch_name合并到当前分支上<br><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支<br><code>git branch branch_name</code>：创建新分支<br><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支<br><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支<br><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p><ul><li><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</li></ul><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应<br><code>git checkout -t origin/branch_name</code>: 将远程的branch_name分支拉取到本地<br><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中<br><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素<br><code>git stash drop</code>：删除栈顶存储的修改<br><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素<br><code>git stash list</code>：查看栈中所有元素</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/inori/a4a81253.html"/>
      <url>/inori/a4a81253.html</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://www.acwing.com/activity/content/57/">AcWing——Linux基础课</a></p><h2 id="文件操作常用命令"><a href="#文件操作常用命令" class="headerlink" title="文件操作常用命令"></a>文件操作常用命令</h2><ul><li><p>ctrl c: 取消命令，并且换行</p></li><li><p>ctrl u: 清空本行命令</p></li><li><p>tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li><li><p>ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p></li><li><p>pwd: 显示当前路径</p></li><li><p>cd XXX: 进入XXX目录下, cd .. 返回上层目录</p></li><li><p>cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如..&#x2F;dir_c&#x2F;a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p></li><li><p>mkdir XXX: 创建目录XXX</p></li><li><p>rm XXX: 删除普通文件</p><ul><li>rm XXX -r: 删除文件夹</li></ul></li><li><p>mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令</p></li><li><p>touch XXX: 创建一个文件</p></li><li><p>cat XXX: 展示文件XXX中的内容</p></li><li><p>复制文本</p><ul><li><p>windows&#x2F;Linux下：Ctrl + insert</p></li><li><p>Mac下：command + c</p></li></ul></li><li><p>粘贴文本</p><ul><li><p>windows&#x2F;Linux下：Shift + insert</p></li><li><p>Mac下：command + v</p></li></ul></li></ul><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><ul><li><p>功能</p><ul><li><p>分屏</p></li><li><p>允许断开Terminal连接后，继续运行进程</p></li></ul></li><li><p>结构：</p><ul><li>一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane</li><li>操作（魔改后）：<ul><li>tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</li><li>按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。</li><li>按下Ctrl + a后手指松开，然后按”（注意是双引号”）：将当前pane上下平分成两个pane。</li><li>Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</li><li>鼠标点击可以选pane。</li><li>按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。</li><li>鼠标拖动pane之间的分割线，可以调整分割线的位置。</li><li>按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。</li><li>按下ctrl + a后手指松开，然后按z：将当前pane全屏&#x2F;取消全屏。</li><li>按下ctrl + a后手指松开，然后按d：挂起当前session。</li><li>tmux a：打开之前挂起的session。</li><li>按下ctrl + a后手指松开，然后按s：选择其它session。<br>方向键 —— 上：选择上一项 session&#x2F;window&#x2F;pane<br>方向键 —— 下：选择下一项 session&#x2F;window&#x2F;pane<br>方向键 —— 右：展开当前项 session&#x2F;window<br>方向键 —— 左：闭合当前项 session&#x2F;window</li><li>按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。</li><li>按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。</li><li>按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。</li><li>鼠标滚轮：翻阅当前pane内的内容。</li><li>在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</li><li>tmux中复制&#x2F;粘贴文本的通用方式：<br> 1. 按下Ctrl + a后松开手指，然后按[<br>      2. 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板<br>      3. 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</li></ul></li></ul></li></ul><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><ul><li>功能：<ul><li>命令行模式下的文本编辑器。</li><li>根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</li><li>使用方式：vim filename<ul><li>如果已有该文件，则打开它。</li><li>如果没有该文件，则打开个一个新的文件，并命名为filename</li></ul></li></ul></li><li>模式：<ul><li>一般命令模式<ul><li>默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</li><li>编辑模式<br>   在一般命令模式里按下i，会进入编辑模式。<br>   按下ESC会退出编辑模式，返回到一般命令模式。</li><li>命令行模式<br>   在一般命令模式里按下:&#x2F;?三个字母中的任意一个，会进入命令行模式。命令行在最下面。<br>   可以查找、替换、保存、退出、配置编辑器等。</li></ul></li></ul></li><li>操作：<ul><li>i和a：进入编辑模式</li><li>ESC：进入一般命令模式<ul><li>h 或 左箭头键：光标向左移动一个字符</li><li>j 或 向下箭头：光标向下移动一个字符</li><li>k 或 向上箭头：光标向上移动一个字符</li><li>l 或 向右箭头：光标向右移动一个字符</li><li>n<Space>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</li><li>0 或 功能键[Home]：光标移动到本行开头</li><li><code>$ 或 功能键[End]</code>：光标移动到本行末尾</li><li>G：光标移动到最后一行</li><li>:n 或 nG：n为数字，光标移动到第n行</li><li>gg：光标移动到第一行，相当于1G</li><li>n<Enter>：n为数字，光标向下移动n行</li><li>&#x2F;word：向光标之下寻找第一个值为word的字符串。</li><li>?word：向光标之上寻找第一个值为word的字符串。</li><li>n：重复前一个查找操作</li><li>N：反向重复前一个查找操作</li><li>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</li><li>:1,$s&#x2F;word1&#x2F;word2&#x2F;g：将全文的word1替换为word2<br>        (20) :1,$s&#x2F;word1&#x2F;word2&#x2F;gc：将全文的word1替换为word2，且在替换前要求用户确认。</li><li>v：选中文本</li><li>d：删除选中的文本</li><li>dd: 删除当前行</li><li>y：复制选中的文本</li><li>yy: 复制当前行</li><li>p: 将复制的数据在光标的下一行&#x2F;下一个位置粘贴</li><li>u：撤销</li><li>Ctrl + r：取消撤销</li><li>大于号 &gt;：将选中的文本整体向右缩进一次</li><li>小于号 &lt;：将选中的文本整体向左缩进一次</li><li>:w 保存</li><li>:w! 强制保存</li><li>:q 退出</li><li>:q! 强制退出</li><li>:wq 保存并退出</li><li>:set paste 设置成粘贴模式，取消代码自动缩进</li><li>:set nopaste 取消粘贴模式，开启代码自动缩进</li><li>:set nu 显示行号</li><li>:set nonu 隐藏行号</li><li>gg&#x3D;G：将全文代码格式化</li><li>:noh 关闭查找关键词高亮</li><li>Ctrl + q：当vim卡死时，可以取消当前正在执行的命令</li></ul></li></ul></li><li>异常处理：<ul><li>每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。</li><li>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<ol><li>找到正在打开该文件的程序，并退出</li><li>直接删掉该swp文件</li></ol></li></ul></li></ul><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>远程登录服务器：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname</span><br></pre></td></tr></table></figure><p>user: 用户名<br>hostname: IP地址或域名</p><ul><li>第一次登录时会提示：</li></ul><blockquote><p> The authenticity of host ‘123.57.47.211 (123.57.47.211)’ can’t be established.<br>ECDSA key fingerprint is SHA256:iy237yysfCe013&#x2F;l+kpDGfEG9xxHxm0dnxnAbJTPpG8.<br>Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])?</p></blockquote><p>输入yes，然后回车即可。<br>这样会将该服务器的信息记录在~&#x2F;.ssh&#x2F;known_hosts文件中。</p><p>然后输入密码即可登录到远程服务器中。</p><p>默认登录端口号为22。如果想登录某一特定端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname -p 22</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>创建文件 ~&#x2F;.ssh&#x2F;config。</p><p>然后在文件中输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host myserver1</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br><span class="line"></span><br><span class="line">Host myserver2</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure><p>之后再使用服务器时，可以直接使用别名myserver1、myserver2。</p><h3 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h3><p>创建密钥：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>执行结束后，~&#x2F;.ssh&#x2F;目录下会多两个文件：</p><ol><li>id_rsa：私钥</li><li>id_rsa.pub：公钥</li></ol><p>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</p><p>例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~&#x2F;.ssh&#x2F;authorized_keys文件里即可。</p><p>也可以使用如下命令一键添加公钥：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id myserver</span><br></pre></td></tr></table></figure><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>命令格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh user@hostname command</span><br></pre></td></tr></table></figure><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道类似于文件重定向，可以将前一个命令的stdout重定向到下一个命令的stdin。</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li><p>管道命令仅处理<code>stdout</code>，会忽略<code>stderr</code></p></li><li><p>管道右边的命令必须能接受<code>stdin</code></p></li><li><p>多个管道命令可以串联</p></li><li><p>与文件重定向的区别</p></li><li><p>文件重定向左边为命令，右边为文件。</p></li><li><p>管道左右两边均为命令，左边有stdout，右边有stdin。</p></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>统计当前目录下所有python文件的总行数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &#x27;*.py&#x27; | xargs cat | wc -l</span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Linux系统中会用很多环境变量来记录配置信息。<br>环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>列出当前环境下的所有环境变量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env  # 显示当前用户的变量</span><br><span class="line">set  # 显示当前shell的变量，包括当前用户的变量;</span><br><span class="line">export  # 显示当前导出成用户变量的shell变量</span><br></pre></td></tr></table></figure><p>输出某个环境变量的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>为了将对环境变量的修改应用到未来所有环境下，可以将修改命令放到<del>&#x2F;.bashrc文件中。<br>修改完</del>&#x2F;.bashrc文件后，记得执行source ~&#x2F;.bashrc，来将修改应用到当前的bash环境下。</p><p>为何将修改命令放到~&#x2F;.bashrc，就可以确保修改会影响未来所有的环境呢？</p><ul><li>每次启动bash，都会先执行~&#x2F;.bashrc。</li><li>每次ssh登陆远程服务器，都会启动一个bash命令行给我们。</li><li>每次tmux新开一个pane，都会启动一个bash命令行给我们。</li><li>所以未来所有新开的环境都会加载我们修改的内容。</li></ul><h3 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h3><ol><li>HOME：用户的家目录。</li><li>PATH：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。</li><li>LD_LIBRARY_PATH：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。</li><li>C_INCLUDE_PATH：C语言的头文件路径，内容是以冒号分隔的路径列表。</li><li>CPLUS_INCLUDE_PATH：CPP的头文件路径，内容是以冒号分隔的路径列表。</li><li>PYTHONPATH：Python导入包的路径，内容是以冒号分隔的路径列表。</li><li>JAVA_HOME：jdk的安装目录。</li><li>CLASSPATH：存放Java导入类的路径，内容是以冒号分隔的路径列表。</li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="系统状况"><a href="#系统状况" class="headerlink" title="系统状况"></a>系统状况</h3><ol><li><p>top：查看所有进程的信息（Linux的任务管理器）</p><ul><li>打开后，输入M：按使用内存排序</li><li>打开后，输入P：按使用CPU排序</li><li>打开后，输入q：退出</li></ul></li><li><p>df -h：查看硬盘使用情况</p></li><li><p>free -h：查看内存使用情况</p></li><li><p>du -sh：查看当前目录占用的硬盘空间</p></li><li><p>ps aux：查看所有进程</p></li><li><p>kill -9 pid：杀死编号为pid的进程</p><ul><li>传递某个具体的信号：<code>kill -s SIGTERM pid</code></li></ul></li><li><p>netstat -nt：查看所有网络连接</p></li><li><p>w：列出当前登陆的用户</p></li><li><p>ping <code>某url</code>：检查是否连网</p></li></ol><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li>chmod：修改文件权限<ul><li>chmod +x xxx：给xxx添加可执行权限</li><li>chmod -x xxx：去掉xxx的可执行权限</li><li>chmod 777 xxx：将xxx的权限改成777</li><li>chmod 777 xxx -R：递归修改整个文件夹的权限</li></ul></li></ul><h3 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h3><ol><li><p>find &#x2F;path&#x2F;to&#x2F;directory&#x2F; -name ‘<em>.py’：搜索某个文件路径下的所有</em>.py文件</p></li><li><p>grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。</p></li><li><p>wc：统计行数、单词数、字节数</p><ul><li>既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；</li><li>wc -l：统计行数</li><li>wc -w：统计单词数</li><li>wc -c：统计字节数</li></ul></li><li><p>tree：展示当前目录的文件结构</p><ul><li>tree &#x2F;path&#x2F;to&#x2F;directory&#x2F;：展示某个目录的文件结构</li><li>tree -a：展示隐藏文件</li></ul></li><li><p>ag xxx：搜索当前目录下的所有文件，检索xxx字符串</p></li><li><p>cut：分割一行内容</p><ul><li>从stdin中读入多行数据</li><li><code>echo $PATH | cut -d &#39;:&#39; -f 3,5</code>：输出PATH用:分割后第3、5列数据</li><li><code>echo $PATH | cut -d &#39;:&#39; -f 3-5</code>：输出PATH用:分割后第3-5列数据</li><li><code>echo $PATH | cut -c 3,5</code>：输出PATH的第3、5个字符</li><li><code>echo $PATH | cut -c 3-5</code>：输出PATH的第3-5个字符</li></ul></li><li><p>sort：将每行内容按字典序排序</p><ul><li><p>可以从stdin中读取多行数据</p></li><li><p>可以从命令行参数中读取文件名列表</p></li></ul></li><li><p>xargs：将stdin中的数据用空格或回车分割成命令行参数</p><ul><li>find . -name ‘*.py’ | xargs cat | wc -l：统计当前目录下所有python文件的总行数</li></ul></li></ol><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><ol><li><p>more：浏览文件内容</p><ul><li><p>回车：下一行</p></li><li><p>空格：下一页</p></li><li><p>b：上一页</p></li><li><p>q：退出</p></li></ul></li><li><p>less：与more类似，功能更全</p><ul><li>回车：下一行</li><li>y：上一行</li><li>Page Down：下一页</li><li>Page Up：上一页</li><li>q：退出</li></ul></li><li><p>head -3 xxx：展示xxx的前3行内容，同时支持从stdin读入内容</p></li><li><p>ail -3 xxx：展示xxx末尾3行内容，同时支持从stdin读入内容</p></li></ol><h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3><p><code>history</code>：展示当前用户的历史操作。内容存放在~&#x2F;.bash_history中</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol><li>md5sum：计算md5哈希值<ul><li>可以从stdin读入内容</li><li>可以在命令行参数中传入文件名列表</li></ul></li><li>time command：统计command命令的执行时间</li><li>ipython3：交互式python3环境。可以当做计算器，或者批量管理文件<ul><li><code>! echo &quot;Hello World&quot;</code>：!表示执行shell脚本</li></ul></li><li>watch -n 0.1 command：每0.1秒执行一次command命令</li><li>tar：压缩文件<ul><li>tar -zcvf xxx.tar.gz &#x2F;path&#x2F;to&#x2F;file&#x2F;*：压缩</li><li>tar -zxvf xxx.tar.gz：解压缩</li></ul></li><li>diff xxx yyy：查找文件xxx与yyy的不同点</li></ol><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><ul><li>sudo command：以root身份执行command命令</li><li>apt-get install xxx：安装软件</li><li>pip install xxx –user –upgrade：安装python包</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis入门篇</title>
      <link href="/inori/8660e5c0.html"/>
      <url>/inori/8660e5c0.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.redis.net.cn/">Redis</a>是一个基于<strong>内存</strong>的<u>key-value</u>结构NoSql数据库。相比于常规的数据库，Redis</p><ul><li>基于内存存储，读写性能高</li><li>适合存储热点数据（热点商品、资讯、新闻）和在短时间内有大量访问的数据</li><li>应用广泛</li></ul><h2 id="Redis启动"><a href="#Redis启动" class="headerlink" title="Redis启动"></a>Redis启动</h2><p>安装好Redis并配置好环境变量之后，在cmd中使用<code>redis-server</code>启动redis，Redis服务默认端口号为6379。</p><p>使用命令<code>redis-cli</code>连接客户端，默认连接的是本地的redis服务，并且使用默认6379端口。也可以通过指定如下参数连接：-h ip地址-p 端口号 -a 密码（如果有）</p><p>也可以使用<a href="https://github.com/qishibo/AnotherRedisDesktopManager">Another-Redis-Desktop-Manager</a>图形化工具连接和管理Redis</p><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串(string)：普通字符串，Redis中最简单的数据类型</li><li>哈希(hash)：类似于Java中的HashMap结构</li><li>列表(list)：按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList</li><li>集合(set)：无序集合，没有重复元素，类似于Java中的HashSet</li><li>有序集合(zset)：集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素</li></ul><h2 id="Redis操作命令"><a href="#Redis操作命令" class="headerlink" title="Redis操作命令"></a>Redis操作命令</h2><h3 id="字符串操作命令"><a href="#字符串操作命令" class="headerlink" title="字符串操作命令"></a>字符串操作命令</h3><ul><li><code>SET key value</code>：设置指定key的值</li><li><code>GET key</code>：获取指定key的值</li><li><code>SETEX key seconds value</code>：设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><code>SETNX key value</code>：只有在 key 不存在时设置 key 的值</li></ul><h3 id="哈希操作命令"><a href="#哈希操作命令" class="headerlink" title="哈希操作命令"></a>哈希操作命令</h3><ul><li><code>HSET key field value</code>：将哈希表 key 中的字段 field 的值设为 value</li><li><code>HGET key field</code>：获取存储在哈希表中指定字段的值</li><li><code>HDEL key field</code>：删除存储在哈希表中的指定字段</li><li><code>HKEYS key</code>：获取哈希表中所有字段</li><li><code>HVALS key</code>：获取哈希表中所有值</li></ul><h3 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h3><ul><li><code>LPUSH key value1 [value2]</code>：将一个或多个值插入到列表头部(左边)</li><li><code>LRANGE key start stop</code>：获取列表指定范围内的元素</li><li><code>RPOP key</code>：移除并获取列表最后一个元素(右边)</li><li><code>LLEN key</code>：获取列表长度</li></ul><h3 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h3><ul><li><code>SADD key member1 [member2]</code>：向集合添加一个或多个成员</li><li><code>SMEMBERS key</code>：返回集合中的所有成员</li><li><code>SCARD key</code>：获取集合的成员数</li><li><code>SINTER key1 [key2]</code>：返回给定所有集合的交集</li><li><code>SUNION key1 [key2]</code>：返回所有给定集合的并集</li><li><code>SREM key member1 [member2]</code>：删除集合中一个或多个成员</li></ul><h3 id="有序集合操作命令"><a href="#有序集合操作命令" class="headerlink" title="有序集合操作命令"></a>有序集合操作命令</h3><ul><li><code>ZADD key score1 member1 [score2 member2]</code>：向有序集合添加一个或多个成员</li><li><code>ZRANGE key start stop [WITHSCORES]</code>：通过索引区间返回有序集合中指定区间内的成员</li><li><code>ZINCRBY key increment member</code>：有序集合中对指定成员的分数加上增量increment</li><li><code>ZREM key member [member ...]</code>：移除有序集合中的一个或多个成员</li></ul><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li><code>KEYS pattern</code>：查找所有符合给定模式(pattern)的key </li><li><code>EXISTS key</code>：检查给定key是否存在</li><li><code>TYPE key</code>：返回key所储存的值的类型</li><li><code>DEL key</code>：该命令用于在key存在时删除 key</li></ul><h2 id="在Java中操作Redis"><a href="#在Java中操作Redis" class="headerlink" title="在Java中操作Redis"></a>在Java中操作Redis</h2><p>Redis的Java客户端很多，常用的有：<u>Jedis</u>、<u>Lettuce</u>、<u><strong>Spring Data Redis</strong></u></p><p>其中Spring Data Redis是Spring的一部分，对Redis底层开发包进行了高度封装。在Spring项目中，可以使用Spring Data Redis来简化操作。</p><h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><ol><li>导入Spring Data Redis的maven坐标</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置Redis数据源</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;lty.redis.host&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;lty.redis.port&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;lty.redis.database&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>编写配置类，创建RedisTemplate对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer将key序列化，避免乱码</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>通过RedisTemplate对象操作Redis</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishService dishService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;DishVO&gt;&gt; <span class="title function_">test</span><span class="params">(Long categoryId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + categoryId;</span><br><span class="line">        List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(list != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// redis中存在数据，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> Result.success(list);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 否则从数据库中查数据</span></span><br><span class="line">        <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dish</span>();</span><br><span class="line">        dish.setCategoryId(categoryId);</span><br><span class="line">        dish.setStatus(StatusConstant.ENABLE);</span><br><span class="line">        list = dishService.listWithFlavor(dish);</span><br><span class="line">        <span class="comment">// 查出来的数据加入到redis中</span></span><br><span class="line">        redisTemplate.opsForValue().set(key, list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Data-Redis使用方式"><a href="#Spring-Data-Redis使用方式" class="headerlink" title="Spring Data Redis使用方式"></a>Spring Data Redis使用方式</h2><p>RedisTemplate针对大量api进行了归类封装,将同一数据类型的操作封装为对应的Operation接口，具体分类如下：</p><ul><li>ValueOperations：string类型数据操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：hash类型的数据操作</li><li>ListOperations：list类型的数据操作</li></ul><h3 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h3><p><code>set void set(K key, V value)</code>：添加获取数据</p><p><code>set void set(K key, V value, long timeout, TimeUnit unit)</code>：设置数据有效期</p><blockquote><p>TimeUnit.DAYS          &#x2F;&#x2F;天<br>TimeUnit.HOURS         &#x2F;&#x2F;小时<br>TimeUnit.MINUTES       &#x2F;&#x2F;分钟<br>TimeUnit.SECONDS       &#x2F;&#x2F;秒<br>TimeUnit.MILLISECONDS  &#x2F;&#x2F;毫秒</p></blockquote><p><code>set void set(K key, V value, long offset)</code>:根据key设置value指定下标字符</p><p><code>get V get(Object key)</code>:Get操作</p><p><code>getAndSet V getAndSet(K key, V value)</code>:设置键的字符串值并返回其旧值</p><p><code>append Integer append(K key, String value)</code>:根据key拼接value的值，如果被拼接的key没值则为空字符串</p><p><code>size Long size(K key)</code>:根据key获取value的长度</p><h3 id="List操作"><a href="#List操作" class="headerlink" title="List操作"></a>List操作</h3><p><code>Long size(K key)</code>:返回存储在键中的列表的长度。如果键不存在，则将其解释为空列表，并返回0。当key存储的值不是列表时返回错误。</p><p><code>Long leftPush(K key, V value)</code>:（从左边插入）将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。</p><p><code>Long leftPushAll(K key, V... values)</code>:（从左边插入）批量把一个数组插入到列表中</p><p><code>Long rightPush(K key, V value)</code>:（从右边插入）将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。（从右边插入）</p><p><code>Long rightPushAll(K key, V... values)</code>:（从右边插入）批量把一个数组插入到列表中</p><p><code>void set(K key, long index, V value)</code>:在列表中index的位置设置value值</p><p><code>Long remove(K key, long count, Object value)</code>:从存储在键中的列表中删除等于值的元素的第一个计数事件。</p><blockquote><p>计数参数以下列方式影响操作：<br>count&gt; 0：删除等于从头到尾移动的值的元素。<br>count &lt;0：删除等于从尾到头移动的值的元素。<br>count &#x3D; 0：删除等于value的所有元素。 </p></blockquote><p><code>V index(K key, long index)</code>:根据下标获取列表中的值，下标是从0开始的，-1为获取全部</p><p><code>V leftPop(K key)</code>:弹出最左边的元素</p><p><code>V rightPop(K key)</code>:弹出最右边的元素</p><h3 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h3><p><code>Long delete(H key, Object... hashKeys)</code>:删除给定的哈希hashKeys</p><p><code>Boolean hasKey(H key, Object hashKey)</code>:判断哈希hashKey是否存在</p><p><code>HV get(H key, Object hashKey)</code>:从键中的哈希获取给定hashKey的值</p><p><code>Set keys(H key)</code>:获取key所对应的散列表的key</p><p><code>Long size(H key)</code>:获取key所对应的散列表的大小个数</p><p><code>void putAll(H key, Map&lt;? extends HK, ? extends HV&gt; m)</code>:使用m中提供的多个散列字段设置到key对应的散列表中</p><p><code>void put(H key, HK hashKey, HV value)</code>:设置散列hashKey的值</p><p><code>List values(H key)</code>:获取整个哈希存储的值根据密钥</p><p><code>Map&lt;HK, HV&gt; entries(H key)</code>:获取整个哈希存储根据密钥</p><p><code>Cursor&lt;Map.Entry&lt;HK, HV&gt;&gt; scan(H key, ScanOptions options)</code>:使用Cursor在key的hash中迭代，相当于迭代器。</p><h3 id="Set操作"><a href="#Set操作" class="headerlink" title="Set操作"></a>Set操作</h3><p><code>Long add(K key, V... values)</code>:无序集合中添加元素，返回添加个数也可以直接在add里面添加多个值 如：template.opsForSet().add(“setTest”,”aaa”,”bbb”)</p><p><code>Long remove(K key, Object... values)</code>:移除集合中一个或多个成员</p><p><code>V pop(K key)</code>:移除并返回集合中的一个随机元素</p><p><code>Boolean move(K key, V value, K destKey)</code>:将 member 元素从 source 集合移动到 destination 集合</p><p><code>Long size(K key)</code>:无序集合的大小长度</p><p><code>et members(K key)</code>:返回集合中的所有成员</p><p><code>Cursor scan(K key, ScanOptions options)</code>:遍历set</p><h3 id="ZSet操作"><a href="#ZSet操作" class="headerlink" title="ZSet操作"></a>ZSet操作</h3><p><code>Boolean add(K key, V value, double score)</code>:新增一个有序集合，存在的话为false，不存在的话为true</p><p><code>Long add(K key, Set&lt;TypedTuple&gt; tuples)</code>:新增一个有序集合</p><p><code>Long remove(K key, Object... values)</code>:从有序集合中移除一个或者多个元素</p><p><code>Long rank(K key, Object o)</code>:返回有序集中指定成员的排名，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Set range(K key, long start, long end)</code>:通过索引区间返回有序集合成指定区间内的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Long count(K key, double min, double max)</code>:通过分数返回有序集合指定区间内的成员个数</p><p><code>Long size(K key)</code>:获取有序集合的成员数，内部调用的就是zCard方法</p><p><code>Double score(K key, Object o)</code>:获取指定成员的score值</p><p><code>Long removeRange(K key, long start, long end)</code>:移除指定索引位置的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Cursor&lt;TypedTuple&gt; scan(K key, ScanOptions options)</code>:遍历zset</p><h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>Spring Cache 是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。</p><p>它提供了一层抽象，底层可以切换不同的缓存实现，例如：</p><ul><li>EHCache</li><li>Caffeine</li><li>Redis</li></ul><p>需要引入Maven坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@EnableCaching</td><td align="center">开启缓存注解功能，通常加在启动类上</td></tr><tr><td align="center">@Cacheable(cacheNames&#x3D;”数据库名”,key&#x3D;”存储的键”)</td><td align="center">在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td align="center">@CachePut</td><td align="center">将方法的返回值放到缓存中</td></tr><tr><td align="center">@CacheEvict(cacheNames &#x3D; “数据库名”,[allEntries(是否全部删除) &#x3D; true],key &#x3D; “要删除的键”)</td><td align="center">将一条或多条数据从缓存中删除</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Plus</title>
      <link href="/inori/1276cc28.html"/>
      <url>/inori/1276cc28.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://baomidou.com/">MyBatis-Plus</a>是<a href="https://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生</p><p>特性：</p><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><p>支持数据库：</p><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库，优炫数据库</li></ul><h2 id="MyBatis-Plus核心功能"><a href="#MyBatis-Plus核心功能" class="headerlink" title="MyBatis-Plus核心功能"></a>MyBatis-Plus核心功能</h2><h3 id="基于Mapper接口CRUD"><a href="#基于Mapper接口CRUD" class="headerlink" title="基于Mapper接口CRUD"></a>基于Mapper接口CRUD</h3><blockquote><p>通用 CRUD 封装BaseMapper接口，<code>Mybatis-Plus</code>启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器! 内部包含常见的单表操作！</p></blockquote><h4 id="Insert方法"><a href="#Insert方法" class="headerlink" title="Insert方法"></a>Insert方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="comment">// T 就是要插入的实体对象</span></span><br><span class="line"><span class="comment">// 默认主键生成策略为雪花算法（后面讲解）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>T</td><td>entity</td><td>实体对象</td></tr></tbody></table><h4 id="Delete方法"><a href="#Delete方法" class="headerlink" title="Delete方法"></a>Delete方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>Wrapper<T></td><td>wrapper</td><td>实体对象封装操作类（可以为 null）</td></tr><tr><td>Collection&lt;? extends Serializable&gt;</td><td>idList</td><td>主键 ID 列表(不能为 null 以及 empty)</td></tr><tr><td>Serializable</td><td>id</td><td>主键 ID</td></tr><tr><td>Map&lt;String, Object&gt;</td><td>columnMap</td><td>表字段 map 对象</td></tr></tbody></table><h4 id="Update方法"><a href="#Update方法" class="headerlink" title="Update方法"></a>Update方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, </span></span><br><span class="line"><span class="params"><span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 修改  主键属性必须值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>T</td><td>entity</td><td>实体对象 (set 条件值,可为 null)</td></tr><tr><td>Wrapper<T></td><td>updateWrapper</td><td>实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</td></tr></tbody></table><h4 id="Select方法"><a href="#Select方法" class="headerlink" title="Select方法"></a>Select方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><p>参数说明</p><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>Serializable</td><td>id</td><td>主键 ID</td></tr><tr><td>Wrapper<T></td><td>queryWrapper</td><td>实体对象封装操作类（可以为 null）</td></tr><tr><td>Collection&lt;? extends Serializable&gt;</td><td>idList</td><td>主键 ID 列表(不能为 null 以及 empty)</td></tr><tr><td>Map&lt;String, Object&gt;</td><td>columnMap</td><td>表字段 map 对象</td></tr><tr><td>IPage<T></td><td>page</td><td>分页查询条件（可以为 RowBounds.DEFAULT）</td></tr></tbody></table><h4 id="自定义和多表映射"><a href="#自定义和多表映射" class="headerlink" title="自定义和多表映射"></a>自定义和多表映射</h4><p>mybatis-plus的默认mapperxml位置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> <span class="comment"># mybatis-plus的配置</span></span><br><span class="line"><span class="comment"># 默认位置 private String[] mapperLocations = new String[]&#123;&quot;classpath*:/mapper/**/*.xml&quot;&#125;;    </span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>自定义mapper方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常自定义方法！</span></span><br><span class="line"><span class="comment">//可以使用注解@Select或者mapper.xml实现</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于mapper.xml实现：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace = 接口的全限定符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于Service接口CRUD"><a href="#基于Service接口CRUD" class="headerlink" title="基于Service接口CRUD"></a>基于Service接口CRUD</h3><p>通用 Service CRUD 封装<a href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java">IService (opens new window)</a>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</p><h4 id="对比Mapper接口CRUD区别："><a href="#对比Mapper接口CRUD区别：" class="headerlink" title="对比Mapper接口CRUD区别："></a>对比Mapper接口CRUD区别：</h4><ul><li>service添加了批量方法</li><li>service层的方法自动添加事务</li></ul><h4 id="使用Iservice接口方式"><a href="#使用Iservice接口方式" class="headerlink" title="使用Iservice接口方式"></a>使用Iservice接口方式</h4><p>接口继承IService接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类继承ServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CRUD方法介绍"><a href="#CRUD方法介绍" class="headerlink" title="CRUD方法介绍"></a>CRUD方法介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">保存：</span><br><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">修改或者保存：</span><br><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">移除：</span><br><span class="line"><span class="comment">// 根据 queryWrapper 设置的条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">更新：</span><br><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">数量： </span><br><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">查询：</span><br><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line">集合：</span><br><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分页查询实现"><a href="#分页查询实现" class="headerlink" title="分页查询实现"></a>分页查询实现</h3><ol><li>导入分页插件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用分页查询</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置分页参数</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//获取分页数据</span></span><br><span class="line">    List&lt;User&gt; list = page.getRecords();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页：&quot;</span>+page.getCurrent());</span><br><span class="line">    System.out.println(<span class="string">&quot;每页显示的条数：&quot;</span>+page.getSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span>+page.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span>+page.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有上一页：&quot;</span>+page.hasPrevious());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有下一页：&quot;</span>+page.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义的mapper方法使用分页</li></ol><p>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数携带Ipage接口</span></span><br><span class="line"><span class="comment">//返回结果为IPage</span></span><br><span class="line">IPage&lt;User&gt; <span class="title function_">selectPageVo</span><span class="params">(IPage&lt;?&gt; page, Integer id)</span>;</span><br></pre></td></tr></table></figure><p>接口实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectPageVo&quot;</span> resultType=<span class="string">&quot;xxx.xxx.xxx.User&quot;</span>&gt;</span><br><span class="line">SELECT * FROM user WHERE id &gt; #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    userMapper.selectPageVo(page,<span class="number">2</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> page.getCurrent();</span><br><span class="line">    System.out.println(<span class="string">&quot;current = &quot;</span> + current);</span><br><span class="line">    <span class="type">long</span> <span class="variable">pages</span> <span class="operator">=</span> page.getPages();</span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + pages);</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();</span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + total);</span><br><span class="line">    <span class="type">List</span> <span class="variable">records</span> <span class="operator">=</span> page.getRecords();</span><br><span class="line">    System.out.println(<span class="string">&quot;records = &quot;</span> + records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件构造器使用"><a href="#条件构造器使用" class="headerlink" title="条件构造器使用"></a>条件构造器使用</h3><h4 id="条件构造器作用"><a href="#条件构造器作用" class="headerlink" title="条件构造器作用"></a>条件构造器作用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>); <span class="comment">// 添加等于条件</span></span><br><span class="line">queryWrapper.ne(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>); <span class="comment">// 添加不等于条件</span></span><br><span class="line">queryWrapper.like(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;@gmail.com&quot;</span>); <span class="comment">// 添加模糊匹配条件</span></span><br><span class="line">等同于： </span><br><span class="line">delete from user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;John&quot;</span> and age != <span class="number">30</span></span><br><span class="line">and email like <span class="string">&quot;%@gmail.com%&quot;</span></span><br><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure><p>使用MyBatis-Plus的条件构造器，你可以构建灵活、高效的查询条件，而不需要手动编写复杂的 SQL 语句。它提供了许多方法来支持各种条件操作符，并且可以通过链式调用来组合多个条件。这样可以简化查询的编写过程，并提高开发效率。</p><h4 id="条件构造器继承结构"><a href="#条件构造器继承结构" class="headerlink" title="条件构造器继承结构"></a>条件构造器继承结构</h4><p>Wrapper：条件构造抽象类，最顶端父类</p><ul><li>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件</li><li>QueryWrapper ： 查询&#x2F;删除条件封装</li><li>UpdateWrapper ： 修改条件封装</li><li>AbstractLambdaWrapper ： 使用Lambda 语法</li><li>LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper</li><li>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</li></ul><h4 id="基于QueryWrapper-组装条件"><a href="#基于QueryWrapper-组装条件" class="headerlink" title="基于QueryWrapper 组装条件"></a>基于QueryWrapper 组装条件</h4><p>组装查询条件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息</span></span><br><span class="line"><span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    .between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">    .isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装排序条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//按年龄降序查询用户，如果年龄相同则按id升序排列</span></span><br><span class="line"><span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">    .orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    .orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装删除条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//删除email为空的用户</span></span><br><span class="line"><span class="comment">//DELETE FROM t_user WHERE (email IS NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="comment">//条件构造器也可以构建删除语句的条件</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and和or关键字使用(修改)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改</span></span><br><span class="line"><span class="comment">//UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL)</span></span><br><span class="line">    queryWrapper</span><br><span class="line">    .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    .gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    .or()</span><br><span class="line">    .isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定列映射查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//查询用户信息的username和age字段</span></span><br><span class="line"><span class="comment">//SELECT username,age FROM t_user</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="comment">//selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>condition判断组织条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//判断条件拼接</span></span><br><span class="line">    <span class="comment">//当name不为null拼接等于, age &gt; 1 拼接等于判断</span></span><br><span class="line">    <span class="comment">//方案1: 手动判断</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(name))&#123;</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方案2: 拼接condition判断</span></span><br><span class="line">    <span class="comment">//每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!</span></span><br><span class="line">    <span class="comment">//eq(condition,列名,值)</span></span><br><span class="line">    queryWrapper.eq(!StringUtils.isEmpty(name),<span class="string">&quot;name&quot;</span>,name)</span><br><span class="line">    .eq(age&gt;<span class="number">1</span>,<span class="string">&quot;age&quot;</span>,age);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于UpdateWrapper组装条件"><a href="#基于UpdateWrapper组装条件" class="headerlink" title="基于UpdateWrapper组装条件"></a>基于UpdateWrapper组装条件</h4><p>使用queryWrapper + 实体类形式可以实现修改，但是无法将列值修改为null值！</p><p>使用updateWrapper:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将id = 3 的email设置为null, age = 18</span></span><br><span class="line">updateWrapper.eq(<span class="string">&quot;id&quot;</span>,<span class="number">3</span>)</span><br><span class="line">.set(<span class="string">&quot;email&quot;</span>,<span class="literal">null</span>)  <span class="comment">// set 指定列和结果</span></span><br><span class="line">.set(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="comment">//如果使用updateWrapper 实体对象写null即可!</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用updateWrapper可以随意设置列的值！！</p><h4 id="基于LambdaQueryWrapper组装条件"><a href="#基于LambdaQueryWrapper组装条件" class="headerlink" title="基于LambdaQueryWrapper组装条件"></a>基于LambdaQueryWrapper组装条件</h4><ol><li><strong>LambdaQueryWrapper对比QueryWrapper优势</strong></li></ol><p>QueryWrapper 示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>)</span><br><span class="line">.ge(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">.orderByDesc(<span class="string">&quot;create_time&quot;</span>)</span><br><span class="line">.last(<span class="string">&quot;limit 10&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure><p>LambdaQueryWrapper 示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">lambdaQueryWrapper.eq(User::getName, <span class="string">&quot;John&quot;</span>)</span><br><span class="line">.ge(User::getAge, <span class="number">18</span>)</span><br><span class="line">.orderByDesc(User::getCreateTime)</span><br><span class="line">.last(<span class="string">&quot;limit 10&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(lambdaQueryWrapper);</span><br></pre></td></tr></table></figure><p>从上面的代码对比可以看出，相比于 QueryWrapper，LambdaQueryWrapper 使用了实体类的属性引用（例如 <code>User::getName</code>、<code>User::getAge</code>），而不是字符串来表示字段名，这提高了代码的可读性和可维护性。</p><ol start="2"><li><strong>lambda表达式</strong></li></ol><p>Lambda 表达式是 Java 8 引入的一种函数式编程特性，它提供了一种更简洁、更直观的方式来表示匿名函数或函数式接口的实现。Lambda 表达式可以用于简化代码，提高代码的可读性和可维护性。</p><p>Lambda 表达式的语法可以分为以下几个部分：</p><ul><li><strong>参数列表：</strong> 参数列表用小括号 <code>()</code> 括起来，可以指定零个或多个参数。如果没有参数，可以省略小括号；如果只有一个参数，可以省略小括号。</li></ul><p>示例：<code>(a, b)</code>, <code>x -&gt;</code>, <code>() -&gt;</code></p><ul><li><strong>箭头符号：</strong> 箭头符号 <code>-&gt;</code> 分割参数列表和 Lambda 表达式的主体部分。</li></ul><p>示例：<code>-&gt;</code></p><ul><li><strong>Lambda 表达式的主体：</strong> Lambda 表达式的主体部分可以是一个表达式或一个代码块。如果是一个表达式，可以省略 return 关键字；如果是多条语句的代码块，需要使用大括号 <code>&#123;&#125;</code> 括起来，并且需要明确指定 return 关键字。</li></ul><p>示例：</p><ul><li>单个表达式：<code>x -&gt; x * x</code></li><li>代码块：<code>(x, y) -&gt; &#123; int sum = x + y; return sum; &#125;</code></li></ul><p>Lambda 表达式的语法可以更具体地描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式实现一个接口的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始匿名内部类方式</span></span><br><span class="line"><span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a-&gt;System.out.println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lambda 表达式实现接口的方法</span></span><br><span class="line">greeting = () -&gt; System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out::println;</span><br><span class="line">() -&gt;  类.XXX(); -&gt; 类：：方法名</span><br><span class="line"><span class="comment">// 调用接口的方法</span></span><br><span class="line">greeting.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 方法引用:</strong></p><p>方法引用是 Java 8 中引入的一种语法特性，它提供了一种简洁的方式来直接引用已有的方法或构造函数。方法引用可以替代 Lambda 表达式，使代码更简洁、更易读。</p><p>Java 8 支持以下几种方法引用的形式：</p><ul><li><p><strong>静态方法引用：</strong> 引用静态方法，语法为 <code>类名::静态方法名</code>。</p></li><li><p><strong>实例方法引用：</strong> 引用实例方法，语法为 <code>实例对象::实例方法名</code>。</p></li><li><p><strong>对象方法引用：</strong> 引用特定对象的实例方法，语法为 <code>类名::实例方法名</code>。</p></li><li><p><strong>构造函数引用：</strong> 引用构造函数，语法为 <code>类名::new</code>。</p></li></ul><p>演示代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReferenceExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">        names.forEach(name -&gt; System.out.println(name));</span><br><span class="line">        <span class="comment">// 使用方法引用</span></span><br><span class="line">        names.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. lambdaQueryWrapper使用案例:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">int</span>    <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!</span></span><br><span class="line">    <span class="comment">//eq(condition,列名,值)</span></span><br><span class="line">    queryWrapper.eq(!StringUtils.isEmpty(name),<span class="string">&quot;name&quot;</span>,name)</span><br><span class="line">    .eq(age&gt;<span class="number">1</span>,<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 使用lambdaQueryWrapper</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//注意: 需要使用方法引用</span></span><br><span class="line">    <span class="comment">//技巧: 类名::方法名</span></span><br><span class="line">    lambdaQueryWrapper.eq(!StringUtils.isEmpty(name), User::getName,name);</span><br><span class="line">    List&lt;User&gt; users= userMapper.selectList(lambdaQueryWrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于LambdaUpdateWrapper组装条件"><a href="#基于LambdaUpdateWrapper组装条件" class="headerlink" title="基于LambdaUpdateWrapper组装条件"></a>基于LambdaUpdateWrapper组装条件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将id = 3 的email设置为null, age = 18</span></span><br><span class="line">updateWrapper.eq(<span class="string">&quot;id&quot;</span>,<span class="number">3</span>)</span><br><span class="line">.set(<span class="string">&quot;email&quot;</span>,<span class="literal">null</span>)  <span class="comment">// set 指定列和结果</span></span><br><span class="line">.set(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambdaUpdateWrapper</span></span><br><span class="line">LambdaUpdateWrapper&lt;User&gt; updateWrapper1 = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">updateWrapper1.eq(User::getId,<span class="number">3</span>)</span><br><span class="line">.set(User::getEmail,<span class="literal">null</span>)</span><br><span class="line">.set(User::getAge,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用updateWrapper 实体对象写null即可!</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心注解使用"><a href="#核心注解使用" class="headerlink" title="核心注解使用"></a>核心注解使用</h3><ol><li>理解和介绍</li></ol><p>MyBatis-Plus是一个基于MyBatis框架的增强工具，提供了一系列简化和增强的功能，用于加快开发人员在使用MyBatis进行数据库访问时的效率。</p><p>MyBatis-Plus提供了一种基于注解的方式来定义和映射数据库操作，其中的注解起到了重要作用。</p><p>理解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口对应的方法为什么会自动触发 user表的crud呢？</p><p>默认情况下， 根据指定的&lt;实体类&gt;的名称对应数据库表名，属性名对应数据库的列名！</p><p>但是不是所有数据库的信息和实体类都完全映射！</p><p>例如： 表名 t_user  → 实体类 User 这时候就不对应了！</p><p>自定义映射关系就可以使用mybatis-plus提供的注解即可！<br>2. @TableName注解</p><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span> <span class="comment">//对应数据库表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊情况：如果表名和实体类名相同（忽略大小写）可以省略该注解！</p><p>其他解决方案：<a href="https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">全局设置前缀</a></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> <span class="comment"># mybatis-plus的配置</span></span><br><span class="line"><span class="attr">global-config:</span></span><br><span class="line"><span class="attr">db-config:</span></span><br><span class="line"><span class="attr">table-prefix:</span> <span class="string">sys_</span> <span class="comment"># 表名前缀字符串</span></span><br></pre></td></tr></table></figure><ol start="3"><li>@TableId 注解</li></ol><ul><li>描述：主键注解</li><li>使用位置：实体类主键字段</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@TableId(value=&quot;主键列名&quot;,type=主键策略)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>类型</th><th>必须指定</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>主键字段名</td></tr><tr><td>type</td><td>Enum</td><td>否</td><td>IdType.NONE</td><td>指定主键类型</td></tr></tbody></table><p><a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/IdType.java">IdType</a>属性可选值：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>AUTO</td><td>数据库 ID 自增 (mysql配置主键自增长)</td></tr><tr><td>ASSIGN_ID（默认）</td><td>分配 ID(主键类型为 Number(Long )或 String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td></tr></tbody></table><p>全局配置修改主键策略:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">configuration:</span><br><span class="line"># 配置MyBatis日志</span><br><span class="line">log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">global-config:</span><br><span class="line">db-config:</span><br><span class="line"># 配置MyBatis-Plus操作表的默认前缀</span><br><span class="line">table-prefix: t_</span><br><span class="line"># 配置MyBatis-Plus的主键策略</span><br><span class="line">id-type: auto</span><br></pre></td></tr></table></figure><p>在以下场景下，添加<code>@TableId</code>注解是必要的：</p><ol><li>实体类的字段与数据库表的主键字段不同名：如果实体类中的字段与数据库表的主键字段不一致，需要使用<code>@TableId</code>注解来指定实体类中表示主键的字段。</li><li>主键生成策略不是默认策略：如果需要使用除了默认主键生成策略以外的策略，也需要添加<code>@TableId</code>注解，并通过<code>value</code>属性指定生成策略。</li><li>雪花算法使用场景</li></ol><p>雪花算法（Snowflake Algorithm）是一种用于生成唯一ID的算法。它由Twitter公司提出，用于解决分布式系统中生成全局唯一ID的需求。</p><p>在传统的自增ID生成方式中，使用单点数据库生成ID会成为系统的瓶颈，而雪花算法通过在分布式系统中生成唯一ID，避免了单点故障和性能瓶颈的问题。</p><p>雪花算法生成的ID是一个64位的整数，由以下几个部分组成：</p><ol><li>时间戳：41位，精确到毫秒级，可以使用69年。</li><li>节点ID：10位，用于标识分布式系统中的不同节点。</li><li>序列号：12位，表示在同一毫秒内生成的不同ID的序号。</li></ol><p>通过将这三个部分组合在一起，雪花算法可以在分布式系统中生成全局唯一的ID，并保证ID的生成顺序性。</p><p>雪花算法的工作方式如下：</p><ol><li>当前时间戳从某一固定的起始时间开始计算，可以用于计算ID的时间部分。</li><li>节点ID是分布式系统中每个节点的唯一标识，可以通过配置或自动分配的方式获得。</li><li>序列号用于记录在同一毫秒内生成的不同ID的序号，从0开始自增，最多支持4096个ID生成。</li></ol><p>需要注意的是，雪花算法依赖于系统的时钟，需要确保系统时钟的准确性和单调性，否则可能会导致生成的ID不唯一或不符合预期的顺序。</p><p>雪花算法是一种简单但有效的生成唯一ID的算法，广泛应用于分布式系统中，如微服务架构、分布式数据库、分布式锁等场景，以满足全局唯一标识的需求。</p><p>雪花算法生成的数字,需要使用Long 或者 String类型主键<br>5. @TableField</p><p>描述：字段注解（非主键）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@TableId</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="meta">@TableField(&quot;nickname&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MyBatis-Plus会自动开启驼峰命名风格映射</strong></p><h2 id="MyBatis-Plus高级扩展"><a href="#MyBatis-Plus高级扩展" class="headerlink" title="MyBatis-Plus高级扩展"></a>MyBatis-Plus高级扩展</h2><h3 id="逻辑删除实现"><a href="#逻辑删除实现" class="headerlink" title="逻辑删除实现"></a>逻辑删除实现</h3><p><strong>概念:</strong></p><p>逻辑删除，可以方便地实现对数据库记录的逻辑删除而不是物理删除。逻辑删除是指通过更改记录的状态或添加标记字段来模拟删除操作，从而保留了删除前的数据，便于后续的数据分析和恢复。</p><ul><li>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</li><li>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</li></ul><p><strong>逻辑删除实现:</strong></p><ol><li>数据库和实体类添加逻辑删除字段</li><li>表添加逻辑删除字段</li></ol><p>可以是一个布尔类型、整数类型或枚举类型。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> deleted <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> ;  # <span class="type">int</span> 类型 <span class="number">1</span> 逻辑删除 <span class="number">0</span> 未逻辑删除</span><br></pre></td></tr></table></figure><ol start="2"><li>实体类添加逻辑删除属性</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line">public class <span class="keyword">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="variable">@TableId</span></span><br><span class="line">private <span class="type">Integer</span> id;</span><br><span class="line">private String name;</span><br><span class="line">private <span class="type">Integer</span> age;</span><br><span class="line">private String email;</span><br><span class="line"></span><br><span class="line"><span class="variable">@TableLogic</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>逻辑删除字段 <span class="type">int</span> mybatis<span class="operator">-</span>plus下,默认 逻辑删除值为<span class="number">1</span> 未逻辑删除 <span class="number">1</span> </span><br><span class="line">private <span class="type">Integer</span> deleted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>指定逻辑删除字段和属性值</li><li>单一指定</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line">public class <span class="keyword">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="variable">@TableId</span></span><br><span class="line">private <span class="type">Integer</span> id;</span><br><span class="line">private String name;</span><br><span class="line">private <span class="type">Integer</span> age;</span><br><span class="line">private String email;</span><br><span class="line"><span class="variable">@TableLogic</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>逻辑删除字段 <span class="type">int</span> mybatis<span class="operator">-</span>plus下,默认 逻辑删除值为<span class="number">1</span> 未逻辑删除 <span class="number">1</span> </span><br><span class="line">private <span class="type">Integer</span> deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>全局指定</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"><span class="attr">global-config:</span></span><br><span class="line"><span class="attr">db-config:</span></span><br><span class="line"><span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line"><span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line"><span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><h4 id="悲观锁和乐观锁场景和介绍"><a href="#悲观锁和乐观锁场景和介绍" class="headerlink" title="悲观锁和乐观锁场景和介绍"></a>悲观锁和乐观锁场景和介绍</h4><p><strong>并发问题场景演示:</strong></p><p><img src="https://secure2.wostatic.cn/static/nWoVTstK7jnH8ida2Urujn/image.png?auth_key=1711513165-swYv5xUT1t4HAcN64ZBD7D-0-aa35481fb137c5a1fb50a1488ffff7bf"></p><p>​    </p><p>**解决思路: **</p><p>乐观锁和悲观锁是在并发编程中用于处理并发访问和资源竞争的两种不同的锁机制!!</p><p>悲观锁:<br>悲观锁的基本思想是，在整个数据访问过程中，将共享资源锁定，以确保其他线程或进程不能同时访问和修改该资源。悲观锁的核心思想是”先保护，再修改”。在悲观锁的应用中，线程在访问共享资源之前会获取到锁，并在整个操作过程中保持锁的状态，阻塞其他线程的访问。只有当前线程完成操作后，才会释放锁，让其他线程继续操作资源。这种锁机制可以确保资源独占性和数据的一致性，但是在高并发环境下，悲观锁的效率相对较低。</p><p>乐观锁:<br>乐观锁的基本思想是，认为并发冲突的概率较低，因此不需要提前加锁，而是在数据更新阶段进行冲突检测和处理。乐观锁的核心思想是”先修改，后校验”。在乐观锁的应用中，线程在读取共享资源时不会加锁，而是记录特定的版本信息。当线程准备更新资源时，会先检查该资源的版本信息是否与之前读取的版本信息一致，如果一致则执行更新操作，否则说明有其他线程修改了该资源，需要进行相应的冲突处理。乐观锁通过避免加锁操作，提高了系统的并发性能和吞吐量，但是在并发冲突较为频繁的情况下，乐观锁会导致较多的冲突处理和重试操作。</p><p>理解点: 悲观锁和乐观锁是两种解决并发数据问题的思路</p><p><strong>具体技术和方案:</strong></p><ol><li>乐观锁实现方案和技术：</li></ol><ul><li>版本号&#x2F;时间戳：为数据添加一个版本号或时间戳字段，每次更新数据时，比较当前版本号或时间戳与期望值是否一致，若一致则更新成功，否则表示数据已被修改，需要进行冲突处理。</li><li>CAS（Compare-and-Swap）：使用原子操作比较当前值与旧值是否一致，若一致则进行更新操作，否则重新尝试。</li><li>无锁数据结构：采用无锁数据结构，如无锁队列、无锁哈希表等，通过使用原子操作实现并发安全。</li></ul><ol start="2"><li>悲观锁实现方案和技术：</li></ol><ul><li>锁机制：使用传统的锁机制，如互斥锁（Mutex Lock）或读写锁（Read-Write Lock）来保证对共享资源的独占访问。</li><li>数据库锁：在数据库层面使用行级锁或表级锁来控制并发访问。</li><li>信号量（Semaphore）：使用信号量来限制对资源的并发访问。</li></ul><p><strong>介绍版本号乐观锁技术的实现流程:</strong></p><ul><li>每条数据添加一个版本号字段version</li><li>取出记录时，获取当前 version</li><li>更新时，检查获取版本号是不是数据库当前最新版本号</li><li>如果是[证明没有人修改数据], 执行更新, set 数据更新 , version &#x3D; version+ 1 </li><li>如果 version 不对[证明有人已经修改了]，我们现在的其他记录就是失效数据!就更新失败</li></ul><h4 id="使用mybatis-plus数据使用乐观锁"><a href="#使用mybatis-plus数据使用乐观锁" class="headerlink" title="使用mybatis-plus数据使用乐观锁"></a>使用mybatis-plus数据使用乐观锁</h4><ol><li>添加版本号更新插件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乐观锁字段添加@Version注解</p><p>注意: 数据库也需要添加version字段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER ADD VERSION INT DEFAULT <span class="number">1</span> ;  # <span class="type">int</span> 类型 乐观锁字段</span><br></pre></td></tr></table></figure><ul><li>支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime</li><li>仅支持 <code>updateById(id)</code> 与 <code>update(entity, wrapper)</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure><ol start="2"><li>正常更新使用即可</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示乐观锁生效场景</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//步骤1: 先查询,在更新 获取version数据</span></span><br><span class="line">    <span class="comment">//同时查询两条,但是version唯一,最后更新的失败</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span>  <span class="operator">=</span> userMapper.selectById(<span class="number">5</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span>  <span class="operator">=</span> userMapper.selectById(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user1.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">    <span class="comment">//乐观锁生效,失败!</span></span><br><span class="line">    userMapper.updateById(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防全表更新和删除实现"><a href="#防全表更新和删除实现" class="headerlink" title="防全表更新和删除实现"></a>防全表更新和删除实现</h3><p>针对 update 和 delete 语句 作用: 阻止恶意的全表更新删除</p><p>添加防止全表更新和删除拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试全部更新或者删除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick8</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;custom_name&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;xxx@mail.com&quot;</span>);</span><br><span class="line">    <span class="comment">//Caused by: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: Prohibition of table update operation</span></span><br><span class="line">    <span class="comment">//全局更新,报错</span></span><br><span class="line">    userService.saveOrUpdate(user,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向工程和MybatisX插件"><a href="#逆向工程和MybatisX插件" class="headerlink" title="逆向工程和MybatisX插件"></a>逆向工程和MybatisX插件</h2><h3 id="ORM思维介绍"><a href="#ORM思维介绍" class="headerlink" title="ORM思维介绍"></a>ORM思维介绍</h3><p>ORM（Object-Relational Mapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作!!</p><p>最终<strong>可以使用面向对象思维进行数据库操作</strong></p><p><strong>ORM 框架通常有半自动和全自动两种方式</strong></p><ul><li>半自动 ORM 通常需要程序员手动编写 SQL 语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。</li><li>全自动 ORM 则是将实体类和数据表进行自动映射，使用 API 进行数据库操作时，ORM 框架会自动执行 SQL 语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL 语句和转换代码。</li></ul><p><strong>半自动和全自动 ORM 框架的区别：</strong></p><ol><li>映射方式：半自动 ORM 框架需要程序员手动指定实体类和数据表之间的映射关系，通常使用 XML 文件或注解方式来指定；全自动 ORM 框架则可以自动进行实体类和数据表的映射，无需手动干预。</li><li>查询方式：半自动 ORM 框架通常需要程序员手动编写 SQL 语句并将查询结果集转换成实体对象；全自动 ORM 框架可以自动组装 SQL 语句、执行查询操作，并将查询结果转换成实体对象。</li><li>性能：由于半自动 ORM 框架需要手动编写 SQL 语句，因此程序员必须对 SQL 语句和数据库的底层知识有一定的了解，才能编写高效的 SQL 语句；而全自动 ORM 框架通过自动优化生成的 SQL 语句来提高性能，程序员无需进行优化。</li><li>学习成本：半自动 ORM 框架需要程序员手动编写 SQL 语句和映射配置，要求程序员具备较高的数据库和 SQL 知识；全自动 ORM 框架可以自动生成 SQL 语句和映射配置，程序员无需了解过多的数据库和 SQL 知识。</li></ol><p>常见的半自动 ORM 框架包括 MyBatis 等；常见的全自动 ORM 框架包括 Hibernate、Spring Data JPA、MyBatis-Plus 等。</p><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>MyBatis 的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml 文件、Mapper 接口等代码文件，简化了开发者手动生成的过程。逆向工程使开发者可以快速地构建起 DAO 层，并快速上手进行业务开发。<br>MyBatis 的逆向工程有两种方式：通过 MyBatis Generator 插件实现和通过 Maven 插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接 URL、用户名、密码、要生成的表名、生成的文件路径等等。<br>总的来说，逆向工程为程序员提供了一种方便快捷的方式，能够快速地生成持久层代码和映射文件，是半自动 ORM 思维像全自动发展的过程，提高程序员的开发效率。</p><p>逆向工程只能生成单表crud的操作，多表查询依然需要自己编写！</p><h3 id="逆向工程插件MyBatisX使用"><a href="#逆向工程插件MyBatisX使用" class="headerlink" title="逆向工程插件MyBatisX使用"></a>逆向工程插件MyBatisX使用</h3><p>MyBatisX 是一个 MyBatis 的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo 类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤：</p><ol><li>安装插件：</li></ol><p>在 IntelliJ IDEA 中打开插件市场，搜索 MyBatisX 并安装。<br>2. 使用 IntelliJ IDEA连接数据库</p><ul><li><p>连接数据库</p></li><li><p>逆向工程使用</p></li></ul><p><img src="https://secure2.wostatic.cn/static/s6LMYQtxCLAQ86ScJS5Kam/image.png?auth_key=1711513456-irs5D2suoMaDcbvLMLPAvw-0-6770defa442ddcfaf7713d246a720652"></p><p>逆向工程案例使用,自动生成单表的crud方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> 针对表【user】的数据库操作Mapper</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertSelective</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">User <span class="title function_">selectByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateByPrimaryKeySelective</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot3框架入门</title>
      <link href="/inori/21ae6bf2.html"/>
      <url>/inori/21ae6bf2.html</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot3介绍"><a href="#SpringBoot3介绍" class="headerlink" title="SpringBoot3介绍"></a>SpringBoot3介绍</h2><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.introducing-spring-boot">SpringBoot</a>帮我们简单、快速地创建一个独立的、生产级别的 <strong>Spring应用（说明：SpringBoot底层是Spring）</strong>，大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术</p><p>SpringBoot的主要目标是：</p><ul><li>为所有 Spring 开发提供更快速、可广泛访问的入门体验。</li><li>开箱即用，设置合理的默认值，但是也可以根据需求进行适当的调整。</li><li>提供一系列大型项目通用的非功能性程序（如嵌入式服务器、安全性、指标、运行检查等）。</li><li>约定大于配置，基本不需要主动编写配置类、也不需要 XML 配置文件。</li></ul><p><strong>总结：简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。</strong></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><blockquote><p>场景：浏览器发送**&#x2F;hello**请求，返回”<strong>Hello,Spring Boot 3!</strong>“</p></blockquote><ol><li><p>开发步骤</p><ol><li><strong>创建Maven工程</strong></li><li><strong>添加依赖(springboot父工程依赖 , web启动器依赖)</strong></li><li><strong>编写启动引导类(springboot项目运行的入口)</strong></li><li><strong>编写处理器Controller</strong></li><li><strong>启动项目</strong></li></ol></li><li><p>创建项目</p></li><li><p>添加依赖</p></li></ol><ul><li>添加父工程坐标</li></ul><p>SpringBoot可以帮我们方便的管理项目依赖 , 在Spring Boot提供了一个名为<strong>spring-boot-starter-parent</strong>的工程，里面已经对各种常用依赖的版本进行了管理，需要以这个项目为父工程，这样就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标(不需要添加版本)即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--所有springboot项目都必须继承自 spring-boot-starter-parent--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加web启动器</li></ul><p>为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的<strong>自动配置依赖</strong>，我们称为<strong>启动器</strong>。因为是web项目，这里引入web启动器，在pom.xml文件中加入如下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--web开发的场景启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>创建package和启动类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@SpringBootApplication</span>是一个特殊的注解，用于标识一个Spring Boot应用程序的入口类。它的主要作用是将三个常用注解组合在一起，简化了配置的过程。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 具体而言，<span class="doctag">@SpringBootApplication</span>注解包含以下三个注解的功能：</span></span><br><span class="line"><span class="comment">*     <span class="doctag">@Configuration</span>：将该类标识为应用程序的配置类。它允许使用Java代码定义和配置Bean。</span></span><br><span class="line"><span class="comment">*     <span class="doctag">@EnableAutoConfiguration</span>：启用Spring Boot的自动配置机制。它根据项目的依赖项自动配置Spring应用程序的行为。自动配置根据类路径、注解和配置属性等条件来决定要使用的功能和配置。</span></span><br><span class="line"><span class="comment">*     <span class="doctag">@ComponentScan</span>：自动扫描并加载应用程序中的组件，如控制器、服务、存储库等。它默认扫描<span class="doctag">@SpringBootApplication</span>注解所在类的包及其子包中的组件。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用<span class="doctag">@SpringBootApplication</span>注解，可以将上述三个注解的功能集中在一个注解上，简化了配置文件的编写和组件的加载和扫描过程。它是Spring Boot应用程序的入口点，标识了应用程序的主类，</span></span><br><span class="line"><span class="comment">* 并告诉Spring Boot在启动时应如何配置和加载应用程序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SpringApplication.run() 方法是启动 Spring Boot 应用程序的关键步骤。它创建应用程序上下文、</span></span><br><span class="line"><span class="comment">// 自动配置应用程序、启动应用程序，并处理命令行参数，使应用程序能够运行和提供所需的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(MainApplication.class,args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>编写处理器Controller</p><p>IoC和DI注解需要在启动类的同包或者子包下方可生效，无需指定，约束俗称。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot 3!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>为什么依赖不需要写版本？</li></ol><ul><li>每个boot项目都有一个父项目<code>spring-boot-starter-parent</code></li><li>parent的父项目是<code>spring-boot-dependencies</code></li><li>父项目 <strong>版本仲裁中心</strong>，把所有常见的jar的依赖版本都声明好了。</li></ul><ol start="2"><li>启动器(Starter)</li></ol><p>Spring Boot提供了一种叫做Starter的概念，它是一组预定义的依赖项集合，旨在简化Spring应用程序的配置和构建过程。Starter包含了一组相关的依赖项，以便在启动应用程序时自动引入所需的库、配置和功能。</p><p>主要作用如下：</p><ol><li>简化依赖管理：Spring Boot Starter通过捆绑和管理一组相关的依赖项，减少了手动解析和配置依赖项的工作。只需引入一个相关的Starter依赖，即可获取应用程序所需的全部依赖。</li><li>自动配置：Spring Boot Starter在应用程序启动时自动配置所需的组件和功能。通过根据类路径和其他设置的自动检测，Starter可以自动配置Spring Bean、数据源、消息传递等常见组件，从而使应用程序的配置变得简单和维护成本降低。</li><li>提供约定优于配置：Spring Boot Starter遵循“约定优于配置”的原则，通过提供一组默认设置和约定，减少了手动配置的需要。它定义了标准的配置文件命名约定、默认属性值、日志配置等，使得开发者可以更专注于业务逻辑而不是繁琐的配置细节。</li><li>快速启动和开发应用程序：Spring Boot Starter使得从零开始构建一个完整的Spring Boot应用程序变得容易。它提供了主要领域（如Web开发、数据访问、安全性、消息传递等）的Starter，帮助开发者快速搭建一个具备特定功能的应用程序原型。</li><li>模块化和可扩展性：Spring Boot Starter的组织结构使得应用程序的不同模块可以进行分离和解耦。每个模块可以有自己的Starter和依赖项，使得应用程序的不同部分可以按需进行开发和扩展。</li></ol><p>Spring Boot提供了许多预定义的Starter，例如spring-boot-starter-web用于构建Web应用程序，spring-boot-starter-data-jpa用于使用JPA进行数据库访问，spring-boot-starter-security用于安全认证和授权等等。</p><p>使用Starter非常简单，只需要在项目的构建文件（例如Maven的pom.xml）中添加所需的Starter依赖，Spring Boot会自动处理依赖管理和配置。</p><p>通过使用Starter，开发人员可以方便地引入和配置应用程序所需的功能，避免了手动添加大量的依赖项和编写冗长的配置文件的繁琐过程。同时，Starter也提供了一致的依赖项版本管理，确保依赖项之间的兼容性和稳定性。</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">spring boot提供的全部启动器</a></p><p>命名规范：</p><ul><li>官方提供的场景：命名为：<code>spring-boot-starter-*</code></li><li>第三方提供场景：命名为：<code>*-spring-boot-starter</code></li></ul><ol start="3"><li>@SpringBootApplication注解的功效？</li></ol><p>@SpringBootApplication添加到启动类上，是一个组合注解，他的功效有具体的子注解实现！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br></pre></td></tr></table></figure><p>@SpringBootApplication注解是Spring Boot框架中的核心注解，它的主要作用是简化和加速Spring Boot应用程序的配置和启动过程。</p><p>具体而言，@SpringBootApplication注解起到以下几个主要作用：</p><ol><li>自动配置：@SpringBootApplication注解包含了@EnableAutoConfiguration注解，用于启用Spring Boot的自动配置机制。自动配置会根据应用程序的依赖项和类路径，自动配置各种常见的Spring配置和功能，减少开发者的手动配置工作。它通过智能地分析类路径、加载配置和条件判断，为应用程序提供适当的默认配置。</li><li>组件扫描：@SpringBootApplication注解包含了@ComponentScan注解，用于自动扫描并加载应用程序中的组件，例如控制器（Controllers）、服务（Services）、存储库（Repositories）等。它默认会扫描@SpringBootApplication注解所在类的包及其子包中的组件，并将它们纳入Spring Boot应用程序的上下文中，使它们可被自动注入和使用。</li><li>声明配置类：@SpringBootApplication注解本身就是一个组合注解，它包含了@Configuration注解，将被标注的类声明为配置类。配置类可以包含Spring框架相关的配置、Bean定义，以及其他的自定义配置。通过@SpringBootApplication注解，开发者可以将配置类与启动类合并在一起，使得配置和启动可以同时发生。</li></ol><p>总的来说，@SpringBootApplication注解的主要作用是简化Spring Boot应用程序的配置和启动过程。它自动配置应用程序、扫描并加载组件，并将配置和启动类合二为一，简化了开发者的工作量，提高了开发效率。</p><h2 id="SpringBoot3配置文件"><a href="#SpringBoot3配置文件" class="headerlink" title="SpringBoot3配置文件"></a>SpringBoot3配置文件</h2><h3 id="统一配置管理概述"><a href="#统一配置管理概述" class="headerlink" title="统一配置管理概述"></a>统一配置管理概述</h3><p>SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（<code>application.properties</code>或<code>application.yml</code>）中！</p><p>配置文件应该放置在Spring Boot工程的<code>src/main/resources</code>目录下。这是因为<code>src/main/resources</code>目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">功能配置参数说明</a></p><p>细节总结：</p><ul><li>集中式管理配置。统一在一个文件完成程序功能参数设置和自定义参数声明 。</li><li>位置：resources文件夹下，必须命名application  后缀 .properties &#x2F; .yaml &#x2F;  .yml 。</li><li>如果同时存在application.properties | application.yml(.yaml) , properties的优先级更高。</li><li>配置基本都有默认值。</li></ul><h3 id="属性配置文件使用"><a href="#属性配置文件使用" class="headerlink" title="属性配置文件使用"></a>属性配置文件使用</h3><ol><li>配置文件</li></ol><p>在 resource 文件夹下面新建 application.properties 配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># application.properties 为统一配置文件</span><br><span class="line"># 内部包含: 固定功能的key,自定义的key</span><br><span class="line"># 此处的配置信息,我们都可以在程序中@Value等注解读取</span><br><span class="line"></span><br><span class="line"># 固定的key</span><br><span class="line"># 启动端口号</span><br><span class="line">server.port=80 </span><br><span class="line"></span><br><span class="line"># 自定义</span><br><span class="line">spring.jdbc.datasource.driverClassName=com.mysql.cj.jdbc.driver</span><br><span class="line">spring.jdbc.datasource.url=jdbc:mysql:///springboot</span><br><span class="line">spring.jdbc.datasource.username=root</span><br><span class="line">spring.jdbc.datasource.password=root</span><br></pre></td></tr></table></figure><ol start="2"><li>读取配置文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.driverClassName&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.url&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.password&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试效果</li></ol><p>在controller注入，输出进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSourceProperties dataSourceProperties ;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(dataSourceProperties);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello Spring Boot ! &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="YAML配置文件使用"><a href="#YAML配置文件使用" class="headerlink" title="YAML配置文件使用"></a>YAML配置文件使用</h3><ol><li>yaml格式介绍</li></ol><p>YAML（YAML Ain’t Markup Language）是一种基于层次结构的数据序列化格式，旨在提供一种易读、人类友好的数据表示方式。</p><p>与<code>.properties</code>文件相比，YAML格式有以下优势：</p><ul><li>层次结构：YAML文件使用缩进和冒号来表示层次结构，使得数据之间的关系更加清晰和直观。这样可以更容易理解和维护复杂的配置，特别适用于深层次嵌套的配置情况。</li><li>自我描述性：YAML文件具有自我描述性，字段和值之间使用冒号分隔，并使用缩进表示层级关系。这使得配置文件更易于阅读和理解，并且可以减少冗余的标点符号和引号。</li><li>注释支持：YAML格式支持注释，可以在配置文件中添加说明性的注释，使配置更具可读性和可维护性。相比之下，<code>.properties</code>文件不支持注释，无法提供类似的解释和说明。</li><li>多行文本：YAML格式支持多行文本的表示，可以更方便地表示长文本或数据块。相比之下，<code>.properties</code>文件需要使用转义符或将长文本拆分为多行。</li><li>类型支持：YAML格式天然支持复杂的数据类型，如列表、映射等。这使得在配置文件中表示嵌套结构或数据集合更加容易，而不需要进行额外的解析或转换。</li><li>更好的可读性：由于YAML格式的特点，它更容易被人类读懂和解释。它减少了配置文件中需要的特殊字符和语法，让配置更加清晰明了，从而减少了错误和歧义。</li></ul><p>综上所述，YAML格式相对于<code>.properties</code>文件具有更好的层次结构表示、自我描述性、注释支持、多行文本表示、复杂数据类型支持和更好的可读性。这些特点使YAML成为一种有力的配置文件格式，尤其适用于复杂的配置需求和人类可读的场景。然而，选择使用YAML还是<code>.properties</code>取决于实际需求和团队的偏好，简单的配置可以使用<code>.properties</code>，而复杂的配置可以选择YAML以获得更多的灵活性和可读性<br>2. yaml语法说明</p><ol><li>数据结构用树形结构呈现，通过缩进来表示层级，</li><li>连续的项目（集合）通过减号 ” - ” 来表示</li><li>键值结构里面的key&#x2F;value对用冒号 ” : ” 来分隔。</li><li>YAML配置文件的扩展名是yaml 或 yml</li><li>例如：</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># YAML配置文件示例</span></span><br><span class="line"><span class="attr">app_name:</span> <span class="string">我的应用程序</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">张三</span></span><br><span class="line"></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5432</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">features:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">登录</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">注册</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">仪表盘</span></span><br><span class="line"></span><br><span class="line"><span class="attr">settings:</span></span><br><span class="line">    <span class="attr">analytics:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">theme:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">jdbc:</span></span><br><span class="line">        <span class="attr">datasource:</span></span><br><span class="line">            <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">jdbc:mysql:///springboot_02</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">            <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><ol start="4"><li>读取配置文件</li></ol><p>读取方式和properties一致</p><h3 id="批量配置文件注入"><a href="#批量配置文件注入" class="headerlink" title="批量配置文件注入"></a>批量配置文件注入</h3><blockquote><p> <strong>@ConfigurationProperties</strong>是SpringBoot提供的重要注解, 他可以将一些配置属性批量注入到bean对象。</p></blockquote><ol><li>创建类，添加属性和注解</li></ol><p>在类上通过@ConfigurationProperties注解声明该类要读取属性配置</p><p>prefix&#x3D;”spring.jdbc.datasource” 读取属性文件中前缀为spring.jdbc.datasource的值。前缀和属性名称和配置文件中的key必须要保持一致才可以注入成功</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.jdbc.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfigurationProperties</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><ol start="2"><li>测试效果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceProperties dataSourceProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceConfigurationProperties dataSourceConfigurationProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dataSourceProperties = &quot;</span> + dataSourceProperties);</span><br><span class="line">        System.out.println(<span class="string">&quot;dataSourceConfigurationProperties = &quot;</span> + dataSourceConfigurationProperties);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot 3!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多环境配置和使用"><a href="#多环境配置和使用" class="headerlink" title="多环境配置和使用"></a>多环境配置和使用</h3><ol><li>需求</li></ol><p>在Spring Boot中，可以使用多环境配置来根据不同的运行环境（如开发、测试、生产）加载不同的配置。SpringBoot支持多环境配置让应用程序在不同的环境中使用不同的配置参数，例如数据库连接信息、日志级别、缓存配置等。</p><p>以下是实现Spring Boot多环境配置的常见方法：</p><ol><li>属性文件分离：将应用程序的配置参数分离到不同的属性文件中，每个环境对应一个属性文件。例如，可以创建<code>application-dev.properties</code>、<code>application-prod.properties</code>和<code>application-test.properties</code>等文件。在这些文件中，可以定义各自环境的配置参数，如数据库连接信息、端口号等。然后，在<code>application.properties</code>中通过<code>spring.profiles.active</code>属性指定当前使用的环境。Spring Boot会根据该属性来加载对应环境的属性文件，覆盖默认的配置。</li><li>YAML配置文件：与属性文件类似，可以将配置参数分离到不同的YAML文件中，每个环境对应一个文件。例如，可以创建<code>application-dev.yml</code>、<code>application-prod.yml</code>和<code>application-test.yml</code>等文件。在这些文件中，可以使用YAML语法定义各自环境的配置参数。同样，通过<code>spring.profiles.active</code>属性指定当前的环境，Spring Boot会加载相应的YAML文件。</li><li>命令行参数(动态)：可以通过命令行参数来指定当前的环境。例如，可以使用<code>--spring.profiles.active=dev</code>来指定使用开发环境的配置。</li></ol><p>通过上述方法，Spring Boot会根据当前指定的环境来加载相应的配置文件或参数，从而实现多环境配置。这样可以简化在不同环境之间的配置切换，并且确保应用程序在不同环境中具有正确的配置。<br>2. 多环境配置（基于方式b实践）</p><blockquote><p>创建开发、测试、生产三个环境的配置文件</p></blockquote><p>application-dev.yml（开发）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///dev</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p>application-test.yml（测试）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///test</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p>application-prod.yml（生产）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///prod</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><ol start="3"><li>环境激活</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line"><span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><p><strong>注意 :</strong></p><p>如果设置了spring.profiles.active，并且和application有重叠属性，以active设置优先。</p><p>如果设置了spring.profiles.active，和application无重叠属性，application设置依然生效！</p><h2 id="SpringBoot3整合SpringMVC"><a href="#SpringBoot3整合SpringMVC" class="headerlink" title="SpringBoot3整合SpringMVC"></a>SpringBoot3整合SpringMVC</h2><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ol><li>创建程序</li><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-starter-springmvc-03<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        web开发的场景启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建启动类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建实体类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username ;</span><br><span class="line">    <span class="keyword">private</span> String password ;</span><br><span class="line">    <span class="keyword">private</span> Integer age ;</span><br><span class="line">    <span class="keyword">private</span> String sex ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>编写Controller</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;杨过&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        user.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="web相关配置"><a href="#web相关配置" class="headerlink" title="web相关配置"></a>web相关配置</h3><p>位置：application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># web相关的配置</span></span><br><span class="line"><span class="comment"># https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment"># 端口号设置</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># 项目根路径</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/boot</span></span><br></pre></td></tr></table></figure><p>当涉及Spring Boot的Web应用程序配置时，以下是五个重要的配置参数：</p><ol><li><code>server.port</code>: 指定应用程序的HTTP服务器端口号。默认情况下，Spring Boot使用8080作为默认端口。您可以通过在配置文件中设置<code>server.port</code>来更改端口号。</li><li><code>server.servlet.context-path</code>: 设置应用程序的上下文路径。这是应用程序在URL中的基本路径。默认情况下，上下文路径为空。您可以通过在配置文件中设置<code>server.servlet.context-path</code>属性来指定自定义的上下文路径。</li><li><code>spring.mvc.view.prefix</code>和<code>spring.mvc.view.suffix</code>: 这两个属性用于配置视图解析器的前缀和后缀。视图解析器用于解析控制器返回的视图名称，并将其映射到实际的视图页面。<code>spring.mvc.view.prefix</code>定义视图的前缀，<code>spring.mvc.view.suffix</code>定义视图的后缀。</li><li><code>spring.resources.static-locations</code>: 配置静态资源的位置。静态资源可以是CSS、JavaScript、图像等。默认情况下，Spring Boot会将静态资源放在<code>classpath:/static</code>目录下。您可以通过在配置文件中设置<code>spring.resources.static-locations</code>属性来自定义静态资源的位置。</li><li><code>spring.http.encoding.charset</code>和<code>spring.http.encoding.enabled</code>: 这两个属性用于配置HTTP请求和响应的字符编码。<code>spring.http.encoding.charset</code>定义字符编码的名称（例如UTF-8），<code>spring.http.encoding.enabled</code>用于启用或禁用字符编码的自动配置。</li></ol><p>这些是在Spring Boot的配置文件中与Web应用程序相关的一些重要配置参数。根据您的需求，您可以在配置文件中设置这些参数来定制和配置您的Web应用程序</p><h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><blockquote><p>在WEB开发中我们需要引入一些静态资源 , 例如 : HTML , CSS , JS , 图片等 , 如果是普通的项目静态资源可以放在项目的webapp目录下。现在使用Spring Boot做开发 , 项目中没有webapp目录 , 我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？</p></blockquote><ol><li>默认路径</li></ol><p>在springboot中就定义了静态资源的默认查找路径：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web;</span><br><span class="line"><span class="comment">//..................</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> String[] staticLocations;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> addMappings;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> customized;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Chain chain;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Resources</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line"><span class="built_in">this</span>.addMappings = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.customized = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">this</span>.chain = <span class="keyword">new</span> <span class="title class_">Chain</span>();</span><br><span class="line"><span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="title class_">Cache</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...........        </span></span><br></pre></td></tr></table></figure><p><strong>默认的静态资源路径为：</strong></p><p><strong>· classpath:&#x2F;META-INF&#x2F;resources&#x2F;</strong></p><p><strong>· classpath:&#x2F;resources&#x2F;</strong></p><p><strong>· classpath:&#x2F;static&#x2F;</strong></p><p><strong>· classpath:&#x2F;public&#x2F;</strong></p><p>我们只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:&#x2F;static&#x2F; 目录下。在resources目录下创建index.html文件</p><ol start="2"><li>覆盖路径</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># web相关的配置</span></span><br><span class="line"><span class="comment"># https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment"># 端口号设置</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># 项目根路径</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/boot</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="comment"># 配置静态资源地址,如果设置,会覆盖默认值</span></span><br><span class="line"><span class="attr">static-locations:</span> <span class="string">classpath:/webapp</span></span><br></pre></td></tr></table></figure><h3 id="自定义拦截器-SpringMVC配置"><a href="#自定义拦截器-SpringMVC配置" class="headerlink" title="自定义拦截器(SpringMVC配置)"></a>自定义拦截器(SpringMVC配置)</h3><ol><li>拦截器声明</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor拦截器的preHandle方法执行....&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor拦截器的postHandle方法执行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor拦截器的afterCompletion方法执行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>拦截器配置</li></ol><p>正常使用配置类，只要保证，<strong>配置类要在启动类的同包或者子包方可生效！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyInterceptor myInterceptor ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* /**  拦截当前目录及子目录下的所有路径 /user/**   /user/findAll  /user/order/findAll</span></span><br><span class="line"><span class="comment">* /*   拦截当前目录下的以及子路径   /user/*     /user/findAll</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">registry.addInterceptor(myInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot3整合Druid数据源"><a href="#SpringBoot3整合Druid数据源" class="headerlink" title="SpringBoot3整合Druid数据源"></a>SpringBoot3整合Druid数据源</h2><ol><li>创建程序</li><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-starter-druid-04<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  web开发的场景启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid启动器的依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 驱动类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>配置文件编写</li></ol><blockquote><p>添加druid连接池的基本配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="comment"># 连接池类型 </span></span><br><span class="line"><span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Druid的其他属性配置 springboot3整合情况下,数据库连接信息必须在Druid属性下!</span></span><br><span class="line"><span class="attr">druid:</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/day01</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># 初始化时建立物理连接的个数</span></span><br><span class="line"><span class="attr">initial-size:</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># 连接池的最小空闲数量</span></span><br><span class="line"><span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># 连接池最大连接数量</span></span><br><span class="line"><span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line"><span class="comment"># 获取连接时最大等待时间，单位毫秒</span></span><br><span class="line"><span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line"><span class="comment"># 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</span></span><br><span class="line"><span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 既作为检测的间隔时间又作为testWhileIdel执行的依据</span></span><br><span class="line"><span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line"><span class="comment"># 销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接(配置连接在池中的最小生存时间)</span></span><br><span class="line"><span class="attr">min-evictable-idle-time-millis:</span> <span class="number">30000</span></span><br><span class="line"><span class="comment"># 用来检测数据库连接是否有效的sql 必须是一个查询语句(oracle中为 select 1 from dual)</span></span><br><span class="line"><span class="attr">validation-query:</span> <span class="string">select</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line"><span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line"><span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否缓存preparedStatement, 也就是PSCache,PSCache对支持游标的数据库性能提升巨大，比如说oracle,在mysql下建议关闭。</span></span><br><span class="line"><span class="attr">pool-prepared-statements:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</span></span><br><span class="line"><span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">-1</span></span><br><span class="line"><span class="comment"># 合并多个DruidDataSource的监控数据</span></span><br><span class="line"><span class="attr">use-global-data-source-stat:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">level:</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><ol start="5"><li>编写Controller</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users where id = ? ; &quot;</span>;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), <span class="number">1</span>);</span><br><span class="line">log.info(<span class="string">&quot;查询的user数据为:&#123;&#125;&quot;</span>,user.toString());</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>启动测试</li></ol><h2 id="SpringBoot3整合Mybatis"><a href="#SpringBoot3整合Mybatis" class="headerlink" title="SpringBoot3整合Mybatis"></a>SpringBoot3整合Mybatis</h2><h3 id="MyBatis整合步骤"><a href="#MyBatis整合步骤" class="headerlink" title="MyBatis整合步骤"></a>MyBatis整合步骤</h3><ol><li>导入依赖：在Spring Boot项目的构建文件（如pom.xml）中添加MyBatis和数据库驱动的相关依赖。例如，如果使用MySQL数据库，您需要添加MyBatis和MySQL驱动的依赖。</li><li>配置数据源：在<code>application.properties</code>或<code>application.yml</code>中配置数据库连接信息，包括数据库URL、用户名、密码、mybatis的功能配置等。</li><li>创建实体类：创建与数据库表对应的实体类。</li><li>创建Mapper接口：创建与数据库表交互的Mapper接口。</li><li>创建Mapper接口SQL实现:可以使用mapperxml文件或者注解方式</li><li>创建程序启动类</li><li>注解扫描：在Spring Boot的主应用类上添加<code>@MapperScan</code>注解，用于扫描和注册Mapper接口。</li><li>使用Mapper接口：在需要使用数据库操作的地方，通过依赖注入或直接实例化Mapper接口，并调用其中的方法进行数据库操作。</li></ol><h3 id="Mybatis整合实践"><a href="#Mybatis整合实践" class="headerlink" title="Mybatis整合实践"></a>Mybatis整合实践</h3><ol><li>创建项目</li><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid启动器的依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 驱动类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">druid:</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///day01</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">configuration:</span>  <span class="comment"># setting配置</span></span><br><span class="line"><span class="attr">auto-mapping-behavior:</span> <span class="string">full</span></span><br><span class="line"><span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.slf4j.Slf4jImpl</span></span><br><span class="line"><span class="attr">type-aliases-package:</span> <span class="string">pojo</span> <span class="comment"># 配置别名</span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span> <span class="comment"># mapperxml位置</span></span><br></pre></td></tr></table></figure><ol start="4"><li>实体类准备</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String account ;</span><br><span class="line">    <span class="keyword">private</span> String password ;</span><br><span class="line">    <span class="keyword">private</span> Integer id ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>Mapper接口准备</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>Mapper接口实现（XML）</li></ol><p>位置：resources&#x2F;mapper&#x2F;UserMapper.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line"><span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;!-- namespace = 接口的全限定符 --&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;queryAll&quot;</span> resultType=<span class="string">&quot;user&quot;</span>&gt;</span><br><span class="line">select * from users</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>编写三层架构代码</li></ol><p>controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">List&lt;User&gt; userList = userService.findList();</span><br><span class="line">log.info(<span class="string">&quot;查询的user数据为:&#123;&#125;&quot;</span>,userList);</span><br><span class="line"><span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findList</span><span class="params">()</span>&#123;</span><br><span class="line">List&lt;User&gt; users = userMapper.queryAll();</span><br><span class="line">log.info(<span class="string">&quot;查询全部数据:&#123;&#125;&quot;</span>,users);</span><br><span class="line"><span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>启动类和接口扫描</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;mapper&quot;)</span> <span class="comment">//mapper接口扫描配置</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="9"><li>启动测试</li></ol><h3 id="声明式事务整合配置"><a href="#声明式事务整合配置" class="headerlink" title="声明式事务整合配置"></a>声明式事务整合配置</h3><p>依赖导入:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：SpringBoot项目会自动配置一个 DataSourceTransactionManager，所以我们只需在方法（或者类）加上 @Transactional 注解，就自动纳入 Spring 的事务管理了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">1</span>);</span><br><span class="line">user.setPassword(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">user.setAccount(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">userMapper.update(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOP整合配置"><a href="#AOP整合配置" class="headerlink" title="AOP整合配置"></a>AOP整合配置</h3><p>依赖导入:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接使用aop注解即可: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com..service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LogAdvice.before&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;joinPoint = &quot;</span> + joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot3项目打包和运行"><a href="#SpringBoot3项目打包和运行" class="headerlink" title="SpringBoot3项目打包和运行"></a>SpringBoot3项目打包和运行</h2><h3 id="添加打包插件"><a href="#添加打包插件" class="headerlink" title="添加打包插件"></a>添加打包插件</h3><blockquote><p>在Spring Boot项目中添加<code>spring-boot-maven-plugin</code>插件是为了支持将项目打包成可执行的可运行jar包。如果不添加<code>spring-boot-maven-plugin</code>插件配置，使用常规的<code>java -jar</code>命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行打包"><a href="#执行打包" class="headerlink" title="执行打包"></a>执行打包</h3><p>在idea点击package进行打包,可以在编译的target文件中查看jar包</p><h3 id="命令启动和参数说明"><a href="#命令启动和参数说明" class="headerlink" title="命令启动和参数说明"></a>命令启动和参数说明</h3><p><code>java -jar</code>命令用于在Java环境中执行可执行的JAR文件。下面是关于<code>java -jar</code>命令的说明：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">命令格式：java -jar  [选项] [参数] <span class="tag">&lt;<span class="name">jar文件名</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性，可以通过<code>System.getProperty()</code>方法在应用程序中获取该属性值。例如：<code>java -jar -Dserver.port=8080 myapp.jar</code>。</li><li><code>-X</code>：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括：</li></ol><ul><li><code>-Xmx&lt;size&gt;</code>：设置JVM的最大堆内存大小，例如 <code>-Xmx512m</code> 表示设置最大堆内存为512MB。</li><li><code>-Xms&lt;size&gt;</code>：设置JVM的初始堆内存大小，例如 <code>-Xms256m</code> 表示设置初始堆内存为256MB。</li></ul><ol start="3"><li><code>-Dspring.profiles.active=&lt;profile&gt;</code>：指定Spring Boot的激活配置文件，可以通过<code>application-&lt;profile&gt;.properties</code>或<code>application-&lt;profile&gt;.yml</code>文件来加载相应的配置。例如：<code>java -jar -Dspring.profiles.active=dev myapp.jar</code>。</li></ol><p>注意：-D 参数必须要在jar之前！否者不生效！</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC框架入门</title>
      <link href="/inori/faa8450.html"/>
      <url>/inori/faa8450.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">Spring Web MVC</a>是基于Servlet API构建的原始Web框架,SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化</p><p><img src="https://secure2.wostatic.cn/static/bnm9zUQo34z7FgXA9vAmfm/image.png?auth_key=1711510047-qBsPAaHR88tC2aDLqhpekV-0-b3cb1c35742a1e107a3a8c3877ea1ebe"></p><p>SpringMVC的作用主要覆盖的是表述层，例如：</p><ul><li>请求映射</li><li>数据输入</li><li>视图界面</li><li>请求分发</li><li>表单回显</li><li>会话控制</li><li>过滤拦截</li><li>异步交互</li><li>文件上传</li><li>文件下载</li><li>数据校验</li><li>类型转换</li></ul><p><strong>总结：</strong></p><ol><li>简化前端参数接收( 形参列表 )</li><li>简化后端数据响应(返回值)</li><li>以及其他……</li></ol><h2 id="SpringMVC核心组件和调用流程"><a href="#SpringMVC核心组件和调用流程" class="headerlink" title="SpringMVC核心组件和调用流程"></a>SpringMVC核心组件和调用流程</h2><p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code> <code>DispatcherServlet</code> 做整体请求处理调度！</p><p>除了<code>DispatcherServlet</code>SpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。</p><p><strong>SpringMVC处理请求流程：</strong></p><p><img src="https://secure2.wostatic.cn/static/no1PDXU3JX5K4cecSAx5oL/image.png?auth_key=1711510176-53NMzAsNwUn8BfjGcoEv4M-0-fd69e4a59e527b36adecb53b624ec5d2"></p><p><strong>SpringMVC涉及组件理解：</strong></p><ol><li>DispatcherServlet:SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发</li><li>HandlerMapping:SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler</li><li>HandlerAdapter:SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器</li><li>Handler:handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果</li><li>ViewResovler:SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的</li></ol><h2 id="SpringMVC接收数据"><a href="#SpringMVC接收数据" class="headerlink" title="SpringMVC接收数据"></a>SpringMVC接收数据</h2><h3 id="访问路径设置"><a href="#访问路径设置" class="headerlink" title="访问路径设置"></a>访问路径设置</h3><p>@RequestMapping注解的作用就是将请求的URL地址和处理请求的方式（handler方法）关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。</p><ol><li><strong>精准路径匹配</strong></li></ol><p>在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>模糊路径匹配</strong></li></ol><p>在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  路径设置为 /product/*  </span></span><br><span class="line"><span class="comment">*    /* 为单层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">*    /product/a/a 不可以</span></span><br><span class="line"><span class="comment">*  路径设置为 /product/** </span></span><br><span class="line"><span class="comment">*   /** 为任意层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">*   /product/a/a 也可以访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/product/*&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductController.show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;product show!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单层匹配和多层匹配：<br><code>/*</code>：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“&#x2F;*&#x2F;*”以此类推。<br><code>/**</code>：可以匹配URL地址中的多层。<br>其中所谓的一层或多层是指一个URL地址字符串被“&#x2F;”划分出来的各个层次<br>这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。</p><ol start="3"><li><strong>类和方法级别区别</strong></li></ol><p><code>@RequestMapping</code> 注解可以用于类级别和方法级别，它们之间的区别如下：</p><ol><li>设置到类级别：<code>@RequestMapping</code> 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。</li><li>设置到方法级别：<code>@RequestMapping</code> 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 <code>@RequestMapping</code> 注解进行更精细的映射。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.标记到handler方法</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/logout&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.优化标记类+handler方法</span></span><br><span class="line"><span class="comment">//类上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//handler方法上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>附带请求方式限制</strong></li></ol><p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问</p><p>如果需要特定指定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">* method = RequestMethod.POST 可以指定单个或者多个请求方式!</span></span><br><span class="line"><span class="comment">* 注意:违背请求方式会出现405异常!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>进阶注解</strong></li></ol><p>还有 <code>@RequestMapping</code> 的 HTTP 方法特定快捷方式变体：</p><ul><li><code>@GetMapping</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code></li><li><code>@DeleteMapping</code></li><li><code>@PatchMapping</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)</span></span><br><span class="line">||</span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/login&quot;)</span></span><br></pre></td></tr></table></figure><p>注意：进阶注解只能添加到handler方法上，无法添加到类上！</p><h3 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h3><h4 id="param和json参数比较"><a href="#param和json参数比较" class="headerlink" title="param和json参数比较"></a>param和json参数比较</h4><p>在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比：</p><ol><li>参数编码：</li></ol><p>param 类型的参数会被编码为 ASCII 码。例如，假设 <code>name=john doe</code>，则会被编码为 <code>name=john%20doe</code>。而 JSON 类型的参数会被编码为 UTF-8。<br>2. 参数顺序：  </p><p>param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。<br>3. 数据类型：  </p><p>param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。<br>4. 嵌套性：  </p><p>param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。<br>5. 可读性：  </p><p>param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。</p><p>总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p><h4 id="param参数接收"><a href="#param参数接收" class="headerlink" title="param参数接收"></a>param参数接收</h4><ol><li><strong>直接接值</strong></li></ol><p>handler接收参数</p><p>只要形参数名和类型与传递参数相同，即可自动接收!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 可以利用形参列表,直接接收前端传递的param参数!</span></span><br><span class="line"><span class="comment">*    要求: 参数名 = 形参名</span></span><br><span class="line"><span class="comment">*          类型相同</span></span><br><span class="line"><span class="comment">* 出现乱码正常，json接收具体解决！！</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回前端数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@GetMapping(value=&quot;/value&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setupForm</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> name + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>@RequestParam注解</strong></li></ol><p>可以使用 <code>@RequestParam</code> 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p><p><code>@RequestParam</code>使用场景：</p><ul><li>指定绑定的请求参数名</li><li>要求请求参数必须传递</li><li>为请求参数提供默认值</li></ul><p>基本用法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*  使用<span class="doctag">@RequestParam</span>注解标记handler方法的形参</span></span><br><span class="line"><span class="comment">*  指定形参对应的请求参数<span class="doctag">@RequestParam</span>(请求参数名称)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(&quot;stuAge&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，使用此批注的方法参数是必需的，但您可以通过将 <code>@RequestParam</code> 批注的 <code>required</code> 标志设置为 <code>false</code>！</p><p>将参数设置非必须，并且设置默认值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params"><span class="meta">@RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line"><span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>特殊场景接值</strong></li></ol><p>一名多值:多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  一名多值,可以使用集合接收即可!但是需要使用<span class="doctag">@RequestParam</span>注解指定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/mul&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">mulForm</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hbs)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hbs = &quot;</span> + hbs);</span><br><span class="line"><span class="keyword">return</span> hbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体接收:Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。</p><p>定义一个用于接收参数的实体类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制器中，使用实体对象接收，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line"><span class="comment">// 在这里可以使用 user 对象的属性来接收请求参数</span></span><br><span class="line">System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！</p><h4 id="路径-参数接收"><a href="#路径-参数接收" class="headerlink" title="路径 参数接收"></a>路径 参数接收</h4><p>路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 <code>@PathVariable</code> 注解来处理路径传递参数。</p><p><code>@PathVariable</code> 注解允许将 URL 中的占位符映射到控制器方法中的参数。</p><p>例如，如果我们想将 <code>/user/&#123;id&#125;</code> 路径下的 <code>&#123;id&#125;</code> 映射到控制器方法的一个参数中，则可以使用 <code>@PathVariable</code> 注解来实现。</p><p>下面是一个使用 <code>@PathVariable</code> 注解处理路径传递参数的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!</span></span><br><span class="line"><span class="comment">* 形参列表取值: <span class="doctag">@PathVariable</span> Long id  如果形参名 = &#123;动态标识&#125; 自动赋值!</span></span><br><span class="line"><span class="comment">*              <span class="doctag">@PathVariable</span>(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, </span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;name&quot;)</span> String uname)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id + <span class="string">&quot;, uname = &quot;</span> + uname);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user_detail&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="json参数接收"><a href="#json参数接收" class="headerlink" title="json参数接收"></a>json参数接收</h4><p>前端传递 JSON 数据时，Spring MVC 框架可以使用 <code>@RequestBody</code> 注解来将 JSON 数据转换为 Java 对象。<code>@RequestBody</code> 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下：</p><ol><li>前端发送 JSON 数据的示例：</li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义一个用于接收 JSON 数据的 Java 类，例如：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在控制器中，使用 <code>@RequestBody</code> 注解来接收 JSON 数据，并将其转换为 Java 对象，例如：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里可以使用 person 对象来操作 JSON 数据中包含的属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>@RequestBody</code> 注解将请求体中的 JSON 数据映射到 <code>Person</code> 类型的 <code>person</code> 参数上，并将其作为一个对象来传递给 <code>addPerson()</code> 方法进行处理。<br>4. 完善配置</p><p>springmvc handlerAdpater配置json转化器,配置类需要明确：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"><span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"><span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"><span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pom.xml 加入jackson依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>@EnableWebMvc注解说明</li></ol><p>@EnableWebMvc注解效果等同于在 XML 配置中，可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 元素</p><h3 id="接收Cookie数据"><a href="#接收Cookie数据" class="headerlink" title="接收Cookie数据"></a>接收Cookie数据</h3><p>可以使用 <code>@CookieValue</code> 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。</p><p>考虑使用以下 cookie 的请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收请求头数据"><a href="#接收请求头数据" class="headerlink" title="接收请求头数据"></a>接收请求头数据</h3><p>可以使用 <code>@RequestHeader</code> 批注将请求标头绑定到控制器中的方法参数。</p><p>请考虑以下带有标头的请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Host                    localhost:<span class="number">8080</span></span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span></span><br><span class="line">Accept-Language         fr,en-gb;q=<span class="number">0.7</span>,en;q=<span class="number">0.3</span></span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line">Keep-Alive              <span class="number">300</span></span><br></pre></td></tr></table></figure><p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span><br><span class="line"><span class="params"><span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="type">long</span> keepAlive)</span> &#123; </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原生Api对象操作"><a href="#原生Api对象操作" class="headerlink" title="原生Api对象操作"></a>原生Api对象操作</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html">https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html</a></p><p>下表描述了支持的控制器方法参数</p><table><thead><tr><th>Controller method argument 控制器方法参数</th><th>Description</th></tr></thead><tbody><tr><td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td><td>请求&#x2F;响应对象</td></tr><tr><td><code>jakarta.servlet.http.HttpSession</code></td><td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td></tr><tr><td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td>用于访问由 Servlet API 公开的原始请求正文。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问由 Servlet API 公开的原始响应正文。</td></tr><tr><td><code>@PathVariable</code></td><td>接收路径参数注解</td></tr><tr><td><code>@RequestParam</code></td><td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestHeader</code></td><td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td></tr><tr><td><code>@CookieValue</code></td><td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestBody</code></td><td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>共享域对象，并在视图呈现过程中向模板公开。</td></tr><tr><td><code>Errors</code>, <code>BindingResult</code></td><td>验证和数据绑定中的错误信息获取对象！</td></tr></tbody></table><p>获取原生对象示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!</span></span><br><span class="line"><span class="comment">* 注意: 接收原生对象,并不影响参数接收!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">api</span><span class="params">(HttpSession session , HttpServletRequest request,</span></span><br><span class="line"><span class="params">    HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;method = &quot;</span> + method);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享域对象操作"><a href="#共享域对象操作" class="headerlink" title="共享域对象操作"></a>共享域对象操作</h3><h4 id="属性（共享）域作用回顾"><a href="#属性（共享）域作用回顾" class="headerlink" title="属性（共享）域作用回顾"></a>属性（共享）域作用回顾</h4><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p><ol><li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。</li><li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。</li><li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。</li><li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li></ol><p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p><h4 id="Request级别属性（共享）域"><a href="#Request级别属性（共享）域" class="headerlink" title="Request级别属性（共享）域"></a>Request级别属性（共享）域</h4><ol><li>使用 Model 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModel</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 在形参位置声明Model类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">Model model)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line"><span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">model.addAttribute(<span class="string">&quot;requestScopeMessageModel&quot;</span>,<span class="string">&quot;i am very happy[model]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 ModelMap 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModelMap</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 在形参位置声明ModelMap类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">ModelMap modelMap)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line"><span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">modelMap.addAttribute(<span class="string">&quot;requestScopeMessageModelMap&quot;</span>,<span class="string">&quot;i am very happy[model map]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 Map 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestMap</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 在形参位置声明Map类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line"><span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">map.put(<span class="string">&quot;requestScopeMessageMap&quot;</span>, <span class="string">&quot;i am very happy[map]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用原生 request 对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/original&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrOriginalRequest</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 拿到原生对象，就可以调用原生方法执行各种操作</span></span><br><span class="line"><span class="params">HttpServletRequest request)</span> &#123;</span><br><span class="line"></span><br><span class="line">request.setAttribute(<span class="string">&quot;requestScopeMessageOriginal&quot;</span>, <span class="string">&quot;i am very happy[original]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用 ModelAndView 对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/mav&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testAttrByModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建ModelAndView对象</span></span><br><span class="line"><span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line"><span class="comment">// 2.存入模型数据</span></span><br><span class="line">modelAndView.addObject(<span class="string">&quot;requestScopeMessageMAV&quot;</span>, <span class="string">&quot;i am very happy[mav]&quot;</span>);</span><br><span class="line"><span class="comment">// 3.设置视图名称</span></span><br><span class="line">modelAndView.setViewName(<span class="string">&quot;target&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Session级别属性（共享）域"><a href="#Session级别属性（共享）域" class="headerlink" title="Session级别属性（共享）域"></a>Session级别属性（共享）域</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/session&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line"><span class="comment">//直接对session对象操作,即对会话范围操作!</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Application级别属性（共享）域"><a href="#Application级别属性（共享）域" class="headerlink" title="Application级别属性（共享）域"></a>Application级别属性（共享）域</h4><p>springmvc会在初始化容器的时候，把servletContext对象存储到ioc容器中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/attr/application&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">attrApplication</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">servletContext.setAttribute(<span class="string">&quot;appScopeMsg&quot;</span>, <span class="string">&quot;i am hungry...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC响应数据"><a href="#SpringMVC响应数据" class="headerlink" title="SpringMVC响应数据"></a>SpringMVC响应数据</h2><h3 id="handler方法分析"><a href="#handler方法分析" class="headerlink" title="handler方法分析"></a>handler方法分析</h3><p>理解handler方法的作用和组成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> 一个controller的方法是控制层的一个处理器,我们称为handler</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> handler需要使用<span class="doctag">@RequestMapping</span>/<span class="doctag">@GetMapping</span>系列,声明路径,在HandlerMapping中注册,供DS查找!</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> handler作用总结:</span></span><br><span class="line"><span class="comment">*       1.接收请求参数(param,json,pathVariable,共享域等) </span></span><br><span class="line"><span class="comment">*       2.调用业务逻辑 </span></span><br><span class="line"><span class="comment">*       3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等)</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> handler如何处理呢</span></span><br><span class="line"><span class="comment">*       1.接收参数: handler(形参列表: 主要的作用就是用来接收参数)</span></span><br><span class="line"><span class="comment">*       2.调用业务: &#123; 方法体  可以向后调用业务方法 service.xx() &#125;</span></span><br><span class="line"><span class="comment">*       3.响应数据: return 返回结果,可以快速响应前端数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handler</span><span class="params">(简化请求参数接收)</span>&#123;</span><br><span class="line">    调用业务方法</span><br><span class="line">    返回的结果 （页面跳转，返回数据（json））</span><br><span class="line">    <span class="keyword">return</span> 简化响应前端数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求数据接收，我们都是通过handler的形参列表</p><p>前端数据响应，我们都是通过handler的return关键字快速处理</p><p>springmvc简化了参数接收和响应</p><h3 id="页面跳转控制"><a href="#页面跳转控制" class="headerlink" title="页面跳转控制"></a>页面跳转控制</h3><h4 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h4><p>在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 <code>redirect</code> 或者 <code>forward</code> 关键字来实现重定向。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirectDemo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 重定向到 /demo 路径 </span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/forward-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forwardDemo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 转发到 /demo 路径</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>将方法的返回值，设置String类型</li><li>转发使用forward关键字，重定向使用redirect关键字</li><li>关键字: &#x2F;路径</li><li>注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！</li></ul><h3 id="返回JSON数据"><a href="#返回JSON数据" class="headerlink" title="返回JSON数据"></a>返回JSON数据</h3><h4 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h4><p>导入jackson依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加json数据转化器</p><p>@EnableWebMvc </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"><span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"><span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"><span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><ol><li>方法上使用@ResponseBody</li></ol><p>可以在方法上使用 <code>@ResponseBody</code>注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，<code>@ResponseBody</code> 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestBody</span> User userParam)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;userParam = &quot;</span> + userParam);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setAge(<span class="number">18</span>);</span><br><span class="line">user.setName(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="comment">//返回的对象,会使用jackson的序列化工具,转成json返回给前端!</span></span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>类上使用@ResponseBody</li></ol><p>如果类中每个方法上都标记了@ResponseBody注解，那么这些注解就可以提取到类上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//responseBody可以添加到类上,代表默认类中的所有方法都生效!</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h4><p>类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解</p><p>RestController源码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">* to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 4.0.1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AliasFor(annotation = Controller.class)</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回静态资源处理"><a href="#返回静态资源处理" class="headerlink" title="返回静态资源处理"></a>返回静态资源处理</h3><ol><li><strong>静态资源概念</strong></li></ol><p>资源本身已经是可以直接拿到浏览器上使用的程度了，<strong>不需要在服务器端做任何运算、处理</strong>。典型的静态资源包括但不限于：</p><ul><li>HTML文件</li><li>图片</li><li>CSS文件</li><li>JavaScript文件</li></ul><ol start="2"><li><strong>静态资源访问问题解决</strong></li></ol><ul><li><p>web应用加入静态资源</p></li><li><p>手动构建确保编译</p></li><li><p>访问静态资源</p></li><li><p>此时访问不到，问题分析：</p><ul><li>DispatcherServlet 的 url-pattern 配置的是“&#x2F;”</li><li>url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理</li><li>对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法</li><li>现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404</li></ul></li></ul><p>在 SpringMVC 配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的问题：其他原本正常的handler请求访问不了了</p><p>解决方案：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器</span><br></pre></td></tr></table></figure><h2 id="RESTFul风格设计和实战"><a href="#RESTFul风格设计和实战" class="headerlink" title="RESTFul风格设计和实战"></a>RESTFul风格设计和实战</h2><p>RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发</p><p>通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件</p><p>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序</p><h3 id="RESTFul风格特点"><a href="#RESTFul风格特点" class="headerlink" title="RESTFul风格特点"></a>RESTFul风格特点</h3><ol><li>每一个URI代表1种资源（URI 是名词）；</li><li>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li><li>资源的表现形式是XML或者<strong>JSON</strong>；</li><li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li></ol><h3 id="RESTFul风格设计规范"><a href="#RESTFul风格设计规范" class="headerlink" title="RESTFul风格设计规范"></a>RESTFul风格设计规范</h3><ol><li><strong>HTTP协议请求方式要求</strong></li></ol><p>REST 风格主张在项目设计、开发过程中，具体的操作符合<strong>HTTP协议定义的请求方式的语义</strong>。</p><table><thead><tr><th>操作</th><th>请求方式</th></tr></thead><tbody><tr><td>查询操作</td><td>GET</td></tr><tr><td>保存操作</td><td>POST</td></tr><tr><td>删除操作</td><td>DELETE</td></tr><tr><td>更新操作</td><td>PUT</td></tr></tbody></table><ol start="2"><li><strong>URL路径风格要求</strong></li></ol><p>REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p><p>使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：GET</td></tr></tbody></table><ul><li>总结</li></ul><p>根据接口的具体动作，选择具体的HTTP协议请求方式</p><p>路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可</p><h2 id="SpringMVC其他扩展"><a href="#SpringMVC其他扩展" class="headerlink" title="SpringMVC其他扩展"></a>SpringMVC其他扩展</h2><h3 id="全局异常处理机制"><a href="#全局异常处理机制" class="headerlink" title="全局异常处理机制"></a>全局异常处理机制</h3><h4 id="异常处理两种方式"><a href="#异常处理两种方式" class="headerlink" title="异常处理两种方式"></a>异常处理两种方式</h4><p>开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。</p><p>对于异常的处理，一般分为两种方式：</p><ul><li>编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</li><li>声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 <code>@Throws</code> 或 <code>@ExceptionHandler</code>），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</li></ul><p>站在宏观角度来看待声明式事务处理：</p><p>整个项目从架构这个层面设计的异常处理的统一机制和规范。</p><p>一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。</p><p>使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！</p><h4 id="基于注解异常声明异常处理"><a href="#基于注解异常声明异常处理" class="headerlink" title="基于注解异常声明异常处理"></a>基于注解异常声明异常处理</h4><ol><li>声明异常处理控制器类</li></ol><p>异常处理控制类，统一定义异常处理handler方法！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* description: 全局异常处理器,内部可以定义异常处理Handler!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@RestControllerAdvice</span> = <span class="doctag">@ControllerAdvice</span> + <span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明异常处理hander方法</li></ol><p>异常处理handler方法和普通的handler方法参数接收和响应都一致！</p><p>只不过异常处理handler方法要映射异常，发生对应的异常会调用！</p><p>普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 异常处理handler </span></span><br><span class="line"><span class="comment">* <span class="doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span></span><br><span class="line"><span class="comment">* 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e 获取异常对象!</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回handler处理结果!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerJsonDateException</span><span class="params">(HttpMessageNotReadableException e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当发生空指针异常会触发此方法!</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerNullException</span><span class="params">(NullPointerException e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 所有异常都会触发此方法!但是如果有具体的异常处理Handler! </span></span><br><span class="line"><span class="comment">* 具体异常处理Handler优先级更高!</span></span><br><span class="line"><span class="comment">* 例如: 发生NullPointerException异常!</span></span><br><span class="line"><span class="comment">*       会触发handlerNullException方法,不会触发handlerException方法!</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件扫描控制器类配置</li></ol><p>确保异常处理控制类被扫描</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;controller&quot;,</span></span><br><span class="line"><span class="meta">&quot;exceptionhandler&quot;&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="拦截器使用"><a href="#拦截器使用" class="headerlink" title="拦截器使用"></a>拦截器使用</h3><p>在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测</p><p><img src="https://secure2.wostatic.cn/static/eBwRN4iKLw9e9DHpVGP4WX/img009.png?auth_key=1711509897-q84g4d16Pi8edgQsgjFxX1-0-e1f8aae4836ccd17e30f941dfd3a90ff"></p><p>拦截器 Springmvc VS 过滤器 javaWeb：</p><ul><li><p>相似点</p><ul><li>拦截：必须先把请求拦住，才能执行后续操作</li><li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul></li><li><p>不同点</p><ul><li>工作平台不同</li><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li><p>拦截的范围</p><ul><li><p>过滤器：能够拦截到的最大范围是整个 Web 应用</p></li><li><p>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</p></li></ul></li><li><p>IOC 容器支持</p><ul><li><p>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</p></li><li><p>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</p></li></ul></li></ul><p>选择：</p><p>功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器</p><p><img src="https://secure-bigfile.wostatic.cn/static/prqG4dtu3rDWj7VwX4WgsW/image.png?auth_key=1711509897-HdeEsMAR2ZKmzeit5j184-0-290313fb34c39d5661341d38a3a72010"></p><h4 id="拦截器使用-1"><a href="#拦截器使用-1" class="headerlink" title="拦截器使用"></a>拦截器使用</h4><ol><li>创建拦截器类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Process01Interceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if( ! preHandler())&#123;return;&#125;</span></span><br><span class="line"><span class="comment">// 在处理请求的目标 handler 方法前执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler);</span><br><span class="line">    System.out.println(<span class="string">&quot;Process01Interceptor.preHandle&quot;</span>);</span><br><span class="line">    <span class="comment">// 返回true：放行</span></span><br><span class="line">    <span class="comment">// 返回false：不放行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在目标 handler 方法之后，handler报错不执行!</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, modelAndView = &quot;</span> + modelAndView);</span><br><span class="line">    System.out.println(<span class="string">&quot;Process01Interceptor.postHandle&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染视图之后执行(最后),一定执行!</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, ex = &quot;</span> + ex);</span><br><span class="line">    System.out.println(<span class="string">&quot;Process01Interceptor.afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器方法拦截位置：</p><p><img src="https://secure2.wostatic.cn/static/9W6TF7dUwqdv2qi4KHAkAr/image.png?auth_key=1711509897-vQhhyorhLrk5H8FZd39JZZ-0-4b9cc18640fe0235a5931bcc1d5a7699"><br>2. 修改配置类添加拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;controller&quot;,&quot;exceptionhandler&quot;&#125;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; </span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>配置详解</li><li>默认拦截全部</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>精准配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line"><span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line"><span class="comment">//也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>排除配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line"><span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//排除匹配,排除应该在匹配的范围内排除</span></span><br><span class="line"><span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line"><span class="comment">//excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>())</span><br><span class="line">.addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>)</span><br><span class="line">.excludePathPatterns(<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>多个拦截器执行顺序</li><li>preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。</li><li>postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。</li><li>afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。</li></ol><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><blockquote><p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p></blockquote><ol><li><strong>校验概述</strong></li></ol><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Null</td><td>标注值必须为 null</td></tr><tr><td>@NotNull</td><td>标注值不可为 null</td></tr><tr><td>@AssertTrue</td><td>标注值必须为 true</td></tr><tr><td>@AssertFalse</td><td>标注值必须为 false</td></tr><tr><td>@Min(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@Max(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@DecimalMin(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@DecimalMax(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@Size(max,min)</td><td>标注值大小必须在 max 和 min 限定的范围内</td></tr><tr><td>@Digits(integer,fratction)</td><td>标注值值必须是一个数字，且必须在可接受的范围内</td></tr><tr><td>@Past</td><td>标注值只能用于日期型，且必须是过去的日期</td></tr><tr><td>@Future</td><td>标注值只能用于日期型，且必须是将来的日期</td></tr><tr><td>@Pattern(value)</td><td>标注值必须符合指定的正则表达式</td></tr></tbody></table><p>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Email</td><td>标注值必须是格式正确的 Email 地址</td></tr><tr><td>@Length</td><td>标注值字符串大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>标注值字符串不能是空字符串</td></tr><tr><td>@Range</td><td>标注值必须在指定的范围内</td></tr></tbody></table><p>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</p><p>配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。<br>2. <strong>操作演示</strong></p><ul><li>导入依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 校验注解实现--&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>应用校验注解</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="comment">//age   1 &lt;=  age &lt; = 150</span></span><br><span class="line"><span class="meta">@Min(10)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//name 3 &lt;= name.length &lt;= 6</span></span><br><span class="line"><span class="meta">@Length(min = 3,max = 10)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//email 邮箱格式</span></span><br><span class="line"><span class="meta">@Email</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>handler标记和绑定错误收集</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Validated</span> 代表应用校验注解! 必须添加!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">save</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user,</span></span><br><span class="line"><span class="params">//在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!</span></span><br><span class="line"><span class="params">BindingResult result)</span>&#123;</span><br><span class="line"><span class="comment">//判断是否有信息绑定错误! 有可以自行处理!</span></span><br><span class="line"><span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> result.getFieldError().toString();</span><br><span class="line"><span class="keyword">return</span> errorMsg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有,正常处理业务即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>易混总结</strong></li></ol><p>@NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p><ol><li>@NotNull  (包装类型不为null)</li></ol><p>@NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。<br>2. @NotEmpty (集合类型长度大于0)</p><p>@NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。<br>3. @NotBlank （字符串，不为null，切不为”  “字符串）</p><p>@NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。</p><p>总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis框架入门</title>
      <link href="/inori/6f411126.html"/>
      <url>/inori/6f411126.html</url>
      
        <content type="html"><![CDATA[<p>​MyBatis是一款优秀的持久层框架，它支持自定义SQL、存储过程以及高级映射。MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作。MyBatis可以通过简单的XML或注解来配置和映射原始类型、接口和Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="向SQL语句传参"><a href="#向SQL语句传参" class="headerlink" title="向SQL语句传参"></a>向SQL语句传参</h3><h4 id="mybatis日志输出配置"><a href="#mybatis日志输出配置" class="headerlink" title="mybatis日志输出配置"></a><strong>mybatis日志输出配置</strong></h4><p>mybatis配置文件设计标签和顶层结构如下：</p><ul><li>configuration（配置）</li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#environments">environments（环境配置）</a></li><li>environment（环境变量）</li><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li></ul><p>我们可以在mybatis的配置文件使用<strong>settings标签</strong>设置，输出运行过程SQL日志，通过查看日志，我们可以判定#{}和${}的输出效果</p><h4 id="形式"><a href="#形式" class="headerlink" title="#{}形式"></a><strong>#{}形式</strong></h4><p>Mybatis会将SQL语句中的<code>#&#123;&#125;</code>转换为问号占位符</p><h4 id="形式-1"><a href="#形式-1" class="headerlink" title="${}形式"></a><strong>${}形式</strong></h4><p><code>$&#123;&#125;</code>形式传参，底层Mybatis做的是字符串拼接操作。通常不会采用<code>$&#123;&#125;</code>的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用<code>$&#123;&#125;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findByColumn</span><span class="params">(<span class="meta">@Param(&quot;column&quot;)</span> String column, </span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;value&quot;)</span> String value)</span>;</span><br></pre></td></tr></table></figure><h3 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h3><h4 id="Mybatis总体机制概括"><a href="#Mybatis总体机制概括" class="headerlink" title="Mybatis总体机制概括"></a><strong>Mybatis总体机制概括</strong></h4><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img005.ebd8c6a3.png"></p><h4 id="单个简单类型参数"><a href="#单个简单类型参数" class="headerlink" title="单个简单类型参数"></a><strong>单个简单类型参数</strong></h4><p>Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee <span class="title function_">selectEmployee</span><span class="params">(Integer empId)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单个简单类型参数，在#{}中可以随意命名，但是没有必要。通常还是使用和接口方法参数同名</p></blockquote><h4 id="实体类类型参数"><a href="#实体类类型参数" class="headerlink" title="实体类类型参数"></a><strong>实体类类型参数</strong></h4><p>Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertEmployee</span><span class="params">(Employee employee)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmployee&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应关系<br><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img006.f9958c52.png"><br>Mybatis会根据#{}中传入的数据，加工成getXxx()方法，通过反射在实体类对象中调用这个方法，从而获取到对应的数据。填充到#{}解析后的问号占位符这个位置</p><h4 id="零散的简单类型数据"><a href="#零散的简单类型数据" class="headerlink" title="零散的简单类型数据"></a><strong>零散的简单类型数据</strong></h4><p>零散的多个简单类型参数，如果没有特殊处理，那么Mybatis无法识别自定义名称,需要在Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">updateEmployee</span><span class="params">(<span class="meta">@Param(&quot;empId&quot;)</span> Integer empId,<span class="meta">@Param(&quot;empSalary&quot;)</span> Double empSalary)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployee&quot;</span>&gt;</span></span><br><span class="line">update t_emp set emp_salary=#&#123;empSalary&#125; where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应关系<br><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img007.976da128.png"></p><h4 id="Map类型参数"><a href="#Map类型参数" class="headerlink" title="Map类型参数"></a><strong>Map类型参数</strong></h4><p>Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">updateEmployeeByMap</span><span class="params">(Map&lt;String, Object&gt; paramMap)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeByMap&quot;</span>&gt;</span></span><br><span class="line">update t_emp set emp_salary=#&#123;empSalaryKey&#125; where emp_id=#&#123;empIdKey&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>junit测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession session;</span><br><span class="line"><span class="comment">//junit5会在每一个@Test方法前执行@BeforeEach方法</span></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">session = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>()</span><br><span class="line">.build(</span><br><span class="line">Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line">.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateEmpNameByMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(EmployeeMapper.class);</span><br><span class="line">Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">&quot;empSalaryKey&quot;</span>, <span class="number">999.99</span>);</span><br><span class="line">paramMap.put(<span class="string">&quot;empIdKey&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.updateEmployeeByMap(paramMap);</span><br><span class="line">log.info(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//junit5会在每一个@Test方法后执行@@AfterEach方法</span></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对应关系</strong>：#{}中写Map中的key<br><strong>使用场景</strong>：有很多零散的参数需要传递，但是没有对应的实体类类型可以使用。使用@Param注解一个一个传入又太麻烦了。所以都封装到Map中。</p><h3 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h3><p>数据输出总体上有两种形式：</p><ul><li>增删改操作返回的受影响行数：直接使用 int 或 long 类型接收即可</li><li>查询操作的查询结果</li></ul><p>我们需要做的是，指定查询的输出数据类型即可</p><h4 id="单个简单类型"><a href="#单个简单类型" class="headerlink" title="单个简单类型"></a>单个简单类型</h4><p>Mapper接口中的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">selectEmpCount</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">select count(*) from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Mybatis 内部给常用的数据类型设定了很多别名。 以 int 类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER 等等。</p></blockquote><p><strong>细节解释：</strong><br>select标签，通过resultType指定查询返回值类型<br>resultType &#x3D; 全限定符 ｜ 别名 ｜ 如果是返回集合类型，写范型类型即可<br>别名问题：<a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases</a><br>类型别名可为Java类型设置一个缩写名字。 它仅用于XML配置，意在降低冗余的全限定类名书写</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当这样配置时，<code>Blog</code>可以用在任何使用domain.blog.Blog的地方，也可以指定一个包名，MyBatis会在包名下面搜索需要的Java Bean，比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span> <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是Mybatis为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_char (since 3.5.10)</td><td>char</td></tr><tr><td>_character (since 3.5.10)</td><td>char</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>char (since 3.5.10)</td><td>Character</td></tr><tr><td>character (since 3.5.10)</td><td>Character</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>biginteger</td><td>BigInteger</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>object[]</td><td>Object[]</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr></tbody></table><h4 id="返回实体类对象Mapper"><a href="#返回实体类对象Mapper" class="headerlink" title="返回实体类对象Mapper"></a>返回实体类对象Mapper</h4><p>接口的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee <span class="title function_">selectEmployee</span><span class="params">(Integer empId)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;</span></span><br><span class="line">select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过给数据库表字段加别名，让查询结果的每一列都和Java实体类中属性对应起来<br>增加全局配置自动识别对应关系，Mybatis全局配置文件中，做了下面的配置，select语句中可以不给字段设置别名</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在全局范围内对Mybatis进行配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="返回主键值"><a href="#返回主键值" class="headerlink" title="返回主键值"></a>返回主键值</h4><ol><li><strong>自增长类型主键</strong></li></ol><p>Mapper接口中的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertEmployee</span><span class="params">(Employee employee)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int insertEmployee(Employee employee); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmployee&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;empId&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp(emp_name,emp_salary)</span><br><span class="line">values(#&#123;empName&#125;,#&#123;empSalary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>junit测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveEmp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">EmployeeMapper</span> <span class="variable">employeeMapper</span> <span class="operator">=</span> session.getMapper(EmployeeMapper.class);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    employee.setEmpName(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">    employee.setEmpSalary(<span class="number">666.66</span>);</span><br><span class="line">    employeeMapper.insertEmployee(employee);</span><br><span class="line">    log.info(<span class="string">&quot;employee.getEmpId() = &quot;</span> + employee.getEmpId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><p>Mybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。<br>2. <strong>非自增长类型主键</strong></p><p>而对于不支持自增型主键的数据库（例如 Oracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用！</p><p>使用 <code>selectKey</code> 帮助插入UUID作为字符串类型主键示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">SELECT UUID() as id</span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    INSERT INTO user (id, username, password) </span><br><span class="line">    VALUES (</span><br><span class="line">    #&#123;id&#125;,</span><br><span class="line">    #&#123;username&#125;,</span><br><span class="line">    #&#123;password&#125;</span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上例中定义了一个<code>insertUser</code>的插入语句来将 <code>User</code> 对象插入到 <code>user</code> 表中。我们使用<code>selectKey</code>来查询 UUID 并设置到 <code>id</code>字段中。</p><p>通过 <code>keyProperty</code> 属性来指定查询到的 UUID 赋值给对象中的 <code>id</code> 属性，而 <code>resultType</code> 属性指定了 UUID 的类型为 <code>java.lang.String</code></p><p>需要注意的是，我们将 <code>selectKey</code> 放在了插入语句的前面，这是因为 MySQL 在 <code>insert</code> 语句中只支持一个 <code>select</code> 子句，而 <code>selectKey</code> 中查询 UUID 的语句就是一个 <code>select</code> 子句，因此我们需要将其放在前面。</p><p>最后，在将<code>User</code>对象插入到 <code>user</code> 表中时，我们直接使用对象中的 <code>id</code> 属性来插入主键值。</p><p>使用这种方式，可以方便地插入 UUID 作为字符串类型主键。</p><h4 id="实体类属性和数据库字段对应关系"><a href="#实体类属性和数据库字段对应关系" class="headerlink" title="实体类属性和数据库字段对应关系"></a>实体类属性和数据库字段对应关系</h4><ol><li>别名对应</li></ol><p>将字段的别名设置成和实体类属性一致。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;</span></span><br><span class="line">select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>关于实体类属性的约定：</p></blockquote><p>getXxx()方法、setXxx()方法把方法名中的get或set去掉，首字母小写。<br>2. 全局配置自动识别驼峰式命名规则</p><p>在Mybatis全局配置文件加入如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SQL语句中可以不使用别名</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Employee selectEmployee(Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用resultMap</li></ol><p>使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empSalary&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRM&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mapperXML标签总结"><a href="#mapperXML标签总结" class="headerlink" title="mapperXML标签总结"></a>mapperXML标签总结</h3><p>MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。</p><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>insert</code> – 映射插入语句。</li><li><code>update</code> – 映射更新语句。</li><li><code>delete</code> – 映射删除语句。</li><li><code>select</code> – 映射查询语句。</li></ul><p><strong>select标签：</strong></p><p>MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPerson&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;自定义结构&quot;</span>&gt;</span> SELECT * FROM PERSON WHERE ID = #&#123;id&#125; <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：#{id}  ${key}</p><p>MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 近似的 JDBC 代码，非 MyBatis 代码...</span></span><br><span class="line"><span class="type">String</span> <span class="variable">selectPerson</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM PERSON WHERE ID=?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(selectPerson);</span><br><span class="line">ps.setInt(<span class="number">1</span>,id);</span><br></pre></td></tr></table></figure><p>select 元素允许你配置很多属性来配置每条语句的行为细节：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>resultType</code></td><td>期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td><code>resultMap</code></td><td>对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td><code>timeout</code></td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td><code>statementType</code></td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr></tbody></table><p><strong>insert, update 和 delete标签：</strong></p><p>数据变更语句 insert，update 和 delete 的实现非常接近：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">keyProperty</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">keyColumn</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">useGeneratedKeys</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;updateAuthor&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;deleteAuthor&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>timeout</code></td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td><code>statementType</code></td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td><code>useGeneratedKeys</code></td><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td><code>keyProperty</code></td><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td><code>keyColumn</code></td><td>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr></tbody></table><h2 id="MyBatis多表映射"><a href="#MyBatis多表映射" class="headerlink" title="MyBatis多表映射"></a>MyBatis多表映射</h2><h3 id="对一映射"><a href="#对一映射" class="headerlink" title="对一映射"></a>对一映射</h3><ol><li>需求说明</li></ol><p>根据ID查询订单，以及订单关联的用户的信息！<br>2. OrderMapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">Order <span class="title function_">selectOrderWithCustomer</span><span class="params">(Integer orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>OrderMapper.xml配置文件</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建resultMap实现“对一”关联关系映射 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id属性：通常设置为这个resultMap所服务的那条SQL语句的id加上“ResultMap” --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- type属性：要设置为这个resultMap所服务的那条SQL语句最终要返回的类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectOrderWithCustomerResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 先设置Order自身属性和字段的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;order_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用association标签配置“对一”关联关系 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- property属性：在Order类中对一的一端进行引用时使用的属性名 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- javaType属性：一的一端类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Customer类的属性和字段名之间的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Order selectOrderWithCustomer(Integer orderId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOrderWithCustomer&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectOrderWithCustomerResultMap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">SELECT order_id,order_name,c.customer_id,customer_name</span><br><span class="line">FROM t_order o</span><br><span class="line">LEFT JOIN t_customer c</span><br><span class="line">ON o.customer_id=c.customer_id</span><br><span class="line">WHERE o.order_id=#&#123;orderId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应关系可以参考下图：</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img018.6c3cfc17.png"><br>4. Mybatis全局注册Mapper文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/OrderMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>junit测试程序</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SqlSession session;</span><br><span class="line"><span class="comment">// junit会在每一个@Test方法前执行@BeforeEach方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">session = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>()</span><br><span class="line">.build(</span><br><span class="line">Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line">.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRelationshipToOne</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">OrderMapper</span> <span class="variable">orderMapper</span> <span class="operator">=</span> session.getMapper(OrderMapper.class);</span><br><span class="line"><span class="comment">// 查询Order对象，检查是否同时查询了关联的Customer对象</span></span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectOrderWithCustomer(<span class="number">2</span>);</span><br><span class="line">log.info(<span class="string">&quot;order = &quot;</span> + order);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// junit会在每一个@Test方法后执行@@AfterEach方法</span></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>关键词</li></ol><p>在“对一”关联关系中，我们的配置比较多，但是关键词就只有：<strong>association</strong>和<strong>javaType</strong></p><h3 id="对多映射"><a href="#对多映射" class="headerlink" title="对多映射"></a>对多映射</h3><ol><li>需求说明</li></ol><p>查询客户和客户关联的订单信息！<br>2. CustomerMapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">Customer <span class="title function_">selectCustomerWithOrderList</span><span class="params">(Integer customerId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>CustomerMapper.xml文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">&quot;selectCustomerWithOrderListResultMap&quot;</span></span><br><span class="line"></span><br><span class="line">type=<span class="string">&quot;customer&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 映射Customer本身的属性 --&gt;</span><br><span class="line">&lt;id column=<span class="string">&quot;customer_id&quot;</span> property=<span class="string">&quot;customerId&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;result column=<span class="string">&quot;customer_name&quot;</span> property=<span class="string">&quot;customerName&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- collection标签：映射“对多”的关联关系 --&gt;</span><br><span class="line">&lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt;</span><br><span class="line">&lt;!-- ofType属性：集合属性中元素的类型 --&gt;</span><br><span class="line">&lt;collection property=<span class="string">&quot;orderList&quot;</span> ofType=<span class="string">&quot;order&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 映射Order的属性 --&gt;</span><br><span class="line">&lt;id column=<span class="string">&quot;order_id&quot;</span> property=<span class="string">&quot;orderId&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;result column=<span class="string">&quot;order_name&quot;</span> property=<span class="string">&quot;orderName&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/collection&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Customer <span class="title function_">selectCustomerWithOrderList</span><span class="params">(Integer customerId)</span>; --&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectCustomerWithOrderList&quot;</span> resultMap=<span class="string">&quot;selectCustomerWithOrderListResultMap&quot;</span>&gt;</span><br><span class="line">SELECT c.customer_id,c.customer_name,o.order_id,o.order_name</span><br><span class="line">FROM t_customer c</span><br><span class="line">LEFT JOIN t_order o</span><br><span class="line">ON c.customer_id=o.customer_id</span><br><span class="line">WHERE c.customer_id=#&#123;customerId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>对应关系可以参考下图：</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img019.dba418c1.png"><br>4. Mybatis全局注册Mapper文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/OrderMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/CustomerMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>junit测试程序</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRelationshipToMulti</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">CustomerMapper</span> <span class="variable">customerMapper</span> <span class="operator">=</span> session.getMapper(CustomerMapper.class);</span><br><span class="line"><span class="comment">// 查询Customer对象同时将关联的Order集合查询出来</span></span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> customerMapper.selectCustomerWithOrderList(<span class="number">1</span>);</span><br><span class="line">log.info(<span class="string">&quot;customer.getCustomerId() = &quot;</span> + customer.getCustomerId());</span><br><span class="line">log.info(<span class="string">&quot;customer.getCustomerName() = &quot;</span> + customer.getCustomerName());</span><br><span class="line">List&lt;Order&gt; orderList = customer.getOrderList();</span><br><span class="line"><span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">log.info(<span class="string">&quot;order = &quot;</span> + order);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>关键词</li></ol><p>在“对多”关联关系中，同样有很多配置，但是提炼出来最关键的就是：“collection”和“ofType”</p><h3 id="多表映射优化"><a href="#多表映射优化" class="headerlink" title="多表映射优化"></a>多表映射优化</h3><table><thead><tr><th>setting属性</th><th>属性含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>autoMappingBehavior</td><td>指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。</td><td>NONE, PARTIAL, FULL</td><td>PARTIAL</td></tr></tbody></table><p>我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名&#x3D;属性名，或者开启驼峰映射也可以自定映射）的result标签！</p><p>修改mybati-sconfig.xml:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启resultMap自动映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FULL&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>修改teacherMapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;teacherMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;tId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;result property=&quot;tName&quot; column=&quot;t_name&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;student&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;sId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;s_id&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;result property=&quot;sName&quot; column=&quot;s_name&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多表映射总结"><a href="#多表映射总结" class="headerlink" title="多表映射总结"></a>多表映射总结</h3><table><thead><tr><th>关联关系</th><th>配置项关键词</th><th>所在配置文件和具体位置</th></tr></thead><tbody><tr><td>对一</td><td>association标签&#x2F;javaType属性&#x2F;property属性</td><td>Mapper配置文件中的resultMap标签内</td></tr><tr><td>对多</td><td>collection标签&#x2F;ofType属性&#x2F;property属性</td><td>Mapper配置文件中的resultMap标签内</td></tr></tbody></table><h2 id="MyBatis动态语句"><a href="#MyBatis动态语句" class="headerlink" title="MyBatis动态语句"></a>MyBatis动态语句</h2><h3 id="if和where标签"><a href="#if和where标签" class="headerlink" title="if和where标签"></a>if和where标签</h3><p>使用动态 SQL 最常见情景是根据条件包含 where  &#x2F; if 子句的一部分。比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp</span><br><span class="line"><span class="comment">&lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#&#123;&#125; --&gt;</span></span><br><span class="line">or emp_name=#&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;gt;</span> 2000&quot;</span>&gt;</span></span><br><span class="line">or emp_salary&gt;#&#123;empSalary&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;?</span></span><br><span class="line"><span class="comment">第二种情况：部分条件满足 WHERE emp_salary&gt;?</span></span><br><span class="line"><span class="comment">第三种情况：所有条件都不满足 没有where子句</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeDynamic&quot;</span>&gt;</span></span><br><span class="line">update t_emp</span><br><span class="line"><span class="comment">&lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">emp_name=#&#123;empName&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span></span><br><span class="line">emp_salary=#&#123;empSalary&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">第一种情况：所有条件都满足 SET emp_name=?, emp_salary=?</span></span><br><span class="line"><span class="comment">第二种情况：部分条件满足 SET emp_salary=?</span></span><br><span class="line"><span class="comment">第三种情况：所有条件都不满足 update t_emp where emp_id=?</span></span><br><span class="line"><span class="comment">没有set子句的update语句会导致SQL语法错误</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose-when-otherwise标签"><a href="#choose-when-otherwise标签" class="headerlink" title="choose&#x2F;when&#x2F;otherwise标签"></a>choose&#x2F;when&#x2F;otherwise标签</h3><p>在多个分支条件中，仅执行一个。</p><ul><li>从上到下依次执行条件判断</li><li>遇到的第一个满足条件的分支会被采纳</li><li>被采纳分支后面的分支都将不被考虑</li><li>如果所有的when分支都不满足，那么就执行otherwise分支</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByConditionByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp</span><br><span class="line">where</span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span>emp_name=#&#123;empName&#125;<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span>emp_salary <span class="symbol">&amp;lt;</span> 3000<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>1=1<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">第一种情况：第一个when满足条件 where emp_name=?</span></span><br><span class="line"><span class="comment">第二种情况：第二个when满足条件 where emp_salary &lt; 3000</span></span><br><span class="line"><span class="comment">第三种情况：两个when都不满足 where 1=1 执行了otherwise</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p><strong>基本用法</strong></p><p>用批量插入举例</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">collection属性：要遍历的集合</span></span><br><span class="line"><span class="comment">item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象</span></span><br><span class="line"><span class="comment">separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符</span></span><br><span class="line"><span class="comment">open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串</span></span><br><span class="line"><span class="comment">close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串</span></span><br><span class="line"><span class="comment">index属性：这里起一个名字，便于后面引用</span></span><br><span class="line"><span class="comment">遍历List集合，这里能够得到List集合的索引值</span></span><br><span class="line"><span class="comment">遍历Map集合，这里能够得到Map集合的key</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;values&quot;</span> <span class="attr">index</span>=<span class="string">&quot;myIndex&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 --&gt;</span></span><br><span class="line">(#&#123;emp.empName&#125;,#&#123;myIndex&#125;,#&#123;emp.empSalary&#125;,#&#123;emp.empGender&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>批量更新时需要注意</strong></p><p>上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true</span><br></pre></td></tr></table></figure><p>对应的foreach标签如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeBatch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span>&gt;</span></span><br><span class="line">update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>关于foreach标签的collection属性</strong></p><p>如果没有给接口中List类型的参数使用@Param注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。这一点可以通过异常信息看出来：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Parameter &#x27;empList&#x27; not found. Available parameters are [arg0, collection, list]</span><br></pre></td></tr></table></figure><p>在实际开发中，为了避免隐晦的表达造成一定的误会，建议使用@Param注解明确声明变量的名称，然后在foreach标签的collection属性中按照@Param注解指定的名称来引用传入的参数。</p><h3 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h3><p><strong>抽取重复的SQL片段</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;mySelectSql&quot;</span>&gt;</span></span><br><span class="line">select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用已抽取的SQL片段</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用include标签引用声明的SQL片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;mySelectSql&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Mapper批量映射优化"><a href="#Mapper批量映射优化" class="headerlink" title="Mapper批量映射优化"></a>Mapper批量映射优化</h2><ol><li>需求</li></ol><p>Mapper配置文件很多时，在全局配置文件中一个一个注册太麻烦，希望有一个办法能够一劳永逸。<br>2. 配置方式</p><p>Mybatis允许在指定 Mapper 映射文件时，只指定其所在的包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时这个包下的所有 Mapper 配置文件将被自动加载、注册，比较方便。<br>3. 资源创建要求</p><ul><li>Mapper 接口和 Mapper 配置文件名称一致</li><li>Mapper 接口：EmployeeMapper.java</li><li>Mapper 配置文件：EmployeeMapper.xml</li><li>Mapper 配置文件放在 Mapper 接口所在的包内</li><li>可以将mapperxml文件放在mapper接口所在的包！</li><li>可以在sources下创建mapper接口包一致的文件夹结构存放mapper.xml文件</li></ul><h2 id="MyBatis总结"><a href="#MyBatis总结" class="headerlink" title="MyBatis总结"></a>MyBatis总结</h2><table><thead><tr><th>核心点</th><th>掌握目标</th></tr></thead><tbody><tr><td>mybatis基础</td><td>使用流程, 参数输入,#{} ${},参数输出</td></tr><tr><td>mybatis多表</td><td>实体类设计,resultMap多表结果映射</td></tr><tr><td>mybatis动态语句</td><td>Mybatis动态语句概念, where , if , foreach标签</td></tr><tr><td>mybatis扩展</td><td>Mapper批量处理,分页插件,逆向工程</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架入门</title>
      <link href="/inori/6c8c2c4f.html"/>
      <url>/inori/6c8c2c4f.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring与SpringFramework"><a href="#Spring与SpringFramework" class="headerlink" title="Spring与SpringFramework"></a>Spring与SpringFramework</h2><p><strong>广义的 Spring：Spring 技术栈</strong>（全家桶）</p><p>广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。</p><p>经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p><p>这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。</p><p><strong>狭义的 Spring：Spring Framework</strong>（基础框架）</p><p>狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。</p><p>Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。</p><p>Spring全家桶的其他框架都是以SpringFramework框架为基础</p><h2 id="SpringFramework主要功能"><a href="#SpringFramework主要功能" class="headerlink" title="SpringFramework主要功能"></a>SpringFramework主要功能</h2><table><thead><tr><th>功能模块</th><th>功能介绍</th></tr></thead><tbody><tr><td>Core Container</td><td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。</td></tr><tr><td>AOP&amp;Aspects</td><td>面向切面编程</td></tr><tr><td>TX</td><td>声明式事务管理。</td></tr><tr><td>Spring MVC</td><td>提供了面向Web应用程序的集成功能。</td></tr></tbody></table><h2 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h2><p>IoC(Inversion of Control)控制反转，对象创建责任的反转，在spring中BeanFacotory是IoC容器的核心接口，负责实例化，定位，配置应用程序中的对象及建立这些对象间的依赖。XmlBeanFacotory实现BeanFactory接口，通过获取xml配置文件数据，组成应用对象及对象间的依赖关系<br>spring中有三种注入方式，一种是set注入，一种是接口注入，另一种是构造方法注入</p><p>IOC，字面理解是控制反转，即对象的控制权被反转了(是什么)。之前一个对象中依赖另一个对象，需要自己new出来，当对象间的依赖关系非常复杂时，这个过程就变得很繁琐，并且代码间的耦合会很高。现在可以通过Ioc容器来管理控制对象的生成，可以把对象的实例化过程简单化，代码间解耦(为什么)。具体可以从DI(Dependency Injection) DL(Dependency Lookup)两个角度理解Ioc。DI中注入的方式包括属性，构造器，setter注入，DL含义是通过容器的API来查找所依赖的资源和协作对象，从Ioc容器维护的bean map中取出来(怎么做)</p><h3 id="组件和组件管理"><a href="#组件和组件管理" class="headerlink" title="组件和组件管理"></a>组件和组件管理</h3><p>整个项目就是由各种组件搭建而成的，原本使用组件需要先new出来并赋值才能使用，现在有了Spring之后组件可以完全交给Spring框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等</p><p><img src="https://secure2.wostatic.cn/static/8LSuy5YWXmufYmPWM894rN/image.png?auth_key=1711448434-igtjNj6H9qouMJDfHrzR1E-0-1708de84eac4b57242780981def9cfef"></p><p>Spring具体的组件管理动作包含：</p><ul><li>组件对象实例化</li><li>组件属性属性赋值</li><li>组件对象之间引用</li><li>组件对象存活周期管理</li></ul><p>我们只需要编写元数据（配置文件）告知Spring管理哪些类组件和他们的关系即可！</p><p>注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！</p><ul><li>组件一定是对象</li><li>对象不一定是组件</li></ul><p>综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！</p><h3 id="Spring-IoC容器和容器实现"><a href="#Spring-IoC容器和容器实现" class="headerlink" title="Spring IoC容器和容器实现"></a>Spring IoC容器和容器实现</h3><h4 id="普通和复杂容器"><a href="#普通和复杂容器" class="headerlink" title="普通和复杂容器"></a>普通和复杂容器</h4><blockquote><p>普通容器只能用来存储，没有更多功能。</p></blockquote><ul><li>数组</li><li>集合：List</li><li>集合：Set</li></ul><blockquote><p>复杂容器可以持续管理组件，从产生到销毁</p></blockquote><p>  如：Servlet容器能够管理Servlet(init,service,destroy)、Filter、Listener这样的组件的一生，所以它是一个复杂容器。</p><table><thead><tr><th>名称</th><th>时机</th><th>次数</th></tr></thead><tbody><tr><td>创建对象</td><td>默认情况：接收到第一次请求  修改启动顺序后：Web应用启动过程中</td><td>一次</td></tr><tr><td>初始化操作</td><td>创建对象之后</td><td>一次</td></tr><tr><td>处理请求</td><td>接收到请求</td><td>多次</td></tr><tr><td>销毁操作</td><td>Web应用卸载之前</td><td>一次</td></tr></tbody></table><p>SpringIoC容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。<br>Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等</p><h4 id="IoC容器具体接口和实现类"><a href="#IoC容器具体接口和实现类" class="headerlink" title="IoC容器具体接口和实现类"></a>IoC容器具体接口和实现类</h4><p><strong>SpringIoc容器接口</strong><br><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！<br><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p><ul><li><p>更容易与 Spring 的 AOP 功能集成</p></li><li><p>消息资源处理（用于国际化）</p></li><li><p>特定于应用程序给予此接口实现，例如Web应用程序的 <code>WebApplicationContext</code></p><p>  简而言之，<code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能<code>ApplicationContext</code>是<code>BeanFactory</code>的完整超集！</p></li></ul><p><strong>ApplicationContext容器实现类</strong></p><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>AnnotationConfigApplicationContext</td><td>通过读取Java配置类创建 IOC 容器对象</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table><p><strong>SpringIoC容器管理配置方式</strong></p><p>Spring IoC容器使用多种形式的配置元数据。此配置元数据表示作为应用程序开发人员如何告诉Spring容器实例化、配置和组装应用程序中的对象。<br>Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式</p><ol><li>XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持</li><li>注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系</li><li>Java配置类方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置</li></ol><h4 id="SpringIoC-DI概念总结"><a href="#SpringIoC-DI概念总结" class="headerlink" title="SpringIoC&#x2F;DI概念总结"></a>SpringIoC&#x2F;DI概念总结</h4><ul><li><p><strong>IoC容器</strong></p><p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令</p></li><li><p><strong>IoC（Inversion of Control）控制反转</strong></p><p>IoC主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC容器来创建和管理，即控制权由应用程序转移到IoC容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即IoC容器维护着构成应用程序的对象，并负责创建这些对象</p></li><li><p><strong>DI (Dependency Injection) 依赖注入</strong></p><p>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在Spring中，DI是通过XML配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter方法注入和接口注入</p></li></ul><h2 id="Spring-IoC实践"><a href="#Spring-IoC实践" class="headerlink" title="Spring IoC实践"></a>Spring IoC实践</h2><h3 id="Spring-IoC-DI实现步骤"><a href="#Spring-IoC-DI实现步骤" class="headerlink" title="Spring IoC&#x2F;DI实现步骤"></a>Spring IoC&#x2F;DI实现步骤</h3><ol><li><strong>配置元数据（配置）</strong></li></ol><p>基于 XML 的配置元数据的基本结构：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">1</span>] <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">2</span>]&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">1</span>] <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">2</span>]&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring IoC容器管理一个或多个组件。这些组件是使用你提供给容器的配置元数据（例如，以 XML <code>&lt;bean/&gt;</code> 定义的形式）创建的。<br><code>&lt;bean/&gt;</code>标签等于组件信息声明</p><ul><li><code>id</code>属性是标识单个 Bean 定义的字符串</li><li><code>class</code>属性定义 Bean 的类型并使用完全限定的类名</li></ul><ol start="2"><li><strong>实例化IoC容器</strong></li></ol><p>提供给 <code>ApplicationContext</code> 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code> 等）加载配置元数据。<br>选择一个合适的容器实现类，进行IoC容器的实例化工作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>获取Bean（组件）</strong></li></ol><p><code>ApplicationContext</code>是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，可以检索 bean 的实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获取ioc容器的组件对象</span></span><br><span class="line"><span class="type">PetStoreService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"><span class="comment">//使用组件对象</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure><h3 id="基于配置类方式管理Bean"><a href="#基于配置类方式管理Bean" class="headerlink" title="基于配置类方式管理Bean"></a>基于配置类方式管理Bean</h3><h4 id="完全注解开发理解"><a href="#完全注解开发理解" class="headerlink" title="完全注解开发理解"></a>完全注解开发理解</h4><p>​Spring完全注解配置是指通过Java配置类代码来配置Spring应用程序，使用注解来替代原本在XML配置文件中的配置。相对于XML配置，完全注解配置具有更强的类型安全性和更好的可读性。<br><strong>两种方式思维转化</strong>：<br>​<br><img src="https://secure2.wostatic.cn/static/uhRgky6LmFBAaYDJfS5SEm/image.png?auth_key=1711452973-o84mq7McYxi2kcJ7eJNooQ-0-8582a6ab10c941bc27775f9a4f2c775b"></p><h4 id="配置类和扫描注解"><a href="#配置类和扫描注解" class="headerlink" title="配置类和扫描注解"></a>配置类和扫描注解</h4><p><strong>xml+注解方式</strong></p><p>配置application.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置自动扫描的包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.包要精准,提高性能!</span></span><br><span class="line"><span class="comment">         2.会扫描指定的包和子包内容</span></span><br><span class="line"><span class="comment">         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.components&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入外部配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;application.properties&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试创建IoC容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xml方式配置文件使用ClassPathXmlApplicationContext容器读取</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>配置类+注解方式（完全注解方式）</strong><br>使用<code>@Configuration</code>注解将一个普通的类标记为Spring的配置类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标注当前类是配置类，替代application.xml    </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//使用注解读取外部配置，替代 &lt;context:property-placeholder标签</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="comment">//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>测试创建IoC容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">iocContainerAnnotation</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfiguration.class);</span><br></pre></td></tr></table></figure><h4 id="Bean定义组件"><a href="#Bean定义组件" class="headerlink" title="@Bean定义组件"></a>@Bean定义组件</h4><p><strong>场景需求</strong>：将Druid连接池对象存储到IoC容器<br><strong>需求分析</strong>：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式<br>配置类方式实现：<br><code>@Bean</code>注释用于指示方法实例化、配置和初始化要由Spring IoC容器管理的新对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标注当前类是配置类，替代application.xml    </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//引入jdbc.properties文件</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:application.properties&quot;,&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//如果第三方类进行IoC管理,无法直接使用@Component相关注解</span></span><br><span class="line">    <span class="comment">//解决方案: xml方式可以使用&lt;bean标签</span></span><br><span class="line">    <span class="comment">//解决方案: 配置类方式,可以使用方法返回值+@Bean注解</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.user&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span>String password,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span>String url,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>String driverClassName)</span>&#123;</span><br><span class="line">        <span class="comment">//使用Java代码实例化</span></span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种配置方式对比"><a href="#三种配置方式对比" class="headerlink" title="三种配置方式对比"></a>三种配置方式对比</h3><h4 id="XML方式配置"><a href="#XML方式配置" class="headerlink" title="XML方式配置"></a>XML方式配置</h4><ol><li>所有内容写到xml格式配置文件中</li><li>声明bean通过&lt;bean标签</li><li>&lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value &#x2F; ref</li><li>引入外部的properties文件可以通过&lt;context:property-placeholder</li><li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li></ol><h4 id="XML-注解方式配置"><a href="#XML-注解方式配置" class="headerlink" title="XML+注解方式配置"></a>XML+注解方式配置</h4><ol><li>注解负责标记IoC的类和进行属性装配</li><li>xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围</li><li>标记IoC注解：@Component,@Service,@Controller,@Repository </li><li>标记DI注解：@Autowired @Qualifier @Resource @Value</li><li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li></ol><h4 id="完全注解方式配置"><a href="#完全注解方式配置" class="headerlink" title="完全注解方式配置"></a>完全注解方式配置</h4><ol><li>完全注解方式指的是去掉xml文件，使用配置类 + 注解实现</li><li>xml文件替换成使用@Configuration注解标记的类</li><li>标记IoC注解：@Component,@Service,@Controller,@Repository </li><li>标记DI注解：@Autowired @Qualifier @Resource @Value</li><li><code>&lt;context:component-scan&gt;</code>标签指定注解范围使用@ComponentScan(basePackages &#x3D; {“”})替代</li><li><code>&lt;context:property-placeholder&gt;</code>引入外部配置文件使用@PropertySource({“classpath:application.properties”,”classpath:jdbc.properties”})替代</li><li><code>&lt;bean&gt;</code>标签使用@Bean注解和方法实现</li><li>IoC具体容器实现选择AnnotationConfigApplicationContext对象</li></ol><h3 id="整合Spring5-Test5搭建测试环境"><a href="#整合Spring5-Test5搭建测试环境" class="headerlink" title="整合Spring5-Test5搭建测试环境"></a>整合Spring5-Test5搭建测试环境</h3><ol><li><p>整合测试环境作用</p><p> 好处1：不需要自己创建IOC容器对象了</p><p> 好处2：任何需要的bean都可以在测试类中直接享受自动装配</p></li><li><p>导入相关依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>整合测试注解使用</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@SpringJUnitConfig(locations = &#123;&quot;classpath:spring-context.xml&quot;&#125;)  //指定配置文件xml</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = &#123;BeanConfig.class&#125;)</span>  <span class="comment">//指定配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Junit5IntegrationTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJunit5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="为什么要有Spring-AOP"><a href="#为什么要有Spring-AOP" class="headerlink" title="为什么要有Spring AOP"></a>为什么要有Spring AOP</h3><p>业务代码已经被一些非核心的代码所混淆，并且占据了大量的空间，显然这种显示的调用过程成为了我们开发过程中的一个痛点，如何将类似这种的非核心的代码剥离出去成为一个迫切需要解决的问题。<br>诸如日志记录，登录权限控制，还有数据库事务的控制，数据库连接的创建和关闭等等，这些都充斥这大量重复性的模板代码</p><h3 id="解决技术代理模式"><a href="#解决技术代理模式" class="headerlink" title="解决技术代理模式"></a>解决技术代理模式</h3><p><strong>代理模式</strong></p><p>​二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p><p>相关术语：</p><ul><li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。</li><li>动词：指做代理这个动作，或这项工作</li><li>名词：扮演代理这个角色的类、对象、方法</li><li>目标：<strong>被代理</strong>“套用”了核心逻辑代码的类、对象、方法。<br>代理在开发中实现的方式具体有两种：静态代理，[动态代理技术]</li></ul><p><strong>动态代理</strong><br>动态代理技术分类</p><ul><li>JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须<strong>实现接口</strong>！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口</li><li>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口</li></ul><h3 id="面向切面编程思维（AOP）"><a href="#面向切面编程思维（AOP）" class="headerlink" title="面向切面编程思维（AOP）"></a>面向切面编程思维（AOP）</h3><ol><li><strong>面向切面编程思想AOP</strong></li></ol><p>AOP：Aspect Oriented Programming面向切面编程<br>AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。<br>使用AOP，可以在不修改原来代码的基础上添加新功能</p><ol start="2"><li><strong>AOP思想主要的应用场景</strong></li></ol><p>AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景：</p><ul><li><p>日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。</p></li><li><p>事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。</p></li><li><p>安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。</p></li><li><p>性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。</p></li><li><p>异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。</p></li><li><p>缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。</p></li><li><p>动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。</p></li></ul><ol start="3"><li><strong>AOP术语名词介绍</strong></li></ol><ul><li>横切关注点</li></ul><p>​从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。<br>​AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><ul><li><p>通知(增强)：每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p><ul><li>前置通知：在被代理的目标方法前执行</li><li>返回通知：在被代理的目标方法成功结束后执行</li><li>异常通知：在被代理的目标方法异常结束后执行</li><li>后置通知：在被代理的目标方法最终结束后执行</li><li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li></ul></li><li><p>连接点 joinpoint</p></li></ul><p>​这也是一个纯逻辑概念，不是语法定义的。指那些被拦截到的点。在Spring中，可以被动态代理拦截目标类的方法<br>​    <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img010.5af189f7.png"></p><ul><li>切入点 pointcut</li></ul><p>​定位连接点的方式，或者可以理解成被选中的连接点！</p><ul><li>切面 aspect</li></ul><p>​切入点和通知的结合。是一个类。</p><ul><li>目标 target</li></ul><p>​被代理的目标对象。</p><ul><li>代理 proxy</li></ul><p>​向目标对象应用通知之后创建的代理对象。</p><ul><li>织入 weave</li></ul><p>​指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。</p><h3 id="Spring-AOP框架介绍和关系梳理"><a href="#Spring-AOP框架介绍和关系梳理" class="headerlink" title="Spring AOP框架介绍和关系梳理"></a>Spring AOP框架介绍和关系梳理</h3><ol><li>AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！</li><li>代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！</li><li>Spring AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！</li></ol><h3 id="Spring-AOP基于注解方式实现和细节"><a href="#Spring-AOP基于注解方式实现和细节" class="headerlink" title="Spring AOP基于注解方式实现和细节"></a>Spring AOP基于注解方式实现和细节</h3><h4 id="Spring-AOP底层技术组成"><a href="#Spring-AOP底层技术组成" class="headerlink" title="Spring AOP底层技术组成"></a>Spring AOP底层技术组成</h4><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img006.84eb95b7.png"></p><ul><li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。</li><li>cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。</li><li>AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。</li></ul><h4 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h4><ol><li>加入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>准备接口</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>纯净实现类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorPureImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i - j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i / j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>声明切面类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Aspect表示这个类是一个切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">// @Component注解保证这个切面类能够放入IOC容器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// @Before注解：声明当前方法是前置通知方法</span></span><br><span class="line">    <span class="comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP前置通知] 方法开始了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterException</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogFinallyEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>开启aspectj注解支持<ol><li>xml方式</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 进行包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启aspectj框架注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​2. 配置类方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;&quot;)</span></span><br><span class="line"><span class="comment">//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>测试效果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = &#123;MyConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCalculator</span><span class="params">()</span>&#123;</span><br><span class="line">        calculator.add(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.atguigu.test.AopTest,testCalculator</span><br><span class="line">[AOP前置通知] 方法开始了</span><br><span class="line">[AOP返回通知] 方法成功返回了</span><br><span class="line">[AOP后置通知] 方法最终结束了</span><br></pre></td></tr></table></figure><h4 id="获取通知细节信息"><a href="#获取通知细节信息" class="headerlink" title="获取通知细节信息"></a>获取通知细节信息</h4><ol><li><strong>JointPoint接口</strong><br>需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。</li></ol><ul><li>要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息）</li><li>要点2：通过目标方法签名对象获取方法名</li><li>要点3：通过JoinPoint对象获取外界调用目标方法时传入的实参列表组成的数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Before注解标记前置通知方法</span></span><br><span class="line"><span class="comment">// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上</span></span><br><span class="line"><span class="comment">// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入</span></span><br><span class="line"><span class="comment">// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(public int aop.api.Calculator.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.通过JoinPoint对象获取目标方法签名对象</span></span><br><span class="line">    <span class="comment">// 方法的签名：一个方法的全部声明信息</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.通过方法的签名对象获取目标方法的详细信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;methodName = &quot;</span> + methodName);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> signature.getModifiers();</span><br><span class="line">    System.out.println(<span class="string">&quot;modifiers = &quot;</span> + modifiers);</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">declaringTypeName</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">    System.out.println(<span class="string">&quot;declaringTypeName = &quot;</span> + declaringTypeName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.由于数组直接打印看不到具体数据，所以转换为List集合</span></span><br><span class="line">    List&lt;Object&gt; argList = Arrays.asList(args);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP前置通知] &quot;</span> + methodName + <span class="string">&quot;方法开始了，参数列表：&quot;</span> + argList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>方法返回值</strong></li></ol><p>在返回通知中，通过**@AfterReturning**注解的returning属性获取目标方法的返回值！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @AfterReturning注解标记返回通知方法</span></span><br><span class="line"><span class="comment">// 在返回通知中获取目标方法返回值分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterReturning注解中通过returning属性设置一个名称</span></span><br><span class="line"><span class="comment">// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参</span></span><br><span class="line"><span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        returning = &quot;targetMethodReturnValue&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreSuccess</span><span class="params">(JoinPoint joinPoint, Object targetMethodReturnValue)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP返回通知] &quot;</span>+methodName+<span class="string">&quot;方法成功结束了，返回值是：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>异常对象捕捉</strong></li></ol><p>在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @AfterThrowing注解标记异常通知方法</span></span><br><span class="line"><span class="comment">// 在异常通知中获取目标方法抛出的异常分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称</span></span><br><span class="line"><span class="comment">// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们</span></span><br><span class="line"><span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        throwing = &quot;targetMethodException&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreException</span><span class="params">(JoinPoint joinPoint, Throwable targetMethodException)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP异常通知] &quot;</span>+methodName+<span class="string">&quot;方法抛异常了，异常类型是：&quot;</span> + targetMethodException.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切点表达式语法"><a href="#切点表达式语法" class="headerlink" title="切点表达式语法"></a>切点表达式语法</h4><ol><li><strong>切点表达式</strong></li></ol><p>AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。</p><ol start="2"><li><strong>切点表达式语法</strong></li></ol><p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img011.dde1a79a.png"></p><p>语法细节</p><ul><li>第一位：execution( )固定开头</li><li>第二位：方法访问修饰符</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">private</span> 直接描述对应修饰符即可</span><br></pre></td></tr></table></figure><ul><li>第三位：方法返回值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> String <span class="keyword">void</span> 直接描述返回值类型</span><br></pre></td></tr></table></figure><ul><li>第四位：指定包的地址</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">固定的包: com.atguigu.api | service | dao</span><br><span class="line">单层的任意命名: com.atguigu.*  = api dao  * = 任意一层的任意命名</span><br><span class="line">任意层任意命名: com.. = api.erdaye com.a.a.a.a.a.a.a  ..任意层,任意命名 用在包上!</span><br><span class="line">注意: ..不能用作包开头   <span class="keyword">public</span> <span class="type">int</span> .. 错误语法  com..</span><br><span class="line">找到任何包下: *..</span><br></pre></td></tr></table></figure><ul><li>第五位：指定类名称</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">固定名称: UserService</span><br><span class="line">任意类名: *</span><br><span class="line">部分任意: com..service.impl.*Impl</span><br><span class="line">任意包任意类: *..*</span><br></pre></td></tr></table></figure><ul><li>第六位：指定方法名称<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">语法和类名一致</span><br><span class="line">任意访问修饰符,任意类的任意方法: * *..*.*</span><br></pre></td></tr></table></figure></li><li>第七位：方法参数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第七位: 方法的参数描述</span><br><span class="line">       具体值: (String,<span class="type">int</span>) != (<span class="type">int</span>,String) 没有参数 ()</span><br><span class="line">       模糊值: 任意参数 有 或者 没有 (..)  ..任意参数的意识</span><br><span class="line">       部分具体和模糊:</span><br><span class="line">         第一个参数是字符串的方法 (String..)</span><br><span class="line">         最后一个参数是字符串 (..String)</span><br><span class="line">         字符串开头,<span class="type">int</span>结尾 (String..<span class="type">int</span>)</span><br><span class="line">         包含<span class="type">int</span>类型(..<span class="type">int</span>..)</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>切点表达式案例</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>查询某包某类下，访问修饰符是公有，返回值是<span class="type">int</span>的全部方法</span><br><span class="line"><span class="number">2.</span>查询某包下类中第一个参数是String的方法</span><br><span class="line"><span class="number">3.</span>查询全部包下，无参数的方法！</span><br><span class="line"><span class="number">4.</span>查询com包下，以<span class="type">int</span>参数类型结尾的方法</span><br><span class="line"><span class="number">5.</span>查询指定包下，Service开头类的私有返回值<span class="type">int</span>的无参数方法</span><br></pre></td></tr></table></figure><h4 id="重用（提取）切点表达式"><a href="#重用（提取）切点表达式" class="headerlink" title="重用（提取）切点表达式"></a>重用（提取）切点表达式</h4><ol><li>重用切点表达式</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// @Before注解：声明当前方法是前置通知方法</span></span><br><span class="line"><span class="comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP前置通知] 方法开始了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterException</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogFinallyEnd</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同一类内部引用</li></ol><p>提取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切入点表达式重用</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(public int aop.api.Calculator.add(int,int)))</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">public void declarPointCut() &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>注意：提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！<br>引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;declarPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCoreOperation</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br></pre></td></tr></table></figure><ol start="3"><li>不同类中引用</li></ol><p>不同类在引用切点，只需要添加类的全限定符+方法名即可！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;aop.aspect.LogAspect.declarPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">roundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br></pre></td></tr></table></figure><ol start="4"><li>切点统一管理</li></ol><p>建议：将切点表达式统一存储到一个类中进行集中管理和维护！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtguiguPointCut</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(public int *..Calculator.sub(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atguiguGlobalPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(public int *..Calculator.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atguiguSecondPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* *..*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><p>环绕通知对应整个 try…catch…finally 结构，包括前面四种通知的所有功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用@Around注解标明环绕通知方法</span></span><br><span class="line"><span class="meta">@Around(value = &quot;aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">manageTransaction</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，</span></span><br><span class="line"><span class="params">        // Spring会将这个类型的对象传给我们</span></span><br><span class="line"><span class="params">        ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ProceedingJoinPoint对象获取目标方法的签名对象</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过签名对象获取目标方法的方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明变量用来存储目标方法的返回值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">targetMethodReturnValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在目标方法执行前：开启事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 开启事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，参数列表：&quot;</span> + Arrays.asList(args));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 过ProceedingJoinPoint对象调用目标方法</span></span><br><span class="line">        <span class="comment">// 目标方法的返回值一定要返回给外界调用者</span></span><br><span class="line">        targetMethodReturnValue = joinPoint.proceed(args);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法成功返回后：提交事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 提交事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，方法返回值：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">    </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">        <span class="comment">// 在目标方法抛异常后：回滚事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 回滚事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，异常：&quot;</span> + e.getClass().getName());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法最终结束后：释放数据库连接</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetMethodReturnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面优先级设置"><a href="#切面优先级设置" class="headerlink" title="切面优先级设置"></a>切面优先级设置</h4><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。</p><ul><li>优先级高的切面：外面</li><li>优先级低的切面：里面</li></ul><p>使用@Order注解可以控制切面的优先级： </p><ul><li>@Order(较小的数)：优先级高</li><li>@Order(较大的数)：优先级低</li></ul><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img012.b353bc56.png"></p><p>此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img014.ee4ed40a.png"></p><h4 id="CGLib动态代理生效"><a href="#CGLib动态代理生效" class="headerlink" title="CGLib动态代理生效"></a>CGLib动态代理生效</h4><p>在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。</p><p>使用总结：</p><ul><li>如果目标类有接口,选择使用jdk动态代理</li><li>如果目标类没有接口,选择cglib动态代理</li><li>如果有接口,接口接值</li><li>如果没有接口,类进行接值</li></ul><h4 id="注解实现小结"><a href="#注解实现小结" class="headerlink" title="注解实现小结"></a>注解实现小结</h4><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img015.9c921baf.png"></p><h2 id="Spring-声明式事务"><a href="#Spring-声明式事务" class="headerlink" title="Spring 声明式事务"></a>Spring 声明式事务</h2><h3 id="声明式事务概念"><a href="#声明式事务概念" class="headerlink" title="声明式事务概念"></a>声明式事务概念</h3><p>声明式事务是指使用注解或XML配置的方式来控制事务的提交和回滚。<br>开发者只需要添加配置即可，具体事务的实现由第三方框架实现，避免我们直接进行事务操作！<br>使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。</p><h4 id="Spring事务管理器"><a href="#Spring事务管理器" class="headerlink" title="Spring事务管理器"></a>Spring事务管理器</h4><ol><li>Spring声明式事务对应依赖</li></ol><ul><li>spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）</li><li>spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager</li><li>spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等</li></ul><ol start="2"><li>Spring声明式事务对应事务管理器接口</li></ol><p>​使用的事务管理器是<code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code>，将来整合JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现</p><p>DataSourceTransactionManager类中的主要方法：</p><ul><li>doBegin()：开启事务</li><li>doSuspend()：挂起事务</li><li>doResume()：恢复挂起的事务</li><li>doCommit()：提交事务</li><li>doRollback()：回滚事务</li></ul><h3 id="基于注解的声明式事务"><a href="#基于注解的声明式事务" class="headerlink" title="基于注解的声明式事务"></a>基于注解的声明式事务</h3><ol><li>准备项目</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 数据库驱动 和 连接池--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- spring-jdbc --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 声明式事务依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>外部配置文件</li></ol><p>jdbc.properties</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://localhost:3306/studb</span><br><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><ol start="3"><li>spring配置文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//druid连接池</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//jdbcTemplate</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>准备dao&#x2F;service层</li></ol><p>dao</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateNameById</span><span class="params">(String name,Integer id)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update students set name = ? where id = ? ;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> jdbcTemplate.update(sql, name, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAgeById</span><span class="params">(Integer age,Integer id)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update students set age = ? where id = ? ;&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,age,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>测试环境搭建</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(JavaConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testTx</span><span class="params">()</span>&#123;</span><br><span class="line">        studentService.changeInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="基本事务控制"><a href="#基本事务控制" class="headerlink" title="基本事务控制"></a>基本事务控制</h4><ol><li>配置事务管理器</li></ol><p>数据库相关的配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description: 数据库和连接池配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponenScan(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化dataSource加入到ioc容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span>String url,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>String driver,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span>String username,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span>String password)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化JdbcTemplate对象,需要使用ioc中的DataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装配事务管理实现对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用声明事务注解@Transactional</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试事务效果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(classes = DataSourceConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testTx</span><span class="params">()</span>&#123;</span><br><span class="line">        studentService.changeInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="事务属性：只读"><a href="#事务属性：只读" class="headerlink" title="事务属性：只读"></a>事务属性：只读</h4><ol><li>只读介绍</li></ol><p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化</p><ol start="2"><li>设置方式</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readOnly = true把当前事务设置为只读 默认是false!</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>针对DML动作设置只读模式</li></ol><p>会抛出下面异常：</p><blockquote><p>Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed</p></blockquote><ol start="4"><li>@Transactional注解放在类上</li><li>生效原则</li></ol><p>​如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将 @Transactional 注解提取到类上。反过来说：@Transactional 注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional 注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了 @Transactional 注解。对一个方法来说，离它最近的 @Transactional 注解中的事务属性设置生效。</p><ol start="6"><li>用法举例</li></ol><p>​在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了便于核对数据库操作结果，不要修改同一条记录</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateTwice</span><span class="params">(……)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// readOnly = true把当前事务设置为只读</span></span><br><span class="line">    <span class="comment">// @Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmpName</span><span class="params">(Integer empId)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务属性：超时时间"><a href="#事务属性：超时时间" class="headerlink" title="事务属性：超时时间"></a>事务属性：超时时间</h4><ol><li>需求</li></ol><p>​事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。<br>​此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p><p>概括来说就是一句话：超时回滚，释放资源。</p><ol start="2"><li>设置超时时间</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,timeout = 3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//休眠4秒,等待方法超时!</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试超时效果</li></ol><p>执行抛出事务超时异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Wed May <span class="number">24</span> 09:<span class="number">10</span>:<span class="number">43</span> IRKT <span class="number">2023</span></span><br><span class="line"></span><br><span class="line">  at org.springframework.transaction.support.ResourceHolderSupport.checkTransactionTimeout(ResourceHolderSupport.java:<span class="number">155</span>)</span><br><span class="line">  at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInMillis(ResourceHolderSupport.java:<span class="number">144</span>)</span><br><span class="line">  at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInSeconds(ResourceHolderSupport.java:<span class="number">128</span>)</span><br><span class="line">  at org.springframework.jdbc.datasource.DataSourceUtils.applyTimeout(DataSourceUtils.java:<span class="number">341</span>)</span><br><span class="line">  at org.springframework.jdbc.core.JdbcTemplate.applyStatementSettings(JdbcTemplate.java:<span class="number">1467</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="事务属性：事务异常"><a href="#事务属性：事务异常" class="headerlink" title="事务属性：事务异常"></a>事务属性：事务异常</h4><ol><li>默认情况</li></ol><p>默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,timeout = 3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置回滚异常</li></ol><p>rollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and Error 异常方可回滚!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment"> * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment"> * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! </span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>设置不回滚的异常</li></ol><p>在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。</p><p>noRollbackFor属性：指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="事务属性：事务隔离级别"><a href="#事务属性：事务隔离级别" class="headerlink" title="事务属性：事务隔离级别"></a>事务属性：事务隔离级别</h4><ol><li>事务隔离级别</li></ol><p>数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：</p><ul><li><p>读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。</p></li><li><p>读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。</p></li><li><p>可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。</p></li><li><p>串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。</p></li></ul><p>不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。</p><ol start="2"><li>事务隔离级别设置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,</span></span><br><span class="line"><span class="meta">                   timeout = 3,</span></span><br><span class="line"><span class="meta">                   rollbackFor = Exception.class,</span></span><br><span class="line"><span class="meta">                   noRollbackFor = FileNotFoundException.class,</span></span><br><span class="line"><span class="meta">                   isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务属性：事务传播行为"><a href="#事务属性：事务传播行为" class="headerlink" title="事务属性：事务传播行为"></a>事务属性：事务传播行为</h4><ol><li>事务传播行为要研究的问题</li></ol><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img012.faac2cb7.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MethodA</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    MethodB();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MethodB</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>propagation属性</li></ol><p>@Transactional注解通过propagation属性设置事务的传播行为。它的默认值是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br></pre></td></tr></table></figure><p>propagation属性的可选值由org.springframework.transaction.annotation.Propagation枚举类提供：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>REQUIRED 默认值</td><td>如果父方法有事务，就加入，如果没有就新建自己独立</td></tr><tr><td>REQUIRES_NEW</td><td>不管父方法是否有事务，都新建事务，都是独立的</td></tr></tbody></table><ul><li>声明两个业务方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,</span></span><br><span class="line"><span class="meta">                   timeout = 3,</span></span><br><span class="line"><span class="meta">                   rollbackFor = Exception.class,</span></span><br><span class="line"><span class="meta">                   noRollbackFor = FileNotFoundException.class,</span></span><br><span class="line"><span class="meta">                   isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明两个独立修改数据库的事务业务方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeAge</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">99</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeName</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test2&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明一个整合业务方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">topService</span><span class="params">()</span>&#123;</span><br><span class="line">        studentService.changeAge();</span><br><span class="line">        studentService.changeName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加传播行为测试</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(classes = AppConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TopService topService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testTx</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        topService.topService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>    在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。</p><h5 id="其他传播行为值"><a href="#其他传播行为值" class="headerlink" title="其他传播行为值"></a>其他传播行为值</h5><ul><li>Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。</li><li>Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。</li><li>Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。</li><li>Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。</li><li>Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。</li><li>Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。</li><li>Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。</li></ul><h2 id="Spring核心点"><a href="#Spring核心点" class="headerlink" title="Spring核心点"></a>Spring核心点</h2><table><thead><tr><th>核心点</th><th>掌握目标</th></tr></thead><tbody><tr><td>spring框架理解</td><td>spring家族和spring framework框架</td></tr><tr><td>spring核心功能</td><td>ioc&#x2F;di , aop , tx</td></tr><tr><td>spring ioc &#x2F; di</td><td>组件管理、ioc容器、ioc&#x2F;di , 三种配置方式</td></tr><tr><td>spring aop</td><td>aop和aop框架和代理技术、基于注解的aop配置</td></tr><tr><td>spring tx</td><td>声明式和编程式事务、动态事务管理器、事务注解、属性</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven工具入门</title>
      <link href="/inori/aba8722c.html"/>
      <url>/inori/aba8722c.html</url>
      
        <content type="html"><![CDATA[<p>Maven 是一款为 Java 项目构建管理、依赖管理的工具（<strong>软件</strong>），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。</p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ol><li>场景概念</li></ol><p>​<strong>场景1：</strong>例如我们项目需要第三方库（依赖），如Druid连接池、MySQL数据库驱动和Jackson等。那么我们可以将需要的依赖项的信息编写到Maven工程的配置文件，Maven软件就会自动下载并复制这些依赖项到项目中，也会自动下载依赖需要的依赖！确保依赖版本正确无冲突和依赖完整</p><p>​<strong>场景2：</strong>项目开发完成后，想要将项目打成.war文件，并部署到服务器中运行，使用Maven软件，我们可以通过一行构建命令（mvn package）快速项目构建和打包<br>2. <strong>依赖管理：</strong></p><p>​Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，而我们仅仅需要编写配置即可<br>3. <strong>构建管理：</strong></p><p>​项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程</p><p>Maven可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可</p><p><img src="https://secure2.wostatic.cn/static/7crHSdhCetVYi4F1JxGLhz/image.png?auth_key=1711440213-eAgGzx2hYA5VgtcCYWA16G-0-6344489149ced524bf51fdb562e4623b"></p><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>安装好Maven并配置环境变量后，使用<code>mvn -v</code>命令测试是否配置完成，如果输出版本信息则配置成功。、</p><ol><li>配置文件</li></ol><blockquote><p>需要修改<strong>maven&#x2F;conf&#x2F;settings.xml</strong>配置文件，来修改maven的一些默认配置。我们主要修改的有三个配置：<br>1.依赖本地缓存位置（本地仓库位置）<br>2.maven下载镜像<br>3.maven选用编译项目的jdk版本</p></blockquote><p>配置本地仓库</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>想要配置为仓库的绝对路径<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置国内阿里镜像</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置jdk17版本项目构建</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-17<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>17<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maven目录"><a href="#maven目录" class="headerlink" title="maven目录"></a>maven目录</h2><ul><li><strong>bin目录</strong>： 该目录包含了mvn运行的脚本，这些脚本用来配置java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。</li><li><strong>boot目录</strong>: 该目录只包含一个文件，该文件为plexus-classworlds-2.5.2.jar。plexus-classworlds是一个类加载器框架，相对于默认的java类加载器，它提供了更加丰富的语法以方便配置，Maven使用该框架加载自己的类库。</li><li><strong>conf目录</strong>: 该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为，一般情况下，我们更偏向于复制该文件至<del>&#x2F;.m2&#x2F;目录下（</del>表示用户目录），然后修改该文件，在用户范围定制Maven的行为。</li><li><strong>lib目录</strong>: 该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar、maven-model-3.0.jar之类的文件，此外这里还包含一些Maven用到的第三方依赖如commons-cli-1.2.jar、commons-lang-2.6.jar等等。</li></ul><h2 id="Maven常用命令说明"><a href="#Maven常用命令说明" class="headerlink" title="Maven常用命令说明"></a>Maven常用命令说明</h2><ul><li><strong>mvn clean</strong>：表示运行清理操作（会默认把target文件夹中的数据清理）</li><li><strong>mvn clean compile</strong>：表示先运行清理之后运行编译，会将代码编译到target文件夹中</li><li><strong>mvn clean test</strong>：运行清理和测试</li><li><strong>mvn clean package</strong>：运行清理和打包</li><li><strong>mvn clean install</strong>：运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用</li><li><strong>mvn clean deploy</strong>：运行清理和发布（发布到私服上面）</li></ul><h2 id="设置http代理"><a href="#设置http代理" class="headerlink" title="设置http代理"></a>设置http代理</h2><p>编辑setting.xml文件，先检查一下代理服务器是否畅通。首先运行<code>telnet IP地址+端口</code>来检测该地址的该端口是否畅通。如果得到出错信息，需要先获取正确的代理服务信息</p><p>检查完毕之后，编辑~&#x2F;.m2&#x2F;settings.xml文件(如果没有该文件，则复制$M2_HOME&#x2F;conf&#x2F;settings.xml)。添加代理配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">proxy</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">host</span>&gt;</span>IP地址<span class="tag">&lt;/<span class="name">host</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>端口号<span class="tag">&lt;/<span class="name">port</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;username&gt;***&lt;/username&gt;  </span></span><br><span class="line"><span class="comment">        &lt;password&gt;***&lt;/password&gt;  </span></span><br><span class="line"><span class="comment">        &lt;nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">          repository.mycom.com|*.baidu.com  </span></span><br><span class="line"><span class="comment">        &lt;/nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">proxy</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>proxies下可以有多个proxy元素，如果声明了多个proxy元素，则默认情况下第一个被激活的proxy会生效。active的值为true表示激活该代理，protocol表示使用的代理协议，这里是http。最重要的是指定正确的主机名和端口。当代理服务需要认证时，就需要配置username和password。nonProxyHost元素用来指定哪些主机不需要代理，可以使用”|”符号来分隔多个主机名。</p><h2 id="依赖的配置"><a href="#依赖的配置" class="headerlink" title="依赖的配置"></a>依赖的配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>实际项目<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>模块<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">version</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">type</span>&gt;</span>依赖类型<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">scope</span>&gt;</span>依赖范围<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">optional</span>&gt;</span>依赖是否可选<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">　　　　 &lt;!—主要用于排除传递性依赖--&gt;</span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">　　　　     <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">　　　　　　　    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　　　　　　　　 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　　　　　　<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根元素project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：</p><ul><li><strong>grounpId、artifactId和version</strong>:以来的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。</li><li><strong>type</strong>:依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar</li><li><strong>scope</strong>:依赖的范围</li><li><strong>optional</strong>:标记依赖是否可选</li><li><strong>exclusions</strong>:用来排除传递性依赖</li></ul><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系，Maven有如下几种依赖范围：</p><ul><li>**compile:**编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。</li><li><strong>test:</strong> 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。</li><li>**provided:**已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。</li><li>**runtime:**运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</li><li>**system:**系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致，但是，使用system范围的依赖时必须通过systemPath元素显示地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.sql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbc-stdext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**import:**导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。 上述除import以外的各种依赖范围与三种classpath的关系如下:</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b27fceaaf09e1~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h2 id="依赖范围-1"><a href="#依赖范围-1" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>假设A依赖于B,B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。第一直接依赖和第二直接依赖的范围决定了传递性依赖的范围，如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间的交叉单元格则表示传递依赖范围。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b27fceba81e2b~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>从上图中，我们可以发现这样的规律：</p><ul><li>当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致；</li><li>当第二直接依赖的范围是test的时候，依赖不会得以传递；</li><li>当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，切传递依赖的范围同样为provided;</li><li>当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile列外，此时传递性依赖范围为runtime.</li></ul><h2 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h2><p>有时候，当传递性依赖造成为题的时候，就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。这就是依赖调解的作用，依赖调解有两大原则： </p><ol><li>路径最近者优先 比如项目有A有这样的依赖关系：A-&gt;B-&gt;C-&gt;X(1.0)、A-&gt;D-&gt;X(2.0),X是A的传递性依赖，但是两条依赖路径上有两个版本的X，所以根据第一原则，A-&gt;D-&gt;X(2.0)路径短，所以X(2.0)会被解析使用</li><li>第一声明者优先 如果路径都一样长的话，第一原则就不行了，比如 A-&gt;B-&gt;Y(1.0)、A-&gt;C-&gt;Y(2.0),Y(1.0)和Y(2.0)的路径一样，所以这时候根据第二原则，先声明的被解析。</li></ol><h2 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h2><p>有时候你引入的依赖中包含你不想要的依赖包，你想引入自己想要的，这时候就要用到排除依赖了，比如下图中spring-boot-starter-web自带了logback这个日志包，我想引入log4j2的，所以我先排除掉logback的依赖包，再引入想要的包就行了</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b27fd18cdd481~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>排除依赖代码结构：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure><p>声明exclustion的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId就能唯一定位依赖图中的某个依赖。</p><h2 id="归类依赖"><a href="#归类依赖" class="headerlink" title="归类依赖"></a>归类依赖</h2><p>有时候我们引入的很多依赖包，他们都来自同一个项目的不同模块，所以他们的版本号都一样，这时候我们可以用属性来统一管理版本号</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juven.mvnbook.account<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>accout-email<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>如图所示，先通过</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    这里定义你需要的版本</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来定义，然后在下面依赖使用${}来引入你的属性。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>在Maven世界中，任何一个依赖、插件或者项目构建的输出，都可以称为构件。得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是仓库。</p><p>实际的Maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候（例如，编译项目的时候需要将依赖加入到classpath中），Maven会自动根据坐标找到仓库中的构件，并使用它们。</p><p>为了实现重用，项目构建完毕后可生成的构件也可以安装或者部署到仓库中，供其他项目使用。</p><h2 id="仓库的布局"><a href="#仓库的布局" class="headerlink" title="仓库的布局"></a>仓库的布局</h2><p>任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径，这便是Maven的仓库布局方式。 该路经与坐标对应关系为groupId&#x2F;artifactId&#x2F;version&#x2F;artifactId-version.packaging</p><p>Maven仓库是基于简单文件系统存储的，我们也理解其存储方式、因此，当遇到一些与仓库相关的问题时，可以很方便的查找相关文件，方便定位问题</p><h2 id="仓库的分类"><a href="#仓库的分类" class="headerlink" title="仓库的分类"></a>仓库的分类</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b27fd1730a299~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>一般来说，在Maven项目目录下，没有诸如lib&#x2F;这样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。</p><p>默认情况下，不管在Window还是Linux下，每个用户在自己用户目录下都有一个路径名为.m2&#x2F;repository&#x2F;的仓库目录。 如果你想自定义本地仓库目录地址。你可以编辑文件~&#x2F;.m2&#x2F;settings.xml，设置localRepository元素的值为想要的仓库地址，例如:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\repository\<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，该用户的本地仓库地址就被设置成了 D:\repository\。 需要注意的是，默认情况下，~&#x2F;.m2&#x2F;settings.xml文件不存在，用户需要从Maven安装目录复制$M2_HOME&#x2F;conf&#x2F;settings.xml文件再进行编辑。</p><h3 id="远程仓库-中央仓库"><a href="#远程仓库-中央仓库" class="headerlink" title="远程仓库-中央仓库"></a>远程仓库-中央仓库</h3><p>由于最原始的本地仓库是空的，Maven必须知道至少一个可用的远程仓库，才能在执行Maven命令的时候下载到需要的构件。中央仓库就是这样一个默认的远程仓库，Maven的安装文件自带了中央仓库的配置。</p><p>中央仓库包含了这个世界上绝大多数流行的开源Java构件，以及源码、作者信息、SCM,信息、许可证信息等，每个月这里都会接受全世界Java程序员大概1亿次的访问，它对全世界Java开发者的贡献由此可见一斑。</p><h3 id="远程仓库-私服"><a href="#远程仓库-私服" class="headerlink" title="远程仓库-私服"></a>远程仓库-私服</h3><p>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。因此，一些无法从外部仓库下载到的构件也能从本地上传到私服上供大家使用。 私服的好处：</p><ul><li>节省自己的外网速度</li><li>加速Maven构建</li><li>部署第三方构建</li><li>提高稳定性，增强控制</li><li>降低中央仓库的负荷</li></ul><h2 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h2><p>在平时的开发中，我们往往不会使用默认的中央仓库，默认的中央仓库访问的速度比较慢，访问的人或许很多，有时候也无法满足我们项目的需求，可能项目需要的某些构件中央仓库中是没有的，而在其他远程仓库中有，如JBoss Maven仓库。这时，可以在pom.xml中配置该仓库，代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.com/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**repository:**在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。</li><li><strong>id：</strong>仓库声明的唯一id，尤其需要注意的是，Maven自带的中央仓库使用的id为central，如果其他仓库声明也使用该id，就会覆盖中央仓库的配置。</li><li><strong>name：</strong>仓库的名称，让我们直观方便的知道仓库是哪个，暂时没发现其他太大的含义。</li><li><strong>url：</strong>指向了仓库的地址，一般来说，该地址都基于http协议，Maven用户都可以在浏览器中打开仓库地址浏览构件。</li><li>**releases和snapshots：**用来控制Maven对于发布版构件和快照版构件的下载权限。需要注意的是**enabled**子元素，该例中releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持，而snapshots的enabled值为false，表示关闭JBoss仓库的快照版本的下载支持。根据该配置，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。</li><li><strong>layout：</strong>元素值default表示仓库的布局是Maven2及Maven3的默认布局，而不是Maven1的布局。基本不会用到Maven1的布局。</li><li><strong>其他：**对于releases和snapshots来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy。<br>1：元素**updatePolicy**用来配置Maven从远处仓库检查更新的频率，默认值是daily，表示Maven每天检查一次。其他可用的值包括：never-从不检查更新；always-每次构建都检查更新；interval：X-每隔X分钟检查一次更新（X为任意整数）。<br>2：元素</strong>checksumPolicy**用来配置Maven检查校验和文件的策略。当构建被部署到Maven仓库中时，会同时部署对应的检验和文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其他可用的值包括：fail-Maven遇到校验和错误就让构建失败；ignore-使Maven完全忽略校验和错误。</li></ul><h2 id="远程仓库认证"><a href="#远程仓库认证" class="headerlink" title="远程仓库认证"></a>远程仓库认证</h2><p>大部分的远程仓库不需要认证，但是如果是自己内部使用，为了安全起见，还是要配置认证信息的。配置认证信息和配置远程仓库不同，远程仓库可以直接在pom.xml中配置，但是认证信息必须配置在settings.xml文件中。这是因为pom往往是被提交到代码仓库中供所有成员访问的，而settings.xml一般只存在于本机。因此，在settings.xml中配置认证信息更为安全。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里除了配置账号密码之外，值关键的就是id了，这个id要跟你在pom.xml里面配置的远程仓库repository的id一致，正是这个id将认证信息与仓库配置联系在了一起。</p><h2 id="部署构件至远程仓库"><a href="#部署构件至远程仓库" class="headerlink" title="部署构件至远程仓库"></a>部署构件至远程仓库</h2><p>我们自己搭建远程仓库的目的就是为了可以方便部署我们自己项目的构件以及一些无法从外部仓库直接获取的构件。这样才能在开发时，供其他对团队成员使用。 Maven除了能对项目进行编译、测试、打包之外，还能将项目生成的构件部署到远程仓库中。首先，需要编辑项目的pom.xml文件。配置distributionManagement元素，代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>public<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>地址<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>地址<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>repository表示表示发布版本（稳定版本）构件的仓库，snapshotRepository表示快照版本（开发测试版本）的仓库。这两个元素都需要配置id、name和url，id为远程仓库的唯一标识，name是为了方便人阅读，关键的url表示该仓库的地址。</p><p>配置完成后运行命令mvn clean deploy，Maven就会将项目构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本的仓库地址，否则就部署到发布版本的仓库地址。当前项目是快照还是发布版本是通过 true 这个来区分的</p><h2 id="仓库服务搜索"><a href="#仓库服务搜索" class="headerlink" title="仓库服务搜索"></a>仓库服务搜索</h2><ul><li>Sonatype Nexus：<a href="https://link.juejin.cn/?target=https://repository.sonatype.org/">repository.sonatype.org&#x2F;</a></li><li>MVNrepository：<a href="https://link.juejin.cn/?target=http://mvnrepository.com/">mvnrepository.com&#x2F;</a></li></ul><p>另外推荐一个插件：Maven Search，可以快速找到需要的jar包</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb技术（下）</title>
      <link href="/inori/7786d571.html"/>
      <url>/inori/7786d571.html</url>
      
        <content type="html"><![CDATA[<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><blockquote><p><code>前端工程化</code>是使用<code>软件工程的方法</code>来<code>单独</code>解决<code>前端</code>的开发流程中<code>模块化、组件化、规范化、自动化</code>的问题,其主要目的为了提高效率和降低成本。 </p></blockquote><h3 id="实现技术栈"><a href="#实现技术栈" class="headerlink" title="实现技术栈"></a>实现技术栈</h3><blockquote><p>前端工程化实现的技术栈有很多,在这里采用ES6+nodejs+npm+Vite+VUE3+router+pinia+axios+Element-plus组合实现</p></blockquote><ul><li>ECMAScript6       VUE3中大量使用ES6语法</li><li>Nodejs                前端项目运行环境</li><li>npm                    依赖下载工具</li><li>vite                      前端项目构建工具</li><li>VUE3                   优秀的渐进式前端框架</li><li>router                 通过路由实现页面切换</li><li>pinia                   通过状态管理实现组件数据传递</li><li>axios                   ajax异步请求封装技术实现前后端数据交互</li><li>Element-plus     可以提供丰富的快速构建网页的组件仓库</li></ul><h2 id="ECMAScript6"><a href="#ECMAScript6" class="headerlink" title="ECMAScript6"></a>ECMAScript6</h2><blockquote><p>ECMAScript6，简称ES6，是<strong>JavaScript</strong>语言的一次重大更新。ES6带来了大量的新特性，包括箭头函数、模板字符串、let和const关键字、解构、默认参数值、模块系统等等，大大提升了JavaScript的开发体验。</p></blockquote><p>ES6对JavaScript的改进在以下几个方面：</p><ol><li>更加简洁：ES6引入了一些新的语法，如箭头函数、类和模板字符串等，使代码更加简洁易懂。</li><li>更强大的功能：ES6引入了一些新的API、解构语法和迭代器等功能，从而使得JavaScript更加强大。</li><li>更好的适用性：ES6引入的模块化功能为JavaScript代码的组织和管理提供了更好的方式，不仅提高了程序的可维护性，还让JavaScript更方便地应用于大型的应用程序。</li></ol><h3 id="变量和模板字符串"><a href="#变量和模板字符串" class="headerlink" title="变量和模板字符串"></a>变量和模板字符串</h3><blockquote><p>ES6 新增了<code>let</code>和<code>const</code>，用来声明变量,使用的细节上也存在诸多差异</p></blockquote><ul><li><p>let和var的差别</p><p>1、let不能重复声明</p><p>2、let有块级作用域，非函数的花括号遇见let会有块级作用域，也就是只能在花括号里面访问。</p><p>3、let不会预解析进行变量提升</p><p>4、let定义的全局变量不会作为window的属性</p></li><li><p>const和var的差异</p><p>1、新增const和let类似，只是const定义的变量不能修改</p><p>2、并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p></li></ul><blockquote><p>模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识  </p></blockquote><p>1、字符串中可以出现换行符</p><p>2、可以使用 ${xxx} 形式输出变量和拼接变量</p><h3 id="解构表达式"><a href="#解构表达式" class="headerlink" title="解构表达式"></a>解构表达式</h3><blockquote><p>ES6 的解构赋值是一种方便的语法，可以快速将数组或对象中的值拆分并赋值给变量。解构赋值的语法使用花括号 <code>&#123;&#125;</code> 表示对象，方括号 <code>[]</code> 表示数组。通过解构赋值，函数更方便进行参数接受等！</p></blockquote><p><strong>数组解构赋值</strong></p><ul><li>可以通过数组解构将数组中的值赋值给变量，语法为：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">//新增变量名任意合法即可，本质是按照顺序进行初始化变量的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>该语句将数组 [1, 2, 3] 中的第一个值赋值给 a 变量，第二个值赋值给 b 变量，第三个值赋值给 c 变量。<br>可以使用默认值为变量提供备选值，在数组中缺失对应位置的值时使用该默认值。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d = <span class="number">4</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>对象解构赋值</strong></p></blockquote><ul><li>可以通过对象解构将对象中的值赋值给变量，语法为：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//新增变量名必须和属性名相同，本质是初始化变量的值为对象中同名属性的值</span></span><br><span class="line"><span class="comment">//等价于 let a = 对象.a  let b = 对象.b</span></span><br><span class="line">  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>该语句将对象 {a: 1, b: 2} 中的 a 属性值赋值给 a 变量，b 属性值赋值给 b 变量。<br>可以为标识符分配不同的变量名称，使用 : 操作符指定新的变量名。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: x, <span class="attr">b</span>: y&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>函数参数解构赋值</strong></p></blockquote><ul><li>解构赋值也可以用于函数参数。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">[x, y]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li><p>该函数接受一个数组作为参数，将其中的第一个值赋给 x，第二个值赋给 y，然后返回它们的和。</p></li><li><p>ES6 解构赋值让变量的初始化更加简单和便捷。通过解构赋值，我们可以访问到对象中的属性，并将其赋值给对应的变量，从而提高代码的可读性和可维护性。</p></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//ES6 允许使用“箭头”（=&gt;）定义函数。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 函数声明</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> fn1 = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fn2</span> = (<span class="params"></span>)=&gt;&#123;&#125; <span class="comment">//箭头函数,此处不需要书写function关键字</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fn3</span> = x =&gt;&#123;&#125; <span class="comment">//单参数可以省略(),多参数无参数不可以</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fn4</span> = x =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">//只有一行方法体可以省略&#123;&#125;;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fun5</span> = x =&gt; x + <span class="number">1</span> <span class="comment">//当函数体只有一句返回值时，可以省略花括号和 return 语句</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. 使用特点 箭头函数this关键字</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在 JavaScript 中，this 关键字通常用来引用函数所在的对象，</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 或者在函数本身作为构造函数时，来引用新对象的实例。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 但是在箭头函数中，this 的含义与常规函数定义中的含义不同，</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 并且是由箭头函数定义时的上下文来决定的，而不是由函数调用时的上下文来决定的。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 箭头函数没有自己的this，this指向的是外层上下文环境的this</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person =&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">showName</span>:<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">//  这里的this是person</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">viewName</span>: <span class="function">() =&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">//  这里的this是window</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    person.<span class="title function_">showName</span>()</span></span><br><span class="line"><span class="language-javascript">    person.<span class="title function_">viewName</span>()</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//this应用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 这里的 this 是上一层作用域中的 this，即 Counter实例化对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">count</span>++;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">count</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="rest和spread"><a href="#rest和spread" class="headerlink" title="rest和spread"></a>rest和spread</h4><blockquote><p>rest参数,在形参上使用和JAVA中的可变参数几乎一样</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1 参数列表中多个普通参数  普通函数和箭头函数中都支持</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> fun1 = <span class="keyword">function</span> (<span class="params">a,b,c,d=<span class="number">10</span></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c,d)&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fun2</span> = (<span class="params">a,b,c,d=<span class="number">10</span></span>) =&gt;&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c,d)&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun1</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun2</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2 ...作为参数列表,称之为rest参数 普通函数和箭头函数中都支持 ,因为箭头函数中无法使用arguments,rest是一种解决方案</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> fun3 = <span class="keyword">function</span> (<span class="params">...args</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(args)&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fun4</span> = (<span class="params">...args</span>) =&gt;&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(args)&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun3</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun4</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// rest参数在一个参数列表中的最后一个只,这也就无形之中要求一个参数列表中只能有一个rest参数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//let fun5 =  (...args,...args2) =&gt;&#123;&#125; // 这里报错</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>spread参数,在实参上使用rest</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//let arrSpread = ...arr;// 这样不可以,...arr必须在调用方法时作为实参使用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fun1</span> =(<span class="params">a,b,c</span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 调用方法时,对arr进行转换 转换为1,2,3 </span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun1</span>(...arr)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//应用场景1 合并数组</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> arr3=[...arr,...arr2]</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr3)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//应用场景2 合并对象属性</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> p1=&#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> p2=&#123;<span class="attr">age</span>:<span class="number">10</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> p3=&#123;<span class="attr">gender</span>:<span class="string">&quot;boy&quot;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person =&#123;...p1,...p2,...p3&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="对象创建和拷贝"><a href="#对象创建和拷贝" class="headerlink" title="对象创建和拷贝"></a>对象创建和拷贝</h3><h4 id="对象创建的语法糖"><a href="#对象创建的语法糖" class="headerlink" title="对象创建的语法糖"></a>对象创建的语法糖</h4><blockquote><p>ES6中新增了对象创建的语法糖,支持了class extends constructor等关键字,让ES6的语法和面向对象的语法更加接近</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">      <span class="comment">// 属性</span></span><br><span class="line">      #n;</span><br><span class="line">      age;</span><br><span class="line">      <span class="keyword">get</span> <span class="title function_">name</span>()&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">n</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">n</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">n</span> =n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 实例方法</span></span><br><span class="line">      <span class="title function_">eat</span>(<span class="params">food</span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>+<span class="string">&quot;岁的&quot;</span>+<span class="variable language_">this</span>.<span class="property">n</span>+<span class="string">&quot;用筷子吃&quot;</span>+food)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 静态方法</span></span><br><span class="line">      <span class="keyword">static</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> a+b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 构造器</span></span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">n</span>=name;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> person =<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// 访问对象属性</span></span><br><span class="line">  <span class="comment">// 调用对象方法</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">n</span>)</span><br><span class="line">  person.<span class="property">name</span>=<span class="string">&quot;小明&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>)</span><br><span class="line">  person.<span class="title function_">eat</span>(<span class="string">&quot;火锅&quot;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span>  <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">      grade ;</span><br><span class="line">      score ;</span><br><span class="line">      <span class="title function_">study</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">name,age </span>) &#123;</span><br><span class="line">          <span class="variable language_">super</span>(name,age);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> stu =<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>,<span class="number">18</span>);</span><br><span class="line">  stu.<span class="title function_">eat</span>(<span class="string">&quot;面条&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="模块化处理"><a href="#模块化处理" class="headerlink" title="模块化处理"></a>模块化处理</h3><blockquote><p>模块化是一种组织和管理前端代码的方式，将代码拆分成小的模块单元，使得代码更易于维护、扩展和复用。它包括了定义、导出、导入以及管理模块的方法和规范。前端模块化的主要优势如下：</p></blockquote><ol><li>提高代码可维护性：通过将代码拆分为小的模块单元，使得代码结构更为清晰，可读性更高，便于开发者阅读和维护。</li><li>提高代码可复用性：通过将重复使用的代码变成可复用的模块，减少代码重复率，降低开发成本。</li><li>提高代码可扩展性：通过模块化来实现代码的松耦合，便于更改和替换模块，从而方便地扩展功能。</li></ol><blockquote><p>目前，前端模块化有多种规范和实现，包括 CommonJS、AMD 和 ES6 模块化。ES6 模块化是 JavaScript 语言的模块标准，使用 import 和 export 关键字来实现模块的导入和导出。现在，大部分浏览器都已经原生支持 ES6 模块化，因此它成为了最为广泛使用的前端模块化标准</p></blockquote><ul><li>ES6模块化的几种暴露和导入方式<ol><li>分别导出</li><li>统一导出</li><li>默认导出</li></ol></li><li><code>ES6中无论以何种方式导出,导出的都是一个对象,导出的内容都可以理解为是向这个对象中添加属性或者方法</code></li></ul><h4 id="分别导出"><a href="#分别导出" class="headerlink" title="分别导出"></a>分别导出</h4><ul><li>module.js 向外分别暴露成员</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.分别暴露</span></span><br><span class="line"><span class="comment">// 模块想对外导出,添加export关键字即可!</span></span><br><span class="line"><span class="comment">// 导出一个变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 导出一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>app.js 导入module.js中的成员</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    *代表module.js中的所有成员</span></span><br><span class="line"><span class="comment">    m1代表所有成员所属的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="comment">// 使用暴露的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m1.<span class="property">PI</span>)</span><br><span class="line"><span class="comment">// 调用暴露的方法</span></span><br><span class="line"><span class="keyword">let</span> result =m1.<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="comment">// 使用暴露的Person类</span></span><br><span class="line"><span class="keyword">let</span> person =<span class="keyword">new</span> m1.<span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">person.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><ul><li>index.html作为程序启动的入口  导入 app.js</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入JS文件 添加type=&#x27;module&#x27; 属性,否则不支持ES6的模块化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./app.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure><h4 id="统一导出"><a href="#统一导出" class="headerlink" title="统一导出"></a>统一导出</h4><ul><li>module.js向外统一导出成员</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.统一暴露</span></span><br><span class="line"><span class="comment">// 模块想对外导出,export统一暴露想暴露的内容!</span></span><br><span class="line"><span class="comment">// 定义一个常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 定义一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统一对外导出(暴露)</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line"><span class="variable constant_">PI</span>,</span><br><span class="line">    sum,</span><br><span class="line">    <span class="title class_">Person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>app.js导入module.js中的成员</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    &#123;&#125;中导入要使用的来自于module.js中的成员</span></span><br><span class="line"><span class="comment">    &#123;&#125;中导入的名称要和module.js中导出的一致,也可以在此处起别名</span></span><br><span class="line"><span class="comment">    &#123;&#125;中如果定义了别名,那么在当前模块中就只能使用别名</span></span><br><span class="line"><span class="comment">    &#123;&#125;中导入成员的顺序可以不是暴露的顺序</span></span><br><span class="line"><span class="comment">    一个模块中可以同时有多个import</span></span><br><span class="line"><span class="comment">    多个import可以导入多个不同的模块,也可以是同一个模块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//import &#123;PI ,Person ,sum &#125;  from &#x27;./module.js&#x27;</span></span><br><span class="line"><span class="comment">//import &#123;PI as pi,Person as People,sum as add&#125;  from &#x27;./module.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">PI</span> ,<span class="title class_">Person</span> ,sum,<span class="variable constant_">PI</span> <span class="keyword">as</span> pi,<span class="title class_">Person</span> <span class="keyword">as</span> <span class="title class_">People</span>,sum <span class="keyword">as</span> add&#125;  <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="comment">// 使用暴露的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pi)</span><br><span class="line"><span class="comment">// 调用暴露的方法</span></span><br><span class="line"><span class="keyword">let</span> result1 =<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1)</span><br><span class="line"><span class="keyword">let</span> result2 =<span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line"><span class="comment">// 使用暴露的Person类</span></span><br><span class="line"><span class="keyword">let</span> person1 =<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">person1.<span class="title function_">sayHello</span>()</span><br><span class="line"><span class="keyword">let</span> person2 =<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&#x27;李四&#x27;</span>,<span class="number">11</span>)</span><br><span class="line">person2.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><h4 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h4><ul><li>modules混合向外导出</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3默认和混合暴露</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    默认暴露语法  export default sum</span></span><br><span class="line"><span class="comment">    默认暴露相当于是在暴露的对象中增加了一个名字为default的属性</span></span><br><span class="line"><span class="comment">    三种暴露方式可以在一个module中混合使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 导出一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出默认</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum</span><br><span class="line"><span class="comment">// 统一导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">   <span class="title class_">Person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>app.js的default和其他导入写法混用</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    *代表module.js中的所有成员</span></span><br><span class="line"><span class="comment">    m1代表所有成员所属的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> add&#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span> <span class="comment">// 用的少</span></span><br><span class="line"><span class="keyword">import</span> add2 <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span> <span class="comment">// 等效于 import &#123;default as add2&#125; from &#x27;./module.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用暴露的方法</span></span><br><span class="line"><span class="keyword">let</span> result =m1.<span class="title function_">default</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="keyword">let</span> result2 =<span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line"><span class="keyword">let</span> result3 =<span class="title function_">add2</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入其他方式暴露的内容</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">PI</span>,<span class="title class_">Person</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="comment">// 使用暴露的Person类</span></span><br><span class="line"><span class="keyword">let</span> person =<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">person.<span class="title function_">sayHello</span>()</span><br><span class="line"><span class="comment">// 使用暴露的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>)</span><br></pre></td></tr></table></figure><h2 id="前端工程化环境搭建"><a href="#前端工程化环境搭建" class="headerlink" title="前端工程化环境搭建"></a>前端工程化环境搭建</h2><h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><blockquote><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，可以使 JavaScript 运行在服务器端。使用 Node.js，可以方便地开发服务器端应用程序，如 Web 应用、API、后端服务，还可以通过 Node.js 构建命令行工具等。相比于传统的服务器端语言（如 PHP、Java、Python 等），Node.js 具有以下特点：</p></blockquote><ul><li>单线程，但是采用了事件驱动、异步 I&#x2F;O 模型，可以处理高并发请求。</li><li>轻量级，使用 C++ 编写的 V8 引擎让 Node.js 的运行速度很快。</li><li>模块化，Node.js 内置了大量模块，同时也可以通过第三方模块扩展功能。</li><li>跨平台，可以在 Windows、Linux、Mac 等多种平台下运行。</li></ul><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><blockquote><p>NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于后端的Maven 。</p></blockquote><h4 id="npm配置"><a href="#npm配置" class="headerlink" title="npm配置"></a>npm配置</h4><blockquote><p>配置依赖下载使用阿里镜像</p></blockquote><ul><li>npm 安装依赖包时默认使用的是官方源，由于国内网络环境的原因，有时会出现下载速度过慢的情况。为了解决这个问题，可以配置使用阿里镜像来加速 npm 的下载速度，具体操作如下：</li><li>打开命令行终端，执行以下命令，配置使用阿里镜像：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><ul><li>确认配置已生效，可以使用以下命令查看当前 registry 的配置：如果输出结果为 <code>https://registry.npmmirror.com</code>，说明配置已成功生效。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><ul><li>如果需要恢复默认的官方源，可以执行以下命令：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm config set registry <span class="attr">https</span>:<span class="comment">//registry.npmjs.org/</span></span><br></pre></td></tr></table></figure><blockquote><p>配置全局依赖下载后存储位置</p></blockquote><ul><li><p>在 Windows 系统上，npm 的全局依赖默认安装在 <code>&lt;用户目录&gt;\AppData\Roaming\npm</code> 目录下。</p></li><li><p>如果需要修改全局依赖的安装路径，可以按照以下步骤操作：</p><ol><li><p>创建一个新的全局依赖存储目录</p></li><li><p>打开命令行终端，执行以下命令来配置新的全局依赖存储路径：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;存储位置&quot;</span><br></pre></td></tr></table></figure></li><li><p>确认配置已生效，可以使用以下命令查看当前的全局依赖存储路径：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a>npm常用命令</h4><blockquote><p>1.项目初始化</p></blockquote><ul><li>npm init<ul><li>进入一个vscode创建好的项目中, 执行 npm init 命令后，npm 会引导您在命令行界面上回答一些问题,例如项目名称、版本号、作者、许可证等信息，并最终生成一个package.json 文件。package.json信息会包含项目基本信息！类似maven的pom.xml</li></ul></li><li>npm init -y<ul><li>执行，-y yes的意思，所有信息使用当前文件夹的默认值</li></ul></li></ul><blockquote><p>2.安装依赖  (<a href="https://www.npmjs.com/">查看所有依赖地址</a>)</p></blockquote><ul><li>npm install 包名 或者 npm install 包名@版本号<ul><li>安装包或者指定版本的依赖包(安装到当前项目中)</li></ul></li><li>npm install -g 包名<ul><li>安装全局依赖包(安装到默认全局目录)则可以在任何项目中使用它，而无需在每个项目中独立安装该包。</li></ul></li><li>npm install<ul><li>安装package.json中的所有记录的依赖</li></ul></li></ul><blockquote><p>3.升级依赖</p></blockquote><ul><li>npm update 包名<ul><li>将依赖升级到最新版本</li></ul></li></ul><blockquote><p>4.卸载依赖</p></blockquote><ul><li>npm uninstall 包名</li></ul><blockquote><p>5.查看依赖</p></blockquote><ul><li><p>npm ls</p><ul><li>查看项目依赖</li></ul></li><li><p>npm list -g</p><ul><li>查看全局依赖</li></ul></li></ul><blockquote><p>6.运行命令</p></blockquote><ul><li><p>npm run 命令是在执行 npm 脚本时使用的命令。npm 脚本是一组在 package.json 文件中定义的可执行命令。npm 脚本可用于启动应用程序，运行测试，生成文档等，还可以自定义命令以及配置需要运行的脚本。</p></li><li><p>在 package.json 文件中，scripts 字段是一个对象，其中包含一组键值对，键是要运行的脚本的名称，值是要执行的命令。例如，以下是一个简单的 package.json 文件：</p></li><li><p>scripts 对象包含 start、test 和 build 三个脚本。当您运行 npm run start 时，将运行 node index.js，并启动应用程序。同样，运行 npm run test 时，将运行 Jest 测试套件，而 npm run build 将运行 webpack 命令以生成最终的构建输出。</p></li><li><p>总之，npm run 命令提供了一种在 package.json 文件中定义和管理一组指令的方法，可以在项目中快速且灵活地运行各种操作。</p></li></ul><h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><p> <strong>Vue的两个核心功能：</strong></p><ul><li><strong>声明式渲染</strong>：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。</li><li><strong>响应性</strong>：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新DOM</li></ul><p><a href="https://cn.vuejs.org/guide/introduction.html">Vue文档</a></p><h3 id="通过Vite实现工程化"><a href="#通过Vite实现工程化" class="headerlink" title="通过Vite实现工程化"></a>通过Vite实现工程化</h3><blockquote><p>Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。<a href="https://cn.vitejs.dev/guide/why.html">https://cn.vitejs.dev/guide/why.html</a></p></blockquote><p>前端工程化的作用包括但不限于：</p><ol><li>快速创建项目：使用脚手架可以快速搭建项目基本框架，避免从零开始搭建项目的重复劳动和繁琐操作，从而节省时间和精力。</li><li>统一的工程化规范：前端脚手架可以预设项目目录结构、代码规范、git提交规范等统一的工程化规范，让不同开发者在同一个项目上编写出风格一致的代码，提高协作效率和质量。</li><li>代码模板和组件库：前端脚手架可以包含一些常用的代码模板和组件库，使开发者在实现常见功能时不再重复造轮子，避免因为轮子质量不高带来的麻烦，能够更加专注于项目的业务逻辑。</li><li>自动化构建和部署：前端脚手架可以自动进行代码打包、压缩、合并、编译等常见的构建工作，可以通过集成自动化部署脚本，自动将代码部署到测试、生产环境等。</li></ol><h4 id="Vite创建Vue3工程化项目"><a href="#Vite创建Vue3工程化项目" class="headerlink" title="Vite创建Vue3工程化项目"></a>Vite创建Vue3工程化项目</h4><blockquote><p>1 使用命令行创建工程</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure><ul><li>第一次使用vite时会提示下载vite,输入y回车即可,下次使用vite就不会出现了</li></ul><blockquote><p>2 安装项目所需依赖</p></blockquote><ul><li>npm install命令安装基础依赖</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./vue3-demo1</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><blockquote><p>3 启动项目</p></blockquote><ul><li>查看项目下的package.json</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue3-demo1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bootstrap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.2.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sass&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.62.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.2.47&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@vitejs/plugin-vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.3.2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h4 id="Vite-Vue3项目的目录结构"><a href="#Vite-Vue3项目的目录结构" class="headerlink" title="Vite+Vue3项目的目录结构"></a>Vite+Vue3项目的目录结构</h4><ul><li>public&#x2F; 目录：用于存放一些公共资源，如 HTML 文件、图像、字体等，这些资源会被直接复制到构建出的目标目录中。</li><li>src&#x2F; 目录：存放项目的源代码，包括 JavaScript、CSS、Vue 组件、图像和字体等资源。在开发过程中，这些文件会被 Vite 实时编译和处理，并在浏览器中进行实时预览和调试。以下是src内部划分建议：<ol><li><code>assets/</code> 目录：用于存放一些项目中用到的静态资源，如图片、字体、样式文件等。</li><li><code>components/</code> 目录：用于存放组件相关的文件。组件是代码复用的一种方式，用于抽象出一个可复用的 UI 部件，方便在不同的场景中进行重复使用。</li><li><code>layouts/</code> 目录：用于存放布局组件的文件。布局组件通常负责整个应用程序的整体布局，如头部、底部、导航菜单等。</li><li><code>pages/</code> 目录：用于存放页面级别的组件文件，通常是路由对应的组件文件。在这个目录下，可以创建对应的文件夹，用于存储不同的页面组件。</li><li><code>plugins/</code> 目录：用于存放 Vite 插件相关的文件，可以按需加载不同的插件来实现不同的功能，如自动化测试、代码压缩等。</li><li><code>router/</code> 目录：用于存放 Vue.js 的路由配置文件，负责管理视图和 URL 之间的映射关系，方便实现页面之间的跳转和数据传递。</li><li><code>store/</code> 目录：用于存放 Vuex 状态管理相关的文件，负责管理应用程序中的数据和状态，方便统一管理和共享数据，提高开发效率。</li><li><code>utils/</code> 目录：用于存放一些通用的工具函数，如日期处理函数、字符串操作函数等。</li></ol></li><li>vite.config.js 文件：Vite 的配置文件，可以通过该文件配置项目的参数、插件、打包优化等。该文件可以使用 CommonJS 或 ES6 模块的语法进行配置。</li><li>package.json 文件：标准的 Node.js 项目配置文件，包含了项目的基本信息和依赖关系。其中可以通过 scripts 字段定义几个命令，如 dev、build、serve 等，用于启动开发、构建和启动本地服务器等操作。</li><li>Vite 项目的入口为 src&#x2F;main.js 文件，这是 Vue.js 应用程序的启动文件，也是整个前端应用程序的入口文件。在该文件中，通常会引入 Vue.js 及其相关插件和组件，同时会创建 Vue 实例，挂载到 HTML 页面上指定的 DOM 元素中。</li></ul><blockquote><p> 2.vite的运行界面</p></blockquote><ul><li>在安装了 Vite 的项目中，可以在 npm scripts 中使用 <code>vite</code> 可执行文件。下面是通过脚手架创建的 Vite 项目中默认的 npm scripts：(package.json)</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span> <span class="comment">// 启动开发服务器，别名：`vite dev`，`vite serve`</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build&quot;</span><span class="punctuation">,</span> <span class="comment">// 为生产环境构建产物</span></span><br><span class="line">    <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span> <span class="comment">// 本地预览生产构建产物</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>运行设置端口号：(vite.config.js)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改vite项目配置文件 vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">  <span class="attr">server</span>:&#123;</span><br><span class="line">    <span class="attr">port</span>:<span class="number">3000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Vite-Vue3项目组件-SFC入门"><a href="#Vite-Vue3项目组件-SFC入门" class="headerlink" title="Vite+Vue3项目组件(SFC入门)"></a>Vite+Vue3项目组件(SFC入门)</h4><blockquote><p>什么是VUE的组件?</p></blockquote><ul><li>一个页面作为整体,是由多个部分组成的,每个部分在这里就可以理解为一个组件</li><li>每个.vue文件就可以理解为一个组件,多个.vue文件可以构成一个整体页面</li><li>组件化给我们带来的另一个好处就是组件的复用和维护非常的方便</li></ul><blockquote><p>什么是.vue文件?</p></blockquote><ul><li><p>传统的页面有.html文件.css文件和.js文件三个文件组成(多文件组件) </p></li><li><p>vue将这文件合并成一个.vue文件(Single-File Component，简称 SFC,单文件组件)</p></li><li><p>.vue文件对js&#x2F;css&#x2F;html统一封装,这是VUE中的概念 该文件由三个部分组成<code>&lt;script&gt;    &lt;template&gt;    &lt;style&gt;</code></p><ul><li>template标签     代表组件的html部分代码代替传统的.html文件</li><li>script标签           代表组件的js代码 代替传统的.js文件</li><li>style标签            代表组件的css样式代码 代替传统的.css文件</li></ul></li></ul><p></p><blockquote><p>工程化vue项目如何组织这些组件?</p></blockquote><ul><li>index.html是项目的入口,其中 <code>&lt;div id =&#39;app&#39;&gt;&lt;/div&gt;</code>是用于挂载所有组建的元素</li><li>index.html中的script标签引入了一个main.js文件,具体的挂载过程在main.js中执行</li><li>main.js是vue工程中非常重要的文件,他决定这项目使用哪些依赖,导入的第一个组件</li><li>App.vue是vue中的核心组件,所有的其他组件都要通过该组件进行导入,该组件通过路由可以控制页面的切换</li></ul><h4 id="Vite-Vue3响应式和setup函数"><a href="#Vite-Vue3响应式和setup函数" class="headerlink" title="Vite+Vue3响应式和setup函数"></a>Vite+Vue3响应式和setup函数</h4><blockquote><p>使用vite创建一个vue+JavaScript项目</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm create vite</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><blockquote><p>vue3响应式数据入门</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//存储vue页面逻辑js代码</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//非响应式数据: 修改后VUE不会更新DOM</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//响应式数据:   修改后VUE会更新DOM</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//VUE2中数据默认是响应式的</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//VUE3中数据要经过ref或者reactive处理后才是响应式的</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//ref是VUE3框架提供的一个函数,需要导入</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//let counter = 1</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//ref处理的响应式数据在js编码修改的时候需要通过.value操作</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//ref响应式数据在绑定到html上时不需要.value</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> counter = <span class="title function_">ref</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">increase</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 通过.value修改响应式数据</span></span></span><br><span class="line"><span class="language-javascript">                counter.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">decrease</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                counter.<span class="property">value</span>--</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                counter,</span></span><br><span class="line"><span class="language-javascript">                increase,</span></span><br><span class="line"><span class="language-javascript">                decrease</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrease()&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      &#123;&#123; counter &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increase()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">button</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>setup函数和语法糖</p></blockquote><ul><li>src&#x2F;App.vue</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; setup&gt;</span><br><span class="line"></span><br><span class="line">/* &lt;script type=&quot;module&quot; setup&gt; 通过setup关键字</span><br><span class="line">可以省略 export default &#123;setup()&#123;   return&#123;&#125;&#125;&#125;这些冗余的语法结构 */</span><br><span class="line">    import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">    // 定义响应式数据</span><br><span class="line">    let counter = ref(1)</span><br><span class="line">    // 定义函数</span><br><span class="line">    function increase()&#123;</span><br><span class="line">        counter.value++</span><br><span class="line">    &#125;</span><br><span class="line">    function decrease()&#123;</span><br><span class="line">        counter.value--</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button @click=&quot;decrease()&quot;&gt;-&lt;/button&gt;</span><br><span class="line">      &#123;&#123; counter &#125;&#125;</span><br><span class="line">      &lt;button @click=&quot;increase()&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    button&#123;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="Vue3视图渲染技术"><a href="#Vue3视图渲染技术" class="headerlink" title="Vue3视图渲染技术"></a>Vue3视图渲染技术</h3><blockquote><p>Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。</p></blockquote><h4 id="插值表达式和文本渲染"><a href="#插值表达式和文本渲染" class="headerlink" title="插值表达式和文本渲染"></a>插值表达式和文本渲染</h4><blockquote><p>插值表达式:最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 ,即双大括号<code>&#123;&#123;&#125;&#125;</code></p></blockquote><ul><li>插值表达式是将数据渲染到元素的指定位置的手段之一</li><li>插值表达式不绝对依赖标签,其位置相对自由</li><li>插值表达式中支持javascript的运算表达式</li><li>插值表达式中也支持函数的调用</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> msg =<span class="string">&quot;hello vue3&quot;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getMsg</span>= (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="string">&#x27;hello vue3 message&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> age = <span class="number">19</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> bee = <span class="string">&#x27;蜜 蜂&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 购物车</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> carts = [&#123;<span class="attr">name</span>:<span class="string">&#x27;可乐&#x27;</span>,<span class="attr">price</span>:<span class="number">3</span>,<span class="attr">number</span>:<span class="number">10</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;薯片&#x27;</span>,<span class="attr">price</span>:<span class="number">6</span>,<span class="attr">number</span>:<span class="number">8</span>&#125;];</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//计算购物车总金额</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">compute</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> count = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> carts)&#123;</span></span><br><span class="line"><span class="language-javascript">          count += carts[index].<span class="property">price</span>*carts[index].<span class="property">number</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> count;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    msg的值为: &#123;&#123; msg &#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    getMsg返回的值为:&#123;&#123; getMsg() &#125;&#125;  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    是否成年: &#123;&#123; age&gt;=18?&#x27;true&#x27;:&#x27;false&#x27; &#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    反转: &#123;&#123; bee.split(&#x27; &#x27;).reverse().join(&#x27;-&#x27;) &#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    购物车总金额: &#123;&#123; compute() &#125;&#125; <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    购物车总金额: &#123;&#123;carts[0].price*carts[0].number + carts[1].price*carts[1].number&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>为了渲染双标中的文本,我们也可以选择使用<code>v-text</code>和<code>v-html</code>命令</p></blockquote><ul><li>v-***这种写法的方式使用的是vue的命令</li><li>v-***的命令必须依赖元素,并且要写在元素的开始标签中</li><li>v-***指令支持ES6中的字符串模板</li><li>插值表达式中支持javascript的运算表达式</li><li>插值表达式中也支持函数的调用</li><li>v-text可以将数据渲染成双标签中间的文本,但是不识别html元素结构的文本</li><li>v-html可以将数据渲染成双标签中间的文本,识别html元素结构的文本</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> msg =<span class="string">&#x27;hello vue3&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getMsg</span>= (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> msg</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> age = <span class="number">19</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> bee = <span class="string">&#x27;蜜 蜂&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> redMsg =<span class="string">&#x27;&lt;font color=\&#x27;red\&#x27;&gt;msg&lt;/font&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> greenMsg =<span class="string">`&lt;font color=\&#x27;green\&#x27;&gt;<span class="subst">$&#123;msg&#125;</span>&lt;/font&gt;`</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&#x27;redMsg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&#x27;getMsg()&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&#x27;age&gt;18?&quot;成年&quot;:&quot;未成年&quot;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&#x27;bee.split(&quot; &quot;).reverse().join(&quot;-&quot;)&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&#x27;redMsg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&#x27;greenMsg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;`&lt;font color=&#x27;green&#x27;&gt;$&#123;msg&#125;&lt;/font&gt;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Attribute属性渲染"><a href="#Attribute属性渲染" class="headerlink" title="Attribute属性渲染"></a>Attribute属性渲染</h4><blockquote><p>想要渲染一个元素的attribute，应该使用<code>v-bind</code>指令</p></blockquote><ul><li>由于插值表达式不能直接放在标签的属性中,所有要渲染元素的属性就应该使用v-bind</li><li>v-bind可以用于渲染任何元素的属性,语法为 <code>v-bind:属性名=&#39;数据名&#39;</code>, 可以简写为 <code>:属性名=&#39;数据名&#39;</code></li></ul><h4 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h4><blockquote><p>我们可以使用 <code>v-on</code> 来监听 DOM 事件，并在事件触发时执行对应的 Vue的JavaScript代码。</p></blockquote><ul><li>用法：<code>v-on:click=&quot;handler&quot;</code> 或简写为 <code>@click=&quot;handler&quot;</code></li><li>vue中的事件名&#x3D;原生事件名去掉<code>on</code> 前缀   如:<code>onClick --&gt; click</code></li><li>handler的值可以是方法事件处理器,也可以是内联事件处理器</li><li>绑定事件时,可以通过一些绑定的修饰符,常见的事件修饰符如下<ul><li><code>.once：只触发一次事件。[重点]</code></li><li><code>.prevent：阻止默认事件。[重点]</code></li><li>.stop：阻止事件冒泡。</li><li>.capture：使用事件捕获模式而不是冒泡模式。</li><li>.self：只在事件发送者自身触发时才触发事件。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 响应式数据 当发生变化时,会自动更新 dom树</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> count=<span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">addCount</span>= (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">incrCount</span>= (<span class="params">event</span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 通过事件对象阻止组件的默认行为</span></span></span><br><span class="line"><span class="language-javascript">    event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>count的值是:&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方法事件处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;addCount()&quot;</span>&gt;</span>addCount<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联事件处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>incrCount<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 事件修饰符 once 只绑定事件一次 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>addOnce<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 事件修饰符 prevent 阻止组件的默认行为 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>prevent<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 原生js方式阻止组件默认行为--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;incrCount($event)&quot;</span>&gt;</span>prevent<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h4><blockquote><p> 此处的响应式是指: 数据模型发生变化时,自动更新DOM树内容,页面上显示的内容会进行同步变化,vue3的数据模型不是自动响应式的,需要我们做一些特殊的处理</p></blockquote><h5 id="响应式实现关键字ref"><a href="#响应式实现关键字ref" class="headerlink" title="响应式实现关键字ref"></a>响应式实现关键字ref</h5><blockquote><p><code>ref</code> 可以将一个基本类型的数据（如字符串，数字等）转换为一个响应式对象。 <code>ref</code> 只能包裹单一元素</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* 从vue中引入ref方法 */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(counter.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* 函数中要操作ref处理过的数据,需要通过.value形式 */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">decr</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      counter.<span class="property">value</span>--;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">incr</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      counter.<span class="property">value</span>++;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decr()&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    &#123;&#123; counter &#125;&#125; </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;incr()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show()&quot;</span>&gt;</span>显示counter值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在上面的例子中，我们使用 <code>ref</code> 包裹了一个数字，在代码中给这个数字加 1 后，视图也会跟着动态更新。需要注意的是，由于使用了 <code>ref</code>，因此需要在访问该对象时使用 <code>.value</code> 来获取其实际值。</li></ul><h5 id="响应式实现关键字reactive"><a href="#响应式实现关键字reactive" class="headerlink" title="响应式实现关键字reactive"></a>响应式实现关键字reactive</h5><blockquote><p>我们可以使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#reactive" title="reactive()">reactive()</a> 函数创建一个响应式对象或数组：</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* 从vue中引入reactive方法 */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref,reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">counter</span>:<span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(data.<span class="property">counter</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* 函数中要操作reactive处理过的数据,需要通过 对象名.属性名的方式 */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">decr</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      data.<span class="property">counter</span>--;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">incr</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      data.<span class="property">counter</span>++;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;data.counter--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decr()&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    &#123;&#123; data.counter &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;data.counter++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;incr()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show()&quot;</span>&gt;</span>显示counter值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>对比ref和reactive:</p></blockquote><ul><li><p>使用 <code>ref</code> 适用于以下开发场景：</p><ul><li>包装基本类型数据：<code>ref</code> 主要用于包装基本类型数据（如字符串、数字等），即只有一个值的数据，如果你想监听这个值的变化，用 <code>ref</code> 最为方便。在组件中使用时也很常见。</li><li>访问方式简单：<code>ref</code> 对象在访问时与普通的基本类型值没有太大区别，只需要通过 <code>.value</code> 访问其实际值即可。</li></ul></li><li><p>使用 <code>reactive</code> 适用于以下开发场景：</p><ul><li>包装复杂对象：<code>reactive</code> 可以将一个普通对象转化为响应式对象，这样在数据变化时会自动更新界面，特别适用于处理复杂对象或者数据结构。</li><li>需要递归监听的属性：使用 <code>reactive</code> 可以递归追踪所有响应式对象内部的变化，从而保证界面的自动更新。</li></ul></li><li><p>综上所述，<code>ref</code> 适用与简单情形下的数据双向绑定，对于只有一个字符等基本类型数据或自定义组件等情况，建议可以使用 <code>ref</code>；而对于对象、函数等较为复杂的数据结构，以及需要递归监听的属性变化，建议使用 <code>reactive</code>。当然，在实际项目中根据需求灵活选择也是十分必要的。</p></li></ul><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><blockquote><p><code>v-if</code> 条件渲染</p></blockquote><ul><li><p><code>v-if=&#39;表达式&#39; </code>只会在指令的表达式返回真值时才被渲染</p></li><li><p>也可以使用 <code>v-else</code> 为 <code>v-if</code> 添加一个“else 区块”。</p></li><li><p>一个 <code>v-else</code> 元素必须跟在一个 <code>v-if</code> 元素后面，否则它将不会被识别。</p></li></ul><blockquote><p><code>v-show</code>条件渲染扩展：</p></blockquote><ul><li><p>另一个可以用来按条件显示一个元素的指令是 <code>v-show</code>。其用法基本一样：</p></li><li><p>不同之处在于 <code>v-show</code> 会在 DOM 渲染中保留该元素；<code>v-show</code> 仅切换了该元素上名为 <code>display</code> 的 CSS 属性。</p></li><li><p><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 <code>v-else</code> 搭配使用。</p></li></ul><blockquote><p><strong><code>v-if</code></strong> <strong>vs</strong> <strong><code>v-show</code></strong></p></blockquote><ul><li><p><code>v-if</code> 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</p></li><li><p><code>v-if</code> 也是<strong>惰性</strong>的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</p></li><li><p>相比之下，<code>v-show</code> 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS <code>display</code> 属性会被切换。</p></li><li><p>总的来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 <code>v-show</code> 较好；如果在运行时绑定条件很少改变，则 <code>v-if</code> 会更合适。</p></li></ul><h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><blockquote><p>我们可以使用 <code>v-for</code> 指令基于一个数组来渲染一个列表。</p></blockquote><ul><li><p><code>v-for</code> 指令的值需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据的数组，而 <code>item</code> 是迭代项的<strong>别名</strong>：</p></li><li><p>在 <code>v-for</code> 块中可以完整地访问父作用域内的属性和变量。<code>v-for</code> 也支持使用可选的第二个参数表示当前项的位置索引。</p></li><li><p>案例：实现购物车显示和删除购物项</p></li></ul><h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><blockquote><p>单项绑定和双向绑定</p></blockquote><ul><li>单向绑定: 响应式数据的变化会更新dom树,但是dom树上用户的操作造成的数据改变不会同步更新到响应式数据</li><li>双向绑定: 响应式数据的变化会更新dom树,但是dom树上用户的操作造成的数据改变会同步更新到响应式数据<ul><li>用户通过表单标签才能够输入数据,所以双向绑定都是应用到表单标签上的,其他标签不行</li><li>v-model专门用于双向绑定表单标签的value属性,语法为 <code>v-model:value=&#39;&#39;</code>,可以简写为 <code>v-model=&#39;&#39;</code></li><li>v-model还可以用于各种不同类型的输入，<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 元素</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//引入模块</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; reactive,ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> hbs = <span class="title function_">ref</span>([]); <span class="comment">//装爱好的值</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> user = <span class="title function_">reactive</span>(&#123;<span class="attr">username</span>:<span class="literal">null</span>,<span class="attr">password</span>:<span class="literal">null</span>,<span class="attr">introduce</span>:<span class="literal">null</span>,<span class="attr">pro</span>:<span class="literal">null</span>&#125;)   </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(hbs.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user));</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">clearx</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//user = &#123;&#125;;// 这中写法会将数据变成非响应的,应该是user.username=&quot;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    user.<span class="property">username</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    user.<span class="property">password</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    user.<span class="property">introduce</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    user.<span class="property">pro</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    hbs.<span class="property">value</span>.<span class="title function_">splice</span>(<span class="number">0</span>,hbs.<span class="property">value</span>.<span class="property">length</span>);;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      账号： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入账号！&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user.username&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      密码： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入账号！&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user.password&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      爱好： </span><br><span class="line">        吃 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吃&quot;</span>&gt;</span> </span><br><span class="line">        喝 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;喝&quot;</span>&gt;</span></span><br><span class="line">        玩 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;玩&quot;</span>&gt;</span></span><br><span class="line">        乐 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;乐&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      简介:<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&quot;user.introduce&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      籍贯:</span><br><span class="line">          <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;user.pro&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>黑<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>吉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>辽<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>&gt;</span>津<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;6&quot;</span>&gt;</span>冀<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;login()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clearx()&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      显示爱好:&#123;&#123; hbs &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      显示用户信息:&#123;&#123; user &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据监听器"><a href="#数据监听器" class="headerlink" title="数据监听器"></a>数据监听器</h4><blockquote><p>计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。我们可以使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#watch" title="watch">watch</a><a href="https://cn.vuejs.org/api/reactivity-core.html#watch" title=" 函数"> 函数</a>在每次响应式状态发生变化时触发回调函数：</p></blockquote><ul><li>watch主要用于以下场景：<ul><li>当数据发生变化时需要执行相应的操作</li><li>监听数据变化，当满足一定条件时触发相应操作</li><li>在异步操作前或操作后需要执行相应的操作</li></ul></li></ul><blockquote><p>监控响应式数据(watchEffect)：</p></blockquote><ul><li>watchEffect默认监听所有的响应式数据</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//引入模块</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref,reactive,watch, watchEffect&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> firstname=<span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> lastname=<span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> fullname=<span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//监听所有响应式数据</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//直接在内部使用监听属性即可，不用外部声明</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//也不需要，即时回调设置，默认初始化就加载</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(firstname.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lastname.<span class="property">name</span>)</span></span><br><span class="line"><span class="language-javascript">    fullname.<span class="property">value</span>=<span class="string">`<span class="subst">$&#123;firstname.value&#125;</span><span class="subst">$&#123;lastname.name&#125;</span>`</span></span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    全名:&#123;&#123;fullname&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    姓氏:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    名字:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastname.name&quot;</span> &gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><blockquote><p>每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为<code>生命周期钩子的函数</code>，让开发者有机会在特定阶段运行自己的代码</p></blockquote><ul><li>周期图解：</li></ul><img src="D:/BaiduNetdiskDownload/images/image_elceCM4Wbp.png" style="zoom: 50%;" /><ul><li>常见钩子函数<ul><li>onMounted()              注册一个回调函数，在组件挂载完成后执行。 </li><li>onUpdated()               注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。 </li><li>onUnmounted()         注册一个回调函数，在组件实例被卸载之后调用。 </li><li>onBeforeMount()       注册一个钩子，在组件被挂载之前被调用。 </li><li>onBeforeUpdate()      注册一个钩子，在组件即将因为响应式状态变更而更新其 DOM 树之前调用。 </li><li>onBeforeUnmount()  注册一个钩子，在组件实例被卸载之前调用。</li></ul></li></ul><h3 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h3><blockquote><p>组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。组件就是实现应用中局部功能代码和资源的集合！在实际应用中，组件常常被组织成层层嵌套的树状结构，这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。</p></blockquote><ul><li><p>组件化：对js&#x2F;css&#x2F;html统一封装,这是VUE中的概念</p></li><li><p>模块化：对js的统一封装,这是ES6中的概念</p></li><li><p>组件化中,对js部分代码的处理使用ES6中的模块化</p></li></ul><h4 id="组件之间传递数据"><a href="#组件之间传递数据" class="headerlink" title="组件之间传递数据"></a>组件之间传递数据</h4><h5 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h5><blockquote><p>Vue3 中父组件向子组件传值可以通过 props 进行，具体操作如下：</p></blockquote><ol><li><p>首先，在父组件中定义需要传递给子组件的值，接着，在父组件的模板中引入子组件，同时在引入子组件的标签中添加 props 属性并为其设置需要传递的值。</p></li><li><p>在 Vue3 中，父组件通过 props 传递给子组件的值是响应式的。也就是说，如果在父组件中的传递的值发生了改变，子组件中的值也会相应地更新。</p></li></ol><ul><li>父组件代码</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Son</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Son.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref,reactive,toRefs&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;parent data!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> title = <span class="title function_">ref</span>(<span class="number">42</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">changeMessage</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    message.<span class="property">value</span> = <span class="string">&#x27;修改数据！&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    title.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用子组件，并且传递数据！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Son</span> <span class="attr">:message</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeMessage&quot;</span>&gt;</span>点击更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子组件代码：Son.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref,isRef,defineProps&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//声明父组件传递属性值</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>:<span class="title class_">String</span> ,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">title</span>:<span class="title class_">Number</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h5><ul><li>父组件：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> <span class="title class_">Son</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Son.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> pdata = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">padd</span> = (<span class="params">data</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2222&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        pdata.<span class="property">value</span> =data;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//自定义接收，子组件传递数据方法！ 参数为数据！</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">psub</span> = (<span class="params">data</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11111&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        pdata.<span class="property">value</span> = data;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 声明@事件名应该等于子模块对应事件名！调用方法可以是当前自定义！--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son</span> @<span class="attr">add</span>=<span class="string">&quot;padd&quot;</span> @<span class="attr">sub</span>=<span class="string">&quot;psub&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        &#123;&#123; pdata &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子组件：Son.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref,defineEmits&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.定义要发送给父组件的方法，可以1或者多个</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> emites = <span class="title function_">defineEmits</span>([<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;sub&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = <span class="title function_">ref</span>(<span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sendMsgToParent</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.出发父组件对应的方法，调用defineEmites对应的属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">emites</span>(<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;add data!&#x27;</span>+data.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">emites</span>(<span class="string">&#x27;sub&#x27;</span>,<span class="string">&#x27;sub data!&#x27;</span>+data.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        data.<span class="property">value</span> ++;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sendMsgToParent&quot;</span>&gt;</span>发送消息给父组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="兄弟传参"><a href="#兄弟传参" class="headerlink" title="兄弟传参"></a>兄弟传参</h5><ul><li>Navigator.vue: 发送数据到App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;defineEmits&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&#x27;sendMenu&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//触发事件，向父容器发送数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">emits</span>(<span class="string">&#x27;sendMenu&#x27;</span>,data);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 推荐写一个根标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;send(&#x27;学员管理&#x27;)&quot;</span>&gt;</span>学员管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;send(&#x27;图书管理&#x27;)&quot;</span>&gt;</span>图书管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;send(&#x27;请假管理&#x27;)&quot;</span>&gt;</span>请假管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;send(&#x27;考试管理&#x27;)&quot;</span>&gt;</span>考试管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;send(&#x27;讲师管理&#x27;)&quot;</span>&gt;</span>讲师管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>App.vue: 发送数据到Content.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Header</span>  <span class="keyword">from</span> <span class="string">&#x27;./components/Header.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Navigator</span>  <span class="keyword">from</span> <span class="string">&#x27;./components/Navigator.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Content</span>  <span class="keyword">from</span> <span class="string">&#x27;./components/Content.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//定义接受navigator传递参数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> navigator_menu = <span class="title function_">ref</span>(<span class="string">&#x27;ceshi&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">receiver</span> = (<span class="params">data</span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    navigator_menu.<span class="property">value</span> = data;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      &#123;&#123; navigator_menu &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">Header</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">Navigator</span> @<span class="attr">sendMenu</span>=<span class="string">&quot;receiver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navigator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Navigator</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 向子组件传递数据--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">Content</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span> <span class="attr">:message</span>=<span class="string">&quot;navigator_menu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Content.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>:<span class="title class_">String</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        展示的主要内容！</span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="router"><a href="#router" class="headerlink" title="router"></a>router</h2><blockquote><p>1 什么是路由？</p></blockquote><ul><li>定义：路由就是根据不同的 URL 地址展示不同的内容或页面。</li><li>通俗理解：路由就像是一个地图，我们要去不同的地方，需要通过不同的路线进行导航。</li></ul><blockquote><p>2 路由的作用</p></blockquote><ul><li>单页应用程序（SPA）中，路由可以实现不同视图之间的无刷新切换，提升用户体验；</li><li>路由还可以实现页面的认证和权限控制，保护用户的隐私和安全；</li><li>路由还可以利用浏览器的前进与后退，帮助用户更好地回到之前访问过的页面。</li></ul><h3 id="router重定向"><a href="#router重定向" class="headerlink" title="router重定向"></a>router重定向</h3><blockquote><p>重定向的作用：将一个路由重定向到另一个路由上</p></blockquote><ul><li>修改示例：访问&#x2F;list和&#x2F;showAll都定向到List.vue</li><li>router.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入路由创建的相关方法</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入vue组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">List</span> <span class="keyword">from</span> <span class="string">&#x27;../components/List.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Add</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Add.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Update</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Update.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由对象,声明路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                <span class="attr">default</span>:<span class="title class_">Home</span>,</span><br><span class="line">                <span class="attr">homeView</span>:<span class="title class_">Home</span></span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                listView : <span class="title class_">List</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/showAll&#x27;</span>,</span><br><span class="line">            <span class="comment">// 重定向</span></span><br><span class="line">            redirect :<span class="string">&#x27;/list&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/add&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                <span class="attr">addView</span>:<span class="title class_">Add</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/update&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                <span class="attr">updateView</span>:<span class="title class_">Update</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 路由的连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>home页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/list&quot;</span>&gt;</span>list页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/showAll&quot;</span>&gt;</span>showAll页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/add&quot;</span>&gt;</span>add页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/update&quot;</span>&gt;</span>update页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 路由连接对应视图的展示位置 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      默认展示位置:<span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Home视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;homeView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      List视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;listView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Add视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;addView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Update视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;updateView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编程式路由-useRouter"><a href="#编程式路由-useRouter" class="headerlink" title="编程式路由(useRouter)"></a>编程式路由(useRouter)</h3><blockquote><p>普通路由</p></blockquote><ul><li><code>&lt;router-link to=&quot;/list&quot;&gt;list页&lt;/router-link&gt;  </code>这种路由,to中的内容目前是固定的,点击后只能切换&#x2F;list对象组件(声明式路由)</li></ul><blockquote><p>编程式路由</p></blockquote><ul><li>通过useRouter,动态决定向那个组件切换的路由</li><li>在 Vue 3 和 Vue Router 4 中，可以使用 <code>useRouter</code> 来实现动态路由(编程式路由)</li><li>这里的 <code>useRouter</code> 方法返回的是一个 router 对象，你可以用它来做如导航到新页面、返回上一页面等操作</li></ul><blockquote><p>案例需求: 通过普通按钮配合事件绑定实现路由页面跳转,不直接使用router-link标签</p></blockquote><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//创建动态路由对象</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> router = <span class="title function_">useRouter</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span>  routePath =<span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span>  <span class="title function_">showList</span>= (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 编程式路由</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 直接push一个路径</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// router.push(&#x27;/list&#x27;)</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// push一个带有path属性的对象</span></span></span><br><span class="line"><span class="language-javascript">      router.<span class="title function_">push</span>(&#123;<span class="attr">path</span>:<span class="string">&#x27;/list&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 路由的连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>home页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/list&quot;</span>&gt;</span>list页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/showAll&quot;</span>&gt;</span>showAll页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/add&quot;</span>&gt;</span>add页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/update&quot;</span>&gt;</span>update页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 动态输入路径,点击按钮,触发单击事件的函数,在函数中通过编程是路由切换页面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showList()&quot;</span>&gt;</span>showList<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 路由连接对应视图的展示位置 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      默认展示位置:<span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Home视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;homeView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      List视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;listView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Add视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;addView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Update视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;updateView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由传参-useRoute"><a href="#路由传参-useRoute" class="headerlink" title="路由传参(useRoute)"></a>路由传参(useRoute)</h3><blockquote><p>路径参数</p></blockquote><ul><li>在路径中使用一个动态字段来实现，我们称之为 <strong>路径参数</strong><ul><li>例如：查看数据详情  <code>/showDetail/1</code>,<code>1</code>就是要查看详情的id,可以动态添值</li></ul></li></ul><blockquote><p>键值对参数</p></blockquote><ul><li><p>类似与get请求通过url传参,数据是键值对形式的</p><ul><li><p>例如: 查看数据详情<code>/showDetail?hid=1</code>,<code>hid=1</code>就是要传递的键值对参数</p></li><li><p>在 Vue 3 和 Vue Router 4 中，你可以使用  <code>useRoute</code> 这个函数从 Vue 的组合式 API 中获取路由对象</p></li><li><p><code>useRoute</code> 方法返回的是当前的 route 对象，你可以用它来获取关于当前路由的信息，如当前的路径、查询参数等</p></li></ul></li></ul><blockquote><p>案例需求:切换到ShowDetail.vue组件时,向该组件通过路由传递参数</p></blockquote><ul><li>修改App.vue文件</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//创建动态路由对象</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> router = <span class="title function_">useRouter</span>()</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//动态路由路径传参方法</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">showDetail</span>= (<span class="params">id,language</span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 尝试使用拼接字符串方式传递路径参数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//router.push(`showDetail/$&#123;id&#125;/$&#123;languange&#125;`)</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">/*路径参数,需要使用params  */</span></span></span><br><span class="line"><span class="language-javascript">      router.<span class="title function_">push</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;showDetail&quot;</span>,<span class="attr">params</span>:&#123;<span class="attr">id</span>:id,<span class="attr">language</span>:language&#125;&#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">showDetail2</span>= (<span class="params">id,language</span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">/*uri键值对参数,需要使用query */</span></span></span><br><span class="line"><span class="language-javascript">      router.<span class="title function_">push</span>(&#123;<span class="attr">path</span>:<span class="string">&quot;/showDetail2&quot;</span>,<span class="attr">query</span>:&#123;<span class="attr">id</span>:id,<span class="attr">language</span>:language&#125;&#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 路径参数   --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/showDetail/1/JAVA&quot;</span>&gt;</span>showDetail路径传参显示JAVA<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showDetail(1,&#x27;JAVA&#x27;)&quot;</span>&gt;</span>showDetail动态路由路径传参显示JAVA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 键值对参数 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-bind:to</span>=<span class="string">&quot;&#123;path:&#x27;/showDetail2&#x27;,query:&#123;id:1,language:&#x27;Java&#x27;&#125;&#125;&quot;</span>&gt;</span>showDetail2键值对传参显示JAVA<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showDetail2(1,&#x27;JAVA&#x27;)&quot;</span>&gt;</span>showDetail2动态路由键值对传参显示JAVA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      showDetail视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;showDetailView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      showDetail2视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;showDetailView2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>修改router.js增加路径参数占位符</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入路由创建的相关方法</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入vue组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ShowDetail</span> <span class="keyword">from</span> <span class="string">&#x27;../components/ShowDetail.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ShowDetail2</span> <span class="keyword">from</span> <span class="string">&#x27;../components/ShowDetail2.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由对象,声明路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 此处:id  :language作为路径的占位符 */</span></span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/showDetail/:id/:language&#x27;</span>,</span><br><span class="line">            <span class="comment">/* 动态路由传参时,根据该名字找到该路由 */</span></span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;showDetail&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                <span class="attr">showDetailView</span>:<span class="title class_">ShowDetail</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/showDetail2&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                <span class="attr">showDetailView2</span>:<span class="title class_">ShowDetail2</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><ul><li>ShowDetail.vue 通过useRoute获取路径参数</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span>&#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; onUpdated,ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取当前的route对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> route =<span class="title function_">useRoute</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> languageId = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> languageName = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//  借助更新时生命周期,将数据更新进入响应式对象</span></span></span><br><span class="line"><span class="language-javascript">    onUpdated (<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取对象中的参数</span></span></span><br><span class="line"><span class="language-javascript">        languageId.<span class="property">value</span>=route.<span class="property">params</span>.<span class="property">id</span></span></span><br><span class="line"><span class="language-javascript">        languageName.<span class="property">value</span>=route.<span class="property">params</span>.<span class="property">language</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(languageId.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(languageName.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ShowDetail页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>编号&#123;&#123;route.params.id&#125;&#125;:&#123;&#123;route.params.language&#125;&#125;是世界上最好的语言<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>编号&#123;&#123;languageId&#125;&#125;:&#123;&#123;languageName&#125;&#125;是世界上最好的语言<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>ShowDetail2.vue通过useRoute获取键值对参数</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span>&#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; onUpdated,ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取当前的route对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> route =<span class="title function_">useRoute</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> languageId = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> languageName = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//  借助更新时生命周期,将数据更新进入响应式对象</span></span></span><br><span class="line"><span class="language-javascript">    onUpdated (<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取对象中的参数(通过query获取参数,此时参数是key-value形式的)</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(languageId.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(languageName.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        languageId.<span class="property">value</span>=route.<span class="property">query</span>.<span class="property">id</span></span></span><br><span class="line"><span class="language-javascript">        languageName.<span class="property">value</span>=route.<span class="property">query</span>.<span class="property">language</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ShowDetail2页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>编号&#123;&#123;route.query.id&#125;&#125;:&#123;&#123;route.query.language&#125;&#125;是世界上最好的语言<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>编号&#123;&#123;languageId&#125;&#125;:&#123;&#123;languageName&#125;&#125;是世界上最好的语言<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><blockquote><p>在 Vue3 中，路由守卫是用于在路由切换期间进行一些特定任务的回调函数。路由守卫可以用于许多任务，例如验证用户是否已登录、在路由切换前提供确认提示、请求数据等。Vue3 为路由守卫提供了全面的支持，并提供了以下几种类型的路由守卫：</p></blockquote><ol><li><strong>全局前置守卫</strong>：在路由切换前被调用，可以用于验证用户是否已登录、中断导航、请求数据等。</li><li><strong>全局后置守卫</strong>：在路由切换之后被调用，可以用于处理数据、操作 DOM 、记录日志等。</li><li><strong>守卫代码的位置</strong>: 在router.js中</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置路由守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>( <span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//to 是目标地包装对象  .path属性可以获取地址</span></span><br><span class="line">    <span class="comment">//from 是来源地包装对象 .path属性可以获取地址</span></span><br><span class="line">    <span class="comment">//next是方法，不调用默认拦截！ next() 放行,直接到达目标组件</span></span><br><span class="line">    <span class="comment">//next(&#x27;/地址&#x27;)可以转发到其他地址,到达目标组件前会再次经过前置路由守卫</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(to.<span class="property">path</span>,<span class="keyword">from</span>.<span class="property">path</span>,next)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要判断，注意避免无限重定向</span></span><br><span class="line">    <span class="keyword">if</span>(to.<span class="property">path</span> == <span class="string">&#x27;/index&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">next</span>(<span class="string">&#x27;/index&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置路由守卫</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Navigate from <span class="subst">$&#123;<span class="keyword">from</span>.path&#125;</span> to <span class="subst">$&#123;to.path&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>登录案例，登录以后才可以进入home,否则必须进入login</p></blockquote><ul><li>定义Login.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> username =<span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> password =<span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> router = <span class="title function_">useRouter</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">login</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(username.<span class="property">value</span>,password.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(username.<span class="property">value</span> == <span class="string">&#x27;root&#x27;</span> &amp; password.<span class="property">value</span> == <span class="string">&#x27;123456&#x27;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            router.<span class="title function_">push</span>(&#123;<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,<span class="attr">query</span>:&#123;<span class="string">&#x27;username&#x27;</span>:username.<span class="property">value</span>&#125;&#125;)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//登录成功利用前端存储机制，存储账号！</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;username&#x27;</span>,username.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//sessionStorage.setItem(&#x27;username&#x27;,username)</span></span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;登录失败，账号或者密码错误！&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        账号： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入账号！&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码！&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;login()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>定义Home.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">import</span> &#123;useRoute,useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">let</span> route =<span class="title function_">useRoute</span>()</span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">let</span> router = <span class="title function_">useRouter</span>()</span></span><br><span class="line"><span class="language-javascript"> <span class="comment">//  并不是每次进入home页时,都有用户名参数传入</span></span></span><br><span class="line"><span class="language-javascript"> <span class="comment">//let username = route.query.username</span></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">let</span> username =<span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;username&#x27;</span>); </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">let</span> <span class="title function_">logout</span>= (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 清除localStorge中的username</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//window.sessionStorage.removeItem(&#x27;username&#x27;)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;username&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 动态路由到登录页</span></span></span><br><span class="line"><span class="language-javascript">    router.<span class="title function_">push</span>(<span class="string">&quot;/login&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"> &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Home页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>欢迎&#123;&#123;username&#125;&#125;登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;logout&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>定义routers.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入路由创建的相关方法</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入vue组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;../components/login.vue&#x27;</span></span><br><span class="line"><span class="comment">// 创建路由对象,声明路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="attr">redirect</span>:<span class="string">&quot;/home&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Login</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置路由的全局前置守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    to 要去那</span></span><br><span class="line"><span class="comment">    from 从哪里来</span></span><br><span class="line"><span class="comment">    next 放行路由时需要调用的方法,不调用则不放行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`从哪里来:<span class="subst">$&#123;<span class="keyword">from</span>.path&#125;</span>,到哪里去:<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(to.<span class="property">path</span> == <span class="string">&#x27;/login&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//放行路由  注意放行不要形成循环  </span></span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//let username =window.sessionStorage.getItem(&#x27;username&#x27;); </span></span><br><span class="line">        <span class="keyword">let</span> username =<span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;username&#x27;</span>); </span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != username)&#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 设置路由的全局后置守卫</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`从哪里来:<span class="subst">$&#123;<span class="keyword">from</span>.path&#125;</span>,到哪里去:<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><ul><li>启动测试</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="数据交互axios"><a href="#数据交互axios" class="headerlink" title="数据交互axios"></a>数据交互axios</h2><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="普通函数和回调函数"><a href="#普通函数和回调函数" class="headerlink" title="普通函数和回调函数"></a>普通函数和回调函数</h4><blockquote><p>普通函数: 正常调用的函数,一般函数执行完毕后才会继续执行下一行代码</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fun1</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun1 invoked&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 调用函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun1</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 函数执行完毕,继续执行后续代码</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;other code processon&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>回调函数: 一些特殊的函数,表示未来才会执行的一些功能,后续代码不会等待该函数执行完毕就开始执行了</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 设置一个2000毫秒后会执行一次的定时任务</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout invoked&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;,<span class="number">2000</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;other code processon&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Promise简介"><a href="#Promise简介" class="headerlink" title="Promise简介"></a>Promise简介</h4><blockquote><p>前端中的异步编程技术，类似Java中的多线程+线程结果回调</p></blockquote><ul><li><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p></li><li><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的API，各种异步操作都可以用同样的方法进行处理。</p></li></ul><p><code>Promise</code>对象有以下两个特点：</p><ol><li>Promise对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成，又称 Fulfilled）和<code>Rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从<code>Pending</code>变为<code>Resolved</code>和从<code>Pending</code>变为<code>Rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。</li></ol><h4 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise基本用法</h4><blockquote><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">/*  </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    1.实例化promise对象,并且执行(类似Java创建线程对象,并且start)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    参数: resolve,reject随意命名,但是一般这么叫!</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    参数: resolve,reject分别处理成功和失败的两个函数! 成功resolve(结果)  失败reject(结果)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    参数: 在function中调用这里两个方法,那么promise会处于两个不同的状态</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    状态: promise有三个状态</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            pending   正在运行</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            resolved  内部调用了resolve方法</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            rejected  内部调用了reject方法</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    参数: 在第二步回调函数中就可以获取对应的结果 </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> promise =<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise do some code ... ...&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//resolve(&quot;promise success&quot;)</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">reject</span>(<span class="string">&quot;promise fail&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;other code1111 invoked&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2.获取回调函数结果  then在这里会等待promise中的运行结果,但是不会阻塞代码继续运行</span></span></span><br><span class="line"><span class="language-javascript">    promise.<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span>(<span class="params">value</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`promise中执行了resolve:<span class="subst">$&#123;value&#125;</span>`</span>)&#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span>(<span class="params">error</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`promise中执行了reject:<span class="subst">$&#123;error&#125;</span>`</span>)&#125;</span></span><br><span class="line"><span class="language-javascript">    )</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 3 其他代码执行   </span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;other code2222 invoked&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="catch"><a href="#catch" class="headerlink" title="catch()"></a>catch()</h4><blockquote><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数，用法类似于<code>try-catch</code></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> promise =<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise do some code ... ...&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 故意响应一个异常对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error message&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;other code1111 invoked&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        then中的reject()的对应方法可以在产生异常时执行,接收到的就是异常中的提示信息</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        then中可以只留一个resolve()的对应方法,reject()方法可以用后续的catch替换</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        then中的reject对应的回调函数被后续的catch替换后,catch中接收的数据是一个异常对象</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        */</span></span></span><br><span class="line"><span class="language-javascript">    promise.<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span>(<span class="params">resolveValue</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`promise中执行了resolve:<span class="subst">$&#123;resolveValue&#125;</span>`</span>)&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//,</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//function(rejectValue)&#123;console.log(`promise中执行了reject:$&#123;rejectValue&#125;`)&#125;</span></span></span><br><span class="line"><span class="language-javascript">    ).<span class="title function_">catch</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span>(<span class="params">error</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125; </span></span><br><span class="line"><span class="language-javascript">    )</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;other code2222 invoked&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="async和await的使用"><a href="#async和await的使用" class="headerlink" title="async和await的使用"></a>async和await的使用</h4><blockquote><p>&#x20;async和await是ES6中用于处理异步操作的新特性。通常，异步操作会涉及到Promise对象，而async&#x2F;await则是在Promise基础上提供了更加直观和易于使用的语法。</p></blockquote><blockquote><p> async 用于标识函数的</p></blockquote><ol><li><p>async标识函数后,async函数的返回值会变成一个promise对象</p></li><li><p>如果函数内部返回的数据是一个非promise对象,async函数的结果会返回一个成功状态 promise对象</p></li><li><p>如果函数内部返回的是一个promise对象,则async函数返回的状态与结果由该对象决定</p></li><li><p>如果函数内部抛出的是一个异常,则async函数返回的是一个失败的promise对象</p></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        async 用于标识函数的</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            1. async标识函数后,async函数的返回值会变成一个promise对象</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            2. 如果函数内部返回的数据是一个非promise对象,async函数的结果会返回一个成功状态 promise对象</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            3. 如果函数内部返回的是一个promise对象,则async函数返回的状态与结果由该对象决定</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            4. 如果函数内部抛出的是一个异常,则async函数返回的是一个失败的promise对象</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//return 10</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//throw new Error(&quot;something wrong&quot;)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;heihei&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> promise</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> promise =<span class="title function_">fun1</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        promise.<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;success:&quot;</span>+value)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        ).<span class="title function_">catch</span>(</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fail:&quot;</span>+value)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        )</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>await</p></blockquote><ol><li>await右侧的表达式一般为一个promise对象,但是也可以是一个其他值</li><li>如果表达式是promise对象,await返回的是promise成功的值</li><li>await会等右边的promise对象执行结束,然后再获取结果,后续代码也会等待await的执行</li><li>如果表达式是其他值,则直接返回该值</li><li>await必须在async函数中,但是async函数中可以没有await</li><li>如果await右边的promise失败了,就会抛出异常,需要通过 try … catch捕获处理</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            1. await右侧的表达式一般为一个promise对象,但是也可以是一个其他值</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            2. 如果表达式是promise对象,await返回的是promise成功的值</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            3. await会等右边的promise对象执行结束,然后再获取结果,后续代码也会等待await的执行</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            4. 如果表达式是其他值,则直接返回该值</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            5. await必须在async函数中,但是async函数中可以没有await</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            6. 如果await右边的promise失败了,就会抛出异常,可以通过 try ... catch捕获处理</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="number">10</span></span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">fun1</span>()</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//let res = await Promise.reject(&quot;something wrong&quot;)</span></span></span><br><span class="line"><span class="language-javascript">            &#125;<span class="keyword">catch</span>(e)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch got:&quot;</span>+e)   </span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;await got:&quot;</span>+res)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fun2</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="什么是axios"><a href="#什么是axios" class="headerlink" title="什么是axios"></a><a href="https://axios-http.com/zh/docs/intro">什么是axios</a></h3><ul><li>Axios 是一个基于 <a href="https://javascript.info/promise-basics" title="promise"><em>promise</em></a> 网络请求库，作用于<a href="https://nodejs.org/" title="node.js">node.js</a>和浏览器中，算是VUE提供发送ajax请求的方式。 它是 <a href="https://www.lullabot.com/articles/what-is-an-isomorphic-application" title="isomorphic"><em>isomorphic</em></a> 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js <code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。它有如下特性:<ul><li>从浏览器创建 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" title="XMLHttpRequests">XMLHttpRequests</a></li><li>从 node.js 创建 <a href="http://nodejs.org/api/http.html" title="http">http</a> 请求</li><li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" title="Promise">Promise</a> API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防御<a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery" title="XSRF">XSRF</a></li></ul></li></ul><h3 id="Axios入门"><a href="#Axios入门" class="headerlink" title="Axios入门"></a>Axios入门</h3><blockquote><p>1 案例需求:请求后台获取随机网站数据</p></blockquote><ul><li>请求的url</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://api.uomg.com/api/rand.qinghua?format=json</span><br></pre></td></tr></table></figure><ul><li>请求的方式</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET/POST</span><br></pre></td></tr></table></figure><ul><li>数据返回的格式</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxxxxxx&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p> 2 安装axios</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><blockquote><p>3 设计页面（App.Vue）</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; onMounted,reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> jsonData =<span class="title function_">reactive</span>(&#123;<span class="attr">code</span>:<span class="number">1</span>,<span class="attr">content</span>:<span class="string">&#x27;xxxxxx&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveMessage</span> =(<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>, <span class="comment">// 请求方式</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">url</span>:<span class="string">&quot;https://api.uomg.com/api/rand.qinghua?format=json&quot;</span>,  <span class="comment">// 请求的url</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>:&#123; <span class="comment">// 当请求方式为post时,data下的数据以JSON串放入请求体,否则以key=value形式放url后</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">username</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">then</span>( <span class="keyword">function</span> (<span class="params">response</span>)&#123;<span class="comment">//响应成功时要执行的函数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(jsonData,response.<span class="property">data</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>)&#123;<span class="comment">// 响应失败时要执行的函数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 通过onMounted生命周期,自动加载一次 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveMessage</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;jsonData.content&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">&quot;getLoveMessage&quot;</span>&gt;</span>更新数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>异步响应的数据结构</p></blockquote><ul><li>响应的数据是经过包装返回的，一个请求的响应包含以下信息。</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  data<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  status<span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  statusText<span class="punctuation">:</span> &#x27;OK&#x27;<span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `headers` 是服务器响应头</span></span><br><span class="line">  <span class="comment">// 所有的 header 名称都是小写，而且可以使用方括号语法访问</span></span><br><span class="line">  <span class="comment">// 例如: `response.headers[&#x27;content-type&#x27;]`</span></span><br><span class="line">  headers<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `config` 是 `axios` 请求的配置信息</span></span><br><span class="line">  config<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `request` 是生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span></span><br><span class="line">  <span class="comment">// 在浏览器中则是 XMLHttpRequest 实例</span></span><br><span class="line">  request<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>then取值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">headers</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">config</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>4 通过async和await处理异步请求</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; onMounted,reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> jsonData =<span class="title function_">reactive</span>(&#123;<span class="attr">code</span>:<span class="number">1</span>,<span class="attr">content</span>:<span class="string">&#x27;xxxxxxxx&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveWords</span> = <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">url</span>:<span class="string">&quot;https://api.uomg.com/api/rand.qinghua?format=json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">username</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveMessage</span> =(<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> &#123;data&#125;  = <span class="keyword">await</span> <span class="title function_">getLoveWords</span>()</span></span><br><span class="line"><span class="language-javascript">     <span class="title class_">Object</span>.<span class="title function_">assign</span>(message,data)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 通过onMounted生命周期,自动加载一次 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveMessage</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;jsonData.content&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">&quot;getLoveMessage&quot;</span>&gt;</span>更新数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> axios在发送异步请求时的可选配置：</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">  url<span class="punctuation">:</span> &#x27;/user&#x27;<span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">  method<span class="punctuation">:</span> &#x27;get&#x27;<span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  baseURL<span class="punctuation">:</span> &#x27;https<span class="punctuation">:</span><span class="comment">//some-domain.com/api/&#x27;,</span></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream</span></span><br><span class="line">  <span class="comment">// 你可以修改请求头。</span></span><br><span class="line">  transformRequest<span class="punctuation">:</span> <span class="punctuation">[</span>function (data<span class="punctuation">,</span> headers) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 对发送的 data 进行任意转换处理</span></span><br><span class="line">    return data;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  transformResponse<span class="punctuation">:</span> <span class="punctuation">[</span>function (data) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 对接收的 data 进行任意转换处理</span></span><br><span class="line">    return data;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 自定义请求头</span></span><br><span class="line">  headers<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;X-Requested-With&#x27;<span class="punctuation">:</span> &#x27;XMLHttpRequest&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `params` 是与请求一起发送的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个简单对象或 URLSearchParams 对象</span></span><br><span class="line">  params<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    ID<span class="punctuation">:</span> <span class="number">12345</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `paramsSerializer`是可选方法，主要用于序列化`params`</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  paramsSerializer<span class="punctuation">:</span> function (params) <span class="punctuation">&#123;</span></span><br><span class="line">    return Qs.stringify(params<span class="punctuation">,</span> <span class="punctuation">&#123;</span>arrayFormat<span class="punctuation">:</span> &#x27;brackets&#x27;<span class="punctuation">&#125;</span>)</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `data` 是作为请求体被发送的数据</span></span><br><span class="line">  <span class="comment">// 仅适用 &#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;DELETE 和 &#x27;PATCH&#x27; 请求方法</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，则必须是以下类型之一:</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属: FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属: Stream, Buffer</span></span><br><span class="line">  data<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    firstName<span class="punctuation">:</span> &#x27;Fred&#x27;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 发送请求体数据的可选语法</span></span><br><span class="line">  <span class="comment">// 请求方式 post</span></span><br><span class="line">  <span class="comment">// 只有 value 会被发送，key 则不会</span></span><br><span class="line">  data<span class="punctuation">:</span> &#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;<span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `timeout` 指定请求超时的毫秒数。</span></span><br><span class="line">  <span class="comment">// 如果请求时间超过 `timeout` 的值，则请求会被中断</span></span><br><span class="line">  timeout<span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span> <span class="comment">// 默认值是 `0` (永不超时)</span></span><br><span class="line">  <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  withCredentials<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// default</span></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，这使测试更加容易。</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。</span></span><br><span class="line">  adapter<span class="punctuation">:</span> function (config) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `auth` HTTP Basic Auth</span></span><br><span class="line">  auth<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    username<span class="punctuation">:</span> &#x27;janedoe&#x27;<span class="punctuation">,</span></span><br><span class="line">    password<span class="punctuation">:</span> &#x27;s00pers3cret&#x27;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `responseType` 表示浏览器将要响应的数据类型</span></span><br><span class="line">  <span class="comment">// 选项包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span></span><br><span class="line">  <span class="comment">// 浏览器专属：&#x27;blob&#x27;</span></span><br><span class="line">  responseType<span class="punctuation">:</span> &#x27;json&#x27;<span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)</span></span><br><span class="line">  <span class="comment">// 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求</span></span><br><span class="line">  <span class="comment">// Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests</span></span><br><span class="line">  responseEncoding<span class="punctuation">:</span> &#x27;utf8&#x27;<span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称</span></span><br><span class="line">  xsrfCookieName<span class="punctuation">:</span> &#x27;XSRF-TOKEN&#x27;<span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称</span></span><br><span class="line">  xsrfHeaderName<span class="punctuation">:</span> &#x27;X-XSRF-TOKEN&#x27;<span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line">  <span class="comment">// 浏览器专属</span></span><br><span class="line">  onUploadProgress<span class="punctuation">:</span> function (progressEvent) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line">  <span class="comment">// 浏览器专属</span></span><br><span class="line">  onDownloadProgress<span class="punctuation">:</span> function (progressEvent) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数</span></span><br><span class="line">  maxContentLength<span class="punctuation">:</span> <span class="number">2000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数</span></span><br><span class="line">  maxBodyLength<span class="punctuation">:</span> <span class="number">2000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。</span></span><br><span class="line">  <span class="comment">// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，</span></span><br><span class="line">  <span class="comment">// 则promise 将会 resolved，否则是 rejected。</span></span><br><span class="line">  validateStatus<span class="punctuation">:</span> function (status) <span class="punctuation">&#123;</span></span><br><span class="line">    return status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认值</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义了在node.js中要遵循的最大重定向数。</span></span><br><span class="line">  <span class="comment">// 如果设置为0，则不会进行重定向</span></span><br><span class="line">  maxRedirects<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `socketPath` 定义了在node.js中使用的UNIX套接字。</span></span><br><span class="line">  <span class="comment">// e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。</span></span><br><span class="line">  <span class="comment">// 只能指定 `socketPath` 或 `proxy` 。</span></span><br><span class="line">  <span class="comment">// 若都指定，这使用 `socketPath` 。</span></span><br><span class="line">  socketPath<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="comment">// default</span></span><br><span class="line">  <span class="comment">// `httpAgent` and `httpsAgent` define a custom agent to be used when performing http</span></span><br><span class="line">  <span class="comment">// and https requests, respectively, in node.js. This allows options to be added like</span></span><br><span class="line">  <span class="comment">// `keepAlive` that are not enabled by default.</span></span><br><span class="line">  httpAgent<span class="punctuation">:</span> new http.Agent(<span class="punctuation">&#123;</span> keepAlive<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">  httpsAgent<span class="punctuation">:</span> new https.Agent(<span class="punctuation">&#123;</span> keepAlive<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `proxy` 定义了代理服务器的主机名，端口和协议。</span></span><br><span class="line">  <span class="comment">// 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。</span></span><br><span class="line">  <span class="comment">// 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。</span></span><br><span class="line">  <span class="comment">// `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。</span></span><br><span class="line">  <span class="comment">// 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`</span></span><br><span class="line">  proxy<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    protocol<span class="punctuation">:</span> &#x27;https&#x27;<span class="punctuation">,</span></span><br><span class="line">    host<span class="punctuation">:</span> &#x27;<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">    port<span class="punctuation">:</span> <span class="number">9000</span><span class="punctuation">,</span></span><br><span class="line">    auth<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      username<span class="punctuation">:</span> &#x27;mikeymike&#x27;<span class="punctuation">,</span></span><br><span class="line">      password<span class="punctuation">:</span> &#x27;rapunz3l&#x27;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// see https://axios-http.com/zh/docs/cancellation</span></span><br><span class="line">  cancelToken<span class="punctuation">:</span> new CancelToken(function (cancel) <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `decompress` indicates whether or not the response body should be decompressed </span></span><br><span class="line">  <span class="comment">// automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header </span></span><br><span class="line">  <span class="comment">// from the responses objects of all decompressed responses</span></span><br><span class="line">  <span class="comment">// - Node only (XHR cannot turn off decompression)</span></span><br><span class="line">  decompress<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// 默认值</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Axios-get和post"><a href="#Axios-get和post" class="headerlink" title="Axios get和post"></a>Axios get和post</h3><blockquote><p>配置添加语法</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url[, config])</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(url,&#123;</span><br><span class="line">   上面指定配置<span class="attr">key</span>:配置值,</span><br><span class="line">   上面指定配置<span class="attr">key</span>:配置值</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">post</span>(url[, data[, config]])</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">post</span>(url,&#123;<span class="attr">key</span>:value <span class="comment">//此位置数据，没有空对象即可&#123;&#125;&#125;,&#123;</span></span><br><span class="line">   上面指定配置<span class="attr">key</span>:配置值,</span><br><span class="line">   上面指定配置<span class="attr">key</span>:配置值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>测试get参数</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; onMounted,ref,reactive,toRaw &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> jsonData =<span class="title function_">reactive</span>(&#123;<span class="attr">code</span>:<span class="number">1</span>,<span class="attr">content</span>:<span class="string">&#x27;xxxxxxx&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveWords</span>= <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> axios.<span class="title function_">get</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;https://api.uomg.com/api/rand.qinghua&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">params</span>:&#123;<span class="comment">// 向url后添加的键值对参数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">format</span>:<span class="string">&#x27;json&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>:<span class="string">&#x27;zhangsan&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>:<span class="string">&#x27;123456&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">headers</span>:&#123;<span class="comment">// 设置请求头</span></span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;Accept&#x27;</span> : <span class="string">&#x27;application/json, text/plain, text/html,*/*&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      )</span></span><br><span class="line"><span class="language-javascript">    &#125;<span class="keyword">catch</span> (e)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> e</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveMessage</span> =(<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">let</span> &#123;data&#125;  = <span class="keyword">await</span> <span class="title function_">getLoveWords</span>()</span></span><br><span class="line"><span class="language-javascript">     <span class="title class_">Object</span>.<span class="title function_">assign</span>(message,data)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 通过onMounted生命周期,自动加载一次 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveMessage</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>测试post参数</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; onMounted,ref,reactive,toRaw &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> jsonData =<span class="title function_">reactive</span>(&#123;<span class="attr">code</span>:<span class="number">1</span>,<span class="attr">content</span>:<span class="string">&#x27;xxxxxxxx&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveWords</span>= <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> axios.<span class="title function_">post</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;https://api.uomg.com/api/rand.qinghua&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="comment">//请求体中的JSON数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>:<span class="string">&#x27;zhangsan&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>:<span class="string">&#x27;123456&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="comment">// 其他参数</span></span></span><br><span class="line"><span class="language-javascript">         <span class="attr">params</span>:&#123;<span class="comment">// url上拼接的键值对参数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">format</span>:<span class="string">&#x27;json&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">headers</span>:&#123;<span class="comment">// 请求头</span></span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;Accept&#x27;</span> : <span class="string">&#x27;application/json, text/plain, text/html,*/*&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      )</span></span><br><span class="line"><span class="language-javascript">    &#125;<span class="keyword">catch</span> (e)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> e</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveMessage</span> =(<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">let</span> &#123;data&#125;  = <span class="keyword">await</span> <span class="title function_">getLoveWords</span>()</span></span><br><span class="line"><span class="language-javascript">     <span class="title class_">Object</span>.<span class="title function_">assign</span>(message,data)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 通过onMounted生命周期,自动加载一次 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveMessage</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Axios-拦截器"><a href="#Axios-拦截器" class="headerlink" title="Axios 拦截器"></a>Axios 拦截器</h3><blockquote><p>如果想在axios发送请求之前,或者是数据响应回来在执行then方法之前做一些额外的工作,可以通过拦截器完成</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器 请求发送之前</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器 数据响应回来</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>定义src&#x2F;axios.js提取拦截器和配置语法</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  创建instance实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>:<span class="string">&#x27;https://api.uomg.com&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>:<span class="number">10000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  添加请求拦截</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="comment">// 设置请求头配置信息</span></span><br><span class="line">    <span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//处理指定的请求头</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;before request&quot;</span>)</span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">Accept</span> = <span class="string">&#x27;application/json, text/plain, text/html,*/*&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 设置请求错误处理函数</span></span><br><span class="line">    <span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request error&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="comment">// 设置响应正确时的处理函数</span></span><br><span class="line">    <span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after success response&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 设置响应异常时的处理函数</span></span><br><span class="line">    <span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after fail response&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 导入我们自己定义的axios.js文件,而不是导入axios依赖  </span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;./axios.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; onMounted,ref,reactive,toRaw &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> jsonData =<span class="title function_">reactive</span>(&#123;<span class="attr">code</span>:<span class="number">1</span>,<span class="attr">content</span>:<span class="string">&#x27;我努力不是为了你而是因为你&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveWords</span>= <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> axios.<span class="title function_">post</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;api/rand.qinghua&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>:<span class="string">&#x27;zhangsan&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>:<span class="string">&#x27;123456&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,<span class="comment">//请求体中的JSON数据</span></span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">params</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">format</span>:<span class="string">&#x27;json&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="comment">// 其他键值对参数</span></span></span><br><span class="line"><span class="language-javascript">      )</span></span><br><span class="line"><span class="language-javascript">    &#125;<span class="keyword">catch</span> (e)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> e</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveMessage</span> =(<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 这里返回的是一个fullfilled状态的promise</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveWords</span>().<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="function">(<span class="params">response</span>) =&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after getloveWords&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span></span><br><span class="line"><span class="language-javascript">          <span class="title class_">Object</span>.<span class="title function_">assign</span>(jsonData,response.<span class="property">data</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    )</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 通过onMounted生命周期,自动加载一次 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveMessage</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="状态管理Pinia"><a href="#状态管理Pinia" class="headerlink" title="状态管理Pinia"></a>状态管理Pinia</h2><h3 id="Pinia介绍"><a href="#Pinia介绍" class="headerlink" title="Pinia介绍"></a>Pinia介绍</h3><blockquote><p>如何实现多个组件之间的数据传递?</p></blockquote><ul><li><p>方式1 组件传参   </p></li><li><p>方式2 路由传参  </p></li><li><p>方式3 通过pinia状态管理定义共享数据</p></li></ul><blockquote><p>当我们有<code>多个组件共享一个共同的状态(数据源)</code>时，多个视图可能都依赖于同一份状态。来自不同视图的交互也可能需要更改同一份状态。虽然我们的手动状态管理解决方案（props,组件间通信,模块化）在简单的场景中已经足够了，但是在大规模的生产应用中还有很多其他事项需要考虑：</p></blockquote><ul><li>更强的团队协作约定</li><li>与 Vue DevTools 集成，包括时间轴、组件内部审查和时间旅行调试</li><li>模块热更新 (HMR)</li><li>服务端渲染支持</li></ul><blockquote><p> <a href="https://pinia.vuejs.org/zh/" title="Pinia">Pinia</a> 就是一个实现了上述需求的状态管理库，由 Vue 核心团队维护，对 Vue 2 和 Vue 3 都可用。<a href="https://pinia.vuejs.org/zh/introduction.html">https://pinia.vuejs.org/zh/introduction.html</a></p></blockquote><h3 id="Pinia基本用法"><a href="#Pinia基本用法" class="headerlink" title="Pinia基本用法"></a>Pinia基本用法</h3><blockquote><p> 安装pinia</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install pinia</span><br></pre></td></tr></table></figure><blockquote><p>定义pinia store对象 src&#x2F;store&#x2F;store.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数据并且对外暴露</span></span><br><span class="line"><span class="comment">// store就是定义共享状态的包装对象</span></span><br><span class="line"><span class="comment">// 内部包含四个属性： id 唯一标识 state 完整类型推理，推荐使用箭头函数 存放的数据 getters 类似属性计算，存储放对数据</span></span><br><span class="line"><span class="comment">// 操作的方法  actions 存储数据的复杂业务逻辑方法</span></span><br><span class="line"><span class="comment">// 理解： store类似Java中的实体类， id就是类名， state 就是装数据值的属性  getters就是get方法，actions就是对数据操作的其他方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> definedPerson = <span class="title function_">defineStore</span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;personPinia&#x27;</span>, <span class="comment">//必须唯一</span></span><br><span class="line">        <span class="attr">state</span>:<span class="function">()=&gt;</span>&#123; <span class="comment">// state中用于定义数据</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">username</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">                <span class="attr">age</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="attr">hobbies</span>:[<span class="string">&#x27;唱歌&#x27;</span>,<span class="string">&#x27;跳舞&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">getters</span>:&#123;<span class="comment">// 用于定义一些通过数据计算而得到结果的一些方法 一般在此处不做对数据的修改操作</span></span><br><span class="line">                 <span class="comment">// getters中的方法可以当做属性值方式使用</span></span><br><span class="line">            <span class="title function_">getHobbiesCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hobbies</span>.<span class="property">length</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">getAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">actions</span>:&#123; <span class="comment">// 用于定义一些对数据修改的方法</span></span><br><span class="line">            <span class="title function_">doubleAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">age</span>=<span class="variable language_">this</span>.<span class="property">age</span>*<span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p> 在main.js配置pinia组件到vue中 </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./routers/router.js&#x27;</span></span><br><span class="line"><span class="comment">// 导pinia</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="comment">// 创建pinia对象</span></span><br><span class="line"><span class="keyword">let</span> pinia= <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">let</span> app =<span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"><span class="comment">// app中使用pinia功能</span></span><br><span class="line">app.<span class="title function_">use</span>(pinia) </span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Operate.vue 中操作Pinia数据</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; definedPerson&#125; <span class="keyword">from</span> <span class="string">&#x27;../store/store&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 读取存储的数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person= <span class="title function_">definedPerson</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> hobby = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>operate视图,用户操作Pinia中的数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        请输入姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.username&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        请输入年龄:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.age&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        请增加爱好:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吃饭&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 吃饭</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;睡觉&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 睡觉</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;打豆豆&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 打豆豆 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用person的doubleAge()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.doubleAge()&quot;</span>&gt;</span>年龄加倍<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用pinia提供的$reset()方法恢复数据的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.$reset()&quot;</span>&gt;</span>恢复默认值<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用$patch方法一次性修改多个属性值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.$patch(&#123;username:&#x27;奥特曼&#x27;,age:100,hobbies:[&#x27;晒太阳&#x27;,&#x27;打怪兽&#x27;]&#125;)&quot;</span>&gt;</span>变身奥特曼<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">显示pinia中的person数据:&#123;&#123;person&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>List.vue中展示Pinia数据</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; definedPerson&#125; <span class="keyword">from</span> <span class="string">&#x27;../store/store&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 读取存储的数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person= <span class="title function_">definedPerson</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>List页面,展示Pinia中的数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        读取姓名:&#123;&#123;person.username&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        读取年龄:&#123;&#123;person.age&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        通过get年龄:&#123;&#123;person.getAge&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        爱好数量:&#123;&#123;person.getHobbiesCount&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        所有的爱好:</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&#x27;(hobby,index) in person.hobbies&#x27;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">v-text</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>定义组件路由router.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入路由创建的相关方法</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入vue组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">List</span>  <span class="keyword">from</span> <span class="string">&#x27;../components/List.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Operate</span>  <span class="keyword">from</span> <span class="string">&#x27;../components/Operate.vue&#x27;</span></span><br><span class="line"><span class="comment">// 创建路由对象,声明路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/opearte&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Operate</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">List</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 对外暴露路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><blockquote><p>App.vue中通过路由切换组件</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/opearte&quot;</span>&gt;</span>显示操作页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/list&quot;</span>&gt;</span>显示展示页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Pinia其他细节"><a href="#Pinia其他细节" class="headerlink" title="Pinia其他细节"></a>Pinia其他细节</h3><blockquote><p> State在大多数情况下，都是store的核心。人们通常会先定义能代表他们 APP 的 state。在 Pinia 中，state 被定义为一个返回初始状态的函数。</p></blockquote><ul><li>store.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> definedPerson = <span class="title function_">defineStore</span>(<span class="string">&#x27;personPinia&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">state</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">username</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                <span class="attr">age</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="attr">hobbies</span>:[<span class="string">&#x27;唱歌&#x27;</span>,<span class="string">&#x27;跳舞&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">getters</span>:&#123;</span><br><span class="line">            <span class="title function_">getHobbiesCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hobbies</span>.<span class="property">length</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">getAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">actions</span>:&#123;</span><br><span class="line">            <span class="title function_">doubleAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">age</span>=<span class="variable language_">this</span>.<span class="property">age</span>*<span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>Operate.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; definedPerson&#125; <span class="keyword">from</span> <span class="string">&#x27;../store/store&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 读取存储的数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person= <span class="title function_">definedPerson</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> hobby = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">addHobby</span>= (<span class="params"></span>)=&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(hobby.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        person.<span class="property">hobbies</span>.<span class="title function_">push</span>(hobby.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听状态</span></span></span><br><span class="line"><span class="language-javascript">    person.$subscribe(<span class="function">(<span class="params">mutation,state</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---subscribe---&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        mutation.storeId</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            person.$id一样</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        mutation.payload</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            传递给 cartStore.$patch() 的补丁对象。</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        state 数据状态,其实是一个代理</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        */</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation.<span class="property">type</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation.<span class="property">payload</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation.<span class="property">storeId</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">$id</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 数据 其实是一个代理对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(state)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>operate视图,用户操作Pinia中的数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        请输入姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.username&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        请输入年龄:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.age&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        请增加爱好:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吃饭&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 吃饭</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;睡觉&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 睡觉</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;打豆豆&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 打豆豆 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;addHobby&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用person的doubleAge()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.doubleAge()&quot;</span>&gt;</span>年龄加倍<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用pinia提供的$reset()方法恢复数据的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.$reset()&quot;</span>&gt;</span>恢复默认值<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用$patch方法一次性修改多个属性值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.$patch(&#123;username:&#x27;奥特曼&#x27;,age:100,hobbies:[&#x27;晒太阳&#x27;,&#x27;打怪兽&#x27;]&#125;)&quot;</span>&gt;</span>变身奥特曼<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">person:&#123;&#123;person&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p> Getter 完全等同于 store 的 state 的<a href="https://cn.vuejs.org/guide/essentials/computed.html" title="计算值">计算值</a>。可以通过 <code>defineStore()</code> 中的 <code>getters</code> 属性来定义它们。<strong>推荐</strong>使用箭头函数，并且它将接收 <code>state</code> 作为第一个参数：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doubleCount</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">count</span> * <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p> Action 相当于组件中的 <a href="https://v3.vuejs.org/guide/data-methods.html#methods" title="method">method</a>。它们可以通过 <code>defineStore()</code> 中的 <code>actions</code> 属性来定义，<strong>并且它们也是定义业务逻辑的完美选择。</strong>类似 <a href="https://pinia.vuejs.org/zh/core-concepts/getters.html" title="getter">getter</a>，action 也可通过 <code>this</code> 访问<strong>整个 store 实例</strong>，并支持**完整的类型标注(以及自动补全)**。不同的是，<code>action</code> 可以是异步的，你可以在它们里面 <code>await</code> 调用任何 API，以及其他 action！</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">randomizeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">100</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>())</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Element-plus"><a href="#Element-plus" class="headerlink" title="Element-plus"></a>Element-plus</h2><blockquote><p>Element Plus 是一套基于 Vue 3 的开源 UI 组件库，是由饿了么前端团队开发的升级版本 Element UI。Element Plus 提供了丰富的 UI 组件、易于使用的 API 接口和灵活的主题定制功能，可以帮助开发者快速构建高质量的 Web 应用程序。</p></blockquote><ul><li>Element Plus 支持按需加载，且不依赖于任何第三方 CSS 库，它可以轻松地集成到任何 Vue.js 项目中。Element Plus 的文档十分清晰，提供了各种组件的使用方法和示例代码，方便开发者快速上手。</li><li>Element Plus 目前已经推出了大量的常用 UI 组件，如按钮、表单、表格、对话框、选项卡等，此外还提供了一些高级组件，如日期选择器、时间选择器、级联选择器、滑块、颜色选择器等。这些组件具有一致的设计和可靠的代码质量，可以为开发者提供稳定的使用体验。</li><li>与 Element UI 相比，Element Plus 采用了现代化的技术架构和更加先进的设计理念，同时具备更好的性能和更好的兼容性。Element Plus 的更新迭代也更加频繁，可以为开发者提供更好的使用体验和更多的功能特性。</li><li>Element Plus 可以在支持 <a href="https://caniuse.com/?feats=mdn-javascript_builtins_regexp_dotall,mdn-javascript_builtins_regexp_lookbehind_assertion,mdn-javascript_builtins_regexp_named_capture_groups,mdn-javascript_builtins_regexp_property_escapes,mdn-javascript_builtins_symbol_asynciterator,mdn-javascript_functions_method_definitions_async_generator_methods,mdn-javascript_grammar_template_literals_template_literal_revision,mdn-javascript_operators_destructuring_rest_in_objects,mdn-javascript_operators_spread_spread_in_destructuring,promise-finally" title="ES2018">ES2018</a> 和 <a href="https://caniuse.com/resizeobserver" title="ResizeObserver">ResizeObserver</a> 的浏览器上运行。 如果您确实需要支持旧版本的浏览器，请自行添加 <a href="https://babeljs.io/" title="Babel">Babel</a> 和相应的 Polyfill</li><li>官网<a href="https://element-plus.gitee.io/zh-CN/">https://element-plus.gitee.io/zh-CN/</a></li><li>由于 Vue 3 不再支持 IE11，Element Plus 也不再支持 IE 浏览器。</li><li><a href="https://element-plus.gitee.io/zh-CN/component/button.html">Element-plus常用组件</a></li></ul><h3 id="Element-plus示例"><a href="#Element-plus示例" class="headerlink" title="Element-plus示例"></a>Element-plus示例</h3><blockquote><p> 1 准备vite项目</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm create vite  // 注意选择 vue+TypeScript</span><br><span class="line">npm install </span><br><span class="line">npm install pinia</span><br><span class="line">npm install axios</span><br></pre></td></tr></table></figure><blockquote><p> 2 安装element-plus</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install element-plus</span><br></pre></td></tr></table></figure><blockquote><p>3 完整引入element-plus</p></blockquote><ul><li>main.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//导入element-plus相关内容</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> value = <span class="title function_">ref</span>(<span class="literal">true</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 直接使用element-plus组件即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-switch</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">size</span>=<span class="string">&quot;large&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">active-text</span>=<span class="string">&quot;Open&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">inactive-text</span>=<span class="string">&quot;Close&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-switch</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> <span class="attr">active-text</span>=<span class="string">&quot;Open&quot;</span> <span class="attr">inactive-text</span>=<span class="string">&quot;Close&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-switch</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">size</span>=<span class="string">&quot;small&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">active-text</span>=<span class="string">&quot;Open&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">inactive-text</span>=<span class="string">&quot;Close&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb技术（上）</title>
      <link href="/inori/72bd32c0.html"/>
      <url>/inori/72bd32c0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Html、CSS、JavaScript基础语法"><a href="#Html、CSS、JavaScript基础语法" class="headerlink" title="Html、CSS、JavaScript基础语法"></a>Html、CSS、JavaScript基础语法</h2><p><a href="https://www.zhihu.com/tardis/bd/art/583518241?source_id=1001">点击这里</a>了解</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>前后端都是使用对象来存储数据的，但是JS的对象和Java的对象并不能互通，两者是将数据转化成JSON进行传输的。</p><p>JSON(JavaScript Object Notation)JS对象简谱，采用完全独立于编程语言的文本格式来存储和表示数据。JSON是一种字符串格式，这种格式无论是在前端还是后端，都可以很容易的转换成对象，所以常用于前后端数据传递。</p><ul><li><p>JSON语法：<code>var obj = &#39;&#123;&quot;属性名&quot;: &quot;属性值&quot;, ...&#125;&#39;</code></p></li><li><p>JSON在客户端（前端）的使用：</p><ol><li>获取JSON字符串</li><li>使用<code>JSON.parse(jsonStr)</code>将JSON转化成对象</li></ol></li><li><p>JSON在服务端（后端）的使用：</p><ol><li>编写需要转化成JSON的对象或者获取到JSON时</li><li>使用<u>GSON</u>、<u>Jackson</u>、<u>Fastjson</u>等第三方工具类（需要导入jar包），将对象转化成JSON字符串。Jackson语法为：<code>new ObjectMapper().writeValueAsString(jsonStr)</code>和<code>new ObjectMapper().readValue(jsonStr, 需要转化的类名.class)</code></li></ol></li></ul><h3 id="BOM编程"><a href="#BOM编程" class="headerlink" title="BOM编程"></a>BOM编程</h3><p>​BOM(Browser Object Model)浏览器对象模型，BOM由一系列对象组成，是访问、控制、修改浏览器的属性和方法(通过window对象及属性的一系列方法控制浏览器行为的一种编程)，BOM没有统一的标准(每种客户端都可以自定标准)，BOM编程是将浏览器窗口的各个组成部分抽象成各个对象,通过各个对象的API操作组件行为的一种编程。<br>BOM编程的对象结构如下：</p><ul><li>window：顶级对象,代表整个浏览器窗口</li><li>location：window对象的属性之一,代表浏览器的地址栏</li><li>history：window对象的属性之一,代表浏览器的访问历史</li><li>screen：window对象的属性之一,代表屏幕</li><li>navigator：window对象的属性之一,代表浏览器软件本身</li><li>document：window对象的属性之一,代表浏览器窗口目前解析的html文档</li><li>console：window对象的属性之一,代表浏览器开发者工具的控制台</li><li>localStorage：window对象的属性之一,代表浏览器的本地数据持久化存储</li><li>sessionStorage window对象的属性之一,代表浏览器的本地数据会话级存储（暂时存储）</li></ul><h3 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h3><p>​DOM(Document Object Model)文档对象模型编程，就是使用document对象的API完成对网页HTML文档进行动态修改,以实现网页数据和样式动态变化效果的编程</p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），HTML DOM 模型被结构化为对象树：</p><p>HTML DOM 是 HTML 的标准对象模型和编程接口。它定义了：</p><ul><li>作为对象的 HTML 元素</li><li>所有 HTML 元素的属性</li><li>访问所有 HTML 元素的方法</li><li>所有 HTML 元素的事件</li></ul><p><strong>文档：一个页面就是一个文档，DOM中使用<code>document</code> 表示。</strong><br><strong>网页：框架标记（<code>frameset</code> <code>iframe</code>）一个页面中包含了多个文档<code>documen</code>对象</strong><br><strong>元素：页面中所有的标签都是元素，DOM中使用<code>element</code>表示</strong><br><strong>节点：页面中所有内容都是节点（标签、属性、文本、注释等），DOM中使用<code>node</code>表示</strong></p><h4 id="DOM基本方法"><a href="#DOM基本方法" class="headerlink" title="DOM基本方法"></a>DOM基本方法</h4><p>DOM能通过JS进行访问，DOM中所有HTML元素都被定义为对象。我们通过JS对这些对象操作，改变HTML元素的内容</p><ul><li>使用<code>getElementByID()</code>方法可以获取带有ID的元素对象</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> mydiv=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(mydiv);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mydiv&quot;</span>&gt;</span>my id a nice man<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>getElementByTagname()</code>方法可以返回带有指定标签名的对象集合</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementByTagname</span>(<span class="string">&#x27;标签名&#x27;</span>)</span><br></pre></td></tr></table></figure><p>也可以获取（父元素）内部所有指定标签名的子元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dlement.<span class="title function_">getElementBytagName</span>(<span class="string">&#x27;标签名&#x27;</span>);</span><br><span class="line"><span class="comment">//父元素必须是单个对象（必须指明）。</span></span><br></pre></td></tr></table></figure><ul><li><code>getElementByName()</code>方法可返回带有指定名称的对象的集合，它查询的元素是name属性，返回的是数组，不是一个元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据类名返回元素对象集合</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;类名&#x27;</span>);</span><br><span class="line"><span class="comment">//根据指定选择器返回第一个元素对象 里面的选择器需要加符号</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;选择器&#x27;</span>);</span><br><span class="line"><span class="comment">//根据指定选择器返回</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;选择器&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>获取body元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span></span><br></pre></td></tr></table></figure><ul><li>获取html元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">dovumentElement</span></span><br></pre></td></tr></table></figure><h4 id="改变HTML元素"><a href="#改变HTML元素" class="headerlink" title="改变HTML元素"></a>改变HTML元素</h4><blockquote><p>JavaScript的DOM操作可以改变网页内容、结构和样式，我们可以利用DOm操作元素来改变元素李的内容、属性等操作</p></blockquote><p><code>element.innerHtml=new htmlcontent</code> ：改变元素的HTML<br><code>element.innerTEXT=new text</code>：改变元素的文本内容<br><code>element.attribute=new value</code>：改变HTML元素的属性值<br><code>element.setAttribute(attribuute,value)</code>：改变HTML元素的属性值<br><code>element.hasAttribute(attribute)</code>：删除元素属性<br><code>element.removeAttribute(attribute)</code>：删除元素属性<br><code>element.style.property=new style</code>：改变html元素的样式</p><ul><li>元素属性innerHtml就是元素的html代码，查找到元素后，可以对其innerHtml属性进行重新赋值修改</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> h1=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">h1.<span class="property">innerHTML</span>=<span class="string">&quot;&lt;h2&gt;World&lt;/h2&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>element.innerText</code>改变element中的文本</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> h1=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//改变文本，html不解析，同时去空格、换行</span></span></span><br><span class="line"><span class="language-javascript">h1.<span class="property">innerText</span>=<span class="string">&quot;&lt;h2&gt;World&lt;/h2&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>attribute 是代词，具体看元素属性。如a标签有href属性，可以使用<code>element.gref</code>来改变</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.4399.com&quot;</span>&gt;</span>网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    a.<span class="property">href</span> = <span class="string">&quot;https://www.qq.com&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过 <code>element.setAttribute </code>方法来改变元素属性值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">setAttribute</span>(attribute, value)</span><br></pre></td></tr></table></figure><p><code>attribute</code>：属性名<br><code>value</code>：属性值</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;hightlight&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.4399.com&quot;</span>&gt;</span>网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;a&quot;</span>); </span></span><br><span class="line"><span class="language-javascript"><span class="comment">//更改属性</span></span></span><br><span class="line"><span class="language-javascript"> a.<span class="title function_">setAttribute</span>(<span class="string">&quot;href&quot;</span>,<span class="string">&quot;https://www.qq.com&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 用className方法更改 class 属性使用 </span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 注意空格，这里是增加一个class</span></span></span><br><span class="line"><span class="language-javascript">    a.<span class="property">className</span> += <span class="string">&quot; hidden&quot;</span>;  </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 用 setAttribute 更改 class 属性直接用 class</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 也可写两个属性</span></span></span><br><span class="line"><span class="language-javascript">    a.<span class="title function_">setAttribute</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;hightlight hidden&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>element.hasAttribute</code>判断是否有指定属性</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.baidu.com&quot;</span>&gt;</span>bd<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> a=documnet.<span class="title function_">querySelector</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">a.<span class="title function_">hasAttribute</span>(<span class="string">&quot;href&quot;</span>);<span class="comment">//返回true</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>element.removeAttribute</code>移除指定元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">date-index</span>=<span class="string">&quot;1&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> a=documnet.<span class="title function_">querySelector</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">a.<span class="title function_">removeAttribute</span>(<span class="string">&quot;date-index&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>使用元素中style 属性可以修改元素样式，修改的样式直接作用在css样式里</p><ul><li><p>css中原本使用“-”连接的名字要转换成驼峰式，如background-color -&gt; backgroundColor</p></li><li><p>修改样式的属性名需要改写</p></li><li><p>属性值都是字符串，设置是必须包括单位</p></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.4399.com&quot;</span>&gt;</span>网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> a =<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">a.<span class="property">style</span>.<span class="property">fontSize</span>=<span class="string">&quot;30px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="获取HTML元素"><a href="#获取HTML元素" class="headerlink" title="获取HTML元素"></a>获取HTML元素</h4><ul><li>利用DOM树可把节点划分不同的关系，<code>node.parentNode</code>:可返回最近的一个父节点，如果没有返回null</li><li><code>parentNode.childNodes(标准)</code>：返回指定节点的子节点的集合;返回值包括所有的子节点、元素节点、文本节点。</li><li><code>parentNodes.children(非标准)</code>：一个只读属性，只返回所有子元素节点，其他节点不返回；获取所有元素节点，需要其他特殊处理，一般不推荐使用<code>childNode</code>，但浏览器都支持。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ul.<span class="property">childNodes</span>.<span class="property">lenth</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(ul.<span class="property">childNodes</span>[i].<span class="property">nodeType</span> == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//ul.childNodes[i] 是元素节点</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ul.<span class="property">childNodes</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>parentNode.firstChild</code>:返回一个子节点，找不到返回null，包含所有的节点。</li><li><code>parentNode.lastChild</code>:返回最后一个子节点，找不到返回null，也包含所有节点<br><strong>以下两个只支持IE9以上</strong></li><li><code>parentNode.firstElementChild</code>:返回第一个子节点，找不到返回null。</li><li><code>parentNode.lastElementChild</code>:返回最后一个元素节点，找不到返回null。</li><li><code>node.nextSibling</code>:返回当前元素的下一个兄弟节点，找不到返回null，包括所有节点。</li><li><code>node.previousSibling</code>:返回当前元素的上一个兄弟节点，找不到返回null，包括所有节点。<br><strong>指定节点</strong>（只支持IE9以上）</li><li><code>node.nextElementSibling</code>:返回当前元素下一个兄弟元素节点，找不到返回null。</li><li><code>node.nextpreviousElementSibling</code>:返回当前元素上一个兄弟节点，找不到返回null。</li></ul><h4 id="操作HTML元素"><a href="#操作HTML元素" class="headerlink" title="操作HTML元素"></a>操作HTML元素</h4><ul><li><p><code>document.createElement()</code>:方法创建由tagName指定的html元素（动态创建元素点）。</p></li><li><p><code>node.appendChild()</code>:方法将一个节点添加到父节点的子节点列表末尾。</p></li><li><p><code>node.insertBefore(child,指定元素)</code>:</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加节点 node.appendChild(child)  node 父级  child子级</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.<span class="title function_">appendChild</span>(li);</span><br><span class="line"><span class="comment">//node.insertBefore(child,指定元素);</span></span><br><span class="line"><span class="keyword">var</span> lili = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">ul.<span class="title function_">insertBefore</span>(lili,ul.<span class="property">children</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><ul><li><code>node.removeChild(child)</code>:方法从DOM中删除一个子节点，返回删除的节点</li></ul><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Tomcat是一款JavaWeb服务器，Tomcat技术先进、性能稳定，而且免费开源，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为比较流行的Web应用服务器</p><h3 id="Tomcat目录及测试"><a href="#Tomcat目录及测试" class="headerlink" title="Tomcat目录及测试"></a>Tomcat目录及测试</h3><ul><li><p>bin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat10.exe、tomcat10w.exe，前者是在控制台下启动Tomcat，后者是弹出GUI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要先配置JAVA_HOME环境变量才能启动，shutdawn.bat用来停止Tomcat</p></li><li><p>conf：这个目录下有四个最为重要的文件：</p><ul><li><p><strong>server.xml：配置整个服务器信息。例如修改端口号。默认HTTP请求的端口号是：8080</strong></p></li><li><p>tomcat-users.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://tomcat.apache.org/xml&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin-gui&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin-script&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-gui&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-script&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-jmx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-status&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">password</span>=<span class="string">&quot;admin&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">roles</span>=<span class="string">&quot;admin-gui,admin-script,manager-gui,manager-script,manager-jmx,manager-status&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text&#x2F;html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME是用来说明文档的内容是什么类型的</p></li><li><p>context.xml：对所有应用的统一配置，通常不会去配置它</p></li></ul></li><li><p>lib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的jar包了，所以建议只把Tomcat需要的jar包放到这个目录下；</p></li><li><p>logs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中</p></li><li><p>temp：存放临时文件</p></li><li><p><strong>webapps：存放web项目的目录，其中每个文件夹都是一个项目</strong>；如果这个目录下已经存在了目录，那么都是tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中访问<a href="http://127.0.0.1:8080，没有给出项目目录时，对应的就是ROOT项目.http://localhost:8080/examples，进入示例项目">http://127.0.0.1:8080，没有给出项目目录时，对应的就是ROOT项目.http://localhost:8080/examples，进入示例项目</a></p></li><li><p>work：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成。可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下</p></li></ul><h3 id="Web项目的标准结构"><a href="#Web项目的标准结构" class="headerlink" title="Web项目的标准结构"></a>Web项目的标准结构</h3><p>app：应用根目录</p><ul><li>static 非必要目录,约定俗成的名字,一般在此处放静态资源 ( css  js  img)</li><li>WEB-INF：必要目录,必须叫WEB-INF,受保护的资源目录,浏览器通过url不可以直接访问的目录<ul><li>classes：必要目录,src下源代码,配置文件,编译后会在该目录下,web项目中如果没有源码,则该目录不会出现</li><li>lib：必要目录,项目依赖的jar编译后会出现在该目录下,web项目要是没有依赖任何jar,则该目录不会出现</li><li>web.xml：必要文件,web项目的基本配置文件. 较新的版本中可以没有该文件,但是学习过程中还是需要该文件</li></ul></li><li>index.html：非必要文件,index.html&#x2F;index.htm&#x2F;index.jsp为默认的欢迎页</li></ul><h3 id="Web项目的部署方式"><a href="#Web项目的部署方式" class="headerlink" title="Web项目的部署方式"></a>Web项目的部署方式</h3><blockquote><p>方式1   直接将编译好的项目放在webapps目录下</p></blockquote><blockquote><p>方式2   将编译好的项目打成war包放在webapps目录下,tomcat启动后会自动解压war包</p></blockquote><blockquote><p>方式3   可以将项目放在非webapps的其他目录下,在tomcat中通过配置文件指向app的实际磁盘路径</p></blockquote><ul><li><p>在磁盘的自定义目录上准备一个app</p></li><li><p>在tomcat的conf下创建Catalina&#x2F;localhost目录,并在该目录下准备一个app.xml文件</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">path: 项目的访问路径,也是项目的上下文路径,就是在浏览器中,输入的项目名称</span></span><br><span class="line"><span class="comment">    docBase: 项目在磁盘中的实际路径</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/app&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;D:\mywebapps\app&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动tomcat访问测试即可</li></ul><h3 id="IDEA部署项目并运行的原理"><a href="#IDEA部署项目并运行的原理" class="headerlink" title="IDEA部署项目并运行的原理"></a>IDEA部署项目并运行的原理</h3><ul><li>idea并没有直接进将编译好的项目放入tomcat的webapps中</li><li>idea根据关联的tomcat,创建了一个tomcat副本,将项目部署到了这个副本中</li><li>idea的tomcat副本在C:\用户\当前用户\AppData\Local\JetBrains\IntelliJIdea\tomcat\</li><li>idea的tomcat副本并不是一个完整的tomcat,副本里只是准备了和当前项目相关的配置文件</li><li>idea启动tomcat时,是让本地tomcat程序按照tomcat副本里的配置文件运行</li><li>idea的tomcat副本部署项目的模式通过conf&#x2F;Catalina&#x2F;localhost&#x2F;*.xml配置文件的形式实现项目部署</li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote><p>Servlet  (server applet) 是运行在服务端(tomcat)的Java小程序，是sun公司提供一套定义动态资源规范; 从代码层面上来讲Servlet就是一个接口</p></blockquote><ul><li><p>Servlet用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。我们可以把Servlet称为Web应用中的<strong>控制器</strong></p></li><li><p>不是所有的JAVA类都能用于处理客户端请求,能处理客户端请求并做出响应的一套技术标准就是Servlet</p></li><li><p>Servlet是运行在服务端的,所以Servlet必须在WEB项目##中开发且在Tomcat这样的服务容器中运行</p></li></ul><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><blockquote><p>步骤1 开发一个web类型的module </p></blockquote><blockquote><p>步骤2 开发一个UserServlet</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span>  <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;atguigu&quot;</span>.equals(username))&#123;</span><br><span class="line">            <span class="comment">//通过响应对象响应信息</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义一个类,要继承HttpServlet类</li><li>重写service方法,该方法主要就是用于处理用户请求的服务方法</li><li>HttpServletRequest 代表请求对象,是有请求报文经过tomcat转换而来的,通过该对象可以获取请求中的信息</li><li>HttpServletResponse 代表响应对象,该对象会被tomcat转换为响应的报文,通过该对象可以设置响应中的信息</li><li>Servlet对象的生命周期(创建,初始化,处理服务,销毁)是由tomcat管理的,无需我们自己new</li><li>HttpServletRequest HttpServletResponse 两个对象也是有tomcat负责转换,在调用service方法时传入给我们用的</li></ul><blockquote><p>步骤3 在web.xml为UseServlet配置请求的映射路径</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给UserServlet起一个别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.UserServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关联别名和映射路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以为一个Servlet匹配多个不同的映射路径,但是不同的Servlet不能使用相同的url-pattern--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/userServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;url-pattern&gt;/userServlet2&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            /        表示通配所有资源,不包括jsp文件</span></span><br><span class="line"><span class="comment">            /*       表示通配所有资源,包括jsp文件</span></span><br><span class="line"><span class="comment">            /a/*     匹配所有以a前缀的映射路径</span></span><br><span class="line"><span class="comment">            *.action 匹配所有以action为后缀的映射路径</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Servlet并不是文件系统中实际存在的文件或者目录,所以为了能够请求到该资源,我们需要为其配置映射路径</li><li>servlet的请求映射路径配置在web.xml中</li><li>servlet-name作为servlet的别名,可以自己随意定义,见名知意就好</li><li>url-pattern标签用于定义Servlet的请求映射路径</li><li>一个servlet可以对应多个不同的url-pattern</li><li>多个servlet不能使用相同的url-pattern</li><li>url-pattern中可以使用一些通配写法<ul><li>&#x2F;        表示通配所有资源,不包括jsp文件</li><li>&#x2F;*      表示通配所有资源,包括jsp文件</li><li>&#x2F;a&#x2F;*     匹配所有以a前缀的映射路径</li><li>*.action 匹配所有以action为后缀的映射路径</li></ul></li></ul><blockquote><p>步骤4 开发一个form表单,向servlet发送一个get请求并携带username参数</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;userServlet&quot;</span>&gt;</span></span><br><span class="line">        请输入用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;校验&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>启动项目,访问index.html ,提交表单测试</p></blockquote><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><blockquote><p>什么是Servlet的生命周期</p></blockquote><ul><li>应用程序中的对象不仅在空间上有层次结构的关系，在时间上也会因为处于程序运行过程中的不同阶段而表现出不同状态和不同行为——这就是对象的生命周期。</li><li>简单的叙述生命周期，就是对象在容器中从开始创建到销毁的过程。</li></ul><blockquote><p>Servlet容器</p></blockquote><ul><li>Servlet对象是Servlet容器创建的，生命周期方法都是由容器(目前我们使用的是Tomcat)调用的。这一点和我们之前所编写的代码有很大不同。在今后的学习中我们会看到，越来越多的对象交给容器或框架来创建，越来越多的方法由容器或框架来调用，开发人员要尽可能多的将精力放在业务逻辑的实现上。</li></ul><blockquote><p>Servlet主要的生命周期执行特点</p></blockquote><table><thead><tr><th>生命周期</th><th>对应方法</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>构造对象</td><td>构造器</td><td>第一次请求或者容器启动</td><td>1</td></tr><tr><td>初始化</td><td>init()</td><td>构造完毕后</td><td>1</td></tr><tr><td>处理服务</td><td>service(HttpServletRequest req,HttpServletResponse resp)</td><td>每次请求</td><td>多次</td></tr><tr><td>销毁</td><td>destory()</td><td>容器关闭时</td><td>1</td></tr></tbody></table><ol><li>Servlet对象在容器中是单例的</li><li>容器是可以处理并发的用户请求的,每个请求在容器中都会开启一个线程</li><li>多个线程可能会使用相同的Servlet对象,所以在Servlet中,我们不要轻易定义一些容易经常发生修改的成员变量</li><li>load-on-startup中定义的正整数表示实例化顺序,如果数字重复了,容器会自行解决实例化顺序问题,但是应该避免重复</li><li>Tomcat容器中,已经定义了一些随系统启动实例化的servlet,我们自定义的servlet的load-on-startup尽量不要占用数字1-5</li></ol><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><ul><li>ServletConfig为Servlet提供初始配置参数的一种对象,每个Servlet都有自己独立唯一的ServletConfig对象</li><li>容器会为每个Servlet实例化一个ServletConfig对象,并通过Servlet生命周期的init方法传入给Servlet作为属性</li></ul><p>了解是什么即可</p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><ul><li>ServletContext对象有称呼为上下文对象,或者叫应用域对象</li><li>容器会为每个app创建一个独立的唯一的ServletContext对象</li><li>ServletContext对象为所有的Servlet所共享</li><li>ServletContext可以为所有的Servlet提供初始配置参数</li></ul><h4 id="ServletContext重要API"><a href="#ServletContext重要API" class="headerlink" title="ServletContext重要API"></a>ServletContext重要API</h4><blockquote><p>获取资源的真实路径</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;资源在web目录中的路径&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>例如我们的目标是需要获取项目中某个静态资源的路径，不是工程目录中的路径，而是<strong>部署目录中的路径</strong>；我们如果直接拷贝其在我们电脑中的完整路径的话其实是有问题的，因为如果该项目以后部署到公司服务器上的话，路径肯定是会发生改变的，所以我们需要使用代码动态获取资源的真实路径.  只要使用了servletContext动态获取资源的真实路径，<strong>那么无论项目的部署路径发生什么变化，都会动态获取项目运行时候的实际路径</strong>，所以就不会发生由于写死真实路径而导致项目部署位置改变引发的路径错误问题</li></ul><blockquote><p>获取项目的上下文路径</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> servletContext.getContextPath();</span><br></pre></td></tr></table></figure><ul><li>项目的部署名称,也叫项目的上下文路径,在部署进入tomcat时所使用的路径,该路径是可能发生变化的,通过该API动态获取项目真实的上下文路径,可以<strong>帮助我们解决一些后端页面渲染技术或者请求转发和响应重定向中的路径问题</strong></li></ul><blockquote><p> 域对象的相关API</p></blockquote><ul><li>域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同</li><li>ServletContext代表应用,所以ServletContext域也叫作应用域,是webapp中最大的域,可以在本应用内实现数据的共享和传递</li><li>webapp中的三大域对象,分别是应用域,会话域,请求域</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void setAttribute(String key,Object value);</td><td>向域中存储&#x2F;修改数据</td></tr><tr><td>Object getAttribute(String key);</td><td>获得域中的数据</td></tr><tr><td>void removeAttribute(String key);</td><td>移除域中的数据</td></tr></tbody></table><h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><ul><li>HttpServletRequest是一个接口,其父接口是ServletRequest</li><li>HttpServletRequest是Tomcat将请求报文转换封装而来的对象,在Tomcat调用service方法时传入</li><li>HttpServletRequest代表客户端发来的请求,所有请求中的信息都可以通过该对象获得</li></ul><h3 id="HttpServletRequest常见API"><a href="#HttpServletRequest常见API" class="headerlink" title="HttpServletRequest常见API"></a>HttpServletRequest常见API</h3><ul><li>获取请求行信息相关(方式,请求的url,协议及版本)</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>StringBuffer getRequestURL();</td><td>获取客户端请求的url</td></tr><tr><td>String getRequestURI();</td><td>获取客户端请求项目中的具体资源</td></tr><tr><td>int getServerPort();</td><td>获取客户端发送请求时的端口</td></tr><tr><td>int getLocalPort();</td><td>获取本应用在所在容器的端口</td></tr><tr><td>int getRemotePort();</td><td>获取客户端程序的端口</td></tr><tr><td>String getScheme();</td><td>获取请求协议</td></tr><tr><td>String getProtocol();</td><td>获取请求协议及版本号</td></tr><tr><td>String getMethod();</td><td>获取请求方式</td></tr></tbody></table><ul><li>获得请求头信息相关</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>String getHeader(String headerName);</td><td>根据头名称获取请求头</td></tr><tr><td>Enumeration<String> getHeaderNames();</td><td>获取所有的请求头名字</td></tr><tr><td>String getContentType();</td><td>获取content-type请求头</td></tr></tbody></table><ul><li>获得请求参数相关</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>String getParameter(String parameterName);</td><td>根据请求参数名获取请求单个参数值</td></tr><tr><td>String[] getParameterValues(String parameterName);</td><td>根据请求参数名获取请求多个参数值数组</td></tr><tr><td>Enumeration<String> getParameterNames();</td><td>获取所有请求参数名</td></tr><tr><td>Map&lt;String, String[]&gt; getParameterMap();</td><td>获取所有请求参数的键值对集合</td></tr><tr><td>BufferedReader getReader() throws IOException;</td><td>获取读取请求体的字符输入流</td></tr><tr><td>ServletInputStream getInputStream() throws IOException;</td><td>获取读取请求体的字节输入流</td></tr><tr><td>int getContentLength();</td><td>获得请求体长度的字节数</td></tr></tbody></table><ul><li>其他API</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>String getServletPath();</td><td>获取请求的Servlet的映射路径</td></tr><tr><td>ServletContext getServletContext();</td><td>获取ServletContext对象</td></tr><tr><td>Cookie[] getCookies();</td><td>获取请求中的所有cookie</td></tr><tr><td>HttpSession getSession();</td><td>获取Session对象</td></tr><tr><td>void setCharacterEncoding(String encoding) ;</td><td>设置请求体字符集</td></tr></tbody></table><h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><ul><li>HttpServletResponse是一个接口,其父接口是ServletResponse</li><li>HttpServletResponse是Tomcat预先创建的,在Tomcat调用service方法时传入</li><li>HttpServletResponse代表对客户端的响应,该对象会被转换成响应的报文发送给客户端,通过该对象我们可以设置响应信息</li></ul><h3 id="HttpServletResponse的常见API"><a href="#HttpServletResponse的常见API" class="headerlink" title="HttpServletResponse的常见API"></a>HttpServletResponse的常见API</h3><ul><li>设置响应行相关</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void setStatus(int  code);</td><td>设置响应状态码</td></tr></tbody></table><ul><li>设置响应头相关</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void setHeader(String headerName, String headerValue);</td><td>设置&#x2F;修改响应头键值对</td></tr><tr><td>void setContentType(String contentType);</td><td>设置content-type响应头及响应字符集(设置MIME类型)</td></tr></tbody></table><ul><li>设置响应体相关</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>PrintWriter getWriter() throws IOException;</td><td>获得向响应体放入信息的字符输出流</td></tr><tr><td>ServletOutputStream getOutputStream() throws IOException;</td><td>获得向响应体放入信息的字节输出流</td></tr><tr><td>void setContentLength(int length);</td><td>设置响应体的字节长度,其实就是在设置content-length响应头</td></tr></tbody></table><ul><li>其他API</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void sendError(int code, String message) throws IOException;</td><td>向客户端响应错误信息的方法,需要指定响应码和响应信息</td></tr><tr><td>void addCookie(Cookie cookie);</td><td>向响应体中增加cookie</td></tr><tr><td>void setCharacterEncoding(String encoding);</td><td>设置响应体字符集</td></tr></tbody></table><blockquote><p>MIME类型</p></blockquote><ul><li>MIME类型,可以理解为文档类型,用户表示传递的数据是属于什么类型的文档</li><li>浏览器可以根据MIME类型决定该用什么样的方式解析接收到的响应体数据</li><li>可以这样理解: 前后端交互数据时,告诉对方发给对方的是 html&#x2F;css&#x2F;js&#x2F;图片&#x2F;声音&#x2F;视频&#x2F;… …</li><li>tomcat&#x2F;conf&#x2F;web.xml中配置了常见文件的拓展名和MIMIE类型的对应关系</li><li>常见的MIME类型举例如下</li></ul><table><thead><tr><th>文件拓展名</th><th>MIME类型</th></tr></thead><tbody><tr><td>.html</td><td>text&#x2F;html</td></tr><tr><td>.css</td><td>text&#x2F;css</td></tr><tr><td>.js</td><td>application&#x2F;javascript</td></tr><tr><td>.png &#x2F;.jpeg&#x2F;.jpg&#x2F;… …</td><td>image&#x2F;jpeg</td></tr><tr><td>.mp3&#x2F;.mpe&#x2F;.mpeg&#x2F; … …</td><td>audio&#x2F;mpeg</td></tr><tr><td>.mp4</td><td>video&#x2F;mp4</td></tr><tr><td>.m1v&#x2F;.m1v&#x2F;.m2v&#x2F;.mpe&#x2F;… …</td><td>video&#x2F;mpeg</td></tr></tbody></table><h2 id="请求转发和响应重定向"><a href="#请求转发和响应重定向" class="headerlink" title="请求转发和响应重定向"></a>请求转发和响应重定向</h2><ul><li>请求转发和响应重定向是web应用中间接访问项目资源的两种手段,也是Servlet控制页面跳转的两种手段</li><li>请求转发通过HttpServletRequest实现,响应重定向通过HttpServletResponse实现</li></ul><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><ul><li>请求转发通过HttpServletRequest对象获取请求转发器实现</li><li>请求转发是服务器内部的行为,对客户端是屏蔽的</li><li>客户端只发送了一次请求,客户端地址栏不变</li><li>服务端只产生了一对请求和响应对象,这一对请求和响应对象会继续传递给下一个资源</li><li>因为全程只有一个HttpServletRequset对象,所以请求参数可以传递,请求域中的数据也可以传递</li><li>请求转发可以转发给其他Servlet动态资源,也可以转发给一些静态资源以实现页面跳转</li><li>请求转发可以转发给WEB-INF下受保护的资源</li><li>请求转发不能转发到本项目以外的外部资源</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>ServletA</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//  获取请求转发器</span></span><br><span class="line">        <span class="comment">//  转发给servlet  ok</span></span><br><span class="line">        <span class="type">RequestDispatcher</span>  <span class="variable">requestDispatcher</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;servletB&quot;</span>);</span><br><span class="line">        <span class="comment">//  转发给一个视图资源 ok</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;welcome.html&quot;);</span></span><br><span class="line">        <span class="comment">//  转发给WEB-INF下的资源  ok</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/views/view1.html&quot;);</span></span><br><span class="line">        <span class="comment">//  转发给外部资源   no</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;http://www.atguigu.com&quot;);</span></span><br><span class="line">        <span class="comment">//  获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">//  向请求域中添加数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;reqKey&quot;</span>,<span class="string">&quot;requestMessage&quot;</span>);</span><br><span class="line">        <span class="comment">//  做出转发动作</span></span><br><span class="line">        requestDispatcher.forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ServletB</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">// 获取请求域中的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reqMessage</span> <span class="operator">=</span> (String)req.getAttribute(<span class="string">&quot;reqKey&quot;</span>);</span><br><span class="line">        System.out.println(reqMessage);</span><br><span class="line">        <span class="comment">// 做出响应</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;servletB response&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应重定向"><a href="#响应重定向" class="headerlink" title="响应重定向"></a>响应重定向</h3><ul><li>响应重定向通过HttpServletResponse对象的sendRedirect方法实现</li><li>响应重定向是服务端通过302响应码和路径,告诉客户端自己去找其他资源,是在服务端提示下的,客户端的行为</li><li>客户端至少发送了两次请求,客户端地址栏是要变化的</li><li>服务端产生了多对请求和响应对象,且请求和响应对象不会传递给下一个资源</li><li>因为全程产生了多个HttpServletRequset对象,所以请求参数不可以传递,请求域中的数据也不可以传递</li><li>重定向可以是其他Servlet动态资源,也可以是一些静态资源以实现页面跳转</li><li>重定向不可以到给WEB-INF下受保护的资源</li><li>重定向可以到本项目以外的外部资源</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul><li>ServletA</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//  获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">//  向请求域中添加数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;reqKey&quot;</span>,<span class="string">&quot;requestMessage&quot;</span>);</span><br><span class="line">        <span class="comment">//  响应重定向</span></span><br><span class="line">        <span class="comment">// 重定向到servlet动态资源 OK</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;servletB&quot;</span>);</span><br><span class="line">        <span class="comment">// 重定向到视图静态资源 OK</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;welcome.html&quot;);</span></span><br><span class="line">        <span class="comment">// 重定向到WEB-INF下的资源 NO</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;WEB-INF/views/view1&quot;);</span></span><br><span class="line">        <span class="comment">// 重定向到外部资源</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;http://www.atguigu.com&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ServletB</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">// 获取请求域中的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reqMessage</span> <span class="operator">=</span> (String)req.getAttribute(<span class="string">&quot;reqKey&quot;</span>);</span><br><span class="line">        System.out.println(reqMessage);</span><br><span class="line">        <span class="comment">// 做出响应</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;servletB response&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><strong>同样实现页面跳转，只要重定向能做到，就优先使用重定向！！！</strong></u></p><h2 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h2><blockquote><p> MVC（Model View Controller）是软件工程中的一种**<code>软件架构模式</code><strong>，它把软件系统分为</strong><code>模型</code><strong>、</strong><code>视图</code><strong>和</strong><code>控制器</code>**三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p></blockquote><ul><li><p><strong>M</strong>：Model 模型层,具体功能如下</p><ol><li>存放和数据库对象的实体类以及一些用于存储非数据库表完整相关的VO对象</li><li>存放一些对数据进行逻辑运算操作的的一些业务处理代码</li></ol></li><li><p><strong>V</strong>：View 视图层,具体功能如下</p><ol><li>存放一些视图文件相关的代码 html css js等</li><li>在前后端分离的项目中,后端已经没有视图文件,该层次已经衍化成独立的前端项目</li></ol></li><li><p><strong>C</strong>：Controller 控制层,具体功能如下</p><ol><li>接收客户端请求,获得请求数据</li><li>将准备好的数据响应给客户端</li></ol></li></ul><blockquote><p>MVC模式下,项目中的常见包</p></blockquote><ul><li>M:<ol><li>实体类包(pojo &#x2F;entity &#x2F;bean) 专门存放和数据库对应的实体类和一些VO对象</li><li>数据库访问包(dao&#x2F;mapper)  专门存放对数据库不同表格CURD方法封装的一些类</li><li>服务包(service)                       专门存放对数据进行业务逻辑运算的一些类</li></ol></li><li>C: 控制层包(controller)</li><li>V:<ol><li>web目录下的视图资源 html css js img 等</li><li>前端工程化后,在后端项目中已经不存在了</li></ol></li></ul><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><h3 id="为什么需要会话管理"><a href="#为什么需要会话管理" class="headerlink" title="为什么需要会话管理"></a>为什么需要会话管理</h3><blockquote><p>HTTP是无状态协议</p></blockquote><ul><li>无状态就是不保存状态,即无状态协议(stateless),HTTP协议自身不对请求和响应之间的通信状态进行保存,也就是说,在HTTP协议这个级别,协议对于发送过的请求或者响应都不做持久化处理</li><li>简单理解:浏览器发送请求,服务器接收并响应,但是服务器不记录请求是否来自哪个浏览器,服务器没记录浏览器的特征,就是客户端的状态</li></ul><h3 id="会话管理实现的手段"><a href="#会话管理实现的手段" class="headerlink" title="会话管理实现的手段"></a>会话管理实现的手段</h3><blockquote><p>Cookie和Session配合解决</p></blockquote><ul><li>cookie是在客户端保留少量数据的技术,主要通过响应头向客户端响应一些客户端要保留的信息</li><li>session是在服务端保留更多数据的技术,主要通过HttpSession对象保存一些和客户端相关的信息</li><li>cookie和session配合记录请求状态</li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><blockquote><p>cookie是一种客户端会话技术,cookie由服务端产生,它是服务器存放在浏览器的一小份数据,浏览器以后每次访问该服务器的时候都会将这小份数据携带到服务器去。</p></blockquote><ul><li>服务端创建cookie,将cookie放入响应对象中,Tomcat容器将cookie转化为set-cookie响应头,响应给客户端</li><li>客户端在收到cookie的响应头时,在下次请求该服务的资源时,会以cookie请求头的形式携带之前收到的Cookie</li><li>cookie是一种键值对格式的数据,从tomcat8.5开始可以保存中文,但是不推荐</li><li>由于cookie是存储于客户端的数据,比较容易暴露,一般不存储一些敏感或者影响安全的数据</li></ul><h3 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h3><blockquote><p>servletA向响应中增加Cookie</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>servletB从请求中读取Cookie</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求中的cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">//迭代cookies数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != cookies &amp;&amp; cookies.length!= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                System.out.println(cookie.getName()+<span class="string">&quot;:&quot;</span>+cookie.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cookie时效性"><a href="#Cookie时效性" class="headerlink" title="Cookie时效性"></a>Cookie时效性</h3><blockquote><p>默认情况下Cookie的有效期是一次会话范围内，我们可以通过cookie的setMaxAge()方法让Cookie持久化保存到浏览器上</p></blockquote><ul><li>会话级Cookie<ul><li>服务器端并没有明确指定Cookie的存在时间</li><li>在浏览器端，Cookie数据存在于内存中</li><li>只要浏览器还开着，Cookie数据就一直都在</li><li>浏览器关闭，内存中的Cookie数据就会被释放</li></ul></li><li>持久化Cookie<ul><li>服务器端明确设置了Cookie的存在时间</li><li>在浏览器端，Cookie数据会被保存到硬盘上</li><li>Cookie在硬盘上存在的时间根据服务器端限定的时间来管控，不受浏览器关闭的影响</li><li>持久化Cookie到达了预设的时间会被释放</li></ul></li></ul><blockquote><p>cookie.setMaxAge(int expiry)参数单位是秒，表示cookie的持久化时间，如果设置参数为0，表示将浏览器中保存的该cookie删除</p></blockquote><ul><li>servletA设置一个Cookie为持久化cookie</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        cookie1.setMaxAge(<span class="number">60</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>servletB接收Cookie,浏览器中间发生一次重启再请求servletB测试</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求中的cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">//迭代cookies数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != cookies &amp;&amp; cookies.length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                System.out.println(cookie.getName()+<span class="string">&quot;:&quot;</span>+cookie.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cookie的提交路径"><a href="#Cookie的提交路径" class="headerlink" title="Cookie的提交路径"></a>Cookie的提交路径</h3><blockquote><p>访问互联网资源时不能每次都需要把所有Cookie带上。访问不同的资源时,可以携带不同的cookie,我们可以通过cookie的setPath(String path) 对cookie的路径进行设置</p></blockquote><ul><li>从ServletA中获取cookie</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置cookie的提交路径，向ServletB请求时会携带c1，向其他资源请求时不携带c1</span></span><br><span class="line">        cookie1.setPath(<span class="string">&quot;/web03_war_exploded/servletB&quot;</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><blockquote><p> HttpSession是一种保留更多信息在服务端的一种技术,服务器会为每一个客户端开辟一块内存空间,即session对象. 客户端在发送请求时,都可以使用自己的session. 这样服务端就可以通过session来记录某个客户端的状态了</p></blockquote><ul><li>服务端在为客户端创建session时,会同时将session对象的id,即JSESSIONID以cookie的形式放入响应对象</li><li>后端创建完session后,客户端会收到一个特殊的cookie,叫做JSESSIONID</li><li>客户端下一次请求时携带JSESSIONID,后端收到后,根据JSESSIONID找到对应的session对象</li><li>通过该机制,服务端通过session就可以存储一些专门针对某个客户端的信息了</li><li>session也是域对象</li></ul><h3 id="HttpSession的使用"><a href="#HttpSession的使用" class="headerlink" title="HttpSession的使用"></a>HttpSession的使用</h3><blockquote><p>用户提交form表单到ServletA,携带用户名,ServletA获取session 将用户名存到Session,用户再请求其他任意Servlet,获取之间存储的用户</p></blockquote><ul><li>定义表单页,提交用户名,提交后</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;servletA&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>定义ServletA,将用户名存入session</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">         <span class="comment">// 获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jSessionId</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(jSessionId);</span><br><span class="line">        <span class="comment">// 判断session是不是新创建的session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> session.isNew();</span><br><span class="line">        System.out.println(isNew);</span><br><span class="line">        <span class="comment">// 向session对象中存入数据</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义其他Servlet,从session中读取用户名</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">         <span class="comment">// 获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jSessionId</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(jSessionId);</span><br><span class="line">        <span class="comment">// 判断session是不是新创建的session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> session.isNew();</span><br><span class="line">        System.out.println(isNew);</span><br><span class="line">        <span class="comment">// 从session中取出数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getSession方法的处理逻辑</p></blockquote><img src="D:\Blog\source\img\JavaWeb_getSession.png" alt="1682477914654" style="zoom: 80%;" /><h3 id="HttpSession时效性"><a href="#HttpSession时效性" class="headerlink" title="HttpSession时效性"></a>HttpSession时效性</h3><blockquote><p>为什么要设置session的时效</p></blockquote><ul><li>用户量很大之后，Session对象相应的也要创建很多。如果一味创建不释放，那么服务器端的内存迟早要被耗尽。</li><li>客户端关闭行为无法被服务端直接侦测,或者客户端较长时间不操作也经常出现,类似这些的情况,就需要对session的时限进行设置了</li><li>默认的session最大闲置时间(两次使用同一个session中的间隔时间) 在tomcat&#x2F;conf&#x2F;web.xml配置为30分钟</li></ul><blockquote><p>可以通过HttpSession的API对最大闲置时间进行设定</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置最大闲置时间</span></span><br><span class="line">session.setMaxInactiveInterval(<span class="number">60</span>);</span><br></pre></td></tr></table></figure><blockquote><p>可以直接让session失效</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接让session失效</span></span><br><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure><h2 id="三大域对象"><a href="#三大域对象" class="headerlink" title="三大域对象"></a>三大域对象</h2><blockquote><p>域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同</p></blockquote><ul><li>web项目中,我们一定要熟练使用的域对象分别是:<u>请求域,会话域,应用域</u></li><li>请求域对象是HttpServletRequest,传递数据的范围是一次请求之内及请求转发</li><li>会话域对象是HttpSession,传递数据的范围是一次会话之内,可以跨多个请求</li><li>应用域对象是ServletContext,传递数据的范围是本应用之内,可以跨多个会话</li></ul><blockquote><p>三大域对象的数据作用范围</p></blockquote><img src="D:\Blog\source\img\JavaWeb_domainType.png" alt="1682488186891" style="zoom:60%;" /><h3 id="域对象常用API"><a href="#域对象常用API" class="headerlink" title="域对象常用API"></a>域对象常用API</h3><table><thead><tr><th>API</th><th>功能</th></tr></thead><tbody><tr><td>void setAttribute(String name,String value)</td><td>向域对象中添加&#x2F;修改数据</td></tr><tr><td>Object getAttribute(String name);</td><td>从域对象中获取数据</td></tr><tr><td>removeAttribute(String name);</td><td>移除域对象中的数据</td></tr></tbody></table><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ul><li>ServletA向三大域中放入数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 向请求域中放入数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;request&quot;</span>,<span class="string">&quot;request-message&quot;</span>);</span><br><span class="line">        <span class="comment">//req.getRequestDispatcher(&quot;servletB&quot;).forward(req,resp);</span></span><br><span class="line">        <span class="comment">// 向会话域中放入数据</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;session&quot;</span>,<span class="string">&quot;session-message&quot;</span>);</span><br><span class="line">        <span class="comment">// 向应用域中放入数据</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        application.setAttribute(<span class="string">&quot;application&quot;</span>,<span class="string">&quot;application-message&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>ServletB从三大于中取出数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 从请求域中获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reqMessage</span> <span class="operator">=</span>(String)req.getAttribute(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">        System.out.println(reqMessage);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从会话域中获取数据</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sessionMessage</span> <span class="operator">=</span>(String)session.getAttribute(<span class="string">&quot;session&quot;</span>);</span><br><span class="line">        System.out.println(sessionMessage);</span><br><span class="line">        <span class="comment">// 从应用域中获取数据</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">applicationMessage</span> <span class="operator">=</span>(String)application.getAttribute(<span class="string">&quot;application&quot;</span>);</span><br><span class="line">        System.out.println(applicationMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>请求转发时,请求域可以传递数据<code>请求域内一般放本次请求业务有关的数据,如:查询到的所有的部门信息</code></li><li>同一个会话内,不用请求转发,会话域可以传递数据<code>会话域内一般放本次会话的客户端有关的数据,如:当前客户端登录的用户</code> </li><li>同一个APP内,不同的客户端,应用域可以传递数据<code>应用域内一般放本程序应用有关的数据 如:Spring框架的IOC容器</code></li></ul><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><blockquote><p>Filter,即过滤器,是JAVAEE技术规范之一,作用目标资源的请求进行过滤的一套技术规范,是Java Web项目中<code>最为实用的技术之一</code></p></blockquote><ul><li>Filter接口定义了过滤器的开发规范,所有的过滤器都要实现该接口</li><li>Filter的工作位置是项目中所有目标资源之前,容器在创建HttpServletRequest和HttpServletResponse对象后,会先调用Filter的doFilter方法</li><li>Filter的doFilter方法可以控制请求是否继续,如果放行,则请求继续,如果拒绝,则请求到此为止,由过滤器本身做出响应</li><li>Filter不仅可以对请求做出过滤,也可以在目标资源做出响应前,对响应再次进行处理</li><li>Filter是GOF中责任链模式的典型案例</li><li>Filter的常用应用包括但不限于: 登录权限检查,解决网站乱码,过滤敏感字符,日志记录,性能分析… …</li></ul><blockquote><p>过滤器开发中应用的场景</p></blockquote><ul><li>日志的记录</li><li>性能的分析</li><li>乱码的处理</li><li>事务的控制</li><li>登录的控制</li><li>跨域的处理</li></ul><blockquote><p>过滤器工作位置图解</p></blockquote><p><img src="D:\Blog\source\img\JavaWeb_Filter.png" alt="1682494494396"></p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><table><thead><tr><th>API</th><th>目标</th></tr></thead><tbody><tr><td>default public void init(FilterConfig filterConfig)</td><td>初始化方法,由容器调用并传入初始配置信息filterConfig对象</td></tr><tr><td>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</td><td>过滤方法,核心方法,过滤请求,决定是否放行,响应之前的其他处理等都在该方法中</td></tr><tr><td>default public void destroy()</td><td>销毁方法,容器在回收过滤器对象之前调用的方法</td></tr></tbody></table><h3 id="Filter使用实例"><a href="#Filter使用实例" class="headerlink" title="Filter使用实例"></a>Filter使用实例</h3><blockquote><p>目标:开发一个日志记录过滤器</p></blockquote><ul><li>用户请求到达目标资源之前,记录用户的请求资源路径</li><li>响应之前记录本次请求目标资源运算的耗时</li><li>可以选择将日志记录进入文件,为了方便测试,这里将日志直接在控制台打印</li></ul><blockquote><p> 定义一个过滤器类,编写功能代码</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span>  <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 参数父转子</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span>(HttpServletRequest)  servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span>  <span class="variable">response</span> <span class="operator">=</span>(HttpServletResponse)  servletResponse;</span><br><span class="line">        <span class="comment">// 拼接日志文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">beforeLogging</span> <span class="operator">=</span>requestURI+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;被请求了&quot;</span>;</span><br><span class="line">        System.out.println(beforeLogging);</span><br><span class="line">        <span class="comment">// 放行请求</span></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">        System.out.println(afterLogging);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>说明<ul><li>doFilter方法中的请求和响应对象是以父接口的形式声明的,实际传入的实参就是HttpServletRequest和HttpServletResponse子接口级别的,可以安全强转</li><li>filterChain.doFilter(request,response); 这行代码的功能是放行请求,如果没有这一行代码,则请求到此为止</li><li>filterChain.doFilter(request,response);在放行时需要传入request和response,意味着请求和响应对象要继续传递给后续的资源,这里没有产生新的request和response对象</li></ul></li></ul><blockquote><p>定义两个Servlet作为目标资源</p></blockquote><ul><li>ServletA</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 处理器请求</span></span><br><span class="line">        System.out.println(<span class="string">&quot;servletA处理请求的方法,耗时10毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟处理请求耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ServletB</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 处理器请求</span></span><br><span class="line">        System.out.println(<span class="string">&quot;servletB处理请求的方法,耗时15毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟处理请求耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">15</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>配置过滤器以及过滤器的过滤范围</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置filter,并为filter起别名--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.LoggingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为别名对应的filter配置要过滤的目标资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过映射路径确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletA<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过后缀名确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过servlet别名确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletBName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>说明</p><ul><li>filter-mapping标签中定义了过滤器对那些资源进行过滤</li><li>子标签url-pattern通过映射路径确定过滤范围<ul><li>&#x2F;servletA  精确匹配,表示对servletA资源的请求进行过滤</li><li>*.html 表示对以.action结尾的路径进行过滤</li><li>&#x2F;* 表示对所有资源进行过滤</li><li>一个filter-mapping下可以配置多个url-pattern</li></ul></li><li>子标签servlet-name通过servlet别名确定对那些servlet进行过滤<ul><li>使用该标签确定目标资源的前提是servlet已经起了别名</li><li>一个filter-mapping下可以定义多个servlet-name</li><li>一个filter-mapping下,servlet-name和url-pattern子标签可以同时存在</li></ul></li></ul></li></ul><h3 id="Filter生命周期"><a href="#Filter生命周期" class="headerlink" title="Filter生命周期"></a>Filter生命周期</h3><blockquote><p>过滤器作为web项目的组件之一,和Servlet的生命周期类似,略有不同,没有servlet的load-on-startup的配置,默认就是系统启动立刻构造</p></blockquote><table><thead><tr><th>阶段</th><th>对应方法</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>创建对象</td><td>构造器</td><td>web应用启动时</td><td>1</td></tr><tr><td>初始化方法</td><td>void init(FilterConfig filterConfig)</td><td>构造完毕</td><td>1</td></tr><tr><td>过滤请求</td><td>void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</td><td>每次请求</td><td>多次</td></tr><tr><td>销毁</td><td>default void destroy()</td><td>web应用关闭时</td><td>1次</td></tr></tbody></table><h3 id="Filter链"><a href="#Filter链" class="headerlink" title="Filter链"></a>Filter链</h3><blockquote><p>一个web项目中,可以同时定义多个过滤器,多个过滤器对同一个资源进行过滤时,工作位置有先后,整体形成一个工作链,称之为过滤器链</p></blockquote><ul><li>过滤器链中的过滤器的顺序由filter-mapping顺序决定</li><li>每个过滤器过滤的范围不同,针对同一个资源来说,过滤器链中的过滤器个数可能是不同的</li><li>如果某个Filter是使用ServletName进行匹配规则的配置，那么这个Filter执行的优先级要更低</li></ul><h4 id="注解方式配置过滤器-WebFilter"><a href="#注解方式配置过滤器-WebFilter" class="headerlink" title="注解方式配置过滤器@WebFilter"></a>注解方式配置过滤器@WebFilter</h4><ul><li>一个比较完整的Filter的XML配置</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置filter,并为filter起别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.LoggingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置filter的初始参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>dateTimePattern<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>yyyy-MM-dd HH:mm:ss<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--为别名对应的filter配置要过滤的目标资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过映射路径确定过滤资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletA<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过后缀名确定过滤资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过servlet别名确定过滤资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletBName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>将xml配置转换成注解方式实现</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(</span></span><br><span class="line"><span class="meta">        filterName = &quot;loggingFilter&quot;,</span></span><br><span class="line"><span class="meta">        initParams = &#123;@WebInitParam(name=&quot;dateTimePattern&quot;,value=&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;,</span></span><br><span class="line"><span class="meta">        urlPatterns = &#123;&quot;/servletA&quot;,&quot;*.html&quot;&#125;,</span></span><br><span class="line"><span class="meta">        servletNames = &#123;&quot;servletBName&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span>  <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SimpleDateFormat dateFormat ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*init初始化方法,通过filterConfig获取初始化参数</span></span><br><span class="line"><span class="comment">    * init方法中,可以用于定义一些其他初始化功能代码</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 获取初始参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dateTimePattern</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;dateTimePattern&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化成员变量</span></span><br><span class="line">        dateFormat=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(dateTimePattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 参数父转子</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span>(HttpServletRequest)  servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span>  <span class="variable">response</span> <span class="operator">=</span>(HttpServletResponse)  servletResponse;</span><br><span class="line">        <span class="comment">// 拼接日志文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">beforeLogging</span> <span class="operator">=</span>requestURI+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;被请求了&quot;</span>;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        System.out.println(beforeLogging);</span><br><span class="line">        <span class="comment">// 获取系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 放行请求</span></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">        <span class="comment">// 获取系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">afterLogging</span> <span class="operator">=</span>requestURI+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;的请求耗时:&quot;</span>+(t2-t1)+<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        System.out.println(afterLogging);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><blockquote><p>监听器：专门用于对域对象对象身上发生的事件或状态改变进行监听和相应处理的对象</p></blockquote><ul><li><p>监听器是GOF设计模式中,观察者模式的典型案例</p></li><li><p>观察者模式: 当被观察的对象发生某些改变时, 观察者自动采取对应的行动的一种设计模式</p></li><li><p>监听器使用的感受类似JS中的事件,被观察的对象发生某些情况时,自动触发代码的执行</p></li><li><p>监听器并不监听web项目中的所有组件,仅仅是对三大域对象做相关的事件监听</p></li></ul><blockquote><p>监听器的分类</p></blockquote><ul><li><p>web中定义八个监听器接口作为监听器的规范,这八个接口按照不同的标准可以形成不同的分类</p></li><li><p>按监听的对象划分</p><ul><li>application域监听器 ServletContextListener  ServletContextAttributeListener </li><li>session域监听器 HttpSessionListener  HttpSessionAttributeListener  HttpSessionBindingListener  HttpSessionActivationListener  </li><li>request域监听器 ServletRequestListener  ServletRequestAttributeListener</li></ul></li><li><p>按监听的事件分</p><ul><li>域对象的创建和销毁监听器 ServletContextListener   HttpSessionListener   ServletRequestListener  </li><li>域对象数据增删改事件监听器 ServletContextAttributeListener  HttpSessionAttributeListener   ServletRequestAttributeListener </li><li>其他监听器  HttpSessionBindingListener  HttpSessionActivationListener</li></ul></li></ul><h3 id="application域监听器"><a href="#application域监听器" class="headerlink" title="application域监听器"></a>application域监听器</h3><blockquote><p>ServletContextListener  监听ServletContext对象的创建与销毁</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>contextInitialized(ServletContextEvent sce)</td><td>ServletContext创建时调用</td></tr><tr><td>contextDestroyed(ServletContextEvent sce)</td><td>ServletContext销毁时调用</td></tr></tbody></table><ul><li>ServletContextEvent对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象。</li></ul><blockquote><p>ServletContextAttributeListener 监听ServletContext中属性的添加、移除和修改</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(ServletContextAttributeEvent scab)</td><td>向ServletContext中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletContextAttributeEvent scab)</td><td>从ServletContext中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletContextAttributeEvent scab)</td><td>当ServletContext中的属性被修改时调用</td></tr></tbody></table><ul><li>ServletContextAttributeEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletContext()</td><td>获取ServletContext对象</td></tr></tbody></table><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><ul><li>定义监听器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> , ServletContextAttributeListener &#123;</span><br><span class="line">    <span class="comment">// 监听初始化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        System.out.println(<span class="string">&quot;application&quot;</span>+application.hashCode()+<span class="string">&quot; initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听销毁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        System.out.println(<span class="string">&quot;application&quot;</span>+application.hashCode()+<span class="string">&quot; destroyed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听数据增加</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scae.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> scae.getValue();</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        System.out.println(<span class="string">&quot;application&quot;</span>+application.hashCode()+<span class="string">&quot; add:&quot;</span>+name+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听数据移除</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scae.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> scae.getValue();</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        System.out.println(<span class="string">&quot;application&quot;</span>+application.hashCode()+<span class="string">&quot; remove:&quot;</span>+name+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听数据修改</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scae.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> scae.getValue();</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">newValue</span> <span class="operator">=</span> application.getAttribute(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;application&quot;</span>+application.hashCode()+<span class="string">&quot; change:&quot;</span>+name+<span class="string">&quot;=&quot;</span>+value+<span class="string">&quot; to &quot;</span>+newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义触发监听器的代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ServletA用于向application域中放入数据</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 向application域中放入数据</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        application.setAttribute(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>);</span><br><span class="line">        application.setAttribute(<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;v2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServletB用于向application域中修改和移除数据</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">appliation</span>  <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="comment">//  修改application域中的数据</span></span><br><span class="line">        appliation.setAttribute(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        <span class="comment">//  删除application域中的数据</span></span><br><span class="line">        appliation.removeAttribute(<span class="string">&quot;k2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="session域监听器"><a href="#session域监听器" class="headerlink" title="session域监听器"></a>session域监听器</h3><blockquote><p>HttpSessionListener  监听HttpSession对象的创建与销毁</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>sessionCreated(HttpSessionEvent hse)</td><td>HttpSession对象创建时调用</td></tr><tr><td>sessionDestroyed(HttpSessionEvent hse)</td><td>HttpSession对象销毁时调用</td></tr></tbody></table><ul><li>HttpSessionEvent对象代表从HttpSession对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpSession对象。</li></ul><blockquote><p>HttpSessionAttributeListener 监听HttpSession中属性的添加、移除和修改</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(HttpSessionBindingEvent se)</td><td>向HttpSession中添加属性时调用</td></tr><tr><td>attributeRemoved(HttpSessionBindingEvent se)</td><td>从HttpSession中移除属性时调用</td></tr><tr><td>attributeReplaced(HttpSessionBindingEvent se)</td><td>当HttpSession中的属性被修改时调用</td></tr></tbody></table><ul><li>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getSession()</td><td>获取触发事件的HttpSession对象</td></tr></tbody></table><h3 id="request域监听器"><a href="#request域监听器" class="headerlink" title="request域监听器"></a>request域监听器</h3><blockquote><p>ServletRequestListener 监听ServletRequest对象的创建与销毁</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>requestInitialized(ServletRequestEvent sre)</td><td>ServletRequest对象创建时调用</td></tr><tr><td>requestDestroyed(ServletRequestEvent sre)</td><td>ServletRequest对象销毁时调用</td></tr></tbody></table><ul><li>ServletRequestEvent对象代表从HttpServletRequest对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpServletRequest对象。另外还有一个方法可以获取到当前Web应用的ServletContext对象。</li></ul><blockquote><p>ServletRequestAttributeListener 监听ServletRequest中属性的添加、移除和修改</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(ServletRequestAttributeEvent srae)</td><td>向ServletRequest中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletRequestAttributeEvent srae)</td><td>从ServletRequest中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletRequestAttributeEvent srae)</td><td>当ServletRequest中的属性被修改时调用</td></tr></tbody></table><ul><li>ServletRequestAttributeEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletRequest ()</td><td>获取触发事件的ServletRequest对象</td></tr></tbody></table><h3 id="sessionBinding监听器"><a href="#sessionBinding监听器" class="headerlink" title="sessionBinding监听器"></a>sessionBinding监听器</h3><blockquote><p>HttpSessionBindingListener 监听当前监听器对象在Session域中的增加与移除</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>valueBound(HttpSessionBindingEvent event)</td><td>该类的实例被放到Session域中时调用</td></tr><tr><td>valueUnbound(HttpSessionBindingEvent event)</td><td>该类的实例从Session中移除时调用</td></tr></tbody></table><ul><li>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取当前事件涉及的属性名</td></tr><tr><td>getValue()</td><td>获取当前事件涉及的属性值</td></tr><tr><td>getSession()</td><td>获取触发事件的HttpSession对象</td></tr></tbody></table><h3 id="钝化活化监听器"><a href="#钝化活化监听器" class="headerlink" title="钝化活化监听器"></a>钝化活化监听器</h3><blockquote><p>HttpSessionActivationListener  监听某个对象在Session中的序列化与反序列化。</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>sessionWillPassivate(HttpSessionEvent se)</td><td>该类实例和Session一起钝化到硬盘时调用</td></tr><tr><td>sessionDidActivate(HttpSessionEvent se)</td><td>该类实例和Session一起活化到内存时调用</td></tr></tbody></table><ul><li>HttpSessionEvent对象代表事件对象，通过getSession()方法获取事件涉及的HttpSession对象。</li></ul><blockquote><p>什么是钝化活化</p></blockquote><ul><li>session对象在服务端是以对象的形式存储于内存的,session过多,服务器的内存也是吃不消的</li><li>而且一旦服务器发生重启,所有的session对象都将被清除,也就意味着session中存储的不同客户端的登录状态丢失</li><li>为了分摊内存 压力并且为了保证session重启不丢失,我们可以设置将session进行钝化处理</li><li>在关闭服务器前或者到达了设定时间时,对session进行序列化到磁盘,这种情况叫做session的钝化</li><li>在服务器启动后或者再次获取某个session时,将磁盘上的session进行反序列化到内存,这种情况叫做session的活化</li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ul><li><p>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p></li><li><p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p></li><li><p>AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p></li><li><p>AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。</p></li><li><p>XMLHttpRequest 只是实现 Ajax 的一种方式。</p></li></ul><h3 id="ajax工作原理"><a href="#ajax工作原理" class="headerlink" title="ajax工作原理"></a>ajax工作原理</h3><p><img src="D:\Blog\source\img\JavaWeb_ajax.png"></p><ul><li>简单来说,我们之前发的请求通过类似  form表单标签,a标签 这种方式,现在通过 运行js代码动态决定什么时候发送什么样的请求</li><li>通过运行JS代码发送的请求浏览器可以不用跳转页面 ,我们可以在JS代码中决定是否要跳转页面</li><li>通过运行JS代码发送的请求,接收到返回结果后,我们可以将结果通过dom编程渲染到页面的某些元素上,实现局部更新</li></ul><h3 id="原生js方式实现ajax"><a href="#原生js方式实现ajax" class="headerlink" title="原生js方式实现ajax"></a>原生js方式实现ajax</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">loadXMLDoc</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 设置回调函数处理响应结果</span></span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (xmlhttp.<span class="property">readyState</span>==<span class="number">4</span> &amp;&amp; xmlhttp.<span class="property">status</span>==<span class="number">200</span>)</span></span><br><span class="line"><span class="language-javascript">      &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="property">innerHTML</span>=xmlhttp.<span class="property">responseText</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 设置请求方式和请求的资源路径</span></span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/ajax_info.txt&quot;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 发送请求</span></span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java命名规范</title>
      <link href="/inori/1761bce2.html"/>
      <url>/inori/1761bce2.html</url>
      
        <content type="html"><![CDATA[<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol><li>由字母、下划线、美元符号和数字组成，长度不限</li><li>首字符不能是数字</li><li>不能是关键字</li><li>不能是true、false和null，尽管这三个不是关键字</li><li>区分大小写</li></ol><h2 id="变量名（驼峰命名法）"><a href="#变量名（驼峰命名法）" class="headerlink" title="变量名（驼峰命名法）"></a>变量名（驼峰命名法）</h2><p>​    变量的名字可大小写混用，但首字符应小写。词由大写字母分隔，限制用下划线，限制使用美元符（$），因为这个字符对内部类有特殊的含义。</p><p>​    如：inputTextSize。</p><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p>​    包的名字应该都是由一个小写单词组成。</p><p>​    如：net.test.modules。</p><h2 id="类名和接口名"><a href="#类名和接口名" class="headerlink" title="类名和接口名"></a>类名和接口名</h2><p>​    类名每个单词的首字母都要大写，通常由多个单词合成一个类名。</p><p>​    如：DataFile、InfoParser。</p><h2 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h2><p>​    常量命名则前面应该是static final，后面变量的名字全部大写。</p><p>​    如：static final MAX &#x3D; 1024。</p><h2 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h2><p>​    方法名的第一个单词应该是动词，但首字母小写，后面每个单词的首字母大写。大写字母将词分隔并限制使用下划线。方法如果有传入参数，参数的名字必须和变量的命名规范一致。使用有意义的参数命名，如果可能的话，使用和要赋值的字段一样的名字。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC和连接池</title>
      <link href="/inori/78c36787.html"/>
      <url>/inori/78c36787.html</url>
      
        <content type="html"><![CDATA[<p>​JDBC是为访问不同数据库提供的统一接口，为使用者屏蔽了细节问题。可以利用JDBC连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。</p><h2 id="数据库连接方式"><a href="#数据库连接方式" class="headerlink" title="数据库连接方式"></a>数据库连接方式</h2><p>连接数据库主要有2种方式</p><ol><li>使用Class.forName自动完成注册驱动，直接连接数据库：</li></ol><blockquote><p>Class.forName(“com.mysql.cj.jdbc.Driver”);</p><p>Connection connection &#x3D; DriverManager.getConnection(url, user, password);&#x2F;&#x2F;其中的参数最好在使用时从文件中提取出来，方便修改</p></blockquote><ol start="2"><li>jdk1.5以后使用了jdbc4，不再需要显示调用Class.forName注册驱动，可以直接使用语句<code>Connection connection = DriverManager.getConnection(url, info);</code>连接数据库</li></ol><h2 id="在Java中输入SQL语句"><a href="#在Java中输入SQL语句" class="headerlink" title="在Java中输入SQL语句"></a>在Java中输入SQL语句</h2><p>在连接建立后，如果需要对数据库进行访问，执行命名或者SQL语句，可以通过Statement、<u>PreparedStatement</u>、CallableStatement，在开发中不会使用Statement，因为其存在SQL注入问题，一般使用PerparedStatement：</p><ul><li>PreparedStatement：执行的SQL语句中的参数用问号(?)来表示，调用相应的set方法来设置对应的参数。set方法有两个参数，第一个参数要设置SQL语句中的?的参数索引（从1开始），第二个是设置SQL语句中参数的值</li></ul><p>在使用DML语句时，直接使用String即可，在使用DQL语句时需要借助ResultSet获取结果：</p><ul><li>ResultSet：保持一个光标指向其当前的数据行。最初光标位于第一行之前。next方法可以将光标移动到下一行，并且在ResultSet对象中没有更多行时返回false，所以可以用while循环遍历结果集。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>使用localhost的test数据库，登录root用户完成对emp表的增删改查。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">// 从Properties文件中获取数据</span></span><br><span class="line">        info.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;driver&quot;</span>);     <span class="comment">// com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;url&quot;</span>);           <span class="comment">// jdbc:mysql://localhost/test</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        <span class="type">String</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="string">&quot;insert into emp values(null, &#x27;小明&#x27;, 18)&quot;</span>;<span class="comment">// 增</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">update</span> <span class="operator">=</span> <span class="string">&quot;update emp set name=&#x27;小红&#x27; where id = 1&quot;</span>;<span class="comment">// 改</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">select</span> <span class="operator">=</span> <span class="string">&quot;select id from emp where name=?&quot;</span>;<span class="comment">// 查</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">drop</span> <span class="operator">=</span> <span class="string">&quot;delete from emp where id = 1&quot;</span>;<span class="comment">// 删</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);<span class="comment">// 连接数据库</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(select);</span><br><span class="line">        preparedStatement.executeUpdate(insert);</span><br><span class="line">        preparedStatement.executeUpdate(update);</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>);<span class="comment">// 设置第一个问号处填写的值</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();<span class="comment">// 使用ResultSet获取select的返回结果</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">        preparedStatement.executeUpdate(drop);</span><br><span class="line">        preparedStatement.close();<span class="comment">// 关闭连接</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDBC处理事务"><a href="#JDBC处理事务" class="headerlink" title="JDBC处理事务"></a>JDBC处理事务</h3><p>使用<code>Connection connection = DriverManager.getConnection(url, user, password);</code>得到数据库连接之后，可以<code>connection.setAutoCommit(false)</code>设置事务不自动提交，然后在正常结束的逻辑后面使用<code>connection.commit()</code>提交事务，如果发生了异常，使用<code>connection.rollback()</code>回滚事务</p><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。使用批处理功能时需要在url后面加入参数<code>?rewriteBatchedStatements=true</code>。批处理往往和PreparedStatement一起使用。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>addBatch():添加需要批量处理的SQL语句或参数</p></li><li><p>executeBatch():执行批量处理语句</p></li><li><p>clearBatch():清空批处理的语句</p></li></ul><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><h3 id="传统连接的问题"><a href="#传统连接的问题" class="headerlink" title="传统连接的问题"></a>传统连接的问题</h3><ul><li>传统的JDBC数据库连接使用DriverManager获取，每次向数据库建立连接时都要将Connection加载到内存中，再验证IP地址，用户名和密码。频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃</li><li>每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致数据库重启</li><li>传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，数据库崩溃。</li><li>解决传统开发中的数据库连接问题,可以采用数据库连接池技术</li></ul><h3 id="连接池原理"><a href="#连接池原理" class="headerlink" title="连接池原理"></a>连接池原理</h3><ol><li>预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从中取出一个，使用完毕之后再放回去</li><li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</li><li>当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中</li></ol><h3 id="连接池种类"><a href="#连接池种类" class="headerlink" title="连接池种类"></a>连接池种类</h3><ol><li>JDBC的数据库连接池使用javax.sql.DataSource表示，DataSource是一个接口，通常由第三方提供实现</li><li><u>C3P0</u>连接池，速度相对较慢，稳定性强(hibernate, spring底层使用该连接池)</li><li>DBCP连接池，速度较快，不稳定</li><li>Proxool数据库连接池，可以监控连接池状态，稳定性较差</li><li>BoneCP数据库连接池，速度快</li><li><u>Druid</u>(德鲁伊)是阿里提供的连接池，集DBCP、C3PO、Proxool优点于一身的数据库连接池</li></ol><h3 id="C3P0连接池"><a href="#C3P0连接池" class="headerlink" title="C3P0连接池"></a>C3P0连接池</h3><p>要使用C3P0连接池，首先要导入C3P0的jar包，并且把jar包当做library加入到项目中</p><p>使用时：</p><ol><li>实例化<code>ComboPooledDataSource</code>数据源对象</li><li>通过配置文件获取数据库相关信息</li><li>通过方法给数据源设置相关参数<code>setDriverClass</code>、<code>setJdbcUrl</code>、<code>setUser</code>、<code>setPassword</code></li><li>设置初始化连接数（连接池中一开始的连接数量）和最大连接数（最多能有多少连接）：<code>setInitialPoolSize(n)</code>、<code>setMaxPoolSize(n)</code></li><li>拿到连接：<code>Connection connection = comboPooledDataSource.getConnection()</code></li></ol><h3 id="Druid连接池"><a href="#Druid连接池" class="headerlink" title="Druid连接池"></a>Druid连接池</h3><ol><li>首先配置Properties文件，在文件中写明driver、url、user、password、initialSize、minIdle、maxActive、maxWait参数</li><li>创建指定参数的数据库连接池<code>DataSource ds = DruidDataSourceFactory.createDataSource(properties)</code></li><li>拿到连接：<code>Connection connection = ds.getConnection()</code></li></ol><h2 id="ApDBUtils"><a href="#ApDBUtils" class="headerlink" title="ApDBUtils"></a>ApDBUtils</h2><p>commons-dbutils是一个JDBC工具类库，可以极大简化jdbc编码的工作量。</p><h3 id="DbUtils类"><a href="#DbUtils类" class="headerlink" title="DbUtils类"></a>DbUtils类</h3><ul><li>QueryRunner类：封装了SQL的执行，可以实现增删改查和批处理操作，线程安全</li><li>ResultSetHandler：用于出来ResultSet，按照数据要求转换成另一种形式<ul><li>BeanHandler:将结果集中的第一行数据封装到一个对应的JavaBean实例中</li><li>BeanListHandler:将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里</li><li>ScalarHandler:查询单行单列信息时，将该信息包装成一个Object对象返回</li><li>update:执行增删改操作，返回受影响的行数</li></ul></li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>首先导入commons-dbutils.jar包，然后才能使用其提供的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        data.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));<span class="comment">// 从文件中读取driver、url、user、password</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(data);<span class="comment">// 创建德鲁伊数据源对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ds.getConnection();·<span class="comment">// 获取连接</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">select</span> <span class="operator">=</span> <span class="string">&quot;select * from emp where id &gt;= ?&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">update</span> <span class="operator">=</span> <span class="string">&quot;update emp set name = ? where id = ?&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="string">&quot;insert into emp values(null, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">update</span> <span class="operator">=</span> <span class="string">&quot;delete from emp where id = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// query执行sql语句，得到resultset并封装到ArrayList中，需要传入connection、sql语句、BeanListHandler对象, 最后的数字是给?赋值，可以有多个</span></span><br><span class="line">        List&lt;Actor&gt; list = queryRunner.query(connection, select, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(Actor.class), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 执行DML语句使用update方法，传入连接，sql和需要赋值的?</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> queryRunner.update(connection, update, <span class="string">&quot;小明&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        rows = queryRunner.update(connection, insert, <span class="string">&quot;小白&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        rows = queryRunner.update(connection, drop, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(Actor a: list)&#123;</span><br><span class="line">            System.out.println(a.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();<span class="comment">// 只需要关闭connection，resultset和perparedStatement由queryRunner自动关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL进阶篇</title>
      <link href="/inori/f4c950eb.html"/>
      <url>/inori/f4c950eb.html</url>
      
        <content type="html"><![CDATA[<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，也可以被成为表类型。</p><ul><li>创建表时可以指定存储引擎，在CREATE TABLE语句后面添加<code>ENGINE=存储引擎名</code></li><li>查询数据库支持的存储引擎：<code>SHOW ENGINES;</code></li></ul><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="D:\Blog\source\img\mysqlStruct.png" alt="mysqlStruct"></p><p>MySQL的服务端是分层实现的：</p><ol><li>连接层：接收客户端连接，完成安全处理，授权和校验权限等操作</li><li>服务层：核心部分，实现SQL接口，解析器，查询优化器，缓存等，所有跨存储引擎的功能也在这一层实现，如过程，函数等</li><li>引擎层：存储引擎负责MySQL中数据的存储和提取的方式，服务器通过API和存储引擎通信。不同的存储引擎有不同的功能</li><li>存储层：存储数据库数据</li></ol><h2 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，MySQL5.5之后默认的存储引擎为InnoDB</p><p>特点：</p><ul><li>DML操作遵循ACID模型，支持事务</li><li>行级锁，提高并发访问性能</li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性</li></ul><p>文件：xxx.ibd，xxx表示表名，InnoDB每张表都会对应这样一个表空间文件，存储表结构（frm，sdi）、数据和索引。</p><h4 id="InnoDB的逻辑存储结构"><a href="#InnoDB的逻辑存储结构" class="headerlink" title="InnoDB的逻辑存储结构"></a>InnoDB的逻辑存储结构</h4><p><img src="D:\Blog\source\img\mysql_innodb.png" alt="mysql_innodb"></p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MySQL早期的默认存储引擎</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：xxx.MYD、xxx.MYI、xxx.sdi。sdi文件存储表结构信息，MYD文件存放数据，MYI文件存储索引</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>表数据存储在内存中，可能会受到硬件问题或断电问题影响，只能将这些表作为临时表或者缓存使用</p><p>特点：</p><ul><li>存放在内存中，访问速度更快</li><li>支持hash索引</li></ul><p>文件：xxx.sdi。存储表结构信息</p><h3 id="三个存储引擎特点对比"><a href="#三个存储引擎特点对比" class="headerlink" title="三个存储引擎特点对比"></a>三个存储引擎特点对比</h3><p><img src="D:\Blog\source\img\mysql_engineSpecial.png" alt="mysql_engineSpecial"></p><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><ul><li><u>InnoDB</u>：适合对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询外还包括更新、删除操作的场景</li><li>MyISAM：适合以读和插入操作为主，对事务的完整性、并发性要求不高的场景，可以被MongoDB替代</li><li>MEMORY：通常作为临时表和缓存，可以被Redis替代</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>​索引是帮助MySQL高效获取数据的<u>有序</u>数据结构。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p>​索引可以提高数据检索的效率，降低数据库的IO成本，并且通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。带来好处的同时，索引降低了更新表的速度，对表进行增删改时效率降低，但是在正常业务中，增删改的频率要远小于查询，基本可以忽略这个缺点。</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：</p><table><thead><tr><th align="center">索引结构</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">B+ Tree</td><td align="center">最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td align="center">Hash</td><td align="center">使用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询。Memory支持该索引</td></tr><tr><td align="center">R-tree空间索引</td><td align="center">主要用于地理空间数据类型，使用较少，MyISAM的特殊索引类型</td></tr><tr><td align="center">Full-text全文索引</td><td align="center">通过建立倒排索引，快速匹配文档的方式，类似于Lucene，Solr，ES。InnoDB和MyISAM支持该索引。</td></tr></tbody></table><p>平常说的索引一般都是B+ Tree索引</p><h4 id="为什么InnoDB存储引擎选择使用B-tree索引"><a href="#为什么InnoDB存储引擎选择使用B-tree索引" class="headerlink" title="为什么InnoDB存储引擎选择使用B+tree索引"></a>为什么InnoDB存储引擎选择使用B+tree索引</h4><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>相对于B Tree，无论是叶子节点还是非叶子节点，都会保存数据，这会导致一页中存储的键值和指针减少，进而导致树的层级变深，性能降低</li><li>相对于Hash索引，B+ Tree支持范围匹配和排序</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><img src="D:\Blog\source\img\mysql_indexType.png" alt="mysql_indexType"></p><p>在InnoDB中，根据索引的存储形式，又可以分为<u>聚集索引</u>和<u>二级索引</u>：</p><p><img src="D:\Blog\source\img\mysql_InnoDBIndexType.png" alt="mysql_InnoDBIndexType"></p><p>在进行查找时，如果查找的不是主键，则需要先在二级索引找到对应的主键，再去聚集索引找到全部信息，这叫做回表查询。</p><h3 id="索引的语法"><a href="#索引的语法" class="headerlink" title="索引的语法"></a>索引的语法</h3><ul><li>创建索引：<code>CREATE [UNIUQE|FULLTEXT] INDEX 索引名 ON 表名(字段列表);</code></li><li>查看索引：<code>SHOW INDEX FROM 表名;</code></li><li>删除索引：<code>DROP INDEX 索引名 ON 表名;</code></li></ul><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><ul><li><p>SQL执行频率：MySQL客户端连接成功后，通过<code>show[session|global] status</code>命令可以提供服务器状态信息。</p><p>如：<code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code>查看数据库增删改查的使用频率</p></li><li><p>慢查询日志：记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>默认是关闭状态，可以通过sql语句<code>set global slow_query_log=ON;</code>和<code>set long_query_time=x;</code>打开慢查询日志记录和设置慢查询门槛时间</p></li><li><p>profile详情：<code>show profiles</code>能够在做SQL优化时帮助我们了解各种操作耗费时间的详情。</p><p>默认profile是关闭状态，通过<code>set global profiling=1;</code>打开。</p><ul><li>查看每一条SQL语句的耗时情况：<code>show profiles;</code></li><li>查看指定query_id的SQL语句各个阶段的耗时情况：<code>show profile for query query_id;</code></li><li>查看指定query_id的SQL语句CPU使用情况：<code>show prifile cpu for query query_id;</code></li></ul></li><li><p>explain执行计划：可以使用explain或者desc命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。语法为EXPLAIN&#x2F;DESC + SELECT语句。</p><p>explain各字段的含义：</p><ul><li>id：表示查询中执行select子句或者是操作表的顺序（id号大的先执行，id相同，执行顺序从上到下）</li><li>select_type：表示select的类型，常见的取值有simple（简单表，不使用表连接和子查询）、primary（主查询）、union（union后面的查询语句）、subquery（子查询语句）</li><li><u>type</u>：表示连接类型，性能由好到差的连接类型为：NULL、system、const、eq_ref、ref、range、index、all</li><li><u>possible_key</u>：显示可能应用在这张表上的索引</li><li><u>key</u>：实际用到的索引</li><li><u>key_len</u>：索引中使用的字节数，索引字段最大可能长度</li><li>rows：MySQL认为必须要执行查询的行数，估计值</li><li>filtered：表示返回结果的行数占续读取行数的百分比，值越大越好</li></ul></li></ul><h3 id="索引使用注意事项"><a href="#索引使用注意事项" class="headerlink" title="索引使用注意事项"></a>索引使用注意事项</h3><ul><li><p>遵守最左前缀法则：如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是**<u>在查询时</u>**select语句必须要从建立索引的最左列开始，并且不跳过索引中的列。如果跳过某一列，后面字段的索引将失效。</p></li><li><p>避免范围查询：在联合索引中，如果出现了范围查询（&gt;、&lt;），范围查询右侧的列索引失效。但是如果使用(&gt;&#x3D;,&lt;&#x3D;)则不会失效，所以在查询时尽量使用&gt;&#x3D;和&lt;&#x3D;。</p></li><li><p>避免索引列运算：在索引列上进行运算操作，索引会失效</p></li><li><p>字符串加引号：如果查询时字符串不加单引号，索引失效</p></li><li><p>避免头部模糊匹配：使用模糊匹配时，使用尾部模糊匹配，索引不会失效，使用头部模糊匹配时，索引失效</p></li><li><p>or连接：用or关键字分割开的条件，只要有一个条件没有建立索引，所有条件的索引都会失效</p></li><li><p>数据分布影响：如果MySQL评估使用索引比全表扫描还慢，则不使用索引</p></li><li><p>SQL提示：优化数据库的一个重要手段，在SQL语句中加入一些人为的提示信息来达到优化操作的目的</p><ul><li>use index(建议使用):<code>EXPLAIN SELECT 字段名 FROM 表名 USE INDEX(索引名) WHERE 条件;</code></li><li>ignore index(不要使用):<code>EXPLAIN SELECT 字段名 FROM 表名 IGNORE INDEX(索引名) WHERE 条件;</code></li><li>force index(强制使用):<code>EXPLAIN SELECT 字段名 FROM 表名 FORCE INDEX(索引名) WHERE 条件;</code></li></ul></li><li><p>尽量使用覆盖索引（需要查找的字段只需要一次索引就能找全，不需要回表），避免select *</p></li><li><p>前缀索引：当字段类型为字符串时，有时需要索引很长的字符串，可以直将字符串的一部分前缀建立索引，达到节约索引空间，提高效率的效果。</p><p>语法：<code>CREATE INDEX 索引名 ON 表名(字段名(n))</code>其中n是想要建立索引的字段前缀长度</p><p>长度选择：可以通过<code>SELECT COUNT(distinct substring(字段名,1,n))/COUNT(*) FROM 表名;</code>来计算索引性，选择合适的长度，越接近1越好</p></li><li><p>联合索引：如果存在多个查询条件，针对查询字段建立联合索引可以做到覆盖查询，提高效率。建立联合索引时要注意字段位置</p></li></ul><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ol><li>数据量较大（大于一百万），且查询比较频繁的表</li><li>针对于常作为查询条件(where)、排序（order by)、分组(group by)操作的字段建立索引</li><li>选择区分度高的列作为索引，建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段的长度较长，可以针对字段建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，只建立有必要的索引，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，需要在创建表时使用NOT NULL约束。这样优化器知道每列是否包含NULL值，可以更好地确定哪个索引更有效</li></ol><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><ol><li>如果需要一次性插入多条数据，可以从三方面进行优化<ul><li>使用批量插入语句：<code>Insert into test values(1,&#39;name1&#39;),(2,&#39;name2&#39;),(3,&#39;name3&#39;); </code></li><li>手动控制事务，全部插入后再关闭事务</li><li>主键顺序插入</li></ul></li><li>如果要大批量插入数据（几百万条），可以使用<code>load</code>指令进行插入</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 客户端连接服务端加上参数 -–local-infile</span></span><br><span class="line">mysql –<span class="operator">-</span><span class="keyword">local</span><span class="operator">-</span>infile <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"><span class="comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 执行load指令将准备好的数据，加载到表结构中</span></span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields</span><br><span class="line">terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> ;</span><br></pre></td></tr></table></figure><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>主键顺序插入的性能要高于乱序插入，因为在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table，IOT)。</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><p>MySQL的排序，有两种方式：</p><ul><li><code>Using filesort</code>: 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</li><li><code>Using index</code>: 通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。</li></ul><p>对于以上的两种排序方式，<code>Using index</code>的性能高，在优化排序操作时，尽量要优化为<code>Using index</code></p><h4 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h4><ol><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)</li></ol><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>优化思路: 一般分页查询时，通过创建<strong>覆盖索引</strong>能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>当update语句的<code>where</code>条件存在索引时，会使用行锁，锁定这一行的数据，但是当<code>where</code>条件没有索引时，会使用表锁锁住整张表，阻止其他的DML请求，降低效率。</p><p>所以update中的<code>where</code>条件尽量选择有索引的列</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除对传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><p>MySQL中的锁，按照锁的粒度分，分为三类：</p><ul><li>全局锁：粒度最大，锁定数据库中的所有表</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：粒度最小，每次操作锁住对应的行数据</li></ul><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个数据库就处于只读状态，后续的DML的写语句，DDL语句，以及更新操作的事务提交语句都将被阻塞</p><p>典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>加全局锁</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure><ul><li>数据备份</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot –p1234 test <span class="operator">&gt;</span> test.sql</span><br></pre></td></tr></table></figure><ul><li>释放锁</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p></li></ul><p>在InnoDB引擎中，可以在备份时加上参数<code>--single-transaction</code>参数来完成不加锁的一致性数据备份。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -uroot –p123456 test &gt; test.sql</span></span><br></pre></td></tr></table></figure><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li><p>表锁</p></li><li><p>元数据锁（meta data lock，MDL）</p></li><li><p>意向锁</p></li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁分为两类：</p><ul><li>表共享读锁（read lock）：对指定表加读锁后，不会影响其他客户端的读，但是会阻塞其他客户端的写</li><li>表共享写锁（write lock）：对指定表加写锁后，会阻塞其他客户端的读和写</li></ul><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p>加锁：lock tables 表名… read&#x2F;write</p><p>释放锁：unlock tables &#x2F; 客户端断开连接</p><h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>元数据锁(meta data lock，MDL)的加锁过程是系统自动控制的，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DM与DDL冲突，保证读写的正确性</p><p>这里的元数据，可以简单理解为就是一张表的表结构。也就是说，某一张表涉及到未提交的事务时，不能修改这张表的表结构</p><p>当对一张表进行增删改查的时候，加MDL读锁(共享)，当对表结构进行变更操作的时候，加MDL写锁(排他)</p><h4 id="常见操作中添加的元数据锁"><a href="#常见操作中添加的元数据锁" class="headerlink" title="常见操作中添加的元数据锁"></a>常见操作中添加的元数据锁</h4><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read&#x2F;write</td><td>SHARED_READ_ONLY &#x2F; SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select 、select … lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>insert 、update、delete、select … for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</p><p>当一个客户端在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁，其他客户端，在对这张表加表锁时，会根据该表上所加的意向锁来判定是否可以成功加表锁，无需逐行判断行锁情况</p><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>意向共享锁(IS): 由语句select … lock in share mode添加。与表锁共享锁(read)兼容，与表锁排他锁(write)互斥</p><p>意向排他锁(IX): 由insert、update、delete、select…for update添加。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥</p><p><u>事务提交后，意向共享锁、意向排他锁，都会自动释放</u></p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁每次操作锁住对应的行数据。粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ul><li><p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在读已提交（READ UNCOMMITTED，RC）、可重复读（REPEATABLE READ，RR）隔离级别下支持。</p></li><li><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下支持。</p></li><li><p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p></li></ul><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</li></ul><p>其中共享锁之与共享锁兼容，排他锁与其他锁都互斥</p><h5 id="常见操作中添加的行锁"><a href="#常见操作中添加的行锁" class="headerlink" title="常见操作中添加的行锁"></a>常见操作中添加的行锁</h5><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何锁</td><td></td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p>默认情况下，InnoDB在RR事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁</li></ul><p>查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h4 id="间隙锁和临键锁"><a href="#间隙锁和临键锁" class="headerlink" title="间隙锁和临键锁"></a>间隙锁和临键锁</h4><p>产生条件：</p><ul><li><p>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁</p></li><li><p>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁</p></li><li><p>索引上的范围查询(唯一索引)，会访问到不满足条件的第一个值为止</p><p>比如查询一张表上<code>id &gt;= 20</code>的数据，并添加共享锁，此时会根据数据库表中现有的数据，将数据分为三个部分：<code>[20]</code>、<code>(20, 表中已有的id最大值)</code>、<code>(id最大值,+∞)</code>，数据库在加锁时会在20加行锁，id最大值的临键锁（包含最大值及最大值之前的间隙），正无穷的临键锁(正无穷及之前的间隙)</p></li></ul><h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p>InnoDB的逻辑存储结构分为表空间、段、区、页、行。</p><p><img src="D:\Blog\source\img\innodb_composition.jpg" alt="innodb_composition"></p><ol><li><p>表空间：表空间是InnoDB存储引擎逻辑结构的最高层，如果用户启用了参数<code>innodb_file_per_table</code>(在8.0版本中默认开启)，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据</p></li><li><p>段：分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）</p></li><li><p>区：区是表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页</p></li><li><p>页：页是InnoDB磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请4-5个区</p></li><li><p>行：InnoDB数据是按行进行存放的。在行中，默认有两个隐藏字段：</p></li></ol><ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，使用广泛。在InnoDB架构图中，左侧为内存结构，右侧为磁盘结构</p><img src="D:\Blog\source\img\innodb_frame.jpg" alt="innodb_frame" style="zoom:80%;" /><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><p>内存结构部分主要有：Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer</p><h5 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h5><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I&#x2F;O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>Buffer Pool是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><p>• free page：空闲page，未被使用</p><p>• clean page：被使用page，数据没有被修改过</p><p>• dirty page：脏页，被使用page，数据被修改过，数据与磁盘的数据不一致，</p><p>参数查看：<code>show variables like &#39;innodb_buffer_pool_size&#39;;</code></p><h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>Change Buffer，更改缓冲区（针对于非唯一的二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>非唯一的二级索引页是以相对随机的顺序插入二级索引，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有ChangeBuffer之后，可以在缓冲池中进行合并处理，减少磁盘IO</p><h5 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a>Adaptive Hash Index</h5><p>自适应hash索引用于优化对Buffer Pool数据的查询。InnoDB中虽然没有直接支持hash索引，但是提供了自适应hash索引。</p><p>hash索引在进行等值匹配时，一般性能要高于B+树，因为hash索引一般只需要一次IO，B+树可能需要几次匹配。但是hash索引又不适合做范围查询、模糊匹配等操作。</p><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p><p><strong>自适应哈希索引，无需人工干预，系统根据情况自动完成</strong></p><p>参数：<code>adaptive_hash_index</code></p><h5 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h5><p>日志缓冲区用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O</p><p>参数:</p><ul><li><code>innodb_log_buffer_size</code>：缓冲区大小</li><li><code>innodb_flush_log_at_trx_commit</code>：日志刷新到磁盘时机，取值主要包含：<ul><li>日志在每次事务提交时写入并刷新到磁盘，默认值</li><li>每秒将日志写入并刷新到磁盘一次</li><li>日志在每次事务提交后写入，并每秒刷新到磁盘一次</li></ul></li></ul><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><h5 id="System-Tablespace"><a href="#System-Tablespace" class="headerlink" title="System Tablespace"></a>System Tablespace</h5><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等）</p><p>参数：<code>innodb_data_file_path</code></p><h5 id="File-Per-Table-Tablespaces"><a href="#File-Per-Table-Tablespaces" class="headerlink" title="File-Per-Table Tablespaces"></a>File-Per-Table Tablespaces</h5><p>每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中，也就是说，每创建一个表，都会产生一个表空间文件</p><p>开关参数：<code>innodb_file_per_table</code>，默认开启</p><h5 id="General-Tablespaces"><a href="#General-Tablespaces" class="headerlink" title="General Tablespaces"></a>General Tablespaces</h5><p>通用表空间，在创建表时，可以指定该表空间</p><ul><li>创建表空间</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE ts_name <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;file_name&#x27;</span> ENGINE <span class="operator">=</span> engine_name;</span><br></pre></td></tr></table></figure><ul><li>创建表空间时制定表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> xxx ... TABLESPACE ts_name;</span><br></pre></td></tr></table></figure><h5 id="Undo-Tablespaces"><a href="#Undo-Tablespaces" class="headerlink" title="Undo Tablespaces"></a>Undo Tablespaces</h5><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</p><h5 id="Temporary-Tablespaces"><a href="#Temporary-Tablespaces" class="headerlink" title="Temporary Tablespaces"></a>Temporary Tablespaces</h5><p>InnoDB使用会话时的临时表空间和全局临时表空间，存储用户创建的临时表等数据。</p><h5 id="Doublewrite-Buffer-Files"><a href="#Doublewrite-Buffer-Files" class="headerlink" title="Doublewrite Buffer Files"></a>Doublewrite Buffer Files</h5><p>双写缓冲区，InnoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread、IO Thread、Purge Thread、Page Cleaner Thread</p><h5 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h5><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。</p><h5 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h5><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</p><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区刷新到磁盘</td></tr></tbody></table><p>通过指令，查看到InnoDB的状态信息，其中就包含IO Thread信息：<code>show engine innodb status \G; </code></p><h5 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h5><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就由Purge Thread来回收</p><h5 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h5><p>协助Master Thread刷新脏页到磁盘的线程，Page Cleaner Thread可以减轻Master Thread的工作压力，减少阻塞</p><h4 id="InnoDB中的事务"><a href="#InnoDB中的事务" class="headerlink" title="InnoDB中的事务"></a><strong>InnoDB中的事务</strong></h4><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败</p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><p>对于这四大特性，其中原子性、一致性、持久性，是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。而隔离性是通过数据库的锁，加上MVCC来保证的</p><h5 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h5><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log），前者在内存中，后者在磁盘中。</p><p>当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复，以循环方式写入重做日志文件。</p><p>有了redolog，对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘或者涉及到的数据已经落盘，此时redo log就可以删除了，所以存在的两个redo log文件是循环写的。</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><ol><li>当前读</li></ol><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读</p><ol start="2"><li>快照读</li></ol><p>简单的select（不加锁）就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方</li><li>Serializable：快照读会退化为当前读</li></ul><ol start="3"><li>MVCC</li></ol><p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐藏字段、undo log日志、readView。</p><h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p>数据库中的表在创建之后，查看表结构时可以显式的看到我们制定创建的字段。实际上除了制定创建的字段以外，InnoDB还会自动的添加三个隐藏字段，及其含义分别是：</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><p>上表中前两个字段是肯定会添加，最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，不会添加该隐藏字段</p><h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>回滚日志，用于记录数据被修改前的信息，作用包含两个: 提供回滚(保证事务的原子性)和MVCC(多版本并发控制) 。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚</p><ul><li><p>Undo log销毁：undo log在事务执行时产生，在事务提交后，insert产生的undo log日志只在回滚时需要，可被立即删除。update、delete产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即</p><p>删除。</p></li><li><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在rollback segment回滚段中，内部包含1024个undo log segment</p></li></ul><h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>当有多个并发事务在访问同一张表时，每个事务提交的sql语句都会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本</p><p>每个并发事务可能都会发起很多次sql请求，最终可以发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录</p><h5 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h5><p>ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id</p><p>包含四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p>在readview中规定了版本链数据的访问规则(trx_id代表当前undo log版本链对应事务ID)：</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>说明</th></tr></thead><tbody><tr><td>trx_id &#x3D;&#x3D; creator_trx_id</td><td>可以访问该版本</td><td>说明数据是当前这个事务更改的</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>说明数据已经提交</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>说明该事务是在ReadView生成后才开启</td></tr><tr><td>min_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id</td><td>如果trx_id不在m_ids中，是可以访问该版本的</td><td>说明数据已经提交</td></tr></tbody></table><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li>READ COMMITTED：在事务中每一次执行快照读时生成ReadView</li><li>REPEATABLE READ：在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</li></ul><h2 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><p>Mysql数据库安装完成后，自带了一下四个数据库，具体作用为：</p><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储MySQL服务器正常运行所需要的各种信息（时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等</td></tr><tr><td>performance_schema</td><td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="mysql客户端工具"><a href="#mysql客户端工具" class="headerlink" title="mysql客户端工具"></a>mysql客户端工具</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line">mysql [options] [database]</span><br><span class="line"># 选项</span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user=name #指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password[=name] #指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host=name #指定服务器IP或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port=port #指定连接端口</span></span><br><span class="line"><span class="operator">-</span>e, <span class="comment">--execute=name #执行SQL语句并退出</span></span><br></pre></td></tr></table></figure><p>-e选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，可以对于一些批处理脚本</p><h4 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h4><p>mysqladmin是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line">mysqladmin [options] command ...</span><br><span class="line"># 选项</span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user=name #指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password[=name] #指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host=name #指定服务器IP或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port=port #指定连接端口</span></span><br></pre></td></tr></table></figure><h4 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h4><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会用到mysqlbinlog日志管理工具</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line">mysqlbinlog [options] log<span class="operator">-</span>files1 log<span class="operator">-</span>files2 ...</span><br><span class="line">#选项</span><br><span class="line"><span class="operator">-</span>d, <span class="comment">--database=name #指定数据库名称，只列出指定的数据库相关操作</span></span><br><span class="line"><span class="operator">-</span>o, <span class="comment">--offset= # 忽略掉日志中的前n行命令</span></span><br><span class="line"><span class="operator">-</span>r,<span class="comment">--result-file=name #将输出的文本格式日志输出到指定文件</span></span><br><span class="line"><span class="operator">-</span>s, <span class="comment">--short-form #显示简单格式,省略掉一些信息</span></span><br><span class="line"><span class="comment">--start-datatime=date1 --stop-datetime=date2 #指定日期间隔内的所有日志</span></span><br><span class="line"><span class="comment">--start-position=pos1 --stop-position=pos2 #指定位置间隔内的所有日志</span></span><br></pre></td></tr></table></figure><h4 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h4><p>mysqlshow客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line">mysqlshow [options] [db_name [table_name [col_name]]]</span><br><span class="line"># 选项</span><br><span class="line"><span class="comment">--count # 显示数据库及表的统计信息（数据库和表均可以不指定）</span></span><br><span class="line"><span class="operator">-</span>i # 显示指定数据库或者指定表的状态信息</span><br></pre></td></tr></table></figure><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p>mysqldump客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] <span class="comment">--database/-B db1 [db2 db3...]</span></span><br><span class="line">mysqldump [options] <span class="comment">--all-databases/-A</span></span><br><span class="line"># 连接选项</span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user=name # 指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password[=name] # 指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host=name # 指定服务器ip或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port= # 指定连接端口</span></span><br><span class="line"># 输出选项</span><br><span class="line"><span class="comment">--add-drop-database # 在每个数据库创建语句前加上drop database语句</span></span><br><span class="line"><span class="comment">--add-drop-table # 在每个表创建语句前加上drop table语句，默认开启;(不开启 (--skip-add-drop-table))</span></span><br><span class="line"><span class="operator">-</span>n, <span class="comment">--no-create-db # 不包含数据库的创建语句</span></span><br><span class="line"><span class="operator">-</span>t, <span class="comment">--no-create-info # 不包含数据表的创建语句</span></span><br><span class="line"><span class="operator">-</span>d <span class="comment">--no-data # 不包含数据</span></span><br><span class="line"><span class="operator">-</span>T, <span class="comment">--tab=name # 自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件</span></span><br></pre></td></tr></table></figure><h4 id="mysqlimport-source"><a href="#mysqlimport-source" class="headerlink" title="mysqlimport&#x2F;source"></a>mysqlimport&#x2F;source</h4><ul><li>mysqlimport是客户端数据导入工具，用来导入mysqldump加 -T 参数后导出的文本文件</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlimport [options] db_name textfile1 [textfile2...]</span><br></pre></td></tr></table></figure><ul><li>source</li></ul><p>如果需要导入sql文件，可以使用mysql中的source指令</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">source <span class="operator">/</span>root<span class="operator">/</span>xxxxx.sql</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础篇</title>
      <link href="/inori/337fcc87.html"/>
      <url>/inori/337fcc87.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h2><table><thead><tr><th align="center">名称</th><th align="center">解释</th><th align="center">简称</th></tr></thead><tbody><tr><td align="center">数据库</td><td align="center">将数据有组织的存储的仓库</td><td align="center">DataBase(DB)</td></tr><tr><td align="center">数据库管理系统</td><td align="center">操纵和管理数据库的大型软件</td><td align="center">DBMS</td></tr><tr><td align="center">SQL</td><td align="center">操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准</td><td align="center">Structured Query Language</td></tr></tbody></table><p>工程师通过SQL操作DBMS，间接管理数据库中的数据</p><p>Oracle、MySQL等系统是关系型数据库管理系统，支持使用SQL语言进行数据库操作。</p><p>关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</p><h3 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h3><p>安装：这里推荐安装Mysql8版本，可以参考<a href="https://zhuanlan.zhihu.com/p/645347983?utm_id=0">这篇文章</a>安装MySQL</p><p>启动与停止：</p><blockquote><p>net start mysql80</p><p>net stop mysql80</p></blockquote><p>客户端连接：<code>mysql [-h 127.0.0.1] [-P 3306] -u root -p</code></p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul><li>SQL语句可以单行或多行书写，以分号结尾</li><li>MySQL中的SQL语句不区分大小写，但是关键字推荐使用大写</li><li>注释：<ul><li>单行注释：<code>-- 注释内容</code>或<code># 注释内容</code>(MySQL特有)</li><li>多行注释：<code>/*注释内容*/</code></li></ul></li></ul><h3 id="SQL数值类型"><a href="#SQL数值类型" class="headerlink" title="SQL数值类型"></a>SQL数值类型</h3><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p><img src="D:\Blog\source\img\mysql_intDataType.png" alt="mysql_datatype"></p><p>无符号数<code>TINYINT UNSIGNED</code>，DECIMAL类型<code>DECIMAL(x,y)</code>，x代表数字的整体长度&#x3D;整数长度+小数长度，y代表小数的长度</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p><img src="D:\Blog\source\img\mysql_charDataType.png" alt="mysql_datatype"></p><p>CHAR为定长字符串，开多少空间就占用多少空间，VARCHAR为变长字符串，根据存储的数据动态计算空间。</p><p>长文本数据分为<u>BLOB</u>和<u>TEXT</u>类型，BLOB表示二进制数据，可以是音频、视频、图像等数据，可以将其存储在数据库中，但是在开发时很少这么做，一般采用专门的文件服务器进行存储。</p><h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><p><img src="D:\Blog\source\img\mysql_timeDataType.png" alt="mysql_timeDataType"></p><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><table><thead><tr><th align="center">分类</th><th align="center">全称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DDL</td><td align="center">Data Definition Language</td><td align="center">数据定义语言，定义数据库对象（数据库，表，字段）</td></tr><tr><td align="center">DML</td><td align="center">Data Manipulation Language</td><td align="center">数据操作语言，对数据库表中的数据进行增删改</td></tr><tr><td align="center">DQL</td><td align="center">Data Query Language</td><td align="center">数据查询语言，查询表中的记录</td></tr><tr><td align="center">DCL</td><td align="center">Data Control Language</td><td align="center">数据控制语言，创建数据库用户、控制访问权限</td></tr></tbody></table><h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><p><code>[...]</code>部分为可选参数</p><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><ul><li>查询所有数据库：<code>SHOW DATABASES;</code></li><li>查询当前数据库：<code>SELECT DATABASE();</code></li><li>创建：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; </code></li><li>删除：<code>DROP DATABASE [IF EXISTS] 数据库名;</code></li><li>使用：<code>USE 数据库名;</code></li></ul><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><ul><li>查询数据库所有表：<code>SHOW TABLES;</code></li><li>查询表结构：<code>DESE 表名;</code></li><li>查询指定表的建表语句：<code>SHOW CREATE TABLE 表名;</code></li><li>创建表：</li></ul><blockquote><p>CREATE TABLE 表名(</p><p>​字段1 字段1类型[COMMENT 字段1注释],</p><p>​字段2 字段2类型[COMMENT 字段2注释],</p><p>​…..,</p><p>​字段n 字段n类型[COMMENT 字段n注释]</p><p>)[COMMENT 表注释];</p></blockquote><ul><li>添加字段：<code>ALTER TABLE 表名 ADD 字段名 类型 [comment] [约束];</code></li><li>修改数据类型：<code>ALTER TABLE 表名 MODIFY 字段名 新类型;</code></li><li>修改字段名和类型：<code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 [comment] [约束];</code></li><li>修改表名：<code>ALTER TABLE 表名 RENAME TO 新表名;</code></li><li>删除字段：<code>ALTER TABLE 表名 DROP 字段名;</code></li><li>删除表：<code>DROP TABLE [IF EXISTS] 表名;</code></li><li>删除指定表并重新创建（格式化该表）：<code>TRUNCATE TABLE 表名;</code></li></ul><h3 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h3><ul><li>给指定字段添加数据：<code>INSERT INTO 表名（字段1，字段2...） VALUES（值1，值2...）;</code></li><li>给全部字段添加数据：<code>INSERT INTO 表名 VALUES（值1，值2...）;</code></li><li>批量添加数据：</li></ul><blockquote><p>INSERT INTO 表名（字段1，字段2…） VALUES（值1，值2…）,（值1，值2…）…;</p><p>INSERT INTO 表名 VALUES（值1，值2…）,（值1，值2…）…;</p></blockquote><ul><li>修改数据：<code>UPDATE 表名 SET 字段1=值1, 字段2=值2...[WHERE 条件];</code></li><li>删除数据：<code>DELETE FROM 表名 [WHERE 条件];</code></li></ul><h3 id="DQL语句"><a href="#DQL语句" class="headerlink" title="DQL语句"></a>DQL语句</h3><ul><li><p>查询多个字段：<code>SELECT 字段1,字段2,... FROM 表名;</code></p></li><li><p>查询全部字段：<code>SELECT * FROM 表名;</code></p></li><li><p>设置别名：<code>SELECT 字段1 AS 别名1,字段2 AS 别名2,... FROM 表名;</code></p></li><li><p>去重：<code>SELECT DISTINCT 字段列表 FROM 表名;</code></p></li><li><p>条件查询：<code>SELECT 字段列表 FROM WHERE 条件列表;</code></p><p><u>此处的条件列表与其他编程语言的条件判断基本一致</u>，个别不一样的中常用的有<code>LIKE 占位符</code>表示模糊匹配（_匹配单个字符，%匹配任意字符）</p></li><li><p>使用聚合函数查询：<code>SELECT 聚合函数(字段列表) FROM 表名;</code></p></li></ul><p>​常用的聚合函数有：<u>count(),max(),min(),avg(),sum()</u>,按列进行计算</p><ul><li><p>分组查询：<code>SELECT 字段列表 FROM 表名 [WHERE 分组前过滤条件] GROUP BY 分组字段名 [HAVING 分组后的过滤条件];</code>（其中having中可以使用聚合函数过滤，where中不可以，并且分组之后查询的字段一般为分组字段和聚合函数）</p></li><li><p>排序查询：<code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;</code></p><p><u>排序方式有两种：ASC：升序（默认），DESC：降序。</u>如果是多字段排序，当且仅当第一个字段相同时按照第二个排。</p></li><li><p>分页查询：<code>SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</code></p><ul><li>索引从0开始编号，起始索引&#x3D;（查询页面-1）*每页的记录数</li><li>分页查询时数据库的方言，不同的数据库中实现语句不同，MySQL中是LIMIT</li><li>如果查的是第一页的数据，起始索引可以省略</li></ul></li></ul><h4 id="DQL语句编写顺序与执行顺序"><a href="#DQL语句编写顺序与执行顺序" class="headerlink" title="DQL语句编写顺序与执行顺序"></a>DQL语句编写顺序与执行顺序</h4><p><img src="D:\Blog\source\img\mysql_DQLSequence.png" alt="mysql_DQLSequence"></p><h3 id="DCL语句"><a href="#DCL语句" class="headerlink" title="DCL语句"></a>DCL语句</h3><ul><li>查询用户：<code>SELECT * FROM user;</code></li><li>创建用户：<code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></li><li>修改用户密码：<code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password &#39;新密码&#39;;</code></li><li>删除用户：<code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>查询用户权限：<code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>授予权限：<code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>撤销权限：<code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></li></ul><h4 id="常用的权限"><a href="#常用的权限" class="headerlink" title="常用的权限"></a>常用的权限</h4><table><thead><tr><th align="center">权限</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">all&#x2F;all privileges</td><td align="center">所有权限</td></tr><tr><td align="center">select</td><td align="center">查询数据</td></tr><tr><td align="center">insert</td><td align="center">插入数据</td></tr><tr><td align="center">update</td><td align="center">修改数据</td></tr><tr><td align="center">delete</td><td align="center">删除数据</td></tr><tr><td align="center">alter</td><td align="center">修改表</td></tr><tr><td align="center">drop</td><td align="center">删除数据库、表、视图</td></tr><tr><td align="center">create</td><td align="center">创建数据库、表</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在数据库中，函数指的是可以直接被另一段程序调用的程序或代码。</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CONCAT(S1,S2,…,Sn)</td><td align="center">字符串拼接，将给定的字符串拼成一个</td></tr><tr><td align="center">LOWER(str)</td><td align="center">str全部字符转成小写</td></tr><tr><td align="center">UPPER(str)</td><td align="center">str全部字符转成大写</td></tr><tr><td align="center">LPAD(str,n,pad)</td><td align="center">左填充，用字符串pad对str的左边进行填充直到长度到达n</td></tr><tr><td align="center">RPAD(str,n,pad)</td><td align="center">右填充，用字符串pad对str的右边进行填充直到长度到达n</td></tr><tr><td align="center">TRIM(str)</td><td align="center">去掉收尾空格</td></tr><tr><td align="center">SUBSTRING(str,start,len)</td><td align="center">返回字符串str从start开始len长度的字符串，索引从1开始</td></tr><tr><td align="center">LENGTH(str)</td><td align="center">返回字符串长度</td></tr></tbody></table><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CEIL(x)</td><td align="center">上取整</td></tr><tr><td align="center">FLOOR(x)</td><td align="center">下取整</td></tr><tr><td align="center">MOD(x,y)</td><td align="center">返回x&#x2F;y的模</td></tr><tr><td align="center">RAND()</td><td align="center">返回0~1的随机数</td></tr><tr><td align="center">ROUND(x,y)</td><td align="center">求x的四舍五入，保留y位小数</td></tr></tbody></table><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CURDATE()</td><td align="center">返回当前日期</td></tr><tr><td align="center">CURTIME()</td><td align="center">获取当前时间</td></tr><tr><td align="center">NOW()</td><td align="center">获取当前日期和时间</td></tr><tr><td align="center">YEAR(date)</td><td align="center">返回指定date的年份</td></tr><tr><td align="center">MONTH(date)</td><td align="center">返回指定date的月份</td></tr><tr><td align="center">DAY(date)</td><td align="center">返回指定date的日</td></tr><tr><td align="center">DATE_ADD(date,INTERVAL expr type)</td><td align="center">返回一个日期&#x2F;时间加上一个时间间隔expr后的时间</td></tr><tr><td align="center">DATEDIFF(date1,date2)</td><td align="center">返回date1和date2之间间隔的天数，date1-date2</td></tr></tbody></table><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">IF(value,t,f)</td><td align="center">如果value为true，返回t，否则返回f</td></tr><tr><td align="center">IFNULL(value1,value2)</td><td align="center">如果value1不为空，返回value1，否则返回value2</td></tr><tr><td align="center">CASE WHEN [val1] THEN [res1]…ELSE[default]END</td><td align="center">如果val1为true，返回res1,…否则返回默认值</td></tr><tr><td align="center">CASE [expr] WHEN [val1] THEN [res1]…ELSE[default]END</td><td align="center">如果expr的值等于val1，返回res1,…否则返回默认值</td></tr></tbody></table><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>​约束是作用于表中字段上的规则，在创建表或修改表的时候添加约束，用于限制存储在表中的数据。可以保证数据的正确，有效性和完整性。</p><h3 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h3><p><img src="D:\Blog\source\img\mysql_limitTyoe.png" alt="mysql_limitTyoe"></p><p>添加约束时只需要在后面直接添加关键字即可，不同约束使用空格隔开</p><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性，具有外键的称为子表&#x2F;从表，外键所关联的表称为父表&#x2F;主表。</p><ul><li>建立外键关联</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可以在创建表时直接指明外键</span><br><span class="line">CREATE TABLE name(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">    ...,</span><br><span class="line">    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 或者建表之后额外添加</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表(主表字段);</span><br></pre></td></tr></table></figure><ul><li>删除外键：<code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></li></ul><h3 id="外键约束-1"><a href="#外键约束-1" class="headerlink" title="外键约束"></a>外键约束</h3><p><img src="D:\Blog\source\img\mysql_fkType.png" alt="mysql_fkType"></p><p>使用时在外键命令后面添加<code>ON UPDATE 行为 ON DELETE 行为</code></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表查询即从多张表中查询数据。可以分为<u>连接查询</u>和<u>子查询</u></p><ul><li><p>连接查询</p><ul><li><p>内连接</p></li><li><p>外连接</p><ul><li><p>左外连接</p></li><li><p>右外连接</p></li></ul></li><li><p>自连接</p></li></ul></li><li><p>子查询</p></li></ul><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li><p>一对一：</p><ul><li>案例：个人与个人信息</li><li>关系：每个人有每个人自己的个人信息</li><li>实现：将基础字段放在一张表中，详情信息放在另一张表中，在任意一方加入外键，关联另一方的主键，并设置外键为UNIQUE</li></ul></li><li><p>一对多&#x2F;多对一：</p><ul><li>案例：部门与员工</li><li>关系：一个部门对应多个员工，一个员工对应一个部门</li><li>实现：在多的一方建立外键，指向一的一方的主键</li></ul></li><li><p>多对多：</p><ul><li>案例：学生与课程</li><li>关系：一个学生可以选修多门课程，一门课程可以有多个学生选择</li><li>实现：建立一张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul></li></ul><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>查询A、B交集部分的数据</p><ul><li>隐式内连接：<code>SELECT 字段列表 FROM 表1,表2 WHERE 条件;</code></li><li>显示内连接：<code>SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件;</code></li></ul><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>查询左表所有数据，以及两张表交集部分的数据</p><p><code>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件; </code></p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>查询右表所有数据，以及两张表交集部分的数据</p><p><code>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件; </code></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>当前表与自身的连接查询，自连接必须使用表别名。自连接可以是内连接查询，也可以是外连接查询</p><p><code>SELECT 字段列表 FROM 表1 别名1 JOIN 表2 别名2 ON 条件; </code></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套SELECT语句称为嵌套查询，也叫子查询，子查询外部的语句可以是增删改查任意一个</p><p>例如：<code>SELECT 字段列表 FROM 表1 WHERE 字段1=(SELECT 字段1 FROM 表2); </code></p><p>根据子查询结果不同，分为：</p><ul><li><p>标量子查询（子查询结果为单个值）：直接嵌套查询即可</p></li><li><p>列子查询：</p><p>常用的操作符：IN(指定范围内),NOT IN(不在指定范围内),ANY(返回列表中任意一个满足条件即可),SOME(同ANY),ALL(条件必须全部满足)</p></li><li><p>行子查询:</p><p>常用的操作符：&#x3D;,&lt;&gt;,IN,NOT IN</p></li><li><p>表子查询（多行多列）:</p><p>常用的操作符：IN</p></li></ul><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询使用union(合并后去重)，union all(合并)命令，可以把多次查询的结果合并起来，形成一个新的查询结果集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 ...</span><br><span class="line">UNION[ALL]</span><br><span class="line">SELECT 字段列表 FROM 表1 ...</span><br></pre></td></tr></table></figure><p>联合查询中多张表的列数必须保持一致，字段类型也要一致。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，是不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求。默认MySQL的事务是自动提交的，即执行DML语句时，MySQL会立即隐式的提交事务。</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>操作事务有两种方式：1.关闭事务的自动提交 2.通过指令显式开启事务</p><ul><li>查看事务提交方式：<code>SELECT @@autocommit;</code></li><li>设置事务提交方式(1为自动提交，0为手动提交）：<code>SET @@autocommit=0;</code> </li><li>开启事务：<code>START TRANSACTION;</code></li><li>提交事务：<code>COMMIT;</code></li><li>回滚事务：<code>ROLLBACK;</code></li></ul><h3 id="事务四大特性ACID"><a href="#事务四大特性ACID" class="headerlink" title="事务四大特性ACID"></a>事务四大特性ACID</h3><ul><li>原子性A：事务不可分割，事务中的操作要么同时成功，要么同时失败。</li><li>一致性C：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性I：数据库系统提供的隔离机制，保证事务在不收外部并发操作影响的独立环境下运行</li><li>持久性D：事务一旦提交或回滚，对数据的改变就是永久的</li></ul><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p>多个并发事务在执行过程当中所出现的问题</p><table><thead><tr><th align="center">问题</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">脏读</td><td align="center">一个事务读取到另一个事务还没有提交的数据</td></tr><tr><td align="center">不可重复读</td><td align="center">一个事物先后读取到同一条数据，但两次读取的数据不同</td></tr><tr><td align="center">幻读</td><td align="center">一个事物按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>√表示该隔离级别会出现对应问题，从上到下隔离级别由低到高，性能由高到低</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read committed</td><td align="center">x</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable Read</td><td align="center">x</td><td align="center">x</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><p>MySQL中的默认隔离级别是<u>Repeatable Read</u>，Oracle是<u>Read committed</u></p><ul><li>查看事务隔离级别：<code>SELECT @@transaction_isolation;</code></li><li>设置事务隔离级别：<code>SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;隔离级别&#125;;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射</title>
      <link href="/inori/e29c8e30.html"/>
      <url>/inori/e29c8e30.html</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>利用反射机制，可以通过外部文件配置，在不修改源码的情况下控制程序，符合设计模型中OCP原则</p><ol><li>反射机制允许程序在执行期间借助于<code>Reflection</code>API取得任何类的内部信息（成员变量、构造器、成员方法等），并能操作对象的属性及方法。</li><li>加载类之后，在堆中产生了一个<code>Class</code>类型的对象，这个对象包括了类的完整结构信息。这个对象就像一面镜子，通过这个镜子看到类的结构，所以称之为：反射</li><li>反射可以做到的事：<ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ul></li><li>使用反射后，程序的执行速度会受到影响</li></ol><h2 id="反射相关的类"><a href="#反射相关的类" class="headerlink" title="反射相关的类"></a>反射相关的类</h2><p>常用的反射相关的类都在<code>java.lang</code>包中</p><ol><li>Class:代表一个类，表示某个类加载后在堆中的对象</li><li>reflect.Method:类的方法</li><li>reflect.Field:类的成员变量，<u>不能得到private属性</u></li><li>reflect.Constructor:构造器</li></ol><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ol><li>Class类也是继承Object的类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class对象，在内存中只有一份，因为类只加载一次（比如在使用反射加载类对象之前已经实例化过一次该类，就不会再调用loadClass方法）</li><li>Class对象存放在堆中</li><li>类的字节码二进制数据存放在方法区，称为类的元数据</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">static Class forName（）</td><td align="center">返回指定类名的Class对象</td></tr><tr><td align="center">Object newInstance()</td><td align="center">返回Class对象的一个实例</td></tr><tr><td align="center">String gatName()</td><td align="center">返回Class对象所表示的实体（类，接口，基本类型等）的名称</td></tr><tr><td align="center">Class getSuperClass()</td><td align="center">返回其父类</td></tr><tr><td align="center">Constructor[] getConstructors()</td><td align="center">返回本类的构造器</td></tr><tr><td align="center">ClassLoader getClassLoader()</td><td align="center">返回类的加载器</td></tr><tr><td align="center">Field[] getFields()</td><td align="center">返回所有public修饰的属性，包括本类及父类</td></tr><tr><td align="center">Field[] getDeclaredFields()</td><td align="center">返回本类所有属性</td></tr><tr><td align="center">Method[] getMethods()</td><td align="center">返回所有public修饰的方法，包括本类及父类</td></tr><tr><td align="center">Method[] getDeclaredMethods()</td><td align="center">返回本类所有方法</td></tr></tbody></table><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><ol><li>若已知一个类的完整路径“包名.类名”，可以通过Class类的<code>forName()</code>获取。<u>应用场景</u>：配置文件，读取类全路径，加载类</li><li>若已知具体的类，可以通过<code>类.class</code>获取，该方式也可以获取基本数据类型的Class对象。<u>应用场景</u>：用于参数传递，如通过反射的对应构造器对象。</li><li>如果已经有该类的实例，可以通过<code>对象.getClass()</code>获取Class对象</li><li>通过类加载器获取：</li></ol><blockquote><p>ClassLoader classLoader &#x3D; test.getClass().getClassLoader();</p><p>Class cls &#x3D; classLoader.loadClass(classAllPath);&#x2F;&#x2F; classAllPath为类的完整路径</p></blockquote><ol start="5"><li>基本数据类型的包装类（Integer，Boolean等）可以通过<code>.TYPE</code>获取Class对象</li></ol><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p>类加载分为<u>静态加载</u>和<u>动态加载</u>。</p><p>静态加载：编译时加载相关的类，如果没有则报错，哪怕不一定会用到这个类，也会加载</p><p>动态加载：运行时加载需要的类，如果运行时不用该类就不会报错，反射使用的就是动态加载方案</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanf.nextInt();</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">// 静态加载，哪怕可能不会使用到这个类也会加载，会直接报错</span></span><br><span class="line">                dog.method();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Dog&quot;</span>);<span class="comment">// 动态加载，当使用到的时候才会报错</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">                m.invoke();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h5><p>大体流程如下图所示。</p><p><img src="D:\Blog\source\img\ClassLoad.png"></p><p>​首先对源码进行编译，生成字节码文件，在运行时进入类加载，由类加载器将类的class文件读入内存，并创建一个Class对象。</p><p>然后进入连接阶段，把二进制数据合并到JRE中，<u>验证：</u>对文件安全性进行验证，<u>准备：</u>对静态变量进行默认初始化并分配空间，解析：把符号引用转成直接引用（地址引用）。最后进行初始化，由JVM负责，执行<code>&lt;clinit&gt;()</code>方法。</p><p>​<code>&lt;clinit&gt;()</code>方法是由编译器按照语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值动作和静态代码块中的语句，并进行合并。虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁，同步。如果多个线程同时去初始化一个类，同一时间内只允许一个线程执行此方法。</p><h3 id="Field类常用方法"><a href="#Field类常用方法" class="headerlink" title="Field类常用方法"></a>Field类常用方法</h3><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">getModifiers()</td><td align="center">以int形式返回修饰符</td></tr><tr><td align="center">getType()</td><td align="center">以Class形式获取返回类型</td></tr><tr><td align="center">getName()</td><td align="center">返回属性名</td></tr><tr><td align="center">getParameterTypes()</td><td align="center">以Class[] 返回参数类型数组</td></tr></tbody></table><p>注：在<code>getModifiers()</code>方法中，返回的int形式为：默认是0，public是1，private是2，protected是4，static是8，final是16。如果有多个修饰符就代数相加。</p><h2 id="反射暴破"><a href="#反射暴破" class="headerlink" title="反射暴破"></a>反射暴破</h2><p>使用反射机制访问private属性、方法、构造器，称为暴破（暴力破解），可以破坏封装特性。  </p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取person类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; person = Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> person.getDeclaredConstructor().newInstance();  <span class="comment">// 创建无参实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建private有参实例</span></span><br><span class="line">        Constructor&lt;?&gt; privateConstructor = person.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        privateConstructor.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴破</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> privateConstructor.newInstance(<span class="string">&quot;Mary&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> person.getDeclaredField(<span class="string">&quot;name&quot;</span>);   <span class="comment">// 获取name属性</span></span><br><span class="line">        name.set(o, <span class="string">&quot;Jack&quot;</span>);    <span class="comment">// 修改name</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">toString</span> <span class="operator">=</span> person.getMethod(<span class="string">&quot;toString&quot;</span>);     <span class="comment">// 获取toString方法</span></span><br><span class="line">        <span class="comment">// 如果方法有返回值，统一返回Object，但是运行类型和方法定义的返回类型一致</span></span><br><span class="line">        System.out.println(toString.invoke(o));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取private属性age</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> person.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.setAccessible(<span class="literal">true</span>);    <span class="comment">// 暴破</span></span><br><span class="line">        age.set(o, <span class="number">23</span>); <span class="comment">// 修改age</span></span><br><span class="line">        System.out.println(age.get(o)); <span class="comment">// 获取age的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取private方法say，如果方法中要求传参，则需要在后面输入参数对应的Class类</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">say</span> <span class="operator">=</span> person.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">        say.setAccessible(<span class="literal">true</span>);    <span class="comment">// 暴破</span></span><br><span class="line">        say.invoke(o1, <span class="string">&quot;success&quot;</span>, <span class="number">1</span>);  <span class="comment">// 激活方法并传入参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String word, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用say方法：&quot;</span> + word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程基础</title>
      <link href="/inori/bc47619b.html"/>
      <url>/inori/bc47619b.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p> 大都是计算机网络的基础知识，这里仅复习一下重点概念。</p><ol><li>IP地址&#x3D;网络地址+主机地址</li><li>IPv4最大的问题在于网络地址资源有限，制约了互联网的应用与发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</li><li>端口号用于标识计算机上某个特定的网络程序，范围是<strong>0~65535</strong>，其中<strong>0~1024</strong>已经被占用，当浏览器或程序要请求特定IP的某些服务时，需要使用IP地址+端口号的形式访问</li><li>常见的端口号：</li></ol><blockquote><p>ssh:22 ftp:21 smtp:25 http: 80</p><p>tomcat: 8080 mysql:3306 oracle:1521 sqlserver:1433</p></blockquote><ol start="5"><li>OSI七层模型是理论上的，并没有实际使用。主要使用的是TCP&#x2F;IP模型四层模型，分为：应用层、传输层、网际层、网络接口层</li><li>TCP协议：<ul><li>使用TCP前需要“三次握手”建立连接，形成传输数据通道，进行可靠传输</li><li>TCP协议进行通信的两个应用进程：客户端、服务端</li><li>在连接中可进行大数据量的传输</li><li>传输完毕需要释放已建立的连接，效率较低</li></ul></li><li>UDP协议：<ul><li>将数据、源、目的地封装成数据包，不需要建立连接，不可靠传输</li><li>每个数据包大小限制64KB</li><li>传输效率高</li></ul></li></ol><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><p>一般使用java.net包进行网络编程</p><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><ol><li>getLocalHost:获取本机的InetAddress对象</li><li>getByName:根据指定的主机名&#x2F;域名获取IP地址对象</li><li>getHostName:获取InetAddress对象的主机名</li><li>getHostAddress:获取InetAddress对象的IP地址</li></ol><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket（套接字）已经成为开发网络应用程序的标准，两台机器进行网络通信时，两端都要有Socket，作为两台机器间通信的端点，网络通信本质上就是Socket间的通信。</p><p>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输，一般主动发起通信的应用程序为客服端，等待通信请求的是服务端。</p><h4 id="Socket-TCP通信"><a href="#Socket-TCP通信" class="headerlink" title="Socket-TCP通信"></a>Socket-TCP通信</h4><p>当需要TCP进行通讯时，使用<code>socket.getOutputStream()和socket.getInputStream()</code>，当客户端连接到服务端时，客户端会由TCP&#x2F;IP协议分配一个端口与服务端进行通信。</p><p>服务器端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端正在侦听&quot;</span> + port + <span class="string">&quot;端口&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();  <span class="comment">// 没侦听到程序就会阻塞在这，如果侦听到了就会返回Socket对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> readLen;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>((readLen = inputStream.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            str += <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用完毕后要关闭连接</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLoaclHost(), <span class="number">9999</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;Hello,Server&quot;</span>.getBytes());</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Socket-UDP通信"><a href="#Socket-UDP通信" class="headerlink" title="Socket-UDP通信"></a>Socket-UDP通信</h4><ol><li>类<strong>DategramSocket</strong>和<strong>DatagramPacket</strong>实现了基于UDP协议的网络通信</li><li>没有明确的服务端和客户端，只有数据的发送端与接收端，并且两者身份可互换</li><li>接收数据和发送数据是通过<strong>DatagramSocket</strong>对象完成</li><li>将数据封装到<strong>DatagramPacket</strong>对象中装包</li><li>当接收到<strong>DatagramPacket</strong>对象时需要进行拆包，取出数据</li></ol><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>端口1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Port1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">        ds.receive(res);<span class="comment">// 开一个缓冲区，从其他端口处接收消息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> res.getLength();</span><br><span class="line">        <span class="type">byte</span>[] data = res.getData();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        ds.close();<span class="comment">// 最后要关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>端口2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Port2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你想说什么？&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanf.next();</span><br><span class="line">        <span class="type">byte</span>[] buf = s.getBytes();</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">sen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, InetAddress.getLocalHost(), <span class="number">9999</span>);<span class="comment">// 发送数据到指定端口</span></span><br><span class="line">        ds.send(sen);</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaIO流</title>
      <link href="/inori/47e3b155.html"/>
      <url>/inori/47e3b155.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>​文件在程序中是以流的形式来操作的，文件保存在硬盘中，通过输入流被java程序读取，程序再通过输出流输出进文件中。流是数据在数据源和程序之间经历的路径，输入流是数据从数据源到程序的路径，输出流是程序到数据源的路径。</p><p>​java.io包中提供了各种流类和接口，以获取不同种类的数据，并通过方法输入或输出数据。</p><h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ul><li>按照数据单位可以分为：字节流（8bit）、字符流</li><li>按照数据流向分为：输入流、输出流</li><li>按照流的角色不同分为：节点流、处理流&#x2F;包装流</li></ul><h2 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a>常用的文件操作</h2><ol><li><p>创建文件对象相关构造器和方法</p><ul><li><code>new File(String pathname)</code>：根据路径创建文件对象</li><li><code>new File(File parent, String child)</code>：根据父目录文件+子路径构建</li><li><code>new File(String parent, String child)</code>：同上</li></ul></li><li><p>获取文件相关信息</p><ul><li><code>getName</code>：获取文件名</li><li><code>getAbsolutePath</code>：获取绝对路径</li><li><code>getParent</code>：获取文件父目录</li><li><code>length</code>：获取文件占用字节</li><li><code>exists</code>：文件是否存在</li><li><code>isFile</code>：是否为文件</li><li><code>isDirectory</code>：是否为文件夹</li><li><code>delete</code>：删除文件</li><li><code>mkdir/mkdirs</code>创建目录&#x2F;多级目录</li></ul></li></ol><h2 id="常用IO类"><a href="#常用IO类" class="headerlink" title="常用IO类"></a>常用IO类</h2><ol><li><p>InputStream&#x2F;OutputStream：从文件中读取字节的类，有基本的字节输入输出功能，常使用byte数组进行接收和写入</p><ul><li>使用<code>getBytes</code>将字符串转成Byte数组，从而对文件进行写入</li><li>使用完输出输入流之后一定要关闭流，可以使用<code>try-with-resources</code>语句来确保资源的正确关闭。</li></ul></li></ol><p>综合使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="string">&quot;/source.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destinationFilePath</span> <span class="operator">=</span> <span class="string">&quot;/destination.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try-with-resources语法：在try语句中初始化流类</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFilePath));</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destinationFilePath))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取并写入文件</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;File copied successfully.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Reader&#x2F;Writer：从文件中读取字符的类，主要用于处理字符数据。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="string">&quot;/source.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destinationFilePath</span> <span class="operator">=</span> <span class="string">&quot;/destination.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try-with-resources语法：在try语句中初始化流类</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(sourceFilePath);</span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destinationFilePath)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取并写入文件</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;File copied successfully.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>节点流可以从一个特定的数据源读写数据，如上面使用的FileReader、FileWriter。节点流是底层流，直接与数据源相接。</p></li><li><p>处理流（包装流）是连接已存在的流，以增加缓冲的方式来提高输入输出的效率，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWritter。处理流既可以消除不同节点流的实现差异，也可以提供方便的方法来完成输入输出。处理流使用了修改器设计模式，不会与数据直接相连。</p></li><li><p>对象流ObjectInputStream&#x2F;ObjectOutputStream是用于对象序列化和反序列化的类。它们可以将对象转换为字节流，以便在网络上传输或保存到文件中。</p><ul><li><p>序列化就是在保存数据时，保存数据的值和数据类型</p></li><li><p>反序列就是在恢复数据时，恢复数据的值和数据类型</p></li><li><p>如果想让某个对象支持序列化，则其类必须实现<strong>Serializable</strong>(推荐，该类为标记接口，不需要实现方法）和<strong>Externalizable</strong>两个接口<u>其中之一</u></p></li><li><p>反序列化时，读取的顺序需要和序列化的顺序一致，并且返回的是Object类型，需要向下转型</p></li><li><p>序列化的类中建议添加<code>SerialVersionUID</code>，为了提高版本兼容性</p></li><li><p>序列化对象时，默认里面所有属性都会序列化（所以要求该类中所有的属性必须可序列化），除了<code>static</code>或<code>transient</code>修饰的成员</p></li><li><p>序列化可继承，父类实现了序列化，则其所有子类都可以序列化</p></li></ul></li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">testPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\test.dat&quot;</span>;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(testPath));</span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(testPath));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person_</span> <span class="operator">=</span> (Person)ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;<span class="comment">// 测试用的序列化类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String likedColor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String likedColor)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.likedColor = likedColor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, likedColor=&#x27;&quot;</span> + likedColor + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>标准输入输出流<code>System.in/System.out</code>：</p><ul><li><p><code>System.in</code>编译类型为InputStream，运行类型为BufferedInputStream，输入对象为键盘</p></li><li><p><code>System.out</code>编译类型和运行类型均为PrintStream，输出对象为显示器</p></li></ul></li><li><p>转换流<code>InputStreamReader/OutputStreamWriter</code>：</p><ul><li><code>InputStreamReader</code>：可以将<code>InputStream</code>包装成<code>Reader</code></li><li><code>OutputStreamWriter</code>：可以将<code>OutputStream</code>包装成<code>Writer</code></li><li>可以在使用时指定编码格式</li></ul></li></ol><p><img src="D:\Blog\source\img\IOType.png"></p><h2 id="Properties读写文件"><a href="#Properties读写文件" class="headerlink" title="Properties读写文件"></a>Properties读写文件</h2><p>​在java集合类中介绍过，Properties类是一种专门用于读写配置文件的集合类。在项目过程中经常要从数据库中读文件，读取的文件类型经常是.properties文件。在Properties文件中配置文件的格式为：<code>key=value</code>，默认格式为String。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol><li>load：加载配置文件的键值对到Properties对象</li><li>store：将Properties中的键值对存储到配置文件，在IDEA中，保存时如果有中文，会存储为unicode码</li><li>list：将数据显示到指定设备&#x2F;流对象</li><li><code>getProperty(key)</code>：根据键获取值</li><li><code>setProperty(key, value)</code>：设置键值对到Properties对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pro.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">// 把键值对显示到控制台</span></span><br><span class="line">        pro.list(System.out);</span><br><span class="line">        <span class="comment">// 根据键获取值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="comment">// 存储键值对到Properties文件中</span></span><br><span class="line">        pro.setProperty(<span class="string">&quot;user2&quot;</span>, <span class="string">&quot;inori&quot;</span>);</span><br><span class="line">        pro.setProperty(<span class="string">&quot;pwd2&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        pro.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/mysql2.properties&quot;</span>), <span class="literal">null</span>); <span class="comment">// 想要写入必须保存，第二个参数为想要写入的注释，如果不为null的话会写在文件的第一行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础部分</title>
      <link href="/inori/9da8abfe.html"/>
      <url>/inori/9da8abfe.html</url>
      
        <content type="html"><![CDATA[<h1 id="待更新（等学完JUC一起更）"><a href="#待更新（等学完JUC一起更）" class="headerlink" title="待更新（等学完JUC一起更）"></a>待更新（等学完JUC一起更）</h1>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="/inori/4b0d9081.html"/>
      <url>/inori/4b0d9081.html</url>
      
        <content type="html"><![CDATA[<h2 id="集合的好处"><a href="#集合的好处" class="headerlink" title="集合的好处"></a>集合的好处</h2><p>之前保存多个数据的时候一直都是用的数组，但是数组</p><ol><li>长度开始时必须指定，而且一旦指定，不能更改</li><li>保存的必须为同一类型的元素</li><li>使用数组进行增加&#x2F;删除元素时比较麻烦</li></ol><p>但是集合避免了这些缺点，可以动态保存任意多个对象。</p><p>常用的集合主要可以分为两类</p><ol><li>单列集合Collection<ul><li>List：ArrayList、LinkedList、Vector</li><li>Set：HashSet、TreeSet</li></ul></li><li>双列集合Map：HashMap、TreeMap、Hashtable、Properties</li></ol><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection是一个接口，不可以实例化。该类提供了一些通用方法，供实现该接口的类使用。</p><ol><li>size：集合中元素个数</li><li>isEmpty：检查集合是否为空</li><li>clear：清空集合</li></ol><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List实现了Collection接口，除了通用方法外，还含有：</p><ol><li>add（i,b)：把b元素添加到集合的i位置</li><li>addAll(i,b)：从i位置开始，把b中所有元素添加进来</li><li>get(i)：得到i位置上的元素</li><li>indexOf(a)&#x2F;lastIndexOf(a)：返回a在List中第一次&#x2F;最后一次出现的位置</li><li>remove(i)：移除并返回i位置上的元素</li><li>set(i,a)：将位置i上的元素替换成a</li><li>subList(i,j)：返回集合下标[i,j)的子集</li></ol><p><strong>ArrayList的扩容机制</strong>：当实例化对象时，可以指定大小。如果使用的无参构造器，则初始化大小为0，添加元素时，扩容为10。无论是否指定了初始大小，如果需要再次扩容，则每次扩充为原大小的1.5倍。</p><p><strong>Vector的扩容机制</strong>：当实例化对象时，可以指定大小。如果使用无参构造器，则初始化大小为10。如果需要扩容则按照两倍扩容。</p><p>Vector相比于ArrayList效率较低，但是Vector在源码中添加了<code>synchronized</code>修饰，保证了线程安全，因此在开发中，需要线程同步安全时，要考虑Vector。</p><p><strong>LinkedList</strong>：本质是双向链表，具有双向链表的一切特性，头尾部增删很快，改查很慢，不适合改查操作多的环境。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合内元素唯一，且不能通过索引查找，遍历顺序不能保证与插入顺序一致。可以使用<code>add</code>、<code>remove</code>方法。</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li>HashSet的底层是HashMap</li><li>添加一个元素时，先得到hash值，使用hash值转化成索引值</li><li>找到存储数据表table，看这个索引位置是否有已经存放的元素，如果没有就加入，如果有并且元素不同（使用equals比较），就添加到最后</li><li>在jdk8中，如果一条链表长度超过<code>TREEIFY_THRESHOLD</code>（默认是8），并且table大小≥<code>MIN_TREEIFY_CAPACITY</code>（默认是64），就会变成红黑树。</li><li>第一次添加元素时，table数组扩容到16，<code>临界值=threShold*loadFactor=最大长度*0.75=16*0.75=12</code></li><li>如果数组长度到了临界值，就会再次进行扩容，<code>容量=当前最大长度*2</code>，直到达到了树化条件，<code>新的临界值=最大长度*0.75</code></li><li>如果想保证元素的遍历顺序等于插入顺序，可以使用<strong>LinkedHashSet</strong>。</li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet是即有序集合，底层基于红黑树，能够确保集合元素按照升序或降序排列。</p><p>相比于HashSet新增的方法有：</p><ol><li>firse&#x2F;last：获取第一个&#x2F;最后一个元素</li><li>floor(a)&#x2F;ceiling(a)：获取小于等于&#x2F;大于等于a的最大&#x2F;最小元素</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map与Collection并列存在，用于保存具有映射关系的数据：键值对。Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中。</p><p>Map接口常用方法：</p><ol><li><code>put(key, value)</code>：添加键值对</li><li><code>remove()</code>：根据键删除映射关系</li><li><code>get(key)</code>：根据键获取值</li><li>size：获取元素个数</li><li>isEmpty：判断Map是否为空</li><li>clear：清空</li><li>containsKey：查找键是否存在</li><li>keySet：返回所有键的集合</li></ol><p>HashMap键值对的两种遍历方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.遍历键，找到值</span></span><br><span class="line">        <span class="keyword">for</span> (String key: hashMap.keySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> hashMap.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.使用entrySet获取键值对</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap没有实现同步，不保证线程安全。</p><p>HashTable与HashMap使用的方法基本一致，区别在于：</p><ol><li>HashTable的键和值都不能为null，否则会报空指针异常</li><li>HashTable是线程安全的，多个线程不能同时修改HashTable中的内容</li><li>HashTable在性能上比HashMap略差</li></ol><p>Properties类是用于处理属性文件的类，继承自HashTable类，并实现了Map接口，特点与HashTable类似。Properties主要用于从properties文件中加载数据到Properties类对象，并进行读取和修改。</p><p>方法：</p><ol><li><code>setProperty(key, value)</code>：添加属性</li><li><code>getProperty(key)</code>：获取属性</li><li>load：加载属性文件</li><li>store：保存属性文件</li></ol><p>TreeMap即有序键值对，可以保证插入的键有序排列，方法与HashMap大致相同，但是TreeMap不允许键为null，只允许值接null。</p><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>Collections是一个操作Set、List、Map等集合的工具类，其中提供了一系列的static方法对元素进行排序、查询和修改等操作。</p><p>主要方法：</p><ol><li>sort：对List进行升序排序，其中可以编写比较器对List指定排序方法</li><li>shuffle：打乱List中元素的顺序</li><li>reverse：对List进行翻转</li><li>swap：交换List中两个元素的位置</li><li>max&#x2F;min：返回集合中最大&#x2F;最小的元素</li><li><code>frequency(Collection, Object)</code>：返回Collection集合中Object的出现次数</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常用类及其方法</title>
      <link href="/inori/12697782.html"/>
      <url>/inori/12697782.html</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>针对八种基本数据类型相应的引用类型，有了类的特点，就能调用类中的方法。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>​这两个过程的主要用途在于使得在需要使用对象的场景中能够使用基本数据类型，以及在需要使用基本数据类型的场景中能够使用对象。例如，在集合类中，只能存储对象而不能存储基本数据类型，因此需要通过装箱将基本数据类型转换为对应的包装类对象。</p><p>​在jdk5之前，需要手动装箱与拆箱，jdk5及之后使用自动装箱与拆箱。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 手动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(num);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> Integer.valueOf(num);</span><br><span class="line">        <span class="comment">// 手动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自动装箱和拆箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ol><li>字符串的字符使用Unicode字符编码，无论字母还是汉字都占2字节</li><li>String类有很多构造器和构造器的重载，常用的有：</li></ol><blockquote><p>String s1 &#x3D; new String();</p><p>String s2 &#x3D; new String(String original);</p><p>String s3 &#x3D; new String(char[] a);</p><p>String s4 &#x3D; new String(char[] a, int startIndex, int count);</p><p>String s5 &#x3D; new String(byte[] b);</p></blockquote><ol start="3"><li>String类实现了接口Serializable（串行化：可以在网络传输）和接口Comparable（比较大小）</li><li>String是final类，不能被继承</li><li>String有属性private final char value[]，用于存放字符串内容</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li>equals：区分大小写，判断内容是否相等</li><li>equalsIgnoreCase：忽略大小写，判断内容是否相等</li><li>length：返回字符串长度</li><li>substring：截取指定范围的子串，前闭后开区间</li><li>trim：去掉前后空格</li><li>charAt：获取索引处字符</li><li>toUpperCase：把字符串全部转换成大写</li><li>toLowerCase：把字符串全部转换成小写</li><li>replace：<code>str.replace(a,b)</code>将str中所有的a替换成b</li><li>split：字符串分割，类似于Python的split，需要用列表接收</li><li>toCharArray：将字符串转化成字符数组<code>char[]</code></li><li>format：用法类似于c的printf</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14159265</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(<span class="string">&quot;a=%d,b=%s,c=%c,d=%.2f&quot;</span>, a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>​StringBuffer是一个容器，因为是线程安全的(方法添加了synchronized修饰)，所以一般用于多线程，代表可变的字符序列，可以对字符串内容进行增删，方法与String大体相同。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><blockquote><p>StringBuffer()：构造一个不带字符的缓冲区，大小为16</p><p>StringBuffer(int capacity)：构造一个不带字符，容量为capacity的缓冲区</p><p>StringBuffer(String str)：构造一个内容为str，大小为str.length()+16的缓冲区</p></blockquote><h4 id="转换机制"><a href="#转换机制" class="headerlink" title="转换机制"></a>转换机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String -&gt; StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer -&gt; String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li>append：向后面添加字符串</li><li>delete：<code>delete(a,b)</code>删除指定范围的字符，左闭右开，即删除[a,b)内的字符</li><li>replace：<code>replace(a,b)</code>用法同delete，删除改为替换</li><li>indexOf：查找指定子串在字符串中第一次出现的位置，没找到返回-1</li><li>insert：<code>insert(a,b)</code>在a位置插入字符串b</li></ol><h3 id="StringBulider类"><a href="#StringBulider类" class="headerlink" title="StringBulider类"></a>StringBulider类</h3><p>​StringBulider和StringBuffer类均代表可变的字符序列，但是StringBulider效率更高，两者方法相同，所以使用和StringBuffer一样，但是StringBulider一般用于单线程。</p><p>效率：StringBulider &gt; StringBuffer &gt; String</p><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>包含用于执行基本数学运算的方法。</p><ol><li>abs：绝对值</li><li>pow：幂运算，<code>pow(a,b)</code>指求a的b次方</li><li>ceil：向上取整</li><li>floor：向下取整</li><li>sqrt：开方</li><li>random：返回一个[0,1)之间的double类型的随机数</li><li>max&#x2F;min：求最值</li></ol><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays用于管理或操作数组。</p><ol><li>toString：将数组内容变成字符串，便于输出查看内容</li><li>sort：将数组排序，可以使用匿名内部类改变排序方法</li><li>binarySearch：通过二分查找有序数组的某一个数，如果存在返回索引。不存在返回<code>-(本应该在的位置+1)</code></li><li>fill：<code>fill(arr, num)</code>将arr数组内容全部变成num</li><li>asList：将一组值转换成list</li></ol><h2 id="大数处理方案"><a href="#大数处理方案" class="headerlink" title="大数处理方案"></a>大数处理方案</h2><p><strong>BigInteger</strong>适合保存超出<code>long</code>表示范围的整数。<strong>BigDecimal</strong>适合保存超出<code>double</code>表示范围的浮点型。</p><p>加减乘除不能使用正常的数学符号，必须使用类给定的方法。</p><p>用法（以BigInteger为例，BigDecimal与之相同）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;9999999999999999999999999999999999&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">add</span> <span class="operator">=</span> num1.add(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">sub</span> <span class="operator">=</span> num1.subtract(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">mul</span> <span class="operator">=</span> num1.multiply(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">div</span> <span class="operator">=</span> num1.divide(num2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意，BigDecimal的除法可能与BigInteger不同</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10.999999999999999999999999999999999991&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果除数除不尽的话会报异常，解决办法：</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">div2</span> <span class="operator">=</span> num3.divide(num4, BigDecimal.ROUND_CEILING); <span class="comment">// 保留与被除数相同的精度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p>用于获得系统时间。</p><ol><li>Date：<code>new Date()</code>获取当前系统时间。</li><li>SimpleDateFormat：将日期转换成指定格式的字符串<code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;)</code>E表示星期</li></ol><h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p>指Calendar类，Calendar是一个抽象类，构造器使用private修饰。可以通过getInstance()获取实例。Calendar没有专门的格式化方法，需要自己组合显示。</p><ol><li><code>Calendar c = Calendar.getInstance()</code>创建日历类对象，包含Calendar字段</li><li>获取日历：</li></ol><blockquote><p>c.get(Calendar.YEAR)</p><p>c.get(Calendar.MONTH) + 1 &#x2F;&#x2F; 月默认从0开始</p><p>c.get(Calendar.DAY_OF_MONTH)</p><p>c.get(Calendar.HOUR)</p><p>c.get(Calendar.MINUTE)</p><p>c.get(Calendar.SECOND)</p></blockquote><h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>为了改善前两代日期类的不足，在jdk8中推出了第三代日期类</p><ol><li>LocalDate：年月日</li><li>LocalTime：时分秒</li><li>LocalDateTime：日期+时间</li></ol><blockquote><p>LocalDateTime ldt &#x3D; LoaclDateTime.now()</p><p>ldt.getYear()</p><p>ldt.getMonthValue()</p><p>ldt.getDayOfMonth()</p><p>ldt.getHour()</p><p>ldt.getMinute()</p><p>ldt.getSecond()</p></blockquote><ol start="4"><li>SimpleDateFormat：格式日期类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LoaclDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format();</span><br></pre></td></tr></table></figure><ol start="5"><li>plus系列方法：<code>plusDay</code>、<code>plusMinutes</code>等方法，可以查看多少天&#x2F;分钟后的日期是什么</li><li>minus系列方法：可以查看给定时间之前的日期是什么</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>​泛型是一种在设计和使用类、接口和方法时，允许更广泛地操作各种数据类型的机制。泛型提供了一种在代码中使用一般类型而不是具体类型的方式，在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值类型、参数类型，这样可以提高代码的重用性、可读性和类型安全性，使用任何字母都可以，通常使用<code>&lt;E&gt;</code>、<code>&lt;T&gt;</code>、<code>&lt;K&gt;</code>表示。Java的源码中使用了大量泛型以提高代码复用性。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Test&lt;Integer&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(<span class="number">1</span>);<span class="comment">// 使用Integer代替E</span></span><br><span class="line">        System.out.println(test.function()); <span class="comment">// 返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt;&#123;</span><br><span class="line">T s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(T s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t, R r)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>给泛型指定数据类型时，只能使用引用类型，不能是基本数据类型</li><li>在给泛型指定具体类型时，可以传入该类型或者该类型的子类型</li><li>使用泛型的数组不能初始化（因为不知道这里要用什么样的类型，不知道要开多大空间）</li><li>静态属性和静态方法中不能使用泛型（因为静态是和类相关的，在类加载时，对象还没有创建，如果静态属性和静态方法使用了泛型，JVM就无法完成初始化）</li><li>泛型方法可以在普通类中，也可以在泛型类中</li><li>如果创建类时没有指定类型，默认为Object</li><li>若在接口类中使用泛型，类型在继承接口或者实现接口时确定</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IUsb</span>&lt;U, R&gt;&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    R <span class="title function_">get</span><span class="params">(U u)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(R r)</span>;</span><br><span class="line">    <span class="keyword">default</span> R <span class="title function_">method</span><span class="params">(U u)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> <span class="keyword">extends</span> <span class="title class_">IUsb</span>&lt;String, Double&gt; &#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">implements</span> <span class="title class_">IUsb</span>&lt;String, Double&gt; &#123;......&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>泛型的通配符：<ul><li><code>&lt;?&gt;</code>代表支持任意泛型类型</li><li><code>&lt;? extends A&gt;</code>代表支持A类以及A的子类，规定了泛型类型的上限</li><li><code>&lt;? super A&gt;</code>代表支持A类以及A的父类，规定了泛型类型的下限</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（三）</title>
      <link href="/inori/9235e063.html"/>
      <url>/inori/9235e063.html</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>使用关键字enum代替class，默认会继承Enum类</li><li><code>public static final 类名 = new 类名(参数)</code>直接使用<code>类名(参数)</code>代替，这种语法会默认调用该类的构造器，如果有无参构造器可以不填参数</li><li>如果有多个常量对象，使用<code>,</code>间隔</li><li>创建的对象放在枚举类的行首</li><li>Enum类不可在外部创建对象，因为其构造器为私有</li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="center">方法名</th><th align="left">详细描述</th></tr></thead><tbody><tr><td align="center">valueOf</td><td align="left">通过字符串找到叫该名字的枚举对象，如果没找到会报异常</td></tr><tr><td align="center">toString</td><td align="left">返回枚举对象的名称，通常会在枚举类中重写该方法</td></tr><tr><td align="center">values</td><td align="left">隐藏在枚举类中的方法，返回一个数组，含有全部定义的枚举对象</td></tr><tr><td align="center">ordinal</td><td align="left">输出该枚举对象的定义次序，从0开始编号</td></tr><tr><td align="center">compareTo</td><td align="left">比较两个枚举对象，按照定义次序比较，返回前面的枚举常量编号减去后面的枚举常量编号</td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>使用enum关键字后不能继承其他类（enum会隐式的继承Enum类）</li><li>枚举类的普通类一样可以实现接口</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解(Annotation)也叫做元数据(Metadata)，用于解释包、类、方法、属性、构造器、局部变量等数据信息。注解不影响程序逻辑，但是可以被编译，相当于嵌入在代码中的补充信息。</p><h3 id="常用的注解符号"><a href="#常用的注解符号" class="headerlink" title="常用的注解符号"></a>常用的注解符号</h3><ol><li><p><code>@Override</code>重写某个父类方法，该注解只能用于方法</p></li><li><p><code>@Deprecated</code>表示某个程序元素已过时，即不推荐使用</p></li><li><p><code>@SuppressWarnings</code>抑制编译器警告，一般使用all，语法<code>@SuppressWarnings(&#123;&quot;all&quot;&#125;)</code></p></li><li><p><code>@interface</code>用于定义了注解类，之后用到再细说</p></li><li><p>元注解</p><ul><li><code>@Retention</code>指定注解的作用范围，有三种类型：<code>SOURCE</code>源码时，<code>CLASS</code>类中，<code>RUNTIME</code>运行时</li><li><code>@Target</code>指定注解可以在哪些地方使用</li><li><code>@Documented</code>指定该注解是否会在javadoc体现</li><li><code>@Inherited</code>子类继承父类的注解</li></ul></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>​在程序执行中发生的不正常行为称为异常，异常不是语法或逻辑错误。</p><p>​正常来说，当程序出现异常时，会立即终止，不会执行后面的代码，但是这样会导致因为一点小错误而耽误整个程序的执行。为了避免这种事情发生，引入异常处理机制进行异常处理，那么即使出现了异常，程序也可以继续执行。</p><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><ol><li>Error：JVM无法解决的严重问题。如：JVM系统内部错误，资源耗尽等严重情况。StackOverflowError、OutOfMemoryError等。Error属于严重错误，程序会崩溃。</li><li>Exception：其他外在因素导致的一般性问题，可以使用<code>try-catch</code>语句跳过避免程序崩溃。比如NullPointerException，ArithmeticException等。Exception分为<strong>运行时异常</strong>和<strong>编译时异常</strong>。</li></ol><h3 id="try-catch用法及注意事项"><a href="#try-catch用法及注意事项" class="headerlink" title="try-catch用法及注意事项"></a>try-catch用法及注意事项</h3><p><code>try-catch</code>类似于Python的<code>try-except</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>, num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> num1 / num2; <span class="comment">// 除0异常</span></span><br><span class="line">        <span class="comment">// 之后的代码不执行，直接进入到catch</span></span><br><span class="line">        <span class="comment">// 若try中没有异常，则不进入catch块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">System.out.println(e.getMessage());  <span class="comment">// 输出异常信息</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;  <span class="comment">// catch语句可以有多个,子类异常在前，父类在后</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">// finally可加可不加</span></span><br><span class="line">        <span class="comment">// 如果加了意味无论try是否有异常，catch是否捕获了异常，都一定会执行finally中的语句</span></span><br><span class="line">        <span class="comment">// 通常将关闭资源的代码放在finally中</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="throws用法"><a href="#throws用法" class="headerlink" title="throws用法"></a>throws用法</h3><p>​如果一个方法中可能产生某种异常，但是不能确定如何处理这种异常，则可以显示地声明抛出异常，表示由该方法的<u>调用者</u>负责处理。</p><p>​throws可以声明抛出的异常列表，可以是异常类型或者异常的父类类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, Exception&#123;</span><br><span class="line">        FileInputStream fis;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d://aa.txt&quot;</span>);<span class="comment">// 不存在此文件会产生FileNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>对于编译异常，程序必须处理。对于运行异常，若程序不处理，默认使用throws向上抛出，直到抛到JVM处终止程序。</li><li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，抛出的异常要么和父类的异常一致，要么为父类抛出异常的子类。</li><li>如果有try-catch语句，就不必用throws</li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义一个异常，用于规定程序必须按照某个指定的逻辑来编写或运行。</p><h4 id="用法及注意事项"><a href="#用法及注意事项" class="headerlink" title="用法及注意事项"></a>用法及注意事项</h4><p>一般情况下，继承<code>RuntimeException</code>类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">50</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumException</span>(<span class="string">&quot;num is too big&quot;</span>);<span class="comment">// 抛出一个自定义异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throws与throw"><a href="#throws与throw" class="headerlink" title="throws与throw"></a>throws与throw</h2><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面接</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（二）</title>
      <link href="/inori/df2b4331.html"/>
      <url>/inori/df2b4331.html</url>
      
        <content type="html"><![CDATA[<h2 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h2><p>在类中定义的变量，加上<code>static</code>称为类变量，否则称为实例变量&#x2F;普通变量。</p><p>性质：</p><ol><li>类中使用<code>static</code>修饰的变量将会被所有同类共享。</li><li><code>static</code>类变量，在类加载时就生成了，不需要创建对象实例就可以访问（以该变量不是<code>private</code>修饰为前提）。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>什么时候需要使用类变量？</li></ol><p>  当我们需要让某个类的所有对象对共享一个变量时可以使用。</p><ol start="2"><li>类变量与实例变量的区别：</li></ol><p>  类变量是该类的所有对象共享的，而实例变量时每个对象独享的。</p><ol start="3"><li>类变量的生命周期随着类加载开始，随着类消亡而被销毁。</li></ol><h2 id="类方法（静态方法）"><a href="#类方法（静态方法）" class="headerlink" title="类方法（静态方法）"></a>类方法（静态方法）</h2><p>类似于类变量，就是在类中定义的方法前使用<code>static</code>修饰。</p><p>使用时不需要将类实例化，直接用类名.方法使用。</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>类方法和普通方法一样，随着类加载而加载，将结构信息存在方法区</li><li>类方法中无<code>this</code>参数，不能使用与对象有关的关键字，如<code>this</code>和<code>super</code>。</li><li>类方法只能访问静态变量和静态方法。</li><li>普通成员方法可以访问静态方法和普通方法。</li></ol><h2 id="理解main方法"><a href="#理解main方法" class="headerlink" title="理解main方法"></a>理解main方法</h2><blockquote><p>public static void main(String[] args){}</p></blockquote><ol><li>main方法由JVM调用</li><li>JVM需要调用类的main()方法，所以该方法的访问权限必须是public</li><li>JVM在执行main()方法时不需要创建对象，所以该方法必须是static</li><li>main方法会接受String类型的数组参数args，该数组中保存着执行java命令时传递给所运行的类的参数</li><li>main方法中想要访问非静态的变量和方法需要先实例化再用。</li></ol><h2 id="代码块的使用"><a href="#代码块的使用" class="headerlink" title="代码块的使用"></a>代码块的使用</h2><p>没有方法名的方法。使用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>或者什么都不写 &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  相当于另外一种形式的构造器，可以做初始化操作，在使用构造器之前会调 用代码块，也就是说优先级高于构造器内的代码。可以将多次出现的重复代码放到代码块中。</p><p>注：如果使用static修饰代码块，则总共只会调用一次。如果是普通代码块，则每创建一次这个类都会执行一次。</p><p>创建对象时，在类中的调用顺序：</p><ol><li>调用静态代码块和静态属性初始化</li><li>调用普通代码块和普通属性初始化</li><li>调用构造方法</li></ol><p>当创建一个子类对象时（继承父类），调用顺序为：</p><ol><li>父类的静态代码块和静态属性</li><li>子类的静态代码块和静态属性</li><li>父类的普通代码块和普通属性</li><li>父类的构造方法</li><li>子类的普通..</li><li>子类的构造方法</li></ol><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final可以修饰类、属性、方法和局部变量，final修饰的属性又叫做常量。</p><p>用法：</p><ol><li>当不希望类被继承时。</li><li>当不希望父类的某个方法被子类覆盖或重写时。</li><li>当不希望类的某个属性的值被修改时。</li><li>当不希望某个局部变量被修改时。</li></ol><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>final修饰的属性一般用XX_XX_XX命名（大写，字母间使用下划线隔开）</p></li><li><p>final属性在定义时必须赋初值，赋值的位置可以在：</p><ul><li><p>定义时直接赋值</p></li><li><p>在构造器中赋值（仅限非static）</p></li><li><p>在代码块中赋值（static时使用静态代码块）</p></li></ul></li><li><p>如果一个类已经是final类了，其中的属性和方法就不要用final修饰了</p></li><li><p>final不能修饰构造器</p></li><li><p>final往往与static一起使用，效率更高，不会导致类加载</p></li><li><p>包装类（Integer、Double、Float、Boolean等）都是使用final修饰的，不可被继承</p></li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>​当在父类中声明了一个方法，但是不知道该如何实现时，就可以不实现，而是把该方法声明为一个抽象方法，同时该类变成一个抽象类。</p><ol><li>用abstract关键字来修饰一个类&#x2F;方法时，这个类就叫做抽象类&#x2F;方法</li><li>抽象类的价值更多作用在于设计，是设计者设计好后，让子类继承并实现抽象类</li><li>抽象类不能被实例化</li><li>抽象方法一定在抽象类中，但是抽象类不一定有抽象方法</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也是抽象类</li><li>抽象方法不能使用private、final和static修饰，因为这三个关键字都与重写相违背（用这三个关键字修饰方法不许被修改）</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  <span class="comment">//抽象类不能有主体&quot;&#123;&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是给出一些没有实现的方法，封装到一起，当某个类要用时，根据具体情况把接口中的方法写出来。</p><p>java8之后，接口中可以有方法的具体实现，但是非静态方法需要使用<code>default</code>修饰。</p><p><strong>接口中的方法都默认使用<code>public abstract</code>修饰，属性默认使用<code>public static final</code>修饰。</strong></p><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">XXX</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">XXXX</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要用到接口时</span></span><br><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>接口不能被实例化（同抽象类）</li><li>一个类可以同时实现多个接口</li></ol><blockquote><p>class X implements Y, Z {}</p></blockquote><ol start="3"><li>接口不能继承类，但是可以继承其他接口(接口与接口之间是继承关系，接口与类之间是实现关系)</li></ol><blockquote><p>interface A extends B, C {}</p></blockquote><ol start="4"><li>接口的修饰符只能是public和默认</li></ol><h4 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h4><p>​当子类继承父类时，自动拥有父类的功能。但因为一个子类只能继承一个父类，如果子类需要扩展功能，就可以通过实现接口的方式扩展。<u>可以理解为实现接口是对java单继承机制的扩展。</u></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类的内部又完整的嵌套了另一个类，被嵌套的类叫做内部类。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类定义在外部类的局部位置，通常在方法或代码块中，有类名。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>可以直接访问外部类的全部成员，包括私有</li><li>不能添加访问修饰符，因为局部内部类的地位相当于一个局部变量。但是可以用final修饰</li><li>作用域：在定义它的方法或代码块中</li><li>外部类想访问局部内部类的成员需要先new一个再访问</li><li>如果外部类中成员和局部内部类中成员重名，访问时使用就近原则，如果想访问外部类，可以使用<code>外部类.this.成员</code>访问</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>​匿名内部类没有类名（但是底层实现的时候有名字），不仅是一个类，还是一个对象，所有它同时拥有类和对象的特性，可以当做实参直接传递。</p><p>特点与局部内部类类似。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类或接口 变量名 = <span class="keyword">new</span> 类或接口(参数)&#123;</span><br><span class="line"><span class="comment">// 类体</span></span><br><span class="line">&#125;;</span><br><span class="line">变量名.方法名();</span><br><span class="line"><span class="comment">// -----------或者--------------</span></span><br><span class="line"><span class="keyword">new</span> 类或接口(参数)&#123;</span><br><span class="line">    <span class="comment">// 类体</span></span><br><span class="line">&#125;.方法名();</span><br></pre></td></tr></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类定义在外部类的成员位置，没有static修饰。其定位是一个类成员，可以添加任意修饰符。并且作用域为整个外部类体。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>假设<code>Outer</code>类中有一个名为<code>Inner</code>的成员内部类，当外部其他类想使用成员内部时：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inn</span> <span class="operator">=</span> out.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：在Outer类中声明一个方法，可以返回Inner对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    .....;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inn</span> <span class="operator">=</span> out.getInnerInstance();</span><br></pre></td></tr></table></figure><p>其他使用方式跟其他内部类相同。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是在成员内部类的基础上，有static修饰，有内部类和静态方法的全部特性。</p><p>当外部其他类想访问静态内部类时,因为是静态的，所以不需要实例化，通过类名直接访问：</p><blockquote><p>Inner inn &#x3D; new Outer.Inner();</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（一）</title>
      <link href="/inori/ef3dafe9.html"/>
      <url>/inori/ef3dafe9.html</url>
      
        <content type="html"><![CDATA[<h2 id="idea常用快捷键"><a href="#idea常用快捷键" class="headerlink" title="idea常用快捷键"></a>idea常用快捷键</h2><ol><li><p>Ctrl + Alt + L  格式化</p></li><li><p>Shift + F10  编译运行</p></li><li><p>Alt + Insert  插入构造器</p></li><li><p>Ctrl + H  显示继承关系</p></li><li><p>Alt+Enter  new完对象后可以直接分配变量名</p></li></ol><h2 id="idea-断点调试"><a href="#idea-断点调试" class="headerlink" title="idea 断点调试"></a>idea 断点调试</h2><ol><li>跳入（F7): 跳入方法内（可以查看JDK原码）</li><li>跳过（F8): 逐行执行代码</li><li>跳出（shift+F8)：跳出方法</li><li>继续（F9)：跳到下一个断点</li></ol><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>JUnit是一个Java语言的单元测试框架，多数Java的开发环境已经继承了JUnit作为单元测试工具。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>​如果在编写主方法时添加了很多非静态的方法，则在逐个测试方法时需要在main()函数中挨个new出来，再逐个测试。这样做非常的麻烦，可以点击<code>Alt + Enter</code>安装JUnit框架，在需要测试的方法上加<code>@Test</code>标识，则该方法前面会出现绿色的运行按钮，这样不需要在main()函数中声明也可以快速执行方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// new Test().m1();</span></span><br><span class="line">        <span class="comment">// new Test().m2();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 is Testing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 is Testing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h2><p>包本质就是文件夹，创建不同的文件夹&#x2F;目录来保存类文件。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>区分相同名字的类</li><li>更好的管理类</li><li>控制访问范围</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>package 文件夹名.文件夹名…</p></blockquote><p>在import上面写，使用idea时会自动添加。</p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table><thead><tr><th align="center">访问级别</th><th align="center">访问控制修饰符</th><th align="center">同类</th><th align="center">同包</th><th align="center">子类</th><th align="center">不同包</th></tr></thead><tbody><tr><td align="center">公开</td><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">受保护</td><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">默认</td><td align="center">无修饰符</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">私有</td><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>封装、继承、多态</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>​封装（encapsulation）就是把抽象出的属性和方法封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作[方法]，才能对数据进行操作。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li><p>将属性私有化</p></li><li><p>提供一个public的类set方法，用于对属性判断并赋值</p></li><li><p>提供一个public的类get方法，用于获取属性的值</p></li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>​当两个类的属性和方法有很多相同部分时，需要继承。即当多个类存在相同的属性和方法时，可以抽象出父类，在父类中定义这些相同的属性和方法，子类不需要重新定义这些属性和方法，只需要通过<code>extends</code>来声明继承。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>提高代码复用性</li><li>提高代码扩展性和可维护性</li></ol><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 子类 extends 父类&#123;</span><br><span class="line"><span class="comment">// 类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>子类自动拥有父类定义的属性和方法</li><li>父类又叫超类，基类</li><li>子类又叫派生类</li><li>一个子类只能有一个直接父类（只能继承一个类），但是可以有很多祖宗类（父类又继承了一个超类，那个超类又继承了一个超类……)</li><li>子类必须调用父类的构造器， 完成父类的初始化</li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器。如果父类没有提供无参构造器，则必须在子类的构造器中用<code>super</code>去指定使用父类的哪个构造器完成对父类的初始化工作</li><li><code>super</code>和<code>this</code>都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>java所有类都是<code>Object</code>类的子类,<code>Object</code>是所有类的基类</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态,多态是建立在封装和继承基础之上的。</p><h4 id="具体体现"><a href="#具体体现" class="headerlink" title="具体体现"></a>具体体现</h4><ol><li>方法的多态（重载和重写等）</li><li>对象的多态<ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时即确定，运行类型可以变化。</li></ul></li></ol><h4 id="对象的向上转型"><a href="#对象的向上转型" class="headerlink" title="对象的向上转型"></a>对象的向上转型</h4><p>父类的引用指向子类的对象</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li><p>可以调用父类中所有成员（遵守访问权限）</p></li><li><p>不能调用子类特有的方法（编译阶段能调用哪些成员，由编译类型决定）</p></li><li><p>最终运行效果看子类(运行类型)的具体实现，即调用方法时，按照从子类（运行类型）开始查找方法。</p></li></ol><h4 id="对象的向下转型"><a href="#对象的向下转型" class="headerlink" title="对象的向下转型"></a>对象的向下转型</h4><p>父类对象转换成子类对象。与向上转型不同，向下转型是不安全的</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">// 编译类型是A，运行类型是B</span></span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">C</span>(); <span class="comment">// 编译类型是A，运行类型是C</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B)a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><ol><li><p>当调用对象方法时，该方法会和该对象的内存地址（运行类型）绑定</p></li><li><p>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用。</p></li></ol><p>补充：<code>instanceOf</code>是比较操作符，用于判断对象的运行类型是否为某类型或某类型的子类型。</p><h2 id="类的五大成员"><a href="#类的五大成员" class="headerlink" title="类的五大成员"></a>类的五大成员</h2><p><strong>属性、方法、构造器、代码块、内部类</strong></p><h3 id="属性-成员变量-字段"><a href="#属性-成员变量-字段" class="headerlink" title="属性&#x2F;成员变量&#x2F;字段"></a>属性&#x2F;成员变量&#x2F;字段</h3><p>就是类中定义的变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>属性的定义方法用变量：<code>访问修饰符 属性类型 属性名</code></li><li>属性如果不赋值会使用默认值。<code>byte、short、int、long</code>赋0，<code>float、double</code>赋0.0，<code>char</code>赋\u0000，<code>boolean</code>赋false，<code>String</code>赋null。</li></ol><h3 id="方法-成员方法"><a href="#方法-成员方法" class="headerlink" title="方法&#x2F;成员方法"></a>方法&#x2F;成员方法</h3><p>就是类中定义的函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSalary</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载(overload)"></a>方法重载(overload)</h4><p>java中允许同一个类中，多个同名方法的存在，但要求形参不一致(变量类型或者变量数量)</p><ol><li>减轻了起名的麻烦</li><li>减轻了记名的麻烦</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalculator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">double</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculator</span><span class="params">(<span class="type">double</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2,<span class="type">int</span> n3)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2 + n3;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重写-override"><a href="#方法重写-override" class="headerlink" title="方法重写(override)"></a>方法重写(override)</h4><ol><li><p>即在子类中重新写一遍父类中的方法，需要和父类方法的参数，名称完全一样</p></li><li><p>返回类型要么一样，要么是父类返回类型的子类，比如<code>Object -&gt; String</code></p></li><li><p>子类方法的访问权限必须大于等于父类方法</p></li></ol><h4 id="方法重载与重写的区别"><a href="#方法重载与重写的区别" class="headerlink" title="方法重载与重写的区别"></a>方法重载与重写的区别</h4><table><thead><tr><th align="center">名称访问</th><th align="center">范围</th><th align="center">方法名</th><th align="center">形参</th><th align="center">返回类型</th><th align="center">修饰符</th></tr></thead><tbody><tr><td align="center">重载</td><td align="center">本类</td><td align="center">相同</td><td align="center">类型、个数或者顺序至少有一个不同</td><td align="center">随意</td><td align="center">随意</td></tr><tr><td align="center">重写</td><td align="center">protected</td><td align="center">相同</td><td align="center">相同</td><td align="center">一致或子类</td><td align="center">大于等于父类</td></tr></tbody></table><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>构造器是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</li><li>如果一个类不写构造器，则默认会有一个无参构造器</li><li>构造器的调用自动完成</li></ol><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问修饰符] 方法名(形参列表)&#123; </span><br><span class="line">     方法体;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>接下来见<a href="/inori/df2b4331">java基础入门（二）</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题.2</title>
      <link href="/inori/3b25fa04.html"/>
      <url>/inori/3b25fa04.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode每日一题"><a href="#LeetCode每日一题" class="headerlink" title="LeetCode每日一题"></a>LeetCode每日一题</h1><p>​今天的每日一题是<a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a>，简单题，直接做。</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出：false</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出：false</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出：true</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>把字符串中每一个字符映射到哈希表上，统计数字，如果ransomNote中的对应字母数量小于magazine就可以返回true。</p><p>优化点：如果ransomNote长度大于magazine了，则直接返回false。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.length() &gt; magazine.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">            map1.put(c, map1.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">            map2.put(c, map2.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> key : map1.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map2.containsKey(key) || map2.get(key) &lt; map1.get(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ransomNote) &gt; <span class="built_in">len</span>(magazine):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tab1, tab2 = Counter(ransomNote), Counter(magazine)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> tab1:</span><br><span class="line">            <span class="keyword">if</span> tab2[key] &lt; tab1[key]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(m+n)，n和m是两个字符串的长度。</li><li>空间复杂度：O(s)，s为字符数量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第379场周赛</title>
      <link href="/inori/d63cc9f2.html"/>
      <url>/inori/d63cc9f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode第379场周赛"><a href="#LeetCode第379场周赛" class="headerlink" title="LeetCode第379场周赛"></a>LeetCode第379场周赛</h1><p>​这场比赛感觉来恶心人的，一堆边界条件，又让我疯狂WA，简单题也WA，受不了了。</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>dimensions</code>。</p><p>对于所有下标 <code>i</code>（<code>0 &lt;= i &lt; dimensions.length</code>），<code>dimensions[i][0]</code> 表示矩形 <code>i</code> 的长度，而 <code>dimensions[i][1]</code> 表示矩形<code>i</code>的宽度。</p><p>返回对角线最<strong>长</strong>的矩形的<strong>面积</strong>。如果存在多个对角线长度相同的矩形，返回面积最<strong>大</strong>的矩形的面积。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：dimensions &#x3D; [[9,3],[8,6]]<br>输出：48<br>解释：<br>下标 &#x3D; 0，长度 &#x3D; 9，宽度 &#x3D; 3。对角线长度 &#x3D; sqrt(9 * 9 + 3 * 3) &#x3D; sqrt(90) ≈ 9.487。<br>下标 &#x3D; 1，长度 &#x3D; 8，宽度 &#x3D; 6。对角线长度 &#x3D; sqrt(8 * 8 + 6 * 6) &#x3D; sqrt(100) &#x3D; 10。<br>因此，下标为 1 的矩形对角线更长，所以返回面积 &#x3D; 8 * 6 &#x3D; 48。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：dimensions &#x3D; [[3,4],[4,3]]<br>输出：12<br>解释：两个矩形的对角线长度相同，为 5，所以最大面积 &#x3D; 12。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= dimensions.length &lt;= 100</code></li><li><code>dimensions[i].length == 2</code></li><li><code>1 &lt;= dimensions[i][0], dimensions[i][1] &lt;= 100</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>又是阅读理解题。</p><p>注意最后一句：如果存在多个对角线长度相同的矩形，返回面积最<strong>大</strong>的矩形的面积。这就需要特判一下了，如果对角线等于当前最大值就更新矩形面积。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">areaOfMaxDiagonal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dimensions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> nums: dimensions)&#123;</span><br><span class="line">            <span class="type">int</span> a = nums[<span class="number">0</span>], b = nums[<span class="number">1</span>];</span><br><span class="line">            <span class="type">double</span> tmp = <span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; s)&#123;<span class="comment">// 当对角线大时直接更新ans</span></span><br><span class="line">                s = tmp;</span><br><span class="line">                ans = a * b;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp == s)&#123;<span class="comment">// 相等时再判断最值</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, a * b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">areaOfMaxDiagonal</span><span class="params">(<span class="type">int</span>[][] dimensions)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] nums: dimensions)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> nums[<span class="number">0</span>], b = nums[<span class="number">1</span>];</span><br><span class="line">            <span class="type">double</span> <span class="variable">tmp</span> <span class="operator">=</span> Math.sqrt(a * a + b * b);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; s)&#123;<span class="comment">// 当对角线大时直接更新ans</span></span><br><span class="line">                s = Math.sqrt(a * a + b * b);</span><br><span class="line">                ans = a * b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp == s)&#123;<span class="comment">// 相等时再判断最值</span></span><br><span class="line">                ans = Math.max(ans, a * b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">areaOfMaxDiagonal</span>(<span class="params">self, dimensions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> dimensions:</span><br><span class="line">            tmp = sqrt(a * a + b * b)</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; s:</span><br><span class="line">                s = tmp</span><br><span class="line">                ans = a * b</span><br><span class="line">            <span class="keyword">elif</span> tmp == s:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, a * b)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)，n为数组长度。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>现有一个下标从 <strong>0</strong> 开始的 <code>8 x 8</code> 棋盘，上面有 <code>3</code> 枚棋子。</p><p>给你 <code>6</code> 个整数 <code>a</code> 、<code>b</code> 、<code>c</code> 、<code>d</code> 、<code>e</code> 和 <code>f</code> ，其中：</p><ul><li><code>(a, b)</code> 表示白色车的位置。</li><li><code>(c, d)</code> 表示白色象的位置。</li><li><code>(e, f)</code> 表示黑皇后的位置。</li></ul><p>假定你只能移动白色棋子，返回捕获黑皇后所需的<strong>最少</strong>移动次数。</p><p><strong>请注意</strong>：</p><ul><li>车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。</li><li>象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。</li><li>如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。</li><li>皇后不能移动。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/12/21/ex1.png" alt="img"></p><blockquote><p>输入：a &#x3D; 1, b &#x3D; 1, c &#x3D; 8, d &#x3D; 8, e &#x3D; 2, f &#x3D; 3<br>输出：2<br>解释：将白色车先移动到 (1, 3) ，然后移动到 (2, 3) 来捕获黑皇后，共需移动 2 次。<br>由于起始时没有任何棋子正在攻击黑皇后，要想捕获黑皇后，移动次数不可能少于 2 次。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/12/21/ex2.png" alt="img"></p><blockquote><p>输入：a &#x3D; 5, b &#x3D; 3, c &#x3D; 3, d &#x3D; 4, e &#x3D; 5, f &#x3D; 2<br>输出：1<br>解释：可以通过以下任一方式移动 1 次捕获黑皇后：</p><ul><li>将白色车移动到 (5, 2) 。</li><li>将白色象移动到 (5, 2) 。</li></ul></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a, b, c, d, e, f &lt;= 8</code></li><li>两枚棋子不会同时出现在同一个格子上。</li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>恶心人的题，分类讨论。</p><ol><li><p>如果车能直接攻击到皇后，或者象能直接攻击到皇后，那么返回1。</p></li><li><p>如果车被象挡住，那么移走象，车就可以攻击到皇后，返回2。</p></li><li><p>如果象被车挡住，那么移走车，象就可以攻击到皇后，返回2。</p></li><li><p>如果车不能直接攻击到皇后，那么车可以水平移动或者垂直移动，其中一个位置必定不会被象挡住，可以攻击到皇后，返回2。</p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMovesToCaptureTheQueen</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span>, c: <span class="built_in">int</span>, d: <span class="built_in">int</span>, e: <span class="built_in">int</span>, f: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="number">9</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="number">9</span> <span class="keyword">and</span> j &lt; <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a == e <span class="keyword">and</span> a != c): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(b == f <span class="keyword">and</span> b != d): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(a == c <span class="keyword">and</span> a == e <span class="keyword">and</span> <span class="built_in">abs</span>(b - f) != <span class="built_in">abs</span>(b - d) + <span class="built_in">abs</span>(d - f)): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(b == d <span class="keyword">and</span> b == f <span class="keyword">and</span> <span class="built_in">abs</span>(a - e) != <span class="built_in">abs</span>(a - c) + <span class="built_in">abs</span>(c - e)): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：<code>O(9 * 4) = O(1)</code>。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们的长度都是偶数<code> n</code> 。</p><p>你必须从 <code>nums1</code> 中移除 <code>n / 2</code> 个元素，同时从 <code>nums2</code> 中也移除 <code>n / 2</code> 个元素。移除之后，你将 <code>nums1</code> 和 <code>nums2</code> 中剩下的元素插入到集合 <code>s</code> 中。</p><p>返回集合 <code>s</code>可能的 <strong>最多</strong> 包含多少元素。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,2,1,2], nums2 &#x3D; [1,1,1,1]<br>输出：2<br>解释：从 nums1 和 nums2 中移除两个 1 。移除后，数组变为 nums1 &#x3D; [2,2] 和 nums2 &#x3D; [1,1] 。因此，s &#x3D; {1,2} 。<br>可以证明，在移除之后，集合 s 最多可以包含 2 个元素。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [2,3,2,3,2,3]<br>输出：5<br>解释：从 nums1 中移除 2、3 和 6 ，同时从 nums2 中移除两个 3 和一个 2 。移除后，数组变为 nums1 &#x3D; [1,4,5] 和 nums2 &#x3D; [2,3,2] 。因此，s &#x3D; {1,2,3,4,5} 。<br>可以证明，在移除之后，集合 s 最多可以包含 5 个元素。 </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,1,2,2,3,3], nums2 &#x3D; [4,4,5,5,6,6]<br>输出：6<br>解释：从 nums1 中移除 1、2 和 3 ，同时从 nums2 中移除 4、5 和 6 。移除后，数组变为 nums1 &#x3D; [1,2,3] 和 nums2 &#x3D; [4,5,6] 。因此，s &#x3D; {1,2,3,4,5,6} 。<br>可以证明，在移除之后，集合 s 最多可以包含 6 个元素。 </p></blockquote><p><strong>提示：</strong></p><ul><li><code>n == nums1.length == nums2.length</code></li><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li><li><code>n</code>是偶数。</li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^9</code></li></ul><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>这题一看，好像很难，但其实就是简单的求交集，数学找规律求方程即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSetSize</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums1)&#123;</span><br><span class="line">            set1.add(i);    <span class="comment">// nums1的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums2)&#123;</span><br><span class="line">            set2.add(i);    <span class="comment">// nums2的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(set1);</span><br><span class="line">        set.addAll(set2);   <span class="comment">// set1和set2的并集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, set1.size() - n / <span class="number">2</span>), x2 = Math.max(<span class="number">0</span>, set2.size() - n / <span class="number">2</span>);   <span class="comment">// nums1和nums2仍需要删除的数的数量</span></span><br><span class="line">        <span class="keyword">if</span>(x1 == <span class="number">0</span> &amp;&amp; x2 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> set.size();  <span class="comment">// 如果不需要删除了，就直接返回两者的并集的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(set1);</span><br><span class="line">        s.retainAll(set2);  <span class="comment">// 两者的交集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Math.min(<span class="number">0</span>, s.size() - x1 - x2);    <span class="comment">// 通过统计找到的规律，先从两者交集中移除元素，如果够用了x=0，不够的话x&lt;0,然后再从两者的并集中移除元素。</span></span><br><span class="line">        <span class="keyword">return</span> set.size() + x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumSetSize</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums1)</span><br><span class="line">        s1, s2 = <span class="built_in">set</span>(nums1), <span class="built_in">set</span>(nums2)</span><br><span class="line">        x1, x2 = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1) - n // <span class="number">2</span>), <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">len</span>(s2) - n // <span class="number">2</span>) <span class="comment"># nums1和nums2仍需要删除的数的数量</span></span><br><span class="line">        <span class="keyword">if</span> (x1 == <span class="number">0</span> <span class="keyword">and</span> x2 == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(s1 | s2)<span class="comment"># 如果不需要删除了，就直接返回两者的并集的长度</span></span><br><span class="line">        </span><br><span class="line">        s = s1 &amp; s2</span><br><span class="line">        x = <span class="built_in">min</span>(<span class="built_in">len</span>(s) - x1 - x2, <span class="number">0</span>) <span class="comment"># 通过统计找到的规律，先从两者交集中移除元素，如果够用了x=0，不够的话x&lt;0,然后再从两者的并集中移除元素。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s1 | s2) + x</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：<code>O(n * 4) = O(n)</code>，定义了4个哈希集合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第121场双周赛</title>
      <link href="/inori/6b6c0081.html"/>
      <url>/inori/6b6c0081.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode第121场双周赛"><a href="#LeetCode第121场双周赛" class="headerlink" title="LeetCode第121场双周赛"></a>LeetCode第121场双周赛</h1><p>​每次这么晚打比赛脑子都要抽风，这次周赛疯狂WA，第一道简单题更是WA了4次，受不了了。每次打比赛我都是能AC三题就是胜利，第四题看一眼题干，能看懂就做，看不懂就不做了，这次确实是A掉三题，只不过罚时了很久就是了…</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>如果一个前缀 <code>nums[0..i]</code> 满足对于 <code>1 &lt;= j &lt;= i</code> 的所有元素都有 <code>nums[j] = nums[j - 1] + 1</code> ，那么我们称这个前缀是一个 <strong>顺序前缀</strong> 。特殊情况是，只包含 <code>nums[0]</code> 的前缀也是一个 <strong>顺序前缀</strong> 。</p><p>请你返回 <code>nums</code> 中没有出现过的 <strong>最小</strong> 整数 <code>x</code> ，满足 <code>x</code> 大于等于 <strong>最长</strong> 顺序前缀的和。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [1,2,3,2,5]<br>输出：6<br>解释：nums 的最长顺序前缀是 [1,2,3] ，和为 6 ，6 不在数组中，所以 6 是大于等于最长顺序前缀和的最小整数。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums &#x3D; [3,4,5,1,12,14,13]<br>输出：15<br>解释：nums 的最长顺序前缀是 [3,4,5] ，和为 12 ，12、13 和 14 都在数组中，但 15 不在，所以 15 是大于等于最长顺序前缀和的最小整数。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= 50</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>纯纯阅读理解题，我就是因为没理解到位WA了三次。</p><ol><li><p>必须<code>1 &lt;= j &lt;= i</code>之间的所有元素全都满足才算一个顺序前缀。并且**nums[0]**也算一个顺序前缀。</p></li><li><p>需要返回的是最长顺序前缀的和，并且这个和在数组中没出现过，如果出现过，就一直+1直到满足条件。</p></li></ol><p>明白了以上几点，再看数据范围：50，啥都不用想了，直接<code>n^2</code>暴力解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingInteger</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, s = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; hashSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            hashSet.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">1</span>, ts = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    tmp ++;</span><br><span class="line">                    ts += nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">// 如果不满足条件直接break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmp);</span><br><span class="line">            <span class="keyword">if</span>(ans == tmp)&#123;<span class="comment">// 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">                s = <span class="built_in">max</span>(s, ts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">50</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s; i &lt;= <span class="number">51</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.<span class="built_in">find</span>(i) == hashSet.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingInteger</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>, ts = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    tmp ++;</span><br><span class="line">                    ts += nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">// 如果不满足条件直接break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, tmp);</span><br><span class="line">            <span class="keyword">if</span>(ans == tmp) s = Math.max(s, ts);<span class="comment">// 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">50</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s; i &lt;= <span class="number">51</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingInteger</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, ans, s = <span class="built_in">len</span>(nums), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        hashSet = <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tmp, ts = <span class="number">1</span>, nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>:</span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">                    ts += nums[j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmp)</span><br><span class="line">            <span class="keyword">if</span> ans == tmp:<span class="comment"># 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">                s = <span class="built_in">max</span>(s, ts)</span><br><span class="line">        <span class="keyword">if</span> s &gt; <span class="number">50</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s, <span class="number">52</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hashSet:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n^2)，n为数组长度。</li><li>空间复杂度：O(n)，定义了一个哈希集合，最坏情况下有n个数。</li></ul><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p><p>你可以对数组执行以下操作 <strong>任意次</strong> ：</p><ul><li>选择数组里的 <strong>任意</strong> 一个元素，并将它的 <strong>二进制</strong> 表示 <strong>翻转</strong> 一个数位，翻转数位表示将 <code>0</code> 变成 <code>1</code> 或者将 <code>1</code> 变成 <code>0</code> 。</li></ul><p>你的目标是让数组里 <strong>所有</strong> 元素的按位异或和得到 <code>k</code> ，请你返回达成这一目标的 <strong>最少</strong> 操作次数。</p><p><strong>注意</strong>，你也可以将一个数的前导 0 翻转。比方说，数字 <code>(101)2</code> 翻转第四个数位，得到 <code>(1101)2</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [2,1,3,4], k &#x3D; 1<br>输出：2<br>解释：我们可以执行以下操作：</p><ul><li>选择下标为 2 的元素，也就是 3 &#x3D;&#x3D; (011)2 ，我们翻转第一个数位得到 (010)2 &#x3D;&#x3D; 2 。数组变为 [2,1,2,4] 。</li><li>选择下标为 0 的元素，也就是 2 &#x3D;&#x3D; (010)2 ，我们翻转第三个数位得到 (110)2 &#x3D;&#x3D; 6 。数组变为 [6,1,2,4] 。<br>最终数组的所有元素异或和为 (6 XOR 1 XOR 2 XOR 4) &#x3D;&#x3D; 1 &#x3D;&#x3D; k 。<br>无法用少于 2 次操作得到异或和等于 k 。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums &#x3D; [2,0,2,0], k &#x3D; 0<br>输出：0<br>解释：数组所有元素的异或和为 (2 XOR 0 XOR 2 XOR 0) &#x3D;&#x3D; 0 &#x3D;&#x3D; k 。所以不需要进行任何操作。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^6</code></li><li><code>0 &lt;= k &lt;= 10^6</code></li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>这道题看似很唬人，其实是纸老虎。</p><p>设nums的异或和为s。</p><p>令<code>s=k</code>就等于<code>s⊕k=0</code>。也就是把数组中所有数全部异或，令其为x，只需要比较x和k有多少位不一样即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            s ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        s ^= k;<span class="comment">// 想知道s和k有几位数不一样只需要异或一次后数1的个数即可</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s)&#123;</span><br><span class="line">            ans += s &amp; <span class="number">1</span>;</span><br><span class="line">            s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            s ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(s ^ k);<span class="comment">// 想知道s和k有几位数不一样只需要异或一次后数1的个数即可,bitCount方法可以直接获取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            s ^= i</span><br><span class="line">        <span class="keyword">return</span> (s ^ k).bit_count()</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)，n为数组长度。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>给你两个正整数 <code>x</code> 和 <code>y</code> 。</p><p>一次操作中，你可以执行以下四种操作之一：</p><ol><li>如果 <code>x</code> 是 <code>11</code> 的倍数，将 <code>x</code> 除以 <code>11</code> 。</li><li>如果 <code>x</code> 是 <code>5</code> 的倍数，将 <code>x</code> 除以 <code>5</code> 。</li><li>将 <code>x</code> 减 <code>1</code> 。</li><li>将 <code>x</code> 加 <code>1</code> 。</li></ol><p>请你返回让 <code>x</code> 和 <code>y</code> 相等的 <strong>最少</strong> 操作次数。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：x &#x3D; 26, y &#x3D; 1<br>输出：3<br>解释：我们可以通过以下操作将 26 变为 1 ：</p><ol><li>将 x 减 1</li><li>将 x 除以 5</li><li>将 x 除以 5<br>将 26 变为 1 最少需要 3 次操作。</li></ol></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：x &#x3D; 54, y &#x3D; 2<br>输出：4<br>解释：我们可以通过以下操作将 54 变为 2 ：</p><ol><li>将 x 加 1</li><li>将 x 除以 11</li><li>将 x 除以 5</li><li>将 x 加 1<br>将 54 变为 2 最少需要 4 次操作。</li></ol></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：x &#x3D; 25, y &#x3D; 30<br>输出：5<br>解释：我们可以通过以下操作将 25 变为 30 ：</p><ol><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1<br>将 25 变为 30 最少需要 5 次操作。</li></ol></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x, y &lt;= 10^4</code></li></ul><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>这题我第一眼看以为是模拟，仔细看了一下样例发现没有这么复杂，可以抽象成最短路问题，直接BFS即可。</p><p>这里有一点可以优化的方法：注意x想要增加只有+1这种方法，所有如果<code>y &gt;= x</code>时，直接返回<code>y - x</code>即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperationsToMakeEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        deque&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(x, <span class="number">0</span>));</span><br><span class="line">        visited.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="type">int</span> tmp = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(now);</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(now);</span><br><span class="line">            <span class="keyword">if</span> (tmp == y)&#123;</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">11</span> == <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp / <span class="number">11</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp / <span class="number">11</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp / <span class="number">11</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp / <span class="number">5</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp / <span class="number">5</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp / <span class="number">5</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp - <span class="number">1</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp - <span class="number">1</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp - <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">find</span>(tmp + <span class="number">1</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp + <span class="number">1</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp + <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperationsToMakeEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        ArrayDeque&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, <span class="number">0</span>&#125;);</span><br><span class="line">        set.add(x);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] now = q.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> now[<span class="number">0</span>], cnt = now[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmp == y) <span class="keyword">return</span> cnt;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">11</span> == <span class="number">0</span> &amp;&amp; !set.contains(tmp / <span class="number">11</span>))&#123;</span><br><span class="line">                set.add(tmp / <span class="number">11</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp / <span class="number">11</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; !set.contains(tmp / <span class="number">5</span>))&#123;</span><br><span class="line">                set.add(tmp / <span class="number">5</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp / <span class="number">5</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span> &amp;&amp; !set.contains(tmp - <span class="number">1</span>))&#123;</span><br><span class="line">                set.add(tmp - <span class="number">1</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp - <span class="number">1</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(tmp + <span class="number">1</span>))&#123;</span><br><span class="line">                set.add(tmp + <span class="number">1</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp + <span class="number">1</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumOperationsToMakeEqual</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> y &gt;= x:</span><br><span class="line">            <span class="keyword">return</span> y - x</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        q.append((x, <span class="number">0</span>))</span><br><span class="line">        visited.add(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp, cnt = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> tmp == y:</span><br><span class="line">                <span class="keyword">return</span> cnt</span><br><span class="line">            <span class="keyword">if</span> tmp % <span class="number">11</span> == <span class="number">0</span> <span class="keyword">and</span> tmp // <span class="number">11</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp // <span class="number">11</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp // <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp % <span class="number">5</span> == <span class="number">0</span> <span class="keyword">and</span> tmp // <span class="number">5</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp // <span class="number">5</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp // <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span> <span class="keyword">and</span> tmp - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp - <span class="number">1</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp + <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp + <span class="number">1</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(x)。</li><li>空间复杂度：O(x)，定义了一个哈希集合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题.1</title>
      <link href="/inori/7752405a.html"/>
      <url>/inori/7752405a.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode每日一题"><a href="#LeetCode每日一题" class="headerlink" title="LeetCode每日一题"></a>LeetCode每日一题</h1><p>​今天的每日一题是<a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/">2807. 在链表中插入最大公约数</a>，难度标的中等，不过我认为应该是简单题</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你一个链表的头 <code>head</code> ，每个结点包含一个整数值。</p><p>在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 <strong>最大公约数</strong> 。</p><p>请你返回插入之后的链表。</p><p>两个数的 <strong>最大公约数</strong> 是可以被两个数字整除的最大正整数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/07/18/ex1_copy.png" alt="img"></p><blockquote><p>输入：head &#x3D; [18,6,10,3]<br>输出：[18,6,6,2,10,1,3]<br>解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。</p><ul><li>18 和 6 的最大公约数为 6 ，插入第一和第二个结点之间。</li><li>6 和 10 的最大公约数为 2 ，插入第二和第三个结点之间。</li><li>10 和 3 的最大公约数为 1 ，插入第三和第四个结点之间。<br>所有相邻结点之间都插入完毕，返回链表。</li></ul></blockquote><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/07/18/ex2_copy1.png" alt="img"></p><blockquote><p>输入：head &#x3D; [7]<br>输出：[7]<br>解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。<br>没有相邻结点，所以返回初始链表。</p></blockquote><p><strong>提示：</strong></p><ul><li>链表中结点数目在 <code>[1, 5000]</code> 之间。</li><li><code>1 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>​这道题很直观，明显是考差欧几里得算法(辗转相除法)<code>gcd(a,b) = gcd(b,a mod b)</code>原理为：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。</p><p>​明白了考察的知识点，这道题就非常简单了，直接遍历链表，在每两个节点直接插入这两个节点的值的最大公约数<code>gcd(node1.val, node2.val)</code>即可，计算gcd的方法可以是 <code>Math.gcd</code>或者自定义方法。</p><p>​有一点需要注意，只有节点数大于1时才需要插入，否则直接返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">insertGreatestCommonDivisors</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = head, *ne = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(ne)&#123;</span><br><span class="line">            ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="built_in">gcd</span>(pre-&gt;val, ne-&gt;val), ne);</span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">            pre = ne;</span><br><span class="line">            ne = ne-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">insertGreatestCommonDivisors</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, ne = head.next;</span><br><span class="line">        <span class="keyword">while</span>(ne != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> gcd(pre.val, ne.val);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(g, ne);</span><br><span class="line">            pre.next = newNode;</span><br><span class="line">            pre = ne;</span><br><span class="line">            ne = ne.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertGreatestCommonDivisors</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">            <span class="keyword">return</span> a <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        pre, ne = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> ne:</span><br><span class="line">            node = ListNode(gcd(pre.val, ne.val), ne)</span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">            pre = ne</span><br><span class="line">            ne = ne.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(nlog⁡M)，其中n为链表长度，M是节点最大可能的值，每次计算要O(logM)的时间。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些碎碎念</title>
      <link href="/inori/303572a2.html"/>
      <url>/inori/303572a2.html</url>
      
        <content type="html"><![CDATA[<h3 id="2024-1-1"><a href="#2024-1-1" class="headerlink" title="2024.1.1"></a>2024.1.1</h3><p>​很久以前就想着搭一个个人博客，但是一直拖着没搞，昨天晚上闲来无事，突然想到这件事，一口气搞出来了。说是个人博客，主要是当我的笔记本用吧，博客里面很多东西都没弄懂，也没弄好。</p><p>​目标是缓慢且持续的更新，学啥更啥…</p><h3 id="2024-1-26"><a href="#2024-1-26" class="headerlink" title="2024.1.26"></a>2024.1.26</h3><p>​终于把期末考试的事搞完了，我认为研究生上的课，不对，应该是本科和研究生上的课不能说是毫无用处，只能说是屁用没有，占用自学的时间，在那坐着浪费时间，老师在课上讲一些已经与当前正在应用的技术脱节很久的老知识，关键是课程报告和结课论文还需要用这些东西，学这些东西以后又用不上，又要浪费一大段时间。唉</p><h3 id="2024-2-1"><a href="#2024-2-1" class="headerlink" title="2024.2.1"></a>2024.2.1</h3><p>​放寒假了，实验室布置了一堆任务，但是我自己还想要自学很多东西，好像放假比不放假还难受。现在开始继续学习并且更新博客了。</p><h3 id="2024-2-9"><a href="#2024-2-9" class="headerlink" title="2024.2.9"></a>2024.2.9</h3><p>​今天除夕，我依旧在学习，得完成自己给自己下定的目标才行，已经拖了好几天了，这两天把它非得干掉。但是在家学不下去啊，学几分钟就想玩，一玩一小时就过去了…太浮躁了，不知道怎么改正，只能是硬学了。</p><h3 id="2024-3-23"><a href="#2024-3-23" class="headerlink" title="2024.3.23"></a>2024.3.23</h3><p>​最近跟组里的师兄聊了聊，感觉写小论文要提上日程了，但是我强化学习还没入门…目前打算学完Redis就开始全力进攻强化学习（目前学到SSM），直到写完小论文和搭好大论文框架，争取今年可以写完，明年找实习。</p><h3 id="2024-5-8"><a href="#2024-5-8" class="headerlink" title="2024.5.8"></a>2024.5.8</h3><p>​压力好大，组里的横向好多，我身上压着三个任务，再加上科研和开发，真的喘不过气……目前科研仍然还没开始，当初想着学完redis就开始，现在springCloud快学完了还没开始，再拖一阵吧，，，导师也不放实习，科研之后慢慢搞</p><h3 id="2024-5-18"><a href="#2024-5-18" class="headerlink" title="2024.5.18"></a>2024.5.18</h3><p>​找工作技术的学习我感觉可以告一段落了，剩下Redis后面的高级篇和原理篇还没学，JVM和JUC还没学，Spring底层原理还没学，做的几个项目还没有整合……这些我感觉不用提前学，因为后续需要读论文搞科研，等我搞完小论文可能学的这些也都忘了…所以我打算从明天开始搞科研，争取今年把小论文写完，大论文框架搭好，然后再学上面的知识点。就这么办吧</p><h3 id="2024-8-6"><a href="#2024-8-6" class="headerlink" title="2024.8.6"></a>2024.8.6</h3><p>​好久没更新了，最近开摆了…论文读不下去，idea想不出来，开题报告也写的依托答辩，想混到毕业回去找个2,3k的工作躺平算了</p><h3 id="2025-2-17"><a href="#2025-2-17" class="headerlink" title="2025.2.17"></a>2025.2.17</h3><p>​小论文写完了，今年要着手找实习找工作了，博客继续开更！就当鼓励自己学习了！</p><h3 id="2025-3-5"><a href="#2025-3-5" class="headerlink" title="2025.3.5"></a>2025.3.5</h3><p>​周围同学好多都开始投实习了，有些都已经找到了，我发现我以前学的好多都忘了，而且还差一些没学，进度差不少，抓点紧吧……</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/inori/4a17b156.html"/>
      <url>/inori/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>费了不少劲！终于把我的博客搭好了！</p><h3 id="所用技术"><a href="#所用技术" class="headerlink" title="所用技术"></a>所用技术</h3><p>​本网站使用GitHub后端+Hexo框架+Butterfly渲染，并在基础上做出了一小部分魔改，加了些花里胡哨的东西，域名在阿里云选购。</p><hr><p>​就说这么多吧，后续我争取做到把每日学到的东西做一个总结，更新在这里，希望可以用这种方法来加深我对知识的理解与记忆。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
