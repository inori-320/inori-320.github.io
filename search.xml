<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见问题汇总（持续更新中）</title>
      <link href="/inori/c92e9465.html"/>
      <url>/inori/c92e9465.html</url>
      
        <content type="html"><![CDATA[<h2 id="你项目中用到了哪些设计模式"><a href="#你项目中用到了哪些设计模式" class="headerlink" title="你项目中用到了哪些设计模式"></a>你项目中用到了哪些设计模式</h2><p>在线程池的创建，Zookeeper客户端的创建使用到的单例模式，避免重复创建</p><p>创建序列化器，编解码器用到了工厂模式，根据用户配置创建不同的序列化方式</p><p>在实现不同序列化方式的时候用到了策略模式，把不同序列化方式封装成一个策略，实现统一接口</p><p>小程序项目中使用注解+AOP实现权限控制，本质是基于代理方法在方法调用前做拦截，用到了代理模式</p><p>在RPC框架中注册中心监听节点变化用到了观察者模式</p><h2 id="Spring中用到了哪些设计模式"><a href="#Spring中用到了哪些设计模式" class="headerlink" title="Spring中用到了哪些设计模式"></a>Spring中用到了哪些设计模式</h2><p>Bean的创建是单例的，用到了单例模式</p><p>Bean的管理使用的BeanFactory，用到了工厂模式</p><p>Bean的注入用到了原型模式，每次注入新实例</p><p>通用逻辑的封装，比如JdbcTemplate，用到了模板方法模式</p><p>Spring事件监听机制用到了观察者模式</p><p>SpringMVC的拦截器、过滤器链用到了责任链模式</p><p>Bean的生命周期管理用到了状态模式</p><p>AOP用到了代理模式</p><p>SpringMVC的HandlerAdapter适配不同Controller用到了适配器模式</p><h2 id="ES的基本原理"><a href="#ES的基本原理" class="headerlink" title="ES的基本原理"></a>ES的基本原理</h2><p>ES中比较关键的概念有索引，相当于MySQL的表，文档，相当于表中的行，字段，相当于表中的列。然后还可以组成集群和分片。</p><p>ES内部的索引使用的倒排索引，原理就是把每个文档的内容进行分词，建立词对应文档ID列表的映射</p><p>当有新的文档写入时，ES首先会通过分词器做文本分析，建立倒排索引，再把数据写到主分片上，由主分片同步到副分片，写入不是立即可见的，默认一秒钟刷新一次</p><h2 id="Nacos如何避免读写冲突"><a href="#Nacos如何避免读写冲突" class="headerlink" title="Nacos如何避免读写冲突"></a>Nacos如何避免读写冲突</h2><p>Nacos主要通过两种机制来避免配置读写冲突。一是写时使用乐观锁机制，客户端提交配置时必须带上当前版本号，如果版本不一致则更新失败，避免写写冲突。二是通过Raft协议实现集群间的数据强一致，所有写请求必须通过Leader，读请求默认从本地读取，如果需要强一致也可以强制读Leader。Nacos客户端使用长轮询机制感知配置变更，确保读时的数据是最新的。</p><h2 id="为什么Kryo序列化方式的体积小"><a href="#为什么Kryo序列化方式的体积小" class="headerlink" title="为什么Kryo序列化方式的体积小"></a>为什么Kryo序列化方式的体积小</h2><p>Kryo直接将对象编码为二进制字节数组，没有像JSON那样的字符冗余，并且Kryo不使用Java的反射机制，而是提前注册类信息，序列化时不需要写类的全限定名，它还支持对象引用追踪，避免重复序列化同一个对象</p><h2 id="zk的一致性算法"><a href="#zk的一致性算法" class="headerlink" title="zk的一致性算法"></a>zk的一致性算法</h2><p>Zookeeper使用Zab协议来实现集群一致性。有领导选举和原子广播两个阶段。当集群初次启动或者Leader节点宕机时会进入领导选举阶段，主要是通过投票和对比事务ID来选择，原子广播阶段，所有写请求由Leader发起并生成事务，广播给所有的Follower，需被超过半数的Follower写入后才能提交，Leader再广播提交消息，确保所有节点以相同顺序应用事务，从而实现强一致性。</p><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>我在参与商城项目的时候有过JVM调优的经历，当时压测的时候频繁出现Full GC，我通过jstat分析内存使用情况，使用-Xms和-Xmx调整了堆的大小，用-Xmn扩大了新生代的大小，后面我还有使用jstack查看线程状态，检查是否有死锁的情况</p><h2 id="单机MySQL如果不做任何优化，最大可以承受多大并发"><a href="#单机MySQL如果不做任何优化，最大可以承受多大并发" class="headerlink" title="单机MySQL如果不做任何优化，最大可以承受多大并发"></a>单机MySQL如果不做任何优化，最大可以承受多大并发</h2><p>MySQL默认的最大连接数是151，也就是最多151个线程同时连接执行SQL，如果只是执行简单的查询，单机QPS大概5000左右，如果是频繁写入的话，TPS可能在1000上下</p><h2 id="如何发现和优化慢SQL"><a href="#如何发现和优化慢SQL" class="headerlink" title="如何发现和优化慢SQL"></a>如何发现和优化慢SQL</h2><p>开启数据库慢查询日志，使用<code>mysqldumpslow</code>汇总慢sql，发现慢sql语句之后，使用<code>explain</code>分析这条语句，主要关注是否用了全表扫描，keys是否走了索引，rows是否过大，然后针对常用的字段，使用最左前缀原则建立索引，同时也要避免select *查询，数据量大时，可以用<code>LIMIT</code>限制查询数量，使用分页时避免大偏移量分页，避免慢sql的话可以针对大数据量的表使用分库分表，也可以结合缓存，分担数据库压力</p><h2 id="Unity中C-的生命周期"><a href="#Unity中C-的生命周期" class="headerlink" title="Unity中C#的生命周期"></a>Unity中C#的生命周期</h2><p>C#脚本的生命周期主要围绕<code>MonoBehaviour</code>类展开，首先是初始化阶段，可以使用Awake（最早被调用，仅执行一次），Start（在第一次 <code>Update</code> 前调用，仅执行一次）进行初始化，然后是运行阶段，使用update、fixedupdate，然后是渲染阶段，OnPreRender，OnRenderObject，OnPostRender，最后是销毁阶段，OnDisable</p><h2 id="Unity为什么需要协程"><a href="#Unity为什么需要协程" class="headerlink" title="Unity为什么需要协程"></a>Unity为什么需要协程</h2><ul><li>实现延时执行而不阻塞主线程：Unity是单线程的，而协程允许先等待一段时间后再执行后续代码</li><li>逐帧执行复杂操作，防止掉帧：当某个任务太重时（如大量计算、加载资源等），协程可以把任务分成多帧执行</li></ul><h2 id="SpringBoot相比于Spring有哪些优点"><a href="#SpringBoot相比于Spring有哪些优点" class="headerlink" title="SpringBoot相比于Spring有哪些优点"></a>SpringBoot相比于Spring有哪些优点</h2><ul><li>Spring需要XML或Java配置类进行配置，SpringBoot提供了自动化配置，大部分默认配置就能满足开发需求</li><li>SpringBoot内置了Tomcat容器，项目可以直接打包成jar运行，不需要部署到外部服务器</li><li>SpringBoot提供了多种starter依赖（如 <code>spring-boot-starter-web</code>、<code>starter-data-jpa</code>），解决了版本兼容与依赖整合的问题</li><li>SpringBoot提供了对主流中间件的默认整合，如Redis、RabbitMQ、MyBatis、Elasticsearch等，通过yml文件即可完成连接配置，无需手动创建Bean</li></ul><h2 id="SpringBoot项目中的分层架构，以及会用到的注解"><a href="#SpringBoot项目中的分层架构，以及会用到的注解" class="headerlink" title="SpringBoot项目中的分层架构，以及会用到的注解"></a>SpringBoot项目中的分层架构，以及会用到的注解</h2><ul><li>Controller层（处理请求，参数解析，返回响应）：@RestController、@Controller、@RequestMapping、@GetMapping、@ResponseBody、@RequestBody</li><li>Service 层（处理具体业务逻辑）：@Service、@Transactional</li><li>DAO层（与数据库交互）：@Mapper</li></ul><h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><ul><li>如何在Linux系统中查询所有运行的java项目：ps -ef | grep java</li><li>linux中查找文件：find -name “filename”</li><li>linux中查看端口号占用情况：netstat或ss -tunlp | grep 端口号</li><li>linux查看进程占用了哪个端口：lsof -p <PID> -i</PID></li></ul><h2 id="hr面相关"><a href="#hr面相关" class="headerlink" title="hr面相关"></a>hr面相关</h2><h3 id="为什么选择我们公司"><a href="#为什么选择我们公司" class="headerlink" title="为什么选择我们公司"></a>为什么选择我们公司</h3><p>我认为贵公司身为一线互联网企业，技术栈和工程实践能力一定都非常成熟，我相信内部一定非常重视技术氛围。在这样一个重视技术、节奏高效的环境，我认为我的能力可以快速得到提升，而且贵公司应该也会有完善的新员工或实习生的培养流程，可以更好的进行线性成长。并且可以在真实项目中锻炼自己的工程能力。而且我了解贵公司在业务领域持续扩展，也有很强的发展潜力，我希望能在这样的平台上深入了解业务</p><h3 id="你对自己的职业规划是怎样的"><a href="#你对自己的职业规划是怎样的" class="headerlink" title="你对自己的职业规划是怎样的"></a>你对自己的职业规划是怎样的</h3><p>短期内，我希望能在测试开发的岗位上打好基础，快速的了解所负责的基础业务和大体流程，在熟悉业务的同时提升自己对系统架构、质量保障的理解，同时也要重点看一下需求文档和开发文档，着重关注侧重点。中期来看，我希望自己不仅仅是执行测试，还能参与到测试平台的开发或质量体系建设中，在“懂技术又懂业务”的方向上深入发展，培养自己的产品意识和工程能力</p><h3 id="是否接受加班"><a href="#是否接受加班" class="headerlink" title="是否接受加班"></a>是否接受加班</h3><p>加班我是完全可以接受的。我理解研发和测试周期中有一些阶段确实需要投入更多，尤其是版本上线前或者新项目初期，我也愿意配合团队冲刺目标。</p><h3 id="你有没有其它公司的-offer"><a href="#你有没有其它公司的-offer" class="headerlink" title="你有没有其它公司的 offer"></a>你有没有其它公司的 offer</h3><p>之前收到过一些offer，不过我都拒绝掉了，目前有一些面试在进行中，也收到了部分反馈，但从技术氛围和业务来看，我个人更倾向于贵公司</p><h3 id="用几个词描述一下自己"><a href="#用几个词描述一下自己" class="headerlink" title="用几个词描述一下自己"></a>用几个词描述一下自己</h3><p>踏实、自驱、逻辑性强。我在项目中喜欢梳理问题和业务逻辑，有条理地分解任务，也习惯自己查资料解决问题；同时我也具备较强的执行力，能把任务落地</p><h3 id="最有成就感的一件事"><a href="#最有成就感的一件事" class="headerlink" title="最有成就感的一件事"></a>最有成就感的一件事</h3><p>是我在读研期间负责的一个国家自然科学基金项目，当时是从零开始写系统设计书，在一次次的项目对接中实现各种功能和交互的逻辑，并且最后的算法训练也是我来做的，期间遇到了项目开发冲突，需求推倒重做，智能体训练失败等问题，但是最终也是平稳交付。负责一个成功交付的项目让我很有成就感</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xxl-Job基础入门</title>
      <link href="/inori/226b10d6.html"/>
      <url>/inori/226b10d6.html</url>
      
        <content type="html"><![CDATA[<h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><p>我们可以思考一下下面业务场景的解决方案:</p><ul><li>某电商平台需要每天上午10点，下午3点，晚上8点发放一批优惠券</li><li>某银行系统需要在信用卡到期还款日的前三天进行短信提醒</li><li>某财务系统需要在每天凌晨0:10分结算前一天的财务数据，统计汇总</li></ul><p>以上场景就是任务调度所需要解决的问题</p><p><strong>任务调度是为了自动完成特定任务，在约定的特定时刻去执行任务的过程</strong></p><h3 id="为什么需要分布式调度"><a href="#为什么需要分布式调度" class="headerlink" title="为什么需要分布式调度"></a>为什么需要分布式调度</h3><p>使用Spring中提供的注解@Scheduled，也能实现调度的功能，在业务类中方法中贴上这个注解,然后在启动类上贴上<code>@EnableScheduling</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/20 * * * * ? &quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//doSomething   </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>但是这种方式：</p><ul><li>只能在一台机器上运行，如果程序或者系统出现异常就会导致功能不可用</li><li>在单机模式下，定时任务是没什么问题的。但当我们部署了多台服务，同时又每台服务又有定时任务时，若不进行合理的控制在同一时间，只有一个定时任务启动执行，定时执行的结果就可能存在混乱和错误了</li><li>原本1分钟内需要处理1万个订单，但是现在需要1分钟内处理10万个订单；原来一个统计需要1小时，现在业务方需要10分钟就统计出来。也许可以多线程、单机多进程处理。的确，多线程并行处理可以提高单位时间的处理效率，但是单机能力毕竟有限（主要是CPU、内存和磁盘），始终会有单机处理不过来的情况</li></ul><h2 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="XXL-Job"></a>XXL-Job</h2><p><a href="https://github.com/xuxueli/xxl-job">XXL-Job</a>是一个轻量级分布式任务调度平台, 其核心设计目标是开发迅速、学习简单、轻量级、易扩展</p><p><img src="/inori/226b10d6/framework.png"></p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p><p>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</p><p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性</p><h3 id="配置调度中心"><a href="#配置调度中心" class="headerlink" title="配置调度中心"></a>配置调度中心</h3><ol><li>下载xxl的源码后，有一个调度数据库初始化的SQL脚本，首先需要把这个脚本导入到数据库中</li><li>按照maven格式将源码导入到idea，使用maven进行编译后运行即可</li></ol><p><img src="/inori/226b10d6/structure.png"></p><ol start="3"><li>修改<code>xxl-job-admin</code>项目的配置文件<code>application.properties</code>,把数据库账号密码配置上</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### web</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/xxl-job-admin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### actuator</span></span><br><span class="line"><span class="attr">management.server.servlet.context-path</span>=<span class="string">/actuator</span></span><br><span class="line"><span class="attr">management.health.mail.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### resources</span></span><br><span class="line"><span class="attr">spring.mvc.servlet.load-on-startup</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">spring.mvc.static-path-pattern</span>=<span class="string">/static/**</span></span><br><span class="line"><span class="attr">spring.resources.static-locations</span>=<span class="string">classpath:/static/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### freemarker</span></span><br><span class="line"><span class="attr">spring.freemarker.templateLoaderPath</span>=<span class="string">classpath:/templates/</span></span><br><span class="line"><span class="attr">spring.freemarker.suffix</span>=<span class="string">.ftl</span></span><br><span class="line"><span class="attr">spring.freemarker.charset</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="attr">spring.freemarker.request-context-attribute</span>=<span class="string">request</span></span><br><span class="line"><span class="attr">spring.freemarker.settings.number_format</span>=<span class="string">0.##########</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### mybatis</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:/mybatis-mapper/*Mapper.xml</span></span><br><span class="line"><span class="comment">#mybatis.type-aliases-package=com.xxl.job.admin.core.model</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, datasource</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://IP地址:端口号/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### datasource-pool</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.idle-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.pool-name</span>=<span class="string">HikariCP</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.max-lifetime</span>=<span class="string">900000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-timeout</span>=<span class="string">10000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-test-query</span>=<span class="string">SELECT 1</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.validation-timeout</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, email</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">spring.mail.port</span>=<span class="string">25</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">xxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.from</span>=<span class="string">xxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.required</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, access token</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string">default_token</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)</span></span><br><span class="line"><span class="attr">xxl.job.i18n</span>=<span class="string">zh_CN</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## xxl-job, triggerpool max size</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.fast.max</span>=<span class="string">200</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.slow.max</span>=<span class="string">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, log retention days</span></span><br><span class="line"><span class="attr">xxl.job.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><ol start="4"><li>运行<code>XxlJobAdminApplication</code>程序，访问调度中心：<a href="http://localhost:8080/xxl-job-admin%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7">http://localhost:8080/xxl-job-admin，默认登录账号</a> “admin&#x2F;123456”</li></ol><h3 id="配置执行器"><a href="#配置执行器" class="headerlink" title="配置执行器"></a>配置执行器</h3><ol><li>添加Maven依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>执行器配置，在配置文件中添加配置</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span></span><br><span class="line"><span class="attr">xxl.job.admin.addresses</span>=<span class="string">http://127.0.0.1:8080/xxl-job-admin</span></span><br><span class="line"><span class="comment">### 执行器通讯TOKEN [选填]：非空时启用；</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string">default_token</span></span><br><span class="line"><span class="comment">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span></span><br><span class="line"><span class="attr">xxl.job.executor.appname</span>=<span class="string">xxl-job-executor-sample</span></span><br><span class="line"><span class="comment">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span></span><br><span class="line"><span class="attr">xxl.job.executor.address</span>=<span class="string"></span></span><br><span class="line"><span class="comment">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span></span><br><span class="line"><span class="attr">xxl.job.executor.ip</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span></span><br><span class="line"><span class="attr">xxl.job.executor.port</span>=<span class="string">9999</span></span><br><span class="line"><span class="comment">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logpath</span>=<span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line"><span class="comment">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建<code>XxlJobConfig</code>配置对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加任务处理类，交给Spring容器管理，在处理方法上贴上<code>@XxlJob</code>注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleXxlJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行定时任务,执行时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>登录调度中心,在任务管理中新增任务,配置内容如下：</p><p><img src="/inori/226b10d6/config1.png"></p><p>然后启动定时调度任务，回到管控台，就可以看到任务已经执行</p><h3 id="执行器集群"><a href="#执行器集群" class="headerlink" title="执行器集群"></a>执行器集群</h3><p>在IDEA中设置SpringBoot项目运行开启多个集群，启动两个SpringBoot程序,需要修改Tomcat端口和执行器端口</p><ul><li><p>Tomcat端口8090程序的命令行参数:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8090 -Dxxl.job.executor.port=9998</span><br></pre></td></tr></table></figure></li><li><p>Tomcat端口8091程序的命令行参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8091 -Dxxl.job.executor.port=9999</span><br></pre></td></tr></table></figure></li></ul><p>在任务管理中，修改路由策略，修改成<code>轮询</code></p><p><img src="/inori/226b10d6/config2.png"></p><p>重新启动,我们可以看到效果是,定时任务会在这两台机器中进行轮询的执行</p><h4 id="调度路由算法"><a href="#调度路由算法" class="headerlink" title="调度路由算法"></a>调度路由算法</h4><ol><li><p>FIRST（第一个）：固定选择第一个机器</p></li><li><p>LAST（最后一个）：固定选择最后一个机器</p></li><li><p>ROUND（轮询）：依次的选择在线的机器发起调度</p></li><li><p>RANDOM（随机）：随机选择在线的机器</p></li><li><p>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上</p></li><li><p>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举</p></li><li><p>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举</p></li><li><p>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度</p></li><li><p>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度</p></li><li><p>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务</p></li></ol><h3 id="分片功能"><a href="#分片功能" class="headerlink" title="分片功能"></a>分片功能</h3><p>需求:在指定节假日，需要给平台的所有用户去发送祝福的短信</p><h4 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h4><p>在数据库中导入<code>xxl_job_demo.sql</code>数据</p><h4 id="集成Druid-MyBatis"><a href="#集成Druid-MyBatis" class="headerlink" title="集成Druid&amp;MyBatis"></a>集成Druid&amp;MyBatis</h4><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加配置</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/xxl_job_demo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p><strong>添加实体类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMobilePlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">private</span> String username;<span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">private</span> String phone;<span class="comment">//手机号码</span></span><br><span class="line">    <span class="keyword">private</span> String info;<span class="comment">//备注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加Mapper处理类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务功能实现"><a href="#业务功能实现" class="headerlink" title="业务功能实现"></a>业务功能实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot;,处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟发送短信动作</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们的案例中有2000+条数据，如果不采取分片形式的话，任务只会在一台机器上执行，这样的话需要20+秒才能执行完任务</p><p>如果采取分片广播的形式的话，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数，可根据分片参数开发分片任务</p><p>获取分片参数方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可参考Sample示例执行器中的示例任务&quot;ShardingJobHandler&quot;了解试用 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line"><span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br></pre></td></tr></table></figure><p>通过这两个参数，我们可以通过求模取余的方式，分别查询，分别执行，这样的话就可以提高处理的速度</p><p>之前2000+条数据只在一台机器上执行需要20+秒才能完成任务，分片后，有两台机器可以共同完成2000+条数据，每台机器处理1000+条数据，这样的话只需要10+秒就能完成任务</p><h4 id="案例改造"><a href="#案例改造" class="headerlink" title="案例改造"></a>案例改造</h4><p><strong>Mapper增加查询方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan where mod(id,#&#123;shardingTotal&#125;)=#&#123;shardingIndex&#125;&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectByMod</span><span class="params">(<span class="meta">@Param(&quot;shardingIndex&quot;)</span> Integer shardingIndex,<span class="meta">@Param(&quot;shardingTotal&quot;)</span>Integer shardingTotal)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务类方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgShardingHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgShardingHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(shardTotal==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果没有分片就直接查询所有数据</span></span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectByMod(shardIndex,shardTotal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把路由策略改成分片广播即可实现分片功能</p><p><img src="/inori/226b10d6/demo.png"></p>]]></content>
      
      
      <categories>
          
          <category> xxl </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目常见问题梳理（持续更新中）</title>
      <link href="/inori/b4ace844.html"/>
      <url>/inori/b4ace844.html</url>
      
        <content type="html"><![CDATA[<h1 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h1><h2 id="为什么要做RPC项目"><a href="#为什么要做RPC项目" class="headerlink" title="为什么要做RPC项目"></a>为什么要做RPC项目</h2><p>目前的应用大部分都是分布式或者微服务架构，通常各个模块之间都是通过rpc来进行调用的，所以我认为自己写一个rpc项目可以更加深入的理解rpc的原理</p><p>然后在写rpc项目的过程中，学会了对Zookeeper和netty的使用，也学会了通信协议设计、序列化算法、服务注册与发现、负载均衡策略的设计和使用。</p><h2 id="项目有什么难点，如何解决的"><a href="#项目有什么难点，如何解决的" class="headerlink" title="项目有什么难点，如何解决的"></a>项目有什么难点，如何解决的</h2><ol><li>关于通信协议的实现和切换模块，我希望客户端和服务端支持http，socket和netty传输协议，并且根据配置自动切换。我的解决方案是首先定义了统一的接口<code>RpcClient</code> 和 <code>RpcServer</code>，然后实现其协议子类比如<code>NettyRpcServer</code>和<code>HttpRpcServer</code>，利用Spring Boot的 <code>@ConditionalOnProperty</code>和<code>@ConditionalOnMissingBean</code> 机制，支持配置项自动装配对应的协议实现</li><li>关于负载均衡模块的实现，就是服务调用时如何在多个服务节点直接选择一个合适的目标节点。我的解决方案是定义一个统一的接口<code>LoadBalance</code>，在此基础上扩展成随机、轮询和一致性哈希三种方法，使用SPI的方式决定具体使用哪种策略，最后把LoadBalance注入到服务发现模块中，实现调用时选择</li><li>关于服务注册和发现模块的实现，我编写了一个注解<code>RpcService</code>，服务启动时会遍历所有使用了这个注解的Bean，然后将服务的接口全限定名和服务提供地址注册到注册中心，然后在Zookeeper层面会创建一个临时节点，表明这个服务被创建成功。然后在客户端通过代理类发起远程调用时，如果存在多个地址，就是用负载均衡模块选择一个，最后建立连接发起远程调用</li><li>还有就是Kryo序列化与多线程环境的兼容性。因为Kryo是线程不安全的，直接复用同一个实例会导致数据错乱。后来我通过ThreadLocal为每个线程分配独立的Kryo实例，避免了线程间冲突，同时保持了性能</li></ol><h2 id="为什么用Netty做网络通信"><a href="#为什么用Netty做网络通信" class="headerlink" title="为什么用Netty做网络通信"></a>为什么用Netty做网络通信</h2><p>因为相比于Java原生的Socket和Http更适合高性能和高并发的场景</p><ul><li>Netty的IO是异步非阻塞的，支持大量并发连接，吞吐量高</li><li>Netty使用线程复用、事件驱动机制，资源占用低，GC压力小</li><li>Netty内部提供粘包半包处理器，实现rpc协议更方便</li></ul><h2 id="http、socket、netty三种网络通信方式的区别"><a href="#http、socket、netty三种网络通信方式的区别" class="headerlink" title="http、socket、netty三种网络通信方式的区别"></a>http、socket、netty三种网络通信方式的区别</h2><ul><li>socket是传输层的协议，是操作系统提供的网络编程接口，只提供最基础的通信方式，可以是阻塞或者非阻塞的，需要自己实现编解码器和传输的逻辑</li><li>http是应用层的协议，基于请求-响应的模式，默认是短连接的，并且不支持双向通信，性能比较低，但是http被很多框架支持，使用比较方便</li><li>netty是一个基于NIO的网络通信框架，底层用到了socket，是异步非阻塞，基于事件驱动的，性能比较高，并且其中提供了粘包半包的处理器和对自定义协议的支持，扩展性比较好</li></ul><h2 id="JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别"><a href="#JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别" class="headerlink" title="JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别"></a>JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别</h2><ul><li>JDK是Java原生的序列化方式，不需要引入三方库，但是序列化后体积比较大，性能低，反序列化速度慢</li><li>Json的可读性比较强，支持跨语言调用，比较适合web接口，但是它占用空间比较大，而且不支持复杂的对象图</li><li>Protostuff是基于Protobuf的序列化方式，支持基础的Java Bean，可以跨语言，并且序列化后体积小，性能高，但是它序列化后不可读</li><li>Hession是一个二进制协议，支持序列化复杂对象，也可以跨语言支持，兼容性比较好</li><li>Kryo适合Java内部序列化，不支持跨语言，序列化性能非常高，默认要求类有无参构造器，而且kryo是线程不安全的</li></ul><h2 id="讲一下自定义协议"><a href="#讲一下自定义协议" class="headerlink" title="讲一下自定义协议"></a>讲一下自定义协议</h2><p>我在rpc项目中的自定义协议头有魔数（4byte，识别协议是否合法），版本号（1byte，兼容后续可能的更新），序列化算法（1byte，具体使用的序列化协议），消息类型（1byte，有请求、响应、心跳），消息状态（1byte，成功，失败，超时），消息序列号（4byte，每个请求的唯一id，处理多路复用的时候可以用到），消息长度（4byte）</p><h2 id="讲一下编解码器"><a href="#讲一下编解码器" class="headerlink" title="讲一下编解码器"></a>讲一下编解码器</h2><p>编码部分是出站处理，把RpcMessage编码成Bytebuf对象，先把自定义协议头写到bytebuf中，再把协议体经过序列化后填充到bytebuf中</p><p>解码部分分为粘包半包解码器和具体解码两部分，关于粘包半包处理我使用的是Netty的定长解码器，在解码器中我设定了偏移量和消息体长度值，因为我的协议有16字节，后4字节代表消息体长度，所以偏移量是12字节，长度是4字节，解码器就通过长度字段，得出body的长度，然后从TCP流中拼接出这条完整消息，或者如果多条消息被粘在一起，Netty会按每条消息长度拆分出多条消息。然后再是具体解码，先校验是否符合我自定义协议的格式，再解出具体消息体</p><h2 id="讲一下Netty心跳机制和Channel的连接复用"><a href="#讲一下Netty心跳机制和Channel的连接复用" class="headerlink" title="讲一下Netty心跳机制和Channel的连接复用"></a>讲一下Netty心跳机制和Channel的连接复用</h2><p>TCP是长连接，但不会自动告诉你对方是否断线，如果一端异常断开，另一端会长时间挂起资源，会造成一定的资源浪费，所以我使用了定期的心跳检测，确认连接是否存活。我使用了netty的IdleStateHandler来实现心跳检测，当检测到写空闲时自动发送一个心跳检测数据包</p><p>然后在rpc框架中，如果每发一次请求就新建TCP连接，就会导致大量Socket打开关闭，并且并发高时会造成端口耗尽的问题。我在项目中使用ConcurrentHashMap存放每个<code>IP+端口号</code>使用过的Channel，如果当前IP的端口再次发起rpc请求后，检测到之前的Channel还没关闭，就可以再次使用，避免重复连接服务端</p><p>然后是多路复用的实现，因为同一个服务可能会发出多个不同的rpc请求，我使用一个<code>ConcurrentHashMap</code>存放每个请求的等待结果区，key是协议头中的sequenceId，value是Netty的Promise（代表一个异步响应），当响应回来时，用sequenceId找到对应的Promise完成结果，就可以做到同一个连接处理多个不同的请求。</p><h2 id="注册中心为什么使用Zookeeper不用Nacos"><a href="#注册中心为什么使用Zookeeper不用Nacos" class="headerlink" title="注册中心为什么使用Zookeeper不用Nacos"></a>注册中心为什么使用Zookeeper不用Nacos</h2><p>我这个RPC框架作为一个独立项目，需要自己实现服务注册&#x2F;发现、监听机制、负载均衡等功能。</p><ul><li>项目对一致性的要求更高，服务注册、注销都是临时节点，Zookeeper会在连接断开时自动清理</li><li>Zookeeper支持监听机制，服务节点变化能即时通知客户端，便于实现本地缓存刷新，Nacos的监听更偏配置文件，服务变化通知粒度更粗一些</li><li>项目使用的是Netty和SpringBoot，整体较轻量，不需要配置中心功能</li><li>Nacos提供了配置中心和服务注册功能，对于微服务项目来说非常适合。但我的RPC框架更偏向于底层架构搭建和分布式通信机制学习，所以我更偏向选用Zookeeper，它更容易控制细节、简洁可定制</li></ul><h2 id="服务如何注册、客户端如何发现、服务如何下线"><a href="#服务如何注册、客户端如何发现、服务如何下线" class="headerlink" title="服务如何注册、客户端如何发现、服务如何下线"></a>服务如何注册、客户端如何发现、服务如何下线</h2><p>服务注册的逻辑在服务提供端，主要流程是服务启动时，连接到Zookeeper，创建持久结点，表示这个服务，然后在持久结点下面创建临时子节点，表示提供这个服务的IP地址和端口号，临时节点中会存数据，是Json格式的服务对象，有服务名，ip地址，端口号和版本号。注册成功后，Zookeeper会维持与该服务实例的心跳连接</p><p>服务发现的逻辑在服务调用端，主要流程是服务启动时连接到Zookeeper，发送rpc请求时，先根据服务名查找服务。如果客户端第一次查找该服务，会从Zookeeper拉取服务列表，构建本地缓存，并设置监听器，后续若服务变化，缓存会自动更新。不是第一次的话则直接调用缓存，然后使用负载均衡算法从服务列表中选一个可用实例，返回该实例信息用于客户端建立连接并发起请求</p><p>服务下线分为两种情况，第一种情况是服务主动下线，服务关闭时使用注销方法将服务从Zookeeper中删除，然后客户端因为配置了监听器，会自动更新缓存列表。第二种情况是服务异常下线，因为Zookeeper有心跳机制，当检测不到这个服务时，会认为这个服务已经停止了，删除这个服务</p><h2 id="介绍一下客户端调用、服务端响应的一个完整流程"><a href="#介绍一下客户端调用、服务端响应的一个完整流程" class="headerlink" title="介绍一下客户端调用、服务端响应的一个完整流程"></a>介绍一下客户端调用、服务端响应的一个完整流程</h2><p>客户端通过代理类发起服务调用，动态代理类会封装请求，客户端进行服务发现，然后使用负载均衡算法选择一个服务提供者发起网络通信请求，请求成功后，使用自定义协议将信息封装为消息头和消息体，并通过编码器和序列化器转成字节数组，将数据发送到目标Channel，服务端收到数据后，进行解码和反序列化，还原消息体，然后通过反射调用目标方法，获取返回结果，再封装消息，进行编码和序列化后将字节数组通过Channel发回到客户端中，然后客户端再进行解码和反序列化获得结果。</p><h2 id="如果zk中的服务节点退出了，服务还能访问吗，怎么做"><a href="#如果zk中的服务节点退出了，服务还能访问吗，怎么做" class="headerlink" title="如果zk中的服务节点退出了，服务还能访问吗，怎么做"></a>如果zk中的服务节点退出了，服务还能访问吗，怎么做</h2><p>如果Zookeeper中某个服务节点退出，它注册的临时节点会自动被删除。客户端如果还用旧地址调用，就会访问失败。为避免这个问题，我在客户端实现了本地服务地址缓存和动态监听机制，保证地址列表是实时更新的。客户端在读取服务地址的时候会注册监听器，一旦某个节点下线了，Zookeeper会提交一个事件给监听器，进而更新本地缓存。但是如果是一个客户端已经请求到这个服务节点了，但是此时这个节点宕机了，那么会出现请求失败的情况，关于这种情况，我配置了失败重试策略，请求发送失败时，使用负载均衡策略切换下一个地址重试</p><h2 id="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信"><a href="#如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信" class="headerlink" title="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信"></a>如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信</h2><p>如果一个服务正在被请求，此时直接下线可能会导致请求失败或连接中断。我采用的是优雅下线策略，先从注册中心摘除服务，但不会马上关闭进程，等待处理中的请求完成后再关闭服务进程，保证客户端本次调用能够完成（netty的EventLoopGroup.shutdownGracefully()）</p><h2 id="你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别"><a href="#你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别" class="headerlink" title="你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别"></a>你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别</h2><p>我做的这个RPC框架虽然不如Dubbo、gRPC功能全面，但胜在轻量级，更适合作为学习、定制型服务通信的基础框架。同时我也实现了一些Dubbo和gRPC中的重要特性，如服务注册、序列化、连接复用、自动注入等功能。</p><p>当然与成熟框架相比，我的RPC框架还存在一些后续可以升级的点：</p><ul><li>服务治理能力（如限流、熔断、降级）</li><li>跨语言支持</li><li>服务可观测性（如日志链路追踪）</li></ul><h2 id="实现一个RPC框架最主要看重哪些点"><a href="#实现一个RPC框架最主要看重哪些点" class="headerlink" title="实现一个RPC框架最主要看重哪些点"></a>实现一个RPC框架最主要看重哪些点</h2><ol><li>通信协议的设计，协议需要清晰的定义请求和响应结构，序列化格式和状态码等数据</li><li>编解码和序列化，编解码和序列化的效率应该要高，然后序列化后的数据体积应该小，看具体业务判断是否需要跨语言</li><li>网络通信性能，阻塞式或者异步式，是否支持连接池、长连接、心跳机制</li><li>服务注册与发现，负载均衡，是否具备故障感知能力</li><li>容错与高可用机制，是否支持失败重试，熔断和降级策略</li><li>还有易用性和可扩展性，是否支持注解，自动装配和可插拔机制</li></ol><h2 id="本地方法调用和远程过程调用有什么区别"><a href="#本地方法调用和远程过程调用有什么区别" class="headerlink" title="本地方法调用和远程过程调用有什么区别"></a>本地方法调用和远程过程调用有什么区别</h2><p>本地方法调用是程序内的方法直接调用，属于同一个进程内的方法调用，延迟很低，调用比较可靠，不需要中间件支持，但是代码的耦合度比较高</p><p>远程过程调用是调用远程服务器上提供的方法，属于不同进程或者不同机器上的方法调用，需要进行网络通信，所以有网络延迟，效率相对较低，也会有网络中断，超时等异常情况，需要中间件的支持，但是做到了服务之间的解耦合</p><h2 id="rpc如何支持服务的熔断和降级的"><a href="#rpc如何支持服务的熔断和降级的" class="headerlink" title="rpc如何支持服务的熔断和降级的"></a>rpc如何支持服务的熔断和降级的</h2><p>熔断是如果某个服务连续调用失败，系统就会临时阻止再发起请求，防止拖垮系统，可以在rpc中引入熔断器组件Sentinel，每个服务接口调用前先经过熔断器判断是否“断路”，统计失败率、超时数等动态判断是否进入熔断状态，还可以支持闭合-&gt;半开-&gt;打开的状态转换</p><p>降级是如果调用失败次数太多，系统就自动返回默认数据或走备用逻辑，可以编写Fallback方法，方法调用失败&#x2F;超时后，调用备用逻辑，返回默认值</p><h2 id="介绍一下一致性哈希算法"><a href="#介绍一下一致性哈希算法" class="headerlink" title="介绍一下一致性哈希算法"></a>介绍一下一致性哈希算法</h2><p>如果使用简单的哈希方式，当服务节点发生变化的时候，所有请求的分发都会大范围变化，这会导致缓存失效，影响系统效率。一致性哈希算法可以做到：节点数量变化时，尽量少地影响原有请求的分配规律，就是请求一致性和低扰动性。</p><p>一致性哈希算法把哈希空间想象成一个环，所有服务实例都通过哈希函数映射到这个环上某个位置，对服务的ip地址，端口号以及服务名称进行hash后对一个比较大的数进行取模，对数据key也进行hash，然后顺时针找到某一个node，就是这个key要存储的服务器。这样如果增加或者删除一台服务器的话，就只会影响部分数据。但是这样做，当节点比较少的时候会造成数据倾斜的问题，大部分数据会集中在某一个服务上。我的项目中使用了虚拟节点的解决方式，每个真实节点会映射为160个虚拟节点，通过MD5算法再生成多个哈希值，映射到哈希环上，对于请求来说，使用服务方法名加请求参数拼接后做MD5，再映射成哈希值，定位到哈希环上离它最近的服务节点，当服务列表变更时，重新构建哈希环，保证一致性，然后这个重建是不会造成大批量请求映射出错的，比如某个请求落到虚拟节点 A，服务列表变了，A 还在，请求还是到 A，如果A不在了，请求会顺时针走一点落到B。</p><h2 id="项目中哪些地方使用到了异步"><a href="#项目中哪些地方使用到了异步" class="headerlink" title="项目中哪些地方使用到了异步"></a>项目中哪些地方使用到了异步</h2><ul><li>Netty的核心通信是异步的，就是所有的IO操作都是异步非阻塞的</li><li>发送rpc请求是异步的，可以发送消息后立刻返回，监听发送是否成功</li><li>接收响应也是异步的，我在发生时生成了一个id，将future对象存到HashMap里，等收到响应后再异步完成这个future</li></ul><h1 id="小程序项目"><a href="#小程序项目" class="headerlink" title="小程序项目"></a>小程序项目</h1><h2 id="你用自定义注解实现了权限控制，讲讲具体是怎么做的"><a href="#你用自定义注解实现了权限控制，讲讲具体是怎么做的" class="headerlink" title="你用自定义注解实现了权限控制，讲讲具体是怎么做的"></a>你用自定义注解实现了权限控制，讲讲具体是怎么做的</h2><p>在这个小程序中，会涉及到三种角色：管理员root，活动发起者admin和活动参与者visitor，不同角色访问系统中接口的权限是不同的。</p><p>在项目中我使用JWT实现用户认证，用户登录后会签发Token，并将用户信息存入上下文，作为认证依据。</p><p>授权部分，我设计了一个自定义注解<code>@CheckPermission</code>来标记每个接口需要的具体权限，并结合AOP实现了权限切面。切面会在方法执行前解析注解，获取当前用户权限列表，进行匹配校验。如果用户具备权限，就放行接口，否则抛出无权限异常，交由全局异常处理器处理。</p><h2 id="用了三级缓存，讲一下细节"><a href="#用了三级缓存，讲一下细节" class="headerlink" title="用了三级缓存，讲一下细节"></a>用了三级缓存，讲一下细节</h2><p>我的项目中使用了Caffeine、Redis和MySQL结构来优化数据访问性能，本地缓存用于存储访问最频繁的数据，活动列表和当前登录用户信息。Redis作为二级缓存，用于存储访问过的活动详情、活动列表和用户信息，最后由数据库层面，存储全部数据</p><p>整体流程是用户访问数据时，先查本地缓存，未命中则查Redis，如果Redis也未命中再查数据库，并将结果同步回前两级缓存。</p><p>关于过期策略，活动信息在Caffeine中缓存5分钟左右，在Redis中缓存30分钟左右。</p><p>本地缓存层面，我使用了Caffeine的<code>CacheLoader</code>和<code>refreshAfterWrite</code>来预先加载数据避免本地的缓存穿透</p><h2 id="数据库表是怎么设计的"><a href="#数据库表是怎么设计的" class="headerlink" title="数据库表是怎么设计的"></a>数据库表是怎么设计的</h2><p>用户表，存放用户信息和用户的角色</p><p>活动表，存放已经发布的活动，活动的相关信息和发起人</p><p>活动报名表，表示活动id和用户id之间的关系</p><h2 id="如何部署项目，上线流程讲一下"><a href="#如何部署项目，上线流程讲一下" class="headerlink" title="如何部署项目，上线流程讲一下"></a>如何部署项目，上线流程讲一下</h2><p>预先在yaml文件中配置好生产环境参数，然后使用maven对项目进行打包，生成jar文件，传到服务器上，使用systemd后台运行项目，然后配置Nginx，将小程序API请求代理到SpringBoot项目端口，然后配置Nginx的ssl，让小程序支持HTTPS。</p><p>redis和mysql都部署在同一台服务器上，SpringBoot通过配置文件连接到redis和mysql</p><h2 id="活动报名如果高并发，怎么防止名额超限或重复提交"><a href="#活动报名如果高并发，怎么防止名额超限或重复提交" class="headerlink" title="活动报名如果高并发，怎么防止名额超限或重复提交"></a>活动报名如果高并发，怎么防止名额超限或重复提交</h2><p>我在每个活动创建的时候，会把名额写入redis中，使用<code>DECR</code>命令，用户报名前先<code>DECR</code>名额，如果减成功则允许报名，否则失败，因为<code>DECR</code>操作是Redis原子命令，天然支持并发控制，报名成功之后我使用redis创建一个活动名加上用户id的分布式锁，表示这个用户已经报名了这个活动，然后这个设置了一个过期时间，在过期时间内我会把这个报名数据写到数据库中，后续用户再重复报名时，因为redis层面的对应数据已经过期了，就会去查询数据库是否有他的信息，如果有再返回已报名的提示，用这个方式防止名额超限和重复报名</p><h2 id="三级缓存的缓存一致性怎么保证"><a href="#三级缓存的缓存一致性怎么保证" class="headerlink" title="三级缓存的缓存一致性怎么保证"></a>三级缓存的缓存一致性怎么保证</h2><p>读请求是如果访问的是用户信息和首页活动列表，那么会先查询本地缓存，在查询redis，最后查询数据库，然后把数据库返回的数据存到redis和本地缓存中</p><p>如果访问的不是这两个，就直接查询redis，没查到再查询数据库，再写会redis。</p><p>写请求的话，我使用的是先更新数据库，在删除缓存的策略。</p><h1 id="电商项目"><a href="#电商项目" class="headerlink" title="电商项目"></a>电商项目</h1><h2 id="说一下分布式事务"><a href="#说一下分布式事务" class="headerlink" title="说一下分布式事务"></a>说一下分布式事务</h2><p>由多个服务通过网络完成一个事务叫分布式事务。</p><p>首先根据CAP原理决定我们的需求，是要实现CP、还是要实现AP。</p><p>实现CP就是要实现强一致性，可以使用 Seata 框架基于AT、TCC模式去实现。</p><p>我们项目中大部分实现的是AP，使用本地消息表加任务调度完成分布式事务最终数据一致性。</p><h2 id="项目中哪里用到了分布式事务，如何解决的"><a href="#项目中哪里用到了分布式事务，如何解决的" class="headerlink" title="项目中哪里用到了分布式事务，如何解决的"></a>项目中哪里用到了分布式事务，如何解决的</h2><ol><li>发布商品，发布商品需要在商品服务的数据库表中记录，同时将商品信息同步到redis和ES</li></ol><ul><li>发布商品使用本地事务向商品表中写入商品数据，同时写入一条待处理的消息到本地消息表</li><li>提交本地事务之后，xxl的调度中心使用分片广播模式向执行器下发任务，开始扫描消息表，查询待处理的消息</li><li>根据消息内容，通过调用Redis和ES的接口完成数据同步</li><li>任务完成后删除消息表记录</li></ul><ol start="2"><li>用户下单，需要调用商品服务扣减库存，订单服务创建订单，用户服务添加购买记录</li></ol><ul><li>订单服务收到下单请求后，开启本地事务，生成订单记录，然后写入本地消息表，记录要通知商品服务和用户服务的消息，提交事务后，通过消息队列发送通知消息</li><li>商品服务和用户服务通过监听消息队列来处理库存的扣减和添加购买记录的逻辑</li><li>如果消息队列发送失败或者没有被消费，就会使用xxl作为定时任务调度器，每隔一段时间扫描本地消息表中的异常记录进行消息补发</li></ul><h2 id="如何进行分布式事务的回滚"><a href="#如何进行分布式事务的回滚" class="headerlink" title="如何进行分布式事务的回滚"></a>如何进行分布式事务的回滚</h2><p>我项目中采用的是一种基于本地消息表和补偿机制的最终一致性方案。没有使用传统的强一致性分布式事务框架，通过状态标记和异步处理来实现逻辑上的回滚</p><p>在整个业务流程中，每个关键操作都配合本地消息表记录执行状态。当某个服务执行失败时，首先在服务内部有失败重试机制，尽最大努力成功，如果重试后仍失败，会将失败消息记录转移到数据库中的事务失败表，并在消息表中更新状态字段，最后使用xxl定时扫描失败记录表，执行补偿逻辑，并且对于一致性要求比较强的场景，我还使用了消息队列进行即时的通知，xxl作为兜底</p><p>比如用户下单操作中，订单服务已经创建好订单了，但是后续商品扣减库存出了问题，现在想要回滚，那么首先商品服务会发送一条失败消息到消息队列中，并且将失败消息记录到数据库中，订单服务获取到之后，会修改订单表中的状态字段为失败，通过状态标记避免后续的处理</p><h2 id="除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路"><a href="#除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路" class="headerlink" title="除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路"></a>除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路</h2><ul><li>XA，两阶段提交，先准备资源，再统一提交或者回滚</li><li>TCC，把每个操作拆分成三部分，先预检查，再尝试获取资源，最后提交实际操作</li><li>SAGA，长事务补偿，将事务拆分为一系列子事务，每个子事务完成后立刻提交，如果后续事务失败，则按顺序调用每个子事务的补偿操作来回滚</li></ul><p>为什么我选择任务调度这种方式，因为我认为这个项目中主要以性能和并发为优先考虑，不适合xa和tcc，并且业务是允许最终一致性的，不是强一致性的，而且消息队列和xxl的方式比较好实现</p><h2 id="Elasticsearch是怎么使用的"><a href="#Elasticsearch是怎么使用的" class="headerlink" title="Elasticsearch是怎么使用的"></a>Elasticsearch是怎么使用的</h2><p>1）首先创建索引（相当于mysql的表），将商品信息添加到索引库，对商品信息进行分词，存储到索引库</p><p>2）在商品服务中编写商品搜索接口，调用es的rest接口根据关键字、商品分类信息进行搜索</p><h3 id="如何保证索引同步"><a href="#如何保证索引同步" class="headerlink" title="如何保证索引同步"></a>如何保证索引同步</h3><p>我项目是使用本地任务表加xxl-job任务调度进行索引同步</p><p>1）添加或修改或删除商品的同时向任务表插入一条记录，这条记录就记录了是修改了哪个商品</p><p>2）任务调度定时扫描任务表，根据任务表的内容对商品信息进行同步，如果添加了商品将商品添加到索引库，如果修改了商品就修改索引库的商品，如果是删除了商品将商品信息从索引库删除</p><h2 id="xxl-job的工作原理是什么"><a href="#xxl-job的工作原理是什么" class="headerlink" title="xxl-job的工作原理是什么"></a>xxl-job的工作原理是什么</h2><p>xxl由调度中心和执行器组成，在应用启动时，执行器会将自己注册到调度中心Admin，然后在Admin中配置定时任务，指定要调哪个Bean和方法，到达任务触发时间后，Admin通过HTTP请求调用对应的执行器，执行结果会通过回调上传给调度中心，如果失败还可以配置自动重试机制。并且如果有很多执行器，xxl还支持负载均衡策略和任务分片</p><p>在我的项目中，我主要使用xxl实现对本地消息表和失败记录表的定时扫描，还有对于优惠券和商品的限时抢购的时间预订功能</p><h2 id="如何保证任务不重复执行"><a href="#如何保证任务不重复执行" class="headerlink" title="如何保证任务不重复执行"></a>如何保证任务不重复执行</h2><p>主要有两种方式，一个是每个任务都会生成一个唯一的Id，业务层判断该任务是否已经执行过，还有每条待处理的消息记录在消息表中含有状态字段，调度器扫描任务时，通过状态判断是否执行过，避免重复触发</p><h2 id="未支付订单如何处理"><a href="#未支付订单如何处理" class="headerlink" title="未支付订单如何处理"></a>未支付订单如何处理</h2><p>在我的项目中使用RabbitMQ的死信队列机制处理未支付订单，用户提交订单之后，系统会向消息队列中发送一条消息，交换机配置为死信交换机，过期后，消息被路由到死信队列，然后执行取消订单，恢复库存的逻辑</p><h2 id="如何保证RabbitMQ的消息可靠性"><a href="#如何保证RabbitMQ的消息可靠性" class="headerlink" title="如何保证RabbitMQ的消息可靠性"></a>如何保证RabbitMQ的消息可靠性</h2><p>可靠性保证主要分为三部分，一个是生产者到消息队列的可靠性，这部分由消息确认机制保证，就是生产者发送消息后，会异步等待消息队列反馈ACK，一个是消息队列内部的可靠性，消息队列内部有持久化机制，可以将未消费消息保存到硬盘中，一个是消息队列到消费者的可靠性，这个与生产者类似，消费者接收到消息并且成功处理之后，会反馈给消息队列，然后消息队列才会把这条消息删除，如果处理失败或者一直没有处理会触发重试机制</p><h3 id="如何避免消息重复消费"><a href="#如何避免消息重复消费" class="headerlink" title="如何避免消息重复消费"></a>如何避免消息重复消费</h3><p>每个业务操作都有唯一ID，这个ID会随着消息一起发送到消息队列中，如果这个消息已经被消费了，就一定会在数据库中有记录，就算消费者后续反馈到消息队列的ack丢失，触发消息队列的重试机制了，消费者再次收到相同消息时也不会重复消费</p><h2 id="为什么选择RabbitMQ"><a href="#为什么选择RabbitMQ" class="headerlink" title="为什么选择RabbitMQ"></a>为什么选择RabbitMQ</h2><p>首先RabbitMQ支持可靠性传输机制，提供了持久化，ack确认机制，消息重试和死信机制，然后它提供了很多的消息路由类型（点对点路由、模糊匹配路由、广播路由），可以应对不同的业务场景</p><h2 id="项目使用Redis缓存了哪些数据"><a href="#项目使用Redis缓存了哪些数据" class="headerlink" title="项目使用Redis缓存了哪些数据"></a>项目使用Redis缓存了哪些数据</h2><p>缓存内容有商品详情、商品列表、用户信息等访问频率可能比较高的数据</p><p>使用的数据结构：</p><ul><li>String：商品详情</li><li>Hash：用户信息、购物车数据</li><li>List：排行榜、热门商品</li></ul><h2 id="如何保证Redis缓存一致性"><a href="#如何保证Redis缓存一致性" class="headerlink" title="如何保证Redis缓存一致性"></a>如何保证Redis缓存一致性</h2><p>对于正常读写场景，我采用的是先更新数据库，再删除缓存的方式，对于高并发写场景，我采用的是先更新缓存，再异步更新数据库的方式，高并发为了减轻数据库压力、提高写入性能，直接写缓存，再通过消息队列异步写数据库，确保最终一致</p><h2 id="优惠券秒杀部分怎么实现的"><a href="#优惠券秒杀部分怎么实现的" class="headerlink" title="优惠券秒杀部分怎么实现的"></a>优惠券秒杀部分怎么实现的</h2><p>秒杀的核心目标首先是保证优惠券不能超卖，同一用户不能重复领券。首先我会把券的库存预加载进Redis中，然后把校验用户身份和扣减库存这两步写到lua脚本里原子执行，然后如果redis返回成功，就会向消息队列中发一条更新数据库的消息，把优惠券写到用户信息中，这样既能流量削峰，也能保证幂等性。</p><h2 id="秒杀的核心瓶颈是什么"><a href="#秒杀的核心瓶颈是什么" class="headerlink" title="秒杀的核心瓶颈是什么"></a>秒杀的核心瓶颈是什么</h2><ul><li>高并发，瞬间就会有上万的用户访问同一个服务，可能会导致服务崩溃。可以使用令牌桶拦截多余请求，或者使用消息队列异步处理</li><li>库存超卖，多个用户并发抢购，有可能库存为0时仍被扣减。可以使用Redis+Lua脚本原子操作</li><li>数据库写入压力，秒杀成功时大量请求写入数据库。可以使用消息队列异步写入，或者分库分表缓解单表写入瓶颈</li><li>重复下单，在redis加一个用户id锁，然后在过期之前把优惠券持有情况写到数据库中，后续分布式锁过期了也可以保证幂等性</li></ul><h2 id="当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施"><a href="#当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施" class="headerlink" title="当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施"></a>当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施</h2><ul><li>首先可以在网关层限流，对IP限流，每个IP每秒不超过5次</li><li>然后可以在服务层限流，以用户id统计单位时间内的访问次数，超出阈值后进入冷却期，在一定时间内限制该用户的访问</li><li>然后在核心接口的访问使用令牌桶，用户抢到令牌才能继续请求</li></ul><h2 id="假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理"><a href="#假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理" class="headerlink" title="假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理"></a>假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理</h2><p>关于这一点，我采用了订单状态控制和幂等机制来确保流程正确性。我在设计订单支付功能时，订单表中有一个状态字段，支付成功只能从未支付转为已支付，退款只能从已支付状态进入。支付成功后立马发起退款，如果当前数据库的订单状态还没转换成未支付，说明当前的订单服务都还没执行完，就会拒绝退款，如果订单状态已经转换成已支付了，就会进入退款流程，然后把订单状态改为已退款，因为订单服务之后会走用户服务和商品服务，用户服务是一定会走的，因为用户曾经创建过这个订单，然后商品服务的话会执行恢复库存这样的操作</p><h2 id="订单失败如何给用户进行反馈的"><a href="#订单失败如何给用户进行反馈的" class="headerlink" title="订单失败如何给用户进行反馈的"></a>订单失败如何给用户进行反馈的</h2><p>用户下单请求是通过接口发起的，在Controller层会捕获所有异常情况，如果业务逻辑执行失败，后端会返回统一格式的失败响应结构，前端拿到响应后通过异常响应信息提示用户。在订单表中有一个状态字段，每个订单可能的到达的状态在字段中都有记录，无论哪一步失败，都会更新订单状态字段，保障用户能获取订单失败的原因</p><h2 id="当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做"><a href="#当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做" class="headerlink" title="当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做"></a>当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做</h2><p>首先将先将失败订单进行归类管理，为后续调度处理提供依据，比如超时未支付，扣库存失败等情况，每一类对应着不同的处理策略</p><p>然后为每个服务维护一张失败任务表，记录异常信息与状态字段，用xxl定时扫描任务表，使用分片广播模式将任务分发到多个执行器实例，每次任务执行前先通过订单状态字段判断是否已经处理保证幂等性，高并发场景下，也可结合分布式锁，确保订单只被一个任务执行，对处理失败的任务，支持自动重试机制，配置最大重试次数，失败次数超过阈值后自动转为人工处理，处理完成后更新订单状态，防止重复处理</p><h2 id="项目中的线程池使用什么方式创建的"><a href="#项目中的线程池使用什么方式创建的" class="headerlink" title="项目中的线程池使用什么方式创建的"></a>项目中的线程池使用什么方式创建的</h2><p>在项目中我使用的是Java原生的ThreadPoolExecutor，核心线程数我选择的是CPU核心数的两倍，最大线程数我用的核心线程数的两倍，非核心线程存活时间我设置的是一分钟，任务队列我用的有界数组队列，长度2000，拒绝策略使用的CallerRunsPolicy，当前线程执行任务。</p><h2 id="做微服务的意义是什么？耦合带来了什么问题？为什么要降低耦合？耦合高了有什么好处？"><a href="#做微服务的意义是什么？耦合带来了什么问题？为什么要降低耦合？耦合高了有什么好处？" class="headerlink" title="做微服务的意义是什么？耦合带来了什么问题？为什么要降低耦合？耦合高了有什么好处？"></a>做微服务的意义是什么？耦合带来了什么问题？为什么要降低耦合？耦合高了有什么好处？</h2><p>微服务的核心理念是将一个大而全的系统拆分为多个小而独立的服务，每个服务专注于一个业务功能，各服务之间通过API通信。</p><p>微服务可以降低模块之间的依赖，每个服务可以独立开发、测试、部署；然后如果某个服务出了故障，不一定影响全局，可以提高系统稳定性；多团队可并行开发，各自维护自己负责的服务；技术栈灵活，每个服务可以选用不同的技术；扩展性也好</p><p>耦合高了提高维护成本，改一个模块容易影响其他模块，容易引发连锁 Bug；扩展困难，无法对某个功能进行独立扩展，只能整体扩容，浪费资源；容错性比较差，一个模块崩了可能导致整个系统挂掉</p><p>耦合高了也有好处，单体应用性能高，逻辑直观，开发调试方便，高频调用时，方法级耦合比微服务高效</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Netty的RPC框架实现</title>
      <link href="/inori/2408437c.html"/>
      <url>/inori/2408437c.html</url>
      
        <content type="html"><![CDATA[<p>RPC又称远程过程调用（Remote Procedure Call），用于解决分布式系统中服务之间的调用问题。通俗地讲，就是开发者能够像调用本地方法一样调用远程的服务。</p><img src="/inori/2408437c/rpc.png" style="zoom:50%;"><p>RPC框架一般必须包含三个组件，分别是<strong>客户端、服务端</strong>以及<strong>注册中心</strong>，一次完整的RPC调用流程一般为：</p><ol><li>服务端启动服务后，将他提供的服务列表发布到注册中心（服务注册）</li><li>客户端会向注册中心订阅相关的服务地址（服务订阅）</li><li>客户端通常会利用本地代理模块 Proxy 向服务端发起远程过程调用，Proxy 负责将调用的方法、参数等数据转化为网络字节流</li><li>客户端从服务列表中根据负载均衡策略选择一个服务地址，并将数据通过网络发送给服务端</li><li>服务端得到数据后，调用对应的服务，然后将结果通过网络返回给客户端</li></ol><p>虽然 RPC 调用流程很容易理解，但是实现一个完整的 RPC 框架设计到很多内容，例如服务注册与发现、通信协议与序列化、负载均衡、动态代理等</p><h2 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h2><ul><li>实现基于Netty&#x2F;Socket&#x2F;Http三种方式进行网路通信</li><li>自定义消息协议，编解码器</li><li>五种序列化算法（JDK、JSON、HESSIAN、KRYO、PROTOSTUFF）</li><li>三种负载均衡算法（RoundRobin、Random、ConsistentHash）</li><li>两种动态代理（JDK、CGLIB）</li><li>基于 Zookeeper 的服务注册与发现，增加服务本地缓存与监听</li><li>集成 Spring，自定义注解提供 RPC 组件扫描、服务注册、服务消费</li><li>集成 SpringBoot，完成自动配置</li><li>增加 Netty 心跳机制，复用 Channel 连接</li><li>实现自定义 SPI 机制</li></ul><h2 id="编解码模块"><a href="#编解码模块" class="headerlink" title="编解码模块"></a>编解码模块</h2><h3 id="粘包半包解决"><a href="#粘包半包解决" class="headerlink" title="粘包半包解决"></a>粘包半包解决</h3><p>这里采取的是消息长度 + 消息内容来解决的此问题，将每一条消息分为header和body，header中包含body的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 粘包半包编码器，使用固定长度的帧解码器，通过约定用定长字节表示接下来数据的长度</span></span><br><span class="line"><span class="comment"> * 非共享，保存了 ByteBuf 的状态信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcFrameDecoder</span> <span class="keyword">extends</span> <span class="title class_">LengthFieldBasedFrameDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">k RpcFrameDecoder#RpcFrameDecoder(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcFrameDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">16384</span>, <span class="number">12</span>, <span class="number">4</span>);  <span class="comment">// 前缀长度16字节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxFrameLength    数据帧的最大长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldOffset 长度域的偏移字节数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldLength 长度域所占的字节数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcFrameDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里我给定的消息体最大长度是16384Byte，即16KB，如果消息体长度比这个要大，就会抛出异常，无法接收</p><blockquote><p> Netty官方建议不要轻易超过 8MB，否则可能导致内存过度分配、内存攻击等问题</p></blockquote><h3 id="编解码实现"><a href="#编解码实现" class="headerlink" title="编解码实现"></a>编解码实现</h3><p>编码部分是出站处理，需要编写RpcMessage模块，即header和body，header是自定义协议：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------</span><br><span class="line">| 魔数 (4byte) | 版本号 (1byte)  | 序列化算法 (1byte) | 消息类型 (1byte) |</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">|    状态类型 (1byte)  |    消息序列号 (4byte)   |    消息长度 (4byte)   |</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">|                        消息内容 (不固定)                             |</span><br><span class="line">---------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>共16字节，在粘包半包解码器中定义了偏移量。</p><p>body部分使用序列化算法进行序列化，然后向下传递。</p><p>解码部分，先验证魔数是否符合要求，然后再进行后续的解码，在使用反序列化算法解析body部分获取消息体，然后向下传递。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Sharable</span><span class="comment">// 不存在线程竞争</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharableRpcMessageCodec</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, RpcMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码器为出站处理，将 RpcMessage 编码为 ByteBuf 对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> msg.getHeader();</span><br><span class="line">        <span class="comment">// 4字节 魔数</span></span><br><span class="line">        buf.writeBytes(header.getMagicNum());</span><br><span class="line">        <span class="comment">// 1字节 版本号</span></span><br><span class="line">        buf.writeByte(header.getVersion());</span><br><span class="line">        <span class="comment">// 1字节 序列化算法</span></span><br><span class="line">        buf.writeByte(header.getSerializerType());</span><br><span class="line">        <span class="comment">// 1字节 消息类型</span></span><br><span class="line">        buf.writeByte(header.getMessageType());</span><br><span class="line">        <span class="comment">// 1字节 消息状态</span></span><br><span class="line">        buf.writeByte(header.getMessageStatus());</span><br><span class="line">        <span class="comment">// 4字节 消息序列号</span></span><br><span class="line">        buf.writeInt(header.getSequenceId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出消息体</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> msg.getBody();</span><br><span class="line">        <span class="comment">// 获取序列化算法</span></span><br><span class="line">        <span class="type">Serialization</span> <span class="variable">serialization</span> <span class="operator">=</span> SerializationFactory</span><br><span class="line">                .getSerialization(SerializationType.parseByType(header.getSerializerType()));</span><br><span class="line">        <span class="comment">// 进行序列化</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = serialization.serialize(body);</span><br><span class="line">        <span class="comment">// 设置消息体长度</span></span><br><span class="line">        header.setLength(bytes.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4字节 消息内容长度</span></span><br><span class="line">        buf.writeInt(header.getLength());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不固定字节 消息内容字节数组</span></span><br><span class="line">        buf.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传递到下一个出站处理器</span></span><br><span class="line">        out.add(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码器为入站处理，将 ByteBuf 对象解码成 RpcMessage 对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 4字节 魔数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> ProtocolConstants.MAGIC_NUM.length;</span><br><span class="line">        <span class="type">byte</span>[] magicNum = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        msg.readBytes(magicNum, <span class="number">0</span>, len);</span><br><span class="line">        <span class="comment">// 判断魔数是否正确，不正确表示非协议请求，不进行处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (magicNum[i] != ProtocolConstants.MAGIC_NUM[i]) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown magic code: &quot;</span> + Arrays.toString(magicNum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1字节 版本号</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 检查版本号是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (version != ProtocolConstants.VERSION) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The version isn&#x27;t compatible &quot;</span> + version);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1字节 序列化算法</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializeType</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 1字节 消息类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 1字节 消息状态</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageStatus</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 4字节 消息序列号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> msg.readInt();</span><br><span class="line">        <span class="comment">// 4字节 长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> msg.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        msg.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建协议头部信息</span></span><br><span class="line">        <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> MessageHeader.builder()</span><br><span class="line">                .magicNum(magicNum)</span><br><span class="line">                .version(version)</span><br><span class="line">                .serializerType(serializeType)</span><br><span class="line">                .messageType(messageType)</span><br><span class="line">                .sequenceId(sequenceId)</span><br><span class="line">                .messageStatus(messageStatus)</span><br><span class="line">                .length(length).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取反序列化算法</span></span><br><span class="line">        <span class="type">Serialization</span> <span class="variable">serialization</span> <span class="operator">=</span> SerializationFactory</span><br><span class="line">                .getSerialization(SerializationType.parseByType(serializeType));</span><br><span class="line">        <span class="comment">// 获取消息枚举类型</span></span><br><span class="line">        <span class="type">MessageType</span> <span class="variable">type</span> <span class="operator">=</span> MessageType.parseByType(messageType);</span><br><span class="line">        <span class="type">RpcMessage</span> <span class="variable">protocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcMessage</span>();</span><br><span class="line">        protocol.setHeader(header);</span><br><span class="line">        <span class="keyword">if</span> (type == MessageType.REQUEST) &#123;</span><br><span class="line">            <span class="comment">// 进行反序列化</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> serialization.deserialize(RpcRequest.class, bytes);</span><br><span class="line">            protocol.setBody(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == MessageType.RESPONSE) &#123;</span><br><span class="line">            <span class="comment">// 进行反序列化</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> serialization.deserialize(RpcResponse.class, bytes);</span><br><span class="line">            protocol.setBody(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == MessageType.HEARTBEAT_REQUEST || type == MessageType.HEARTBEAT_RESPONSE) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> serialization.deserialize(String.class, bytes);</span><br><span class="line">            protocol.setBody(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 传递到下一个处理器</span></span><br><span class="line">        out.add(protocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化算法"><a href="#序列化算法" class="headerlink" title="序列化算法"></a>序列化算法</h2><p>客户端和服务端在通信过程中肯定要传输数据，但是这些数据不可能是直接明文传输的，我们需要对数据进行编码，那么该如何编解码呢？</p><p>如果采用TCP协议，我们需要将调用的接口、方法、请求参数、调用属性等信息序列化成二进制字节流传递给服务提供方，服务端接收到数据后，再把二进制字节流反序列化得到调用信息，然后利用反射的原理调用对应方法，最后将返回结果、返回码、异常信息等返回给客户端。所谓序列化和反序列化就是将对象转换成二进制流以及将二进制流再转换成对象的过程。因为网络通信依赖于字节流，而且这些请求信息都是不确定的，所以一般会选用通用且高效的序列化算法。比较常用的序列化算法有<code>FastJson、Kryo、Hessian、Protobuf</code>等，这些第三方序列化算法都比Java原生的序列化操作都更加高效</p><p>Dubbo支持多种序列化算法，并定义了Serialization接口规范，所有序列化算法扩展都必须实现该接口，其中默认使用的是<code>Hessian</code>序列化算法</p><p>序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等同样也起着至关重要的作用，是提升分布式系统性能的最关键因素之一</p><p>判断一个编码框架的优劣主要从以下几个方面：</p><ol><li>是否支持跨语言，支持语种是否丰富</li><li>编码后的码流</li><li>编解码的性能</li><li>类库是否小巧，API使用是否方便</li><li>使用者开发的工作量和难度</li></ol><p>本项目计划实现5种序列化算法，分别为：<u>JDK、JSON、HESSIAN、KRYO 、PROTOSTUFF</u>，其中JSON使用GSON实现</p><p>五种序列化算法的比较如下：</p><table><thead><tr><th>序列化算法</th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>Kryo</strong></td><td>速度快，序列化后体积小</td><td>跨语言支持较复杂</td></tr><tr><td><strong>Hessian</strong></td><td>默认支持跨语言</td><td>较慢</td></tr><tr><td><strong>Protostuff</strong></td><td>速度快，基于protobuf</td><td>需静态编译</td></tr><tr><td><strong>Json</strong></td><td>使用方便</td><td>性能一般</td></tr><tr><td><strong>Jdk</strong></td><td>使用方便，可序列化所有类</td><td>速度慢，占空间</td></tr></tbody></table><h3 id="Hessian序列化"><a href="#Hessian序列化" class="headerlink" title="Hessian序列化"></a>Hessian序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HessianSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建字节数组输出流（内存缓冲区）</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="comment">// 创建Hessian序列化输出流</span></span><br><span class="line">            <span class="type">HessianSerializerOutput</span> <span class="variable">hso</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializerOutput</span>(baos);</span><br><span class="line">            hso.writeObject(object);</span><br><span class="line">            hso.flush();</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Hessian serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将字节数组包装为输入流</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="comment">// 创建 Hessian 反序列化输入流</span></span><br><span class="line">            <span class="type">HessianSerializerInput</span> <span class="variable">hsi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializerInput</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> (T) hsi.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Hessian deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jdk序列化"><a href="#Jdk序列化" class="headerlink" title="Jdk序列化"></a>Jdk序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">            oos.writeObject(object);</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Jdk serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line">            <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Jdk deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h3><p>由于Gson默认不能序列化Class对象，因为Class没有默认的序列化方案，举个例子，我们的RPCRequest类是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名称：请求的服务名 + 版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求调用的方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameterValues;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们要远程调用的方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(String id, <span class="type">int</span> level)</span></span><br></pre></td></tr></table></figure><p>那我们就会创建这个<code>RpcRequest</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequest</span>();</span><br><span class="line">request.setMethod(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">request.setParameterTypes(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;String.class, <span class="type">int</span>.class&#125;);</span><br><span class="line">request.setParameterValues(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;abc123&quot;</span>, <span class="number">5</span>&#125;);</span><br></pre></td></tr></table></figure><p>如果我们要使用Gson序列化这个类时，就可以自己注册一个 <code>JsonSerializer&lt;Class&lt;?&gt;&gt;</code> 和 <code>JsonDeserializer&lt;Class&lt;?&gt;&gt;</code>，完全实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义 JavaClass 对象序列化，解决 Gson 无法序列化 Class 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassCodec</span> <span class="keyword">implements</span> <span class="title class_">JsonSerializer</span>&lt;Class&lt;?&gt;&gt;, JsonDeserializer&lt;Class&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// 反序列化 String -&gt; Class</span></span><br><span class="line">        <span class="meta">@SneakyThrows</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) <span class="keyword">throws</span> JsonParseException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> json.getAsString();</span><br><span class="line">            <span class="keyword">return</span> Class.forName(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化 Class -&gt; String (类名)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> JsonElement <span class="title function_">serialize</span><span class="params">(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonPrimitive</span>(src.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class="keyword">new</span> <span class="title class_">ClassCodec</span>()).create();</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> gson.toJson(object);</span><br><span class="line">            <span class="keyword">return</span> json.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Json serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class="keyword">new</span> <span class="title class_">ClassCodec</span>()).create();</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="keyword">return</span> gson.fromJson(json, clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonSyntaxException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Json deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kryo序列化"><a href="#Kryo序列化" class="headerlink" title="Kryo序列化"></a>Kryo序列化</h3><p>为什么Kryo线程不安全？其他序列化方法为什么线程安全？这个问题我们之后单独开一个帖子说~</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// kryo 线程不安全，所以使用 ThreadLocal 保存 kryo 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        <span class="comment">// 注册需要序列化的类（提高性能并减少数据体积）</span></span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(baos);</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get(); <span class="comment">// 获取当前线程的 Kryo 实例</span></span><br><span class="line">            <span class="comment">// 将对象序列化为 byte 数组</span></span><br><span class="line">            kryo.writeObject(output, object);</span><br><span class="line">            <span class="comment">// 清理线程变量，避免内存泄漏</span></span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Kryo serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(bais);</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// 将 byte 数组反序列化为 T 对象</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">object</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Kryo deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Protostuff序列化"><a href="#Protostuff序列化" class="headerlink" title="Protostuff序列化"></a>Protostuff序列化</h3><p>Protostuff需要用一个<code>LinkedBuffer</code>作为临时写入区域，项目中提前分配一个共享的 <code>BUFFER</code>，避免每次都重新分配，提高性能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtostuffSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提前分配好 Buffer，避免每次进行序列化都需要重新分配 buffer 内存空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;LinkedBuffer&gt; BUFFER_THREAD_LOCAL =</span><br><span class="line">        ThreadLocal.withInitial(() -&gt; LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="type">LinkedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> BUFFER_THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取对象的运行时 schema</span></span><br><span class="line">            <span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> RuntimeSchema.getSchema(object.getClass());</span><br><span class="line">            <span class="comment">// 使用 protostuff 将对象转为字节数组</span></span><br><span class="line">            <span class="keyword">return</span> ProtostuffIOUtil.toByteArray(object, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Protostuff serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 使用完 buffer 后清空，避免内存泄漏</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Schema&lt;T&gt; schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="comment">// 创建空对象并填充数据</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">object</span> <span class="operator">=</span> schema.newMessage();</span><br><span class="line">            ProtostuffIOUtil.mergeFrom(bytes, object, schema);</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Protostuff deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>在分布式系统中，不同服务之间应该如何通信呢？传统的方式可以通过 HTTP 请求调用、保存服务端的服务列表等，这样做需要开发者主动感知到服务端暴露的信息，系统之间耦合严重。为了更好地将客户端和服务端解耦，以及实现服务优雅上线和下线，于是注册中心就出现了。在RPC框架中，主要是使用注册中心来实现服务注册和发现的功能。服务端节点上线后自行向注册中心注册服务列表，节点下线时需要从注册中心将节点元数据信息移除。客户端向服务端发起调用时，自己负责从注册中心获取服务端的服务列表，然后在通过负载均衡算法选择其中一个服务节点进行调用。</p><p>现在思考一个问题，服务在下线时需要从注册中心移除元数据，那么注册中心怎么才能感知到服务下线呢？我们最先想到的方法就是节点主动通知的实现方式，当节点需要下线时，向注册中心发送下线请求，让注册中心移除自己的元数据信息。但是如果节点异常退出，例如断网、进程崩溃等，那么注册中心将会一直残留异常节点的元数据，从而可能造成服务调用出现问题。</p><p>为了避免上述问题，实现服务优雅下线比较好的方式是采用主动通知 + 心跳检测的方案。除了主动通知注册中心下线外，还需要增加节点与注册中心的心跳检测功能，这个过程也叫作探活。心跳检测可以由节点或者注册中心负责，例如注册中心可以向服务节点每 60s 发送一次心跳包，如果 3 次心跳包都没有收到请求结果，可以任务该服务节点已经下线。</p><p>采用注册中心的好处是可以解耦客户端和服务端之间错综复杂的关系，并且能够实现对服务的动态管理。服务配置可以支持动态修改，然后将更新后的配置推送到客户端和服务端，无须重启任何服务。</p><p>本项目计划实现以Zookeeper为注册中心。</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>关键字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会话超时时间，客户端在此时间内未与 zk 服务器保持心跳，则认为连接断开</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SESSION_TIMEOUT</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// zk 客户端连接 zk 服务器时的连接超时时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONNECT_TIMEOUT</span> <span class="operator">=</span> <span class="number">15</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 超时重试间隔时间，用于指数回退重试策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE_SLEEP_TIME</span> <span class="operator">=</span> <span class="number">3</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 最大重试次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RETRY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// zk中所有服务注册的根路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/rpc&quot;</span>;</span><br><span class="line"><span class="comment">// Curator 提供的 zk 客户端对象，封装了 zookeeper 的连接管理、重试、监听等功能</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"><span class="comment">// Curator 的服务发现组件，用于查询、注册、注销服务实例</span></span><br><span class="line"><span class="keyword">private</span> ServiceDiscovery&lt;ServiceInfo&gt; serviceDiscovery;</span><br></pre></td></tr></table></figure><p>构造方法，传入Zookeeper地址并进行初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ZookeeperServiceRegistry</span><span class="params">(String registryAddress)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建zk客户端示例</span></span><br><span class="line">        client = CuratorFrameworkFactory</span><br><span class="line">                .newClient(registryAddress, SESSION_TIMEOUT, CONNECT_TIMEOUT,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(BASE_SLEEP_TIME, MAX_RETRY));</span><br><span class="line">        <span class="comment">// 开启客户端通信</span></span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 ServiceDiscovery 服务注册中心</span></span><br><span class="line">        serviceDiscovery = ServiceDiscoveryBuilder.builder(ServiceInfo.class)</span><br><span class="line">                .client(client)</span><br><span class="line">                .serializer(<span class="keyword">new</span> <span class="title class_">JsonInstanceSerializer</span>&lt;&gt;(ServiceInfo.class))</span><br><span class="line">                .basePath(BASE_PATH)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        serviceDiscovery.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;An error occurred while starting the zookeeper registry: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册方法，将服务注册到zk中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceInstance&lt;ServiceInfo&gt; serviceInstance = ServiceInstance.&lt;ServiceInfo&gt;builder()</span><br><span class="line">                .name(serviceInfo.getServiceName())</span><br><span class="line">                .address(serviceInfo.getAddress())</span><br><span class="line">                .port(serviceInfo.getPort())</span><br><span class="line">                .payload(serviceInfo)</span><br><span class="line">                .build();</span><br><span class="line">        serviceDiscovery.registerService(serviceInstance);</span><br><span class="line">        log.info(<span class="string">&quot;Successfully registered [&#123;&#125;] service.&quot;</span>, serviceInstance.getName());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;An error occurred when rpc server registering [%s] service.&quot;</span>,</span><br><span class="line">                serviceInfo.getServiceName()), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务注销与删除方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(ServiceInfo serviceInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ServiceInstance&lt;ServiceInfo&gt; serviceInstance = ServiceInstance.&lt;ServiceInfo&gt;builder()</span><br><span class="line">            .name(serviceInfo.getServiceName())</span><br><span class="line">            .address(serviceInfo.getAddress())</span><br><span class="line">            .port(serviceInfo.getPort())</span><br><span class="line">            .payload(serviceInfo)</span><br><span class="line">            .build();</span><br><span class="line">    serviceDiscovery.unregisterService(serviceInstance);</span><br><span class="line">    log.warn(<span class="string">&quot;Successfully unregistered &#123;&#125; service.&quot;</span>, serviceInstance.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    serviceDiscovery.close();</span><br><span class="line">    client.close();</span><br><span class="line">    log.info(<span class="string">&quot;Destroy zookeeper registry completed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>关键字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SESSION_TIMEOUT</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONNECT_TIMEOUT</span> <span class="operator">=</span> <span class="number">15</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE_SLEEP_TIME</span> <span class="operator">=</span> <span class="number">3</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RETRY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/rpc&quot;</span>;</span><br><span class="line"><span class="comment">// 负载均衡接口</span></span><br><span class="line"><span class="keyword">private</span> LoadBalance loadBalance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> org.apache.curator.x.discovery.ServiceDiscovery&lt;ServiceInfo&gt; serviceDiscovery;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServiceCache: 将在zk中的服务数据缓存至本地，并监听服务变化，实时更新缓存</span></span><br><span class="line"><span class="comment"> * 服务本地缓存，将服务缓存到本地并增加 watch 事件，当远程服务发生改变时自动更新服务缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ServiceCache&lt;ServiceInfo&gt;&gt; serviceCacheMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 将服务列表缓存到本地内存，当服务发生变化时，由 serviceCache 进行服务列表更新操作，当 zk 挂掉时，将保存当前服务列表以便继续提供服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;ServiceInfo&gt;&gt; serviceMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>构造方法，初始化zk客户端和服务发现对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ZookeeperServiceDiscovery</span><span class="params">(String registryAddress, LoadBalance loadBalance)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadBalance = loadBalance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建zk客户端示例</span></span><br><span class="line">        client = CuratorFrameworkFactory</span><br><span class="line">                .newClient(registryAddress, SESSION_TIMEOUT, CONNECT_TIMEOUT,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(BASE_SLEEP_TIME, MAX_RETRY));</span><br><span class="line">        <span class="comment">// 开启客户端通信</span></span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 ServiceDiscovery 服务注册中心</span></span><br><span class="line">        serviceDiscovery = ServiceDiscoveryBuilder.builder(ServiceInfo.class)</span><br><span class="line">                .client(client)</span><br><span class="line">                .serializer(<span class="keyword">new</span> <span class="title class_">JsonInstanceSerializer</span>&lt;&gt;(ServiceInfo.class))</span><br><span class="line">                .basePath(BASE_PATH)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 开启 服务发现</span></span><br><span class="line">        serviceDiscovery.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;An error occurred while starting the zookeeper discovery: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取服务列表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ServiceInfo&gt; <span class="title function_">getServices</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!serviceMap.containsKey(serviceName)) &#123;</span><br><span class="line">        <span class="comment">// 首次调用时，为该服务名构建一个本地缓存，并开始监听 zk 目录下该服务名节点的变化</span></span><br><span class="line">        ServiceCache&lt;ServiceInfo&gt; serviceCache = serviceDiscovery.serviceCacheBuilder()</span><br><span class="line">                .name(serviceName)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 添加服务监听，当服务发生变化时主动更新本地缓存并通知</span></span><br><span class="line">        serviceCache.addListener(<span class="keyword">new</span> <span class="title class_">ServiceCacheListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cacheChanged</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;The service [&#123;&#125;] cache has changed. The current number of service samples is &#123;&#125;.&quot;</span></span><br><span class="line">                        , serviceName, serviceCache.getInstances().size());</span><br><span class="line">                <span class="comment">// 更新本地缓存的服务列表</span></span><br><span class="line">                serviceMap.put(serviceName, serviceCache.getInstances().stream()</span><br><span class="line">                        .map(ServiceInstance::getPayload)</span><br><span class="line">                        .collect(Collectors.toList()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> &#123;</span><br><span class="line">                <span class="comment">// 当连接状态发生改变时，只打印提示信息，保留本地缓存的服务列表</span></span><br><span class="line">                log.info(<span class="string">&quot;The client &#123;&#125; connection status has changed. The current status is: &#123;&#125;.&quot;</span></span><br><span class="line">                        , client, newState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 开启服务缓存监听</span></span><br><span class="line">        serviceCache.start();</span><br><span class="line">        <span class="comment">// 将服务缓存对象存入本地</span></span><br><span class="line">        serviceCacheMap.put(serviceName, serviceCache);</span><br><span class="line">        <span class="comment">// 将服务列表缓存到本地</span></span><br><span class="line">        serviceMap.put(serviceName, serviceCacheMap.get(serviceName).getInstances()</span><br><span class="line">                .stream()</span><br><span class="line">                .map(ServiceInstance::getPayload)</span><br><span class="line">                .collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serviceMap.get(serviceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择服务实例，根据服务名 + 负载均衡策略选择一个可用的 <code>ServiceInfo</code> 服务实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">discover</span><span class="params">(RpcRequest request)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loadBalance.select(getServices(request.getServiceName()), request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;Remote service discovery did not find service %s.&quot;</span>,</span><br><span class="line">                request.getServiceName()), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清理所有zk相关连接资源，确保优雅下线：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (ServiceCache&lt;ServiceInfo&gt; serviceCache : serviceCacheMap.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (serviceCache != <span class="literal">null</span>) &#123;</span><br><span class="line">            serviceCache.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (serviceDiscovery != <span class="literal">null</span>) &#123;</span><br><span class="line">        serviceDiscovery.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>在分布式系统中，服务提供者和服务消费者都会有多台节点，如何保证服务提供者所有节点的负载均衡呢？</p><p>客户端在发起调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。客户端需要拿到服务端节点的状态信息，并根据不同的策略实现负载均衡算法</p><ul><li>Round-Robin轮询：依次轮询服务端节点</li><li>Weighted Round-Robin 权重轮询：对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量</li><li>Least Connections 最少连接数：客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU利用率最低等其他维度的负载均衡方案</li><li>Consistent Hash 一致性 Hash：目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点</li></ul><p>本项目实现Random、Round-Robin、Consistent Hash三种负载均衡算法</p><p>首先编写一个抽象类，定义实现负载均衡的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLoadBalance</span> <span class="keyword">implements</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">select</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="literal">null</span> || invokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果服务列表中只有一个服务，无需进行负载均衡，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行负载均衡，由具体的子类实现</span></span><br><span class="line">        <span class="keyword">return</span> doSelect(invokers, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现具体负载均衡策略的选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers 服务列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  rpc 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回服务信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机负载均衡"><a href="#随机负载均衡" class="headerlink" title="随机负载均衡"></a>随机负载均衡</h3><p>随机选择一个节点即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(random.nextInt(invokers.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="轮询负载均衡"><a href="#轮询负载均衡" class="headerlink" title="轮询负载均衡"></a>轮询负载均衡</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(getAndIncrement() % invokers.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前值并加一，通过 CAS 原子更新，当前值到达 &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125; 时，重新设值为 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回当前的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = atomicInteger.get();</span><br><span class="line">            next = prev == Integer.MAX_VALUE ? <span class="number">0</span> : prev + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!atomicInteger.compareAndSet(prev, next));<span class="comment">//把prev更新成next</span></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性哈希负载均衡"><a href="#一致性哈希负载均衡" class="headerlink" title="一致性哈希负载均衡"></a>一致性哈希负载均衡</h3><p>在分布式系统中，负载均衡是将请求分发到多个服务节点上的关键手段。如果使用简单的哈希方式（比如：<code>hash(key) % 节点数量</code>），当服务节点发生变化（如新增或下线一个服务节点），所有请求的分发都会大范围变化，这会导致：</p><ul><li>原本某个 key 缓存在 A 节点，新请求可能被分配到 B，导致缓存失效</li><li>用户粘性丧失，会话丢失</li><li>系统效率大幅下降</li></ul><p>所以我们希望：<strong>节点数量变化时，尽量少地影响原有请求的分配规律</strong></p><p>一致性哈希算法就是为此设计的，它有两个目标：</p><ol><li>相同的请求key总是路由到同一个节点（请求一致性）</li><li>节点变动时，只有<strong>极少数 key</strong>被重新分配（低扰动性）</li></ol><h4 id="一致性哈希的基本原理"><a href="#一致性哈希的基本原理" class="headerlink" title="一致性哈希的基本原理"></a>一致性哈希的基本原理</h4><ol><li>将哈希空间想象成一个“环”</li></ol><ul><li>假设 hash 值范围是 0 ~ 2³²-1，我们可以把它画成一个圆环</li><li>所有节点（服务实例）都通过哈希函数映射到这个环上某个位置</li></ul><ol start="2"><li>将请求（根据其 key）也映射到环上</li></ol><ul><li>请求经过哈希函数也会得到一个 hash 值，在环上的某个点</li></ul><ol start="3"><li>如何选择目标节点？</li></ol><ul><li>从请求所在的 hash 点开始，顺时针查找，直到找到第一个节点</li><li>这个节点就是这个请求应该被分配到的服务节点</li></ul><p>举个例子：</p><p>假设环上有 3 个节点：</p><ul><li>A → 哈希值 1000</li><li>B → 哈希值 4000</li><li>C → 哈希值 7000</li></ul><p>如果请求 key 哈希值为 4200，它将落在 C（7000）上</p><p>如果 key 哈希值为 8000，环上没有节点比它大，就从头开始找，第一个是 A（1000），所以分到 A</p><h4 id="虚拟节点机制"><a href="#虚拟节点机制" class="headerlink" title="虚拟节点机制"></a>虚拟节点机制</h4><p>真实服务节点数量较少（如3~5个），哈希分布不均匀，可能会出现某个节点承载大量请求的情况，导致负载不均</p><p>虚拟节点的做法：</p><ul><li>每个真实节点被映射成多个虚拟节点（通常是160个）</li><li>每个虚拟节点 hash 后也放在环上</li><li>请求还是通过 hash 值查找最近的虚拟节点，然后找出它对应的真实节点</li></ul><p>效果</p><ul><li>请求被均匀地分布到多个虚拟节点上</li><li>从而间接实现真实节点的负载均衡</li></ul><h4 id="处理节点变更问题"><a href="#处理节点变更问题" class="headerlink" title="处理节点变更问题"></a>处理节点变更问题</h4><p>新增节点：</p><ul><li>会在环上增加一些新的虚拟节点</li><li>新虚拟节点会“截断”一小段原本属于其他节点的请求范围</li><li>只有这一小部分请求分配发生变化，其他绝大部分 key 对应的服务节点不变</li></ul><p>删除节点：</p><ul><li>其虚拟节点从环上移除</li><li>这些虚拟节点对应的请求会顺时针路由到下一个节点</li><li>同样只影响少部分请求</li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>编写静态内部类，实现一致性哈希的核心部分，维护一个<strong>虚拟节点环</strong>来实现平衡性和低扰动性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashSelector</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 TreeMap 存储虚拟节点（virtualInvokers 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构，底层使用红黑树，比HashMap查询速度要快）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, ServiceInfo&gt; virtualInvokers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invokers 的原始哈希码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> identityHashCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个 ConsistentHashSelector 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers         存储虚拟节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replicaNumber    虚拟节点数，默认为 160</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> identityHashCode invokers 的原始哈希码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsistentHashSelector</span><span class="params">(List&lt;ServiceInfo&gt; invokers, <span class="type">int</span> replicaNumber, <span class="type">int</span> identityHashCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.virtualInvokers = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.identityHashCode = identityHashCode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ServiceInfo invoker : invokers) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> invoker.getAddress();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 对 address + i 进行 md5 运算，得到一个长度为16的字节数组</span></span><br><span class="line">                <span class="type">byte</span>[] digest = md5(address + i);</span><br><span class="line">                <span class="comment">// 对 digest 部分字节进行4次 hash 运算，得到四个不同的 long 型正整数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                    <span class="comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span></span><br><span class="line">                    <span class="comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span></span><br><span class="line">                    <span class="comment">// h = 2, h = 3 时过程同上</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> hash(digest, h);</span><br><span class="line">                    <span class="comment">// 将 hash 到 invoker 的映射关系存储到 virtualInvokers 中</span></span><br><span class="line">                    virtualInvokers.put(m, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行 md5 运算，返回摘要字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 编码字符串 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编码后的摘要内容，长度为 16 的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] md5(String key) &#123;</span><br><span class="line">        MessageDigest md;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] bytes = key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            md.update(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> md.digest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据摘要生成 hash 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> digest md5摘要内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number 当前索引数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> hash 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">hash</span><span class="params">(<span class="type">byte</span>[] digest, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (((<span class="type">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">                &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">select</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 对参数 key 进行 md5 运算</span></span><br><span class="line">        <span class="type">byte</span>[] digest = md5(key);</span><br><span class="line">        <span class="comment">// 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，</span></span><br><span class="line">        <span class="comment">// 寻找合适的 Invoker</span></span><br><span class="line">        <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个大于等于 hash 值的服务信息，若没有则返回第一个</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ServiceInfo <span class="title function_">selectForKey</span><span class="params">(<span class="type">long</span> hash)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到 TreeMap 中查找第一个节点值大于或等于当前 hash 的 Invoker</span></span><br><span class="line">        Map.Entry&lt;Long, ServiceInfo&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class="line">        <span class="comment">// 如果 hash 大于 Invoker 在圆环上最大的位置，此时 entry = null，需要将 TreeMap 的头节点赋值给 entry</span></span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">            entry = virtualInvokers.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希方法步骤：</p><ol><li>用MD5算法生成摘要：对IP地址+端口号执行MD5，得到长度16字节的摘要</li><li>从摘要中提取出多个32-bit的无符号整数（即虚拟节点哈希值）<ul><li>每次从 16 字节的摘要中，取出连续的 4 字节</li><li>对这四个字节通过位运算拼接成一个32位的整数，代表一个hash值</li><li>执行4次，得到4个hash值</li></ul></li></ol><p>具体轮询方法实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到请求的方法名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    <span class="comment">// 构建对应的 key 值，key = 全限定类名 + &quot;.&quot; + 方法名，比如 com.xxx.DemoService.sayHello</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> request.getServiceName() + <span class="string">&quot;.&quot;</span> + method;</span><br><span class="line">    <span class="comment">// 获取 invokers 原始的 hashCode</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">identityHashCode</span> <span class="operator">=</span> System.identityHashCode(invokers);</span><br><span class="line">    <span class="comment">// 从 map 从获取对应的 selector</span></span><br><span class="line">    <span class="type">ConsistentHashSelector</span> <span class="variable">selector</span> <span class="operator">=</span> selectors.get(key);</span><br><span class="line">    <span class="comment">// 如果为 null，表示之前没有缓存过，如果 hashcode 不一致，表示缓存的服务列表发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="literal">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">        <span class="comment">// 创建新的 selector 并缓存</span></span><br><span class="line">        selectors.put(key, <span class="keyword">new</span> <span class="title class_">ConsistentHashSelector</span>(invokers, <span class="number">160</span>, identityHashCode));</span><br><span class="line">        selector = selectors.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 ConsistentHashSelector 的 select 方法选择 Invoker</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">selectKey</span> <span class="operator">=</span> key;</span><br><span class="line">    <span class="comment">// 将 key 与 方法参数进行 hash 运算，因此 ConsistentHashLoadBalance 的负载均衡逻辑只受参数值影响，</span></span><br><span class="line">    <span class="comment">// 具有相同参数值的请求将会被分配给同一个服务提供者。ConsistentHashLoadBalance 不关系权重</span></span><br><span class="line">    <span class="keyword">if</span> (request.getParameterValues() != <span class="literal">null</span> &amp;&amp; request.getParameterValues().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        selectKey += Arrays.stream(request.getParameterValues());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selector.select(selectKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方法名和参数生成哈希键，从缓存中获取一致性哈希选择器，根据选择器将相同参数请求始终路由到同一个服务节点，实现基于参数的一致性哈希负载均衡</p><h2 id="网络通信模块"><a href="#网络通信模块" class="headerlink" title="网络通信模块"></a>网络通信模块</h2><p>本项目实现了基于Netty、Http、Socket三种网络通信方式，关于这三种通信方式的区别，我会在另一个文章中说明</p><h3 id="Netty通信"><a href="#Netty通信" class="headerlink" title="Netty通信"></a>Netty通信</h3><p>首先编写通信处理入口，使用Netty启动TCP服务器监听指定端口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Integer port)</span> &#123;</span><br><span class="line">        <span class="comment">// boss 处理 accept 事件</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">// worker 处理 read/write 事件</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line"></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 是否开启 TCP 底层心跳机制</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG))</span><br><span class="line">                    <span class="comment">// 当客户端第一次请求时才会进行初始化</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 30s内没有收到客户端的请求就关闭连接，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcFrameDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SharableRpcMessageCodec</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyRpcRequestHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，同步等待绑定成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(inetAddress, port).sync();</span><br><span class="line">            log.debug(<span class="string">&quot;Rpc server add &#123;&#125; started on the port &#123;&#125;.&quot;</span>, inetAddress, port);</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException | InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;An error occurred while starting the rpc service.&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler中我加入了NettyRpcRequestHandler，作为具体的业务实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcRequestHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestHandler rpcRequestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NettyRpcRequestHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">RpcMessage</span> <span class="variable">responseRpcMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcMessage</span>();</span><br><span class="line">                <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> msg.getHeader();</span><br><span class="line">                <span class="type">MessageType</span> <span class="variable">type</span> <span class="operator">=</span> MessageType.parseByType(header.getMessageType());</span><br><span class="line">                log.debug(<span class="string">&quot;The message received by the server is: &#123;&#125;&quot;</span>, msg.getBody());</span><br><span class="line">                <span class="comment">// 如果是心跳检测请求信息</span></span><br><span class="line">                <span class="keyword">if</span> (type == MessageType.HEARTBEAT_REQUEST) &#123;</span><br><span class="line">                    header.setMessageType(MessageType.HEARTBEAT_RESPONSE.getType());</span><br><span class="line">                    header.setMessageStatus(MessageStatus.SUCCESS.getCode());</span><br><span class="line">                    <span class="comment">// 设置响应头部信息</span></span><br><span class="line">                    responseRpcMessage.setHeader(header);</span><br><span class="line">                    responseRpcMessage.setBody(ProtocolConstants.PONG);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理 Rpc 请求信息</span></span><br><span class="line">                    <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> (RpcRequest) msg.getBody();</span><br><span class="line">                    <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">                    <span class="comment">// 设置头部消息类型</span></span><br><span class="line">                    header.setMessageType(MessageType.RESPONSE.getType());</span><br><span class="line">                    <span class="comment">// 反射调用</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取本地反射调用结果</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> rpcRequestHandler.handleRpcRequest(request);</span><br><span class="line">                        response.setReturnValue(result);</span><br><span class="line">                        header.setMessageStatus(MessageStatus.SUCCESS.getCode());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;The service [&#123;&#125;], the method [&#123;&#125;] invoke failed!&quot;</span>, request.getServiceName(), request.getMethod());</span><br><span class="line">                        <span class="comment">// 若不设置，堆栈信息过多，导致报错</span></span><br><span class="line">                        response.setExceptionValue(<span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Error in remote procedure call, &quot;</span> + e.getMessage()));</span><br><span class="line">                        header.setMessageStatus(MessageStatus.FAIL.getCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置响应头部信息</span></span><br><span class="line">                    responseRpcMessage.setHeader(header);</span><br><span class="line">                    responseRpcMessage.setBody(response);</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;responseRpcMessage: &#123;&#125;.&quot;</span>, responseRpcMessage);</span><br><span class="line">                <span class="comment">// 将结果写入，传递到下一个处理器</span></span><br><span class="line">                ctx.writeAndFlush(responseRpcMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 确保 ByteBuf 被释放，防止发生内存泄露</span></span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义事件，当触发读空闲时，自动关闭客户端channel连接，netty自动调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="type">IdleState</span> <span class="variable">state</span> <span class="operator">=</span> ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;idle check happen, so close the connection.&quot;</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;server catch exception&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Http通信"><a href="#Http通信" class="headerlink" title="Http通信"></a>Http通信</h3><p>编写http通信实现类，通过内置Tomcat实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRpcServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Integer port)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> tomcat.getServer();</span><br><span class="line">            <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> server.findService(<span class="string">&quot;Tomcat&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>();</span><br><span class="line">            connector.setPort(port);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">hostname</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line"></span><br><span class="line">            <span class="type">StandardEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEngine</span>();</span><br><span class="line">            engine.setDefaultHost(hostname);</span><br><span class="line"></span><br><span class="line">            <span class="type">StandardHost</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardHost</span>();</span><br><span class="line">            host.setName(hostname);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardContext</span>();</span><br><span class="line">            context.setPath(contextPath);</span><br><span class="line">            context.addLifecycleListener(<span class="keyword">new</span> <span class="title class_">Tomcat</span>.FixContextListener());</span><br><span class="line"></span><br><span class="line">            host.addChild(context);</span><br><span class="line">            engine.addChild(host);</span><br><span class="line"></span><br><span class="line">            service.setContainer(engine);</span><br><span class="line">            service.addConnector(connector);</span><br><span class="line"></span><br><span class="line">            tomcat.addServlet(contextPath, <span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>());</span><br><span class="line">            context.addServletMappingDecoded(<span class="string">&quot;/*&quot;</span>, <span class="string">&quot;dispatcher&quot;</span>);</span><br><span class="line"></span><br><span class="line">            tomcat.start();</span><br><span class="line">            tomcat.getServer().await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException | UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Tomcat server failed to start.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat接收到http请求后，会交给DispatcherServlet类进行统一处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前处理器数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cpuNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(cpuNum * <span class="number">2</span>, cpuNum * <span class="number">2</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpRpcRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> SingletonFactory.getInstance(HttpRpcRequestHandler.class);</span><br><span class="line">        threadPool.submit(() -&gt; handler.handle(req, resp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后由DispatcherServlet将请求发给HttpRpcRequestHandler进行实际业务处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRpcRequestHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestHandler rpcRequestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HttpRpcRequestHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(req.getInputStream());</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(resp.getOutputStream());</span><br><span class="line">            <span class="comment">// 读取客户端请求</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> (RpcRequest) ois.readObject();</span><br><span class="line">            log.debug(<span class="string">&quot;The server received message is &#123;&#125;.&quot;</span>, request);</span><br><span class="line">            <span class="comment">// 创建一个 RpcResponse 对象来响应客户端</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求的服务对应的实例对象反射调用方法的结果</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> rpcRequestHandler.handleRpcRequest(request);</span><br><span class="line">                response.setReturnValue(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;The service [&#123;&#125;], the method [&#123;&#125;] invoke failed!&quot;</span>, request.getServiceName(), request.getMethod());</span><br><span class="line">                <span class="comment">// 若不设置，堆栈信息过多，导致报错</span></span><br><span class="line">                response.setExceptionValue(<span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Error in remote procedure call, &quot;</span> + e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;The response is &#123;&#125;.&quot;</span>, response);</span><br><span class="line">            oos.writeObject(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The http server failed to handle client rpc request.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Socket通信"><a href="#Socket通信" class="headerlink" title="Socket通信"></a>Socket通信</h3><p>socket通信是最原始的通信方式，首先编写server类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketRpcServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前处理器数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cpuNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程大小：这一点要看我们执行的任务是cpu密集型，还是io密集型</span></span><br><span class="line">    <span class="comment">// 如果有关于计算机计算，比较消耗资源的是cpu密集型，线程大小应该设置为：cpu 核数 + 1</span></span><br><span class="line">    <span class="comment">// 如果有关网络传输，连接数据库等，是io密集型，线程大小应该设置为：cpu * 2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(cpuNum * <span class="number">2</span>, cpuNum * <span class="number">2</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Integer port)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">hostAddress</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(hostAddress, port));</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="comment">// 循环接受客户端 Socket 连接（accept为阻塞时等待连接）</span></span><br><span class="line">            <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;The client connected [&#123;&#125;].&quot;</span>, socket.getInetAddress());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> <span class="title class_">SocketRpcRequestHandler</span>(socket));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 服务端连断开，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;The socket server failed to start on port %d.&quot;</span>, port), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是具体的请求处理逻辑，实现<code>Runnable</code>接口，配合线程池执行每一个客户端连接的请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketRpcRequestHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestHandler rpcRequestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketRpcRequestHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;The server handle client message by thread &#123;&#125;.&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream())) &#123;</span><br><span class="line">            <span class="comment">// 注意：SocketServer 接受和发送的数据为：RpcRequest, RpcResponse</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">// 直接读取客户端发送过来的 RpcRequest，此时不需要进行编解码，无需消息协议</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> (RpcRequest) ois.readObject();</span><br><span class="line">            log.debug(<span class="string">&quot;The server received message is &#123;&#125;.&quot;</span>, request);</span><br><span class="line">            <span class="comment">// 创建一个 RpcResponse 对象用来响应给客户端</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求的服务对应的实例对象反射调用方法的结果</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> rpcRequestHandler.handleRpcRequest(request);</span><br><span class="line">                response.setReturnValue(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;The service [&#123;&#125;], the method [&#123;&#125;] invoke failed!&quot;</span>, request.getServiceName(), request.getMethod());</span><br><span class="line">                <span class="comment">// 若不设置，堆栈信息过多，导致报错</span></span><br><span class="line">                response.setExceptionValue(<span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Error in remote procedure call, &quot;</span> + e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;The response is &#123;&#125;.&quot;</span>, response);</span><br><span class="line">            oos.writeObject(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The socket server failed to handle client rpc request.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>RPC框架怎么做到像调用本地接口一样调用远端服务呢？这必须依赖动态代理来实现</p><p>需要创建一个代理对象，在代理对象中完成数据报文编码，然后发起调用发送数据给服务提供方，以此屏蔽RPC框架的调用细节。因为代理类是在运行时生成的，所以代理类的生成速度、生成的字节码大小都会影响RPC框架整体的性能和资源消耗</p><p>动态代理比较主流的实现方案有以下几种：JDK、Cglib、Javassist、ASM、ByteBuddy</p><ul><li>JDK：在运行时可以动态创建代理类，但是 JDK 动态代理的功能比较局限，代理对象必须实现一个接口，否则抛出异常。因为代理类会继承Proxy类，然而 Java 是不支持多重继承的，只能通过接口实现多态。JDK 动态代理所生成的代理类是接口的实现类，不能代理接口中不存在的方法。JDK 动态代理是通过反射调用的形式代理类中的方法，比直接调用肯定是性能要慢的</li><li>Cglib：Cglib是基于ASM字节码生成框架实现的，通过字节码技术生成的代理类，所以代理类的类型是不受限制的。而且Cglib生成的代理类是继承于被代理类，所以可以提供更加灵活的功能。在代理方法方面，Cglib 是有优势的，它采用了 FastClass 机制，为代理类和被代理类各自创建一个 Class，这个 Class会为代理类和被代理类的方法分配 index 索引，FastClass 就可以通过 index 直接定位要调用的方法，并直接调用，这是一种空间换时间的优化思路</li><li>Javassist和ASM。二者都是Java字节码操作框架，使用起来难度较大，需要开发者对 Class 文件结构以及 JVM 都有所了解，但是它们都比反射的性能要高</li><li>Byte Buddy 也是一个字节码生成和操作的类库，Byte Buddy 功能强大，相比于 Javassist 和 ASM，Byte Buddy 提供了更加便捷的 API，用于创建和修改 Java 类，无须理解字节码的格式，而且 Byte Buddy 更加轻量，性能更好</li></ul><p>本项目实现了JDK和CGLIB动态代理</p><p>具体的代理逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientStubProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务发现中心实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery discovery;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RpcClient 传输实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient rpcClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端配置属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClientProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientStubProxyFactory</span><span class="params">(ServiceDiscovery discovery, RpcClient rpcClient, RpcClientProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.discovery = discovery;</span><br><span class="line">        <span class="built_in">this</span>.rpcClient = rpcClient;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理对象缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; proxyMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz   服务接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version 版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;     代理对象的参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应版本的代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz, String version)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) proxyMap.computeIfAbsent(ServiceUtil.serviceKey(clazz.getName(), version), serviceName -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果目标类是一个接口或者 是 java.lang.reflect.Proxy 的子类 则默认使用 JDK 动态代理</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isInterface() || Proxy.isProxyClass(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;clazz&#125;, <span class="comment">// 注意，这里的接口是 clazz 本身（要代理的实现类所实现的接口）</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ClientStubInvocationHandler</span>(discovery, rpcClient, properties, serviceName));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 使用 CGLIB 动态代理</span></span><br><span class="line">                <span class="comment">// 创建动态代理增加类</span></span><br><span class="line">                <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">                <span class="comment">// 设置类加载器</span></span><br><span class="line">                enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">                <span class="comment">// 设置被代理类</span></span><br><span class="line">                enhancer.setSuperclass(clazz);</span><br><span class="line">                <span class="comment">// 设置方法拦截器</span></span><br><span class="line">                enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">ClientStubMethodInterceptor</span>(discovery, rpcClient, properties, serviceName));</span><br><span class="line">                <span class="comment">// 创建代理类</span></span><br><span class="line">                <span class="keyword">return</span> enhancer.create();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Netty心跳机制与Channel复用"><a href="#Netty心跳机制与Channel复用" class="headerlink" title="Netty心跳机制与Channel复用"></a>Netty心跳机制与Channel复用</h2><p>为了解决每次请求客户端都要重新与服务端建立netty连接，非常耗时，增加心跳检查机制，保持长连接，复用channel连接；</p><ul><li>长连接：避免了每次调用新建TCP连接，提高了调用的响应速度</li><li>Channel 连接复用：避免重复连接服务端</li><li>多路复用：单个TCP连接可交替传输多个请求和响应的消息，降低了连接的等待闲置时间，从而减少了同样并发数下的网络连接数，提高了系统吞吐量</li></ul><h3 id="多路复用实现"><a href="#多路复用实现" class="headerlink" title="多路复用实现"></a>多路复用实现</h3><p>使用一个<code>ConcurrentHashMap</code>存放每个请求的等待结果区，当响应回来时，用sequenceId找到对应的Promise完成结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Promise&lt;RpcMessage&gt;&gt; UNPROCESSED_RPC_RESPONSES = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>拿到已经返回结果的Promise：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MessageType</span> <span class="variable">type</span> <span class="operator">=</span> MessageType.parseByType(msg.getHeader().getMessageType());</span><br><span class="line">        <span class="comment">// 如果是 RpcResponse 请求</span></span><br><span class="line">        <span class="keyword">if</span> (type == MessageType.RESPONSE) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> msg.getHeader().getSequenceId();</span><br><span class="line">            <span class="comment">// 拿到还未执行完成的 promise 对象</span></span><br><span class="line">            Promise&lt;RpcMessage&gt; promise = UNPROCESSED_RPC_RESPONSES.remove(sequenceId);</span><br><span class="line">            <span class="keyword">if</span> (promise != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> ((RpcResponse) msg.getBody()).getExceptionValue();</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="literal">null</span>) &#123;</span><br><span class="line">                    promise.setSuccess(msg);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.setFailure(exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == MessageType.HEARTBEAT_RESPONSE) &#123; <span class="comment">// 如果是心跳检查请求</span></span><br><span class="line">            log.debug(<span class="string">&quot;Heartbeat info &#123;&#125;.&quot;</span>, msg.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放内存，防止内存泄漏</span></span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发出请求后，存放还未返回结果的Promise：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RpcMessage <span class="title function_">sendRpcRequest</span><span class="params">(RequestMetadata requestMetadata)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建接收返回结果的 promise</span></span><br><span class="line">    Promise&lt;RpcMessage&gt; promise;</span><br><span class="line">    <span class="comment">// 获取 Channel 对象</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> getChannel(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(requestMetadata.getServerAddr(), requestMetadata.getPort()));</span><br><span class="line">    <span class="keyword">if</span> (channel.isActive()) &#123;</span><br><span class="line">        <span class="comment">// 创建 promise 来接受结果         指定执行完成通知的线程</span></span><br><span class="line">        promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(channel.eventLoop());</span><br><span class="line">        <span class="comment">// 获取请求的序列号 ID</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> requestMetadata.getRpcMessage().getHeader().getSequenceId();</span><br><span class="line">        <span class="comment">// 存入还未处理的请求</span></span><br><span class="line">        RpcResponseHandler.UNPROCESSED_RPC_RESPONSES.put(sequenceId, promise);</span><br><span class="line">        <span class="comment">// 发送数据并监听发送状态</span></span><br><span class="line">        channel.writeAndFlush(requestMetadata.getRpcMessage()).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;The client send the message successfully, msg: [&#123;&#125;].&quot;</span>, requestMetadata);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                future.channel().close();</span><br><span class="line">                promise.setFailure(future.cause());</span><br><span class="line">                log.error(<span class="string">&quot;The client send the message failed.&quot;</span>, future.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">timeout</span> <span class="operator">=</span> requestMetadata.getTimeout();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待结果返回（让出cpu资源，同步阻塞调用线程main，其他线程去执行获取操作（eventLoop））</span></span><br><span class="line">        <span class="comment">// 如果没有指定超时时间，则 await 直到 promise 完成</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="literal">null</span> || timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            promise.await();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在指定超时时间内等待结果返回</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> promise.await(requestMetadata.getTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                promise.setFailure(<span class="keyword">new</span> <span class="title class_">TimeoutException</span>(String.format(<span class="string">&quot;The Remote procedure call exceeded the &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;specified timeout of %dms.&quot;</span>, timeout)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (promise.isSuccess()) &#123;</span><br><span class="line">            <span class="comment">// 返回响应结果</span></span><br><span class="line">            <span class="keyword">return</span> promise.getNow();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(promise.cause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The channel is inactivate.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="长连接实现"><a href="#长连接实现" class="headerlink" title="长连接实现"></a>长连接实现</h3><p>在client的响应消息处理器中添加自定义时间处理器，当检测到写空闲发生时自动发送一个心跳包：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户自定义事件处理器，处理写空闲，当检测到写空闲发生自动发送一个心跳检测数据包</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx ctx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evt evt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception ex</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((IdleStateEvent) evt).state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Write idle happen [&#123;&#125;].&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">            <span class="comment">// 构造 心跳检查 RpcMessage</span></span><br><span class="line">            <span class="type">RpcMessage</span> <span class="variable">rpcMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcMessage</span>();</span><br><span class="line">            <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> MessageHeader.build(SerializationType.KRYO.name());</span><br><span class="line">            header.setMessageType(MessageType.HEARTBEAT_REQUEST.getType());</span><br><span class="line">            rpcMessage.setHeader(header);</span><br><span class="line">            rpcMessage.setBody(ProtocolConstants.PING);</span><br><span class="line">            <span class="comment">// 发送心跳检测请求</span></span><br><span class="line">            ctx.writeAndFlush(rpcMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Channel连接复用"><a href="#Channel连接复用" class="headerlink" title="Channel连接复用"></a>Channel连接复用</h3><p>使用ConcurrentHashMap存放每个<code>IP+端口号</code>使用过的Channel，如果当前IP的端口再次发起rpc请求后，检测到之前的Channel还没关闭，就可以再次使用，避免重复连接服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储 Channel，key 为 ip:port，val 为 channel 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">get</span><span class="params">(String hostname, Integer port)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> hostname + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">        <span class="comment">// 如果之前对应的 ip port 已经建立了 channel</span></span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 取出 channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channels.get(key);</span><br><span class="line">            <span class="comment">// 如果 channel 不为 null，并且处于活跃状态（连接状态）</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 为 null 或者已经关闭连接，从 map 中移除</span></span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">get</span><span class="params">(InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(inetSocketAddress.getHostName(), inetSocketAddress.getPort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String hostname, Integer port, Channel channel)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> hostname + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(InetSocketAddress inetSocketAddress, Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.set(inetSocketAddress.getHostName(), inetSocketAddress.getPort(), channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成Spring自定义注解"><a href="#集成Spring自定义注解" class="headerlink" title="集成Spring自定义注解"></a>集成Spring自定义注解</h2><p>首先编写RpcService注解类，提供服务接口、接口名和版本等元数据，供框架进行服务发现、注册和远程调用时使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口类型，默认为 void.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口名（全限定名），默认为 &quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本号，默认 1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写Spring扩展机制中的一个实现类，扫描被@RpcService标注的组件并将对应的BeanDefiniton对象注册到Spring</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法会在 spring 自定义扫描执行之后执行，这个时候 beanDefinitionMap 已经有扫描到的 beanDefinition 对象了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotationMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry           current bean definition registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 RpcComponentScan 注解的属性和值</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">annotationAttributes</span> <span class="operator">=</span> AnnotationAttributes</span><br><span class="line">                .fromMap(annotationMetadata.getAnnotationAttributes(RpcComponentScan.class.getName()));</span><br><span class="line">        String[] basePackages = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (annotationAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处去获取RpcComponentScan 注解的 basePackages 值</span></span><br><span class="line">            basePackages = annotationAttributes.getStringArray(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有指定名称的话,默认就用当前类所在包</span></span><br><span class="line">        <span class="keyword">if</span> (basePackages.length == <span class="number">0</span>) &#123;</span><br><span class="line">            basePackages = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;((StandardAnnotationMetadata) annotationMetadata).getIntrospectedClass().getPackage().getName()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个浏览 RpcService 注解的 Scanner</span></span><br><span class="line">        <span class="type">RpcClassPathBeanDefinitionScanner</span> <span class="variable">rpcServiceScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcClassPathBeanDefinitionScanner</span>(registry, RpcService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.resourceLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">            rpcServiceScanner.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描包下的所有 Rpc bean 并返回注册成功的数量（scan方法会调用register方法去注册扫描到的类并生成 BeanDefinition 注册到 spring 容器）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rpcServiceScanner.scan(basePackages);</span><br><span class="line">        log.info(<span class="string">&quot;The number of BeanDefinition scanned and registered by RpcServiceScanner is &#123;&#125;.&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写RpcComponentScan注解类，调用上述具体实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(RpcBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcComponentScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扫描包路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;basePackages&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扫描包路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在经过调用链，服务已经被注册到Spring中了，接下来利用Spring框架自动将服务信息注册到注册中心：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcServer rpcServer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcServerProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcServerBeanPostProcessor</span><span class="params">(ServiceRegistry serviceRegistry, RpcServer rpcServer, RpcServerProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">        <span class="built_in">this</span>.rpcServer = rpcServer;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 bean 实例化后，初始化后，检测标注有 <span class="doctag">@RpcService</span> 注解的类，将对应的服务类进行注册，对外暴露服务，同时进行本地服务注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增强后的 bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException Bean 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 判断当前 bean 是否被 @RpcService 注解标注</span></span><br><span class="line">        <span class="keyword">if</span> (bean.getClass().isAnnotationPresent(RpcService.class)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[&#123;&#125;] is annotated with [&#123;&#125;].&quot;</span>, bean.getClass().getName(), RpcService.class.getCanonicalName());</span><br><span class="line">            <span class="comment">// 获取到该类的 @RpcService 注解</span></span><br><span class="line">            <span class="type">RpcService</span> <span class="variable">rpcService</span> <span class="operator">=</span> bean.getClass().getAnnotation(RpcService.class);</span><br><span class="line">            String interfaceName;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(rpcService.interfaceName())) &#123;</span><br><span class="line">                interfaceName = rpcService.interfaceClass().getName();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                interfaceName = rpcService.interfaceName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> rpcService.version();</span><br><span class="line">            <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> ServiceUtil.serviceKey(interfaceName, version);</span><br><span class="line">            <span class="comment">// 构建 ServiceInfo 对象</span></span><br><span class="line">            <span class="type">ServiceInfo</span> <span class="variable">serviceInfo</span> <span class="operator">=</span> ServiceInfo.builder()</span><br><span class="line">                    .appName(properties.getAppName())</span><br><span class="line">                    .serviceName(serviceName)</span><br><span class="line">                    .version(version)</span><br><span class="line">                    .address(properties.getAddress())</span><br><span class="line">                    .port(properties.getPort())</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 进行远程服务注册</span></span><br><span class="line">            serviceRegistry.register(serviceInfo);</span><br><span class="line">            <span class="comment">// 进行本地服务缓存注册</span></span><br><span class="line">            LocalServiceCache.addService(serviceName, bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开机自启动 - 此方法实现于 &#123;<span class="doctag">@link</span> CommandLineRunner&#125; 接口，基于 springboot</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args incoming main method arguments 命令行参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 启动异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; rpcServer.start(properties.getPort())).start();</span><br><span class="line">        log.info(<span class="string">&quot;Rpc server [&#123;&#125;] start, the appName is &#123;&#125;, the port is &#123;&#125;&quot;</span>,</span><br><span class="line">                rpcServer, properties.getAppName(), properties.getPort());</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当服务关闭之后，将服务从 注册中心 上清除（关闭连接）</span></span><br><span class="line">                serviceRegistry.destroy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个注解是服务提供方的，下面实现服务调用方的注解<code>RpcReference</code>，用于标记需要动态代理生成远程服务调用客户端的字段或方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口类型，默认为 void.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口名（全限定名），默认为 &quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本号，默认 1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负载均衡策略，合法的值包括：random, roundrobin, leastactive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">loadbalance</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service mock name, use interface name + Mock if not set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">mock</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务调用超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写打上注解标签后的实现细节，在Spring完成Bean实例化之后，扫描Bean中标注了<code>@RpcReference</code>注解的字段，并将这些字段替换为对应的客户端代理对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClientStubProxyFactory proxyFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcClientBeanPostProcessor</span><span class="params">(ClientStubProxyFactory proxyFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxyFactory = proxyFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在bean实例化完后，扫描bean中需要进行rpc注入的属性，将对应的属性使用代理对象进行替换</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     bean 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName bean 名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后置增强后的 bean 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException bean 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取该 bean 的类的所有属性（getFields - 获取所有的public属性，getDeclaredFields - 获取所有声明的属性，不区分访问修饰符）</span></span><br><span class="line">        Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">        <span class="comment">// 遍历所有属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 判断是否被 RpcReference 注解标注</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(RpcReference.class)) &#123;</span><br><span class="line">                <span class="comment">// 获得 RpcReference 注解</span></span><br><span class="line">                <span class="type">RpcReference</span> <span class="variable">rpcReference</span> <span class="operator">=</span> field.getAnnotation(RpcReference.class);</span><br><span class="line">                <span class="comment">// 默认类为属性当前类型</span></span><br><span class="line">                <span class="comment">// filed.class = java.lang.reflect.Field</span></span><br><span class="line">                <span class="comment">// filed.type = com.wxy.xxx.service.XxxService</span></span><br><span class="line">                Class&lt;?&gt; clazz = field.getType();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果指定了全限定类型接口名</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(rpcReference.interfaceName())) &#123;</span><br><span class="line">                        clazz = Class.forName(rpcReference.interfaceName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果指定了接口类型</span></span><br><span class="line">                    <span class="keyword">if</span> (rpcReference.interfaceClass() != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">                        clazz = rpcReference.interfaceClass();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取指定类型的代理对象</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> proxyFactory.getProxy(clazz, rpcReference.version());</span><br><span class="line">                    <span class="comment">// 关闭安全检查</span></span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 设置域的值为代理对象</span></span><br><span class="line">                    field.set(bean, proxy);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;Failed to obtain proxy object, the type of field %s is %s, &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;and the specified loaded proxy type is %s.&quot;</span>, field.getName(), field.getClass(), clazz), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成SpringBoot实现自动装配"><a href="#集成SpringBoot实现自动装配" class="headerlink" title="集成SpringBoot实现自动装配"></a>集成SpringBoot实现自动装配</h2><p>编写对应的自动配置的配置类以及 <code>spring.factories</code> 文件，引入对应的<code>starter</code>即可完成自动配置功能。</p><p>server端的配置类，主要作用有</p><ul><li>将服务注册到注册中心</li><li>启动RPC服务，监听请求连接</li><li>开启Bean后处理器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RpcServerProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RpcServerProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ServiceRegistry 实例 bean，当没有配置时默认使用 zookeeper 作为配置中心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceRegistry&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;registry&quot;, havingValue = &quot;zookeeper&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceRegistry <span class="title function_">zookeeperServiceRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZookeeperServiceRegistry</span>(properties.getRegistryAddr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceRegistry&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;registry&quot;, havingValue = &quot;nacos&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceRegistry <span class="title function_">nacosServiceRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosServiceRegistry</span>(properties.getRegistryAddr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当没有配置通信协议属性时，默认使用 netty 作为通讯协议</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcServer&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;transport&quot;, havingValue = &quot;netty&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServer <span class="title function_">nettyRpcServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NettyRpcServer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcServer&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;transport&quot;, havingValue = &quot;http&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &#123;&quot;org.apache.catalina.startup.Tomcat&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServer <span class="title function_">httpRpcServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpRpcServer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcServer&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;transport&quot;, havingValue = &quot;socket&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServer <span class="title function_">socketRpcServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SocketRpcServer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(&#123;ServiceRegistry.class, RpcServer.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServerBeanPostProcessor <span class="title function_">rpcServerBeanPostProcessor</span><span class="params">(<span class="meta">@Autowired</span> ServiceRegistry serviceRegistry,</span></span><br><span class="line"><span class="params">                                                                 <span class="meta">@Autowired</span> RpcServer rpcServer,</span></span><br><span class="line"><span class="params">                                                                 <span class="meta">@Autowired</span> RpcServerProperties properties)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcServerBeanPostProcessor</span>(serviceRegistry, rpcServer, properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client的自动配置类，主要作用有：</p><ul><li>配置负载均衡算法</li><li>服务发现</li><li>客户端网络通信，用来发送和接收响应</li><li>动态代理类</li><li>开启Bean后处理器</li><li>退出时清理组件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RpcClientProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性绑定的实现方式二：</span></span><br><span class="line"><span class="comment">     * - 创建 RpcClientProperties 对象，绑定到配置文件</span></span><br><span class="line"><span class="comment">     * - 如果使用此方法，可以直接给属性赋初始值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment 当前应用的环境（支持 yaml、properties 等文件格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的绑定属性类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> 弃用，使用被 &#123;<span class="doctag">@link</span> org.springframework.boot.context.properties.ConfigurationProperties&#125; 标注的属性类代替，</span></span><br><span class="line"><span class="comment">     * 生成 metadata。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> RpcClientProperties <span class="title function_">rpcClientProperties</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取绑定器，将对应的属性绑定到指定类上</span></span><br><span class="line">        BindResult&lt;RpcClientProperties&gt; bind = Binder.get(environment).bind(<span class="string">&quot;rpc.client&quot;</span>, RpcClientProperties.class);</span><br><span class="line">        <span class="comment">// 获取实例</span></span><br><span class="line">        <span class="keyword">return</span> bind.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RpcClientProperties rpcClientProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;loadBalance&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">// 不指定 value 则值默认为当前创建的类</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;loadbalance&quot;, havingValue = &quot;random&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalance <span class="title function_">randomLoadBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomLoadBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;loadBalance&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;loadbalance&quot;, havingValue = &quot;roundRobin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalance <span class="title function_">roundRobinLoadBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoundRobinLoadBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;loadBalance&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;loadbalance&quot;, havingValue = &quot;consistentHash&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalance <span class="title function_">consistentHashLoadBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsistentHashLoadBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceDiscovery&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(LoadBalance.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;registry&quot;, havingValue = &quot;zookeeper&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceDiscovery <span class="title function_">zookeeperServiceDiscovery</span><span class="params">(<span class="meta">@Autowired</span> LoadBalance loadBalance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZookeeperServiceDiscovery</span>(rpcClientProperties.getRegistryAddr(), loadBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceDiscovery&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(LoadBalance.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;registry&quot;, havingValue = &quot;nacos&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceDiscovery <span class="title function_">nacosServiceDiscovery</span><span class="params">(<span class="meta">@Autowired</span> LoadBalance loadBalance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosServiceDiscovery</span>(rpcClientProperties.getRegistryAddr(), loadBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcClient&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;transport&quot;, havingValue = &quot;netty&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> RpcClient <span class="title function_">nettyRpcClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NettyRpcClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcClient&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;transport&quot;, havingValue = &quot;http&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcClient <span class="title function_">httpRpcClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpRpcClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcClient&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;transport&quot;, havingValue = &quot;socket&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcClient <span class="title function_">socketRpcClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SocketRpcClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(&#123;ServiceDiscovery.class, RpcClient.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> ClientStubProxyFactory <span class="title function_">clientStubProxyFactory</span><span class="params">(<span class="meta">@Autowired</span> ServiceDiscovery serviceDiscovery,</span></span><br><span class="line"><span class="params">                                                         <span class="meta">@Autowired</span> RpcClient rpcClient,</span></span><br><span class="line"><span class="params">                                                         <span class="meta">@Autowired</span> RpcClientProperties rpcClientProperties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientStubProxyFactory</span>(serviceDiscovery, rpcClient, rpcClientProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> RpcClientBeanPostProcessor <span class="title function_">rpcClientBeanPostProcessor</span><span class="params">(<span class="meta">@Autowired</span> ClientStubProxyFactory clientStubProxyFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcClientBeanPostProcessor</span>(clientStubProxyFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> RpcClientExitDisposableBean <span class="title function_">rpcClientExitDisposableBean</span><span class="params">(<span class="meta">@Autowired</span> ServiceDiscovery serviceDiscovery)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcClientExitDisposableBean</span>(serviceDiscovery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty常见问题</title>
      <link href="/inori/4840342e.html"/>
      <url>/inori/4840342e.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Netty"><a href="#什么是Netty" class="headerlink" title="什么是Netty"></a>什么是Netty</h3><p>Netty是一个基于Java NIO (Non-blocking I&#x2F;O)的网络通信框架，它提供了高性能、可扩展性和可靠性的网络编程解决方案，是一个广泛应用于分布式系统的网络通信库</p><h3 id="Netty有哪些核心组件"><a href="#Netty有哪些核心组件" class="headerlink" title="Netty有哪些核心组件"></a>Netty有哪些核心组件</h3><p>Netty由三层结构构成：</p><ul><li>网络通信层：有三个组件：Bootstrap、ServerBootstrap、Channel<ul><li>Bootstrap负责客户端启动，连接指定服务器</li><li>ServerBootstrap负责服务器启动，监听指定端口</li><li>Channel是网络通信的载体</li></ul></li><li>事件调度层：有EventLoopGroup、EventLoop<ul><li>EventLoopGroup本质上是一个线程池，主要是负责接受IO请求，分配线程处理请求</li><li>EventLoop是具体的一个线程</li></ul></li><li>服务编排层：ChannelPipline、ChannelHandler、ChannelHandlerContext<ul><li>ChannelPipline负责将多个ChannelHandler组成一个链，可以看成一个流水线</li><li>ChannelHandler是对数据进行处理，可以看作成一道道工序</li><li>ChannelHandlerContext用来保存ChannelHandler的上下文信息</li></ul></li></ul><h3 id="Netty有几种线程模型"><a href="#Netty有几种线程模型" class="headerlink" title="Netty有几种线程模型"></a>Netty有几种线程模型</h3><p>一共三种Reactor模型</p><ul><li>单线程单Reactor模型，有三个组件：<ul><li>Acceptor：处理客户端连接请求</li><li>Reactor：监听和分发事件</li><li>Handler：业务处理</li><li>缺点：<ul><li>如果有一个Handler阻塞，会影响整个服务的吞吐量</li><li>无法充分利用多核CPU的性能</li></ul></li></ul></li></ul><img src="/inori/4840342e/reactor.png" style="zoom:50%;"><ul><li>多线程多Reactor模型（主从多线程Reactor模型）<ul><li>把Reactor拆分为了：Main-Reactor和SubReactor</li><li>Main-Reactor负责接受连接，然后随机分配给SubReactor</li></ul></li><li>主从 Reactor 多线程 + 业务线程池（WorkerGroup + 自定义业务线程池）<ul><li>WorkerGroup 只做 IO（读写、解码、编码）</li><li>业务逻辑交由独立线程池执行（例如使用 <code>DefaultEventExecutorGroup</code>）</li><li>优点：避免耗时业务阻塞IO线程，更高的业务并发能力，线程资源更加分离</li><li>缺点：如果业务线程池设置不当，也可能成为瓶颈</li></ul></li></ul><h3 id="Netty的优势"><a href="#Netty的优势" class="headerlink" title="Netty的优势"></a>Netty的优势</h3><ul><li>使用简单：封装了NIO的很多细节，使用更简单</li><li>功能强大：预置了多种编解码功能，支持多种主流协议</li><li>定制能力强：可以通过ChannelHandler对通信框架进行灵活地扩展</li></ul><h3 id="Netty高性能表现在哪些方面"><a href="#Netty高性能表现在哪些方面" class="headerlink" title="Netty高性能表现在哪些方面"></a>Netty高性能表现在哪些方面</h3><ul><li>IO线程模型：同步非阻塞，用最少的资源做更多的事</li><li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输</li><li>内存池设计：申请的内存可以重用，主要指直接内存</li><li>串形化处理读写：避免使用锁带来的性能开销</li></ul><h3 id="Netty的心跳机制"><a href="#Netty的心跳机制" class="headerlink" title="Netty的心跳机制"></a>Netty的心跳机制</h3><p>Netty的心跳机制是指通过定时发送心跳包来保持连接的机制。通常情况下，当连接空闲一段时间后，就会发送心跳包，如果对端没有响应，则判断连接已经失效，需要进行重连或其他操作。Netty的心跳机制可以通过<code>IdleStateHandler</code>实现，它可以检测连接的空闲状态并触发相应事件</p><h3 id="Netty的内存管理机制"><a href="#Netty的内存管理机制" class="headerlink" title="Netty的内存管理机制"></a>Netty的内存管理机制</h3><p>Netty的内存管理机制采用了堆外内存池的方式，即通过ByteBuf实现内存的分配和回收。Netty提供了两种ByteBuf实现类：PooledByteBuf和UnpooledByteBuf，前者是基于内存池实现的，可以重复利用内存，提高了内存的利用率；后者是基于堆内存实现的，不需要进行内存的池化和池化管理</p><h3 id="Netty的常用协议"><a href="#Netty的常用协议" class="headerlink" title="Netty的常用协议"></a>Netty的常用协议</h3><ul><li>HTTP&#x2F;HTTPS</li><li>WebSocket</li><li>TCP&#x2F;UDP</li><li>DNS</li><li>STOMP</li></ul><h3 id="Netty的ChannelHandler有哪些类型"><a href="#Netty的ChannelHandler有哪些类型" class="headerlink" title="Netty的ChannelHandler有哪些类型"></a>Netty的ChannelHandler有哪些类型</h3><ul><li>ChannelInboundHandler：用于处理Channel的入站数据和事件</li><li>ChannelOutboundHandler：用于处理Channel的出站数据和事件</li><li>ChannelDuplexHandler：同时实现了ChannelInboundHandler和ChannelOutboundHandler接口，可以同时处理入站数据和出站数据</li><li>ChannelHandlerContext：用于传递ChannelHandler之间的上下文信息</li></ul><h3 id="Netty的ByteBuf和Java-NIO的ByteBuffer有什么区别"><a href="#Netty的ByteBuf和Java-NIO的ByteBuffer有什么区别" class="headerlink" title="Netty的ByteBuf和Java NIO的ByteBuffer有什么区别"></a>Netty的ByteBuf和Java NIO的ByteBuffer有什么区别</h3><ul><li>内存分配方式不同<ul><li>Netty的ByteBuf采用了池化的方式进行内存分配，可以重复利用内存，减少了内存的分配和回收开销</li><li>Java NIO的ByteBuffer采用了直接或堆内存的方式进行内存分配，需要进行内存的分配和回收管理。</li></ul></li><li>功能不同<ul><li>Netty的ByteBuf提供了更加丰富的API，支持对缓冲区进行动态扩容、切片、读写标记等操作</li><li>Java NIO的ByteBuffer只提供了基本的读写方法</li></ul></li></ul><h3 id="Netty的启动流程"><a href="#Netty的启动流程" class="headerlink" title="Netty的启动流程"></a>Netty的启动流程</h3><ul><li>创建EventLoopGroup对象，用于管理Channel的EventLoop</li><li>创建ServerBootstrap对象，用于配置ServerChannel和Channel的参数和属性</li><li>绑定ServerChannel监听端口，并调用bind()方法启动服务</li><li>创建ChannelInitializer对象，用于初始化Channel的处理器链</li><li>在ChannelPipeline中添加ChannelHandler处理器，用于处理Channel上的I&#x2F;O事件和数据</li></ul><h4 id="初始化（main线程调用）"><a href="#初始化（main线程调用）" class="headerlink" title="初始化（main线程调用）"></a>初始化（main线程调用）</h4><ol><li>创建NioServerSocketChannel</li><li>初始化handler等待调用</li></ol><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><ol><li>启动nio线程(main线程)</li><li>原生ServerSocketChannel注册至selector未关注事件(nio线程)</li><li>执行NioServerSocketChannel初始化handler(nio线程)</li></ol><h4 id="绑定监听端口-nio线程调用"><a href="#绑定监听端口-nio线程调用" class="headerlink" title="绑定监听端口(nio线程调用)"></a>绑定监听端口(nio线程调用)</h4><ol><li>原生ServerSocketChannel绑定</li><li>触发NioServerSocketChannel active事件</li></ol><h3 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h3><p>重要组成部分：selector、线程、任务队列</p><p>NioEventLoop即会处理io事件，也会处理普通事件</p><h4 id="selector何时创建"><a href="#selector何时创建" class="headerlink" title="selector何时创建"></a>selector何时创建</h4><p>在构造方法调用时创建</p><h4 id="EventLoop为什么有两个selector成员（selector和unwarppedSelector）"><a href="#EventLoop为什么有两个selector成员（selector和unwarppedSelector）" class="headerlink" title="EventLoop为什么有两个selector成员（selector和unwarppedSelector）"></a>EventLoop为什么有两个selector成员（selector和unwarppedSelector）</h4><p>为了增强灵活性、性能优化和对JDK selector的bug做规避处理</p><p>unwarppedSelector：Java NIO 的原始 Selector，Netty保留它为了保底、调试和 fallback</p><p>selector：Netty包装过的Selector，使用自定义的 <code>SelectedSelectionKeySet</code> 替换掉了 JDK 默认的 <code>HashSet</code>，避免频繁的内存分配和迭代开销</p><h4 id="EventLoop的nio线程什么时候启动"><a href="#EventLoop的nio线程什么时候启动" class="headerlink" title="EventLoop的nio线程什么时候启动"></a>EventLoop的nio线程什么时候启动</h4><p>在首次调用execute方法时启动，通过<code>state</code>状态位保证线程只会启动一次</p><h4 id="netty的weakup方法如何理解"><a href="#netty的weakup方法如何理解" class="headerlink" title="netty的weakup方法如何理解"></a>netty的weakup方法如何理解</h4><p>只有其他线程提交任务时，才会调用selector的weakup方法，并且方法使用weakenup变量，使用CAS来保证并发，如果有多个线程提交任务时，可以避免weakup方法被频繁调用</p><h4 id="每次循环时，什么时候进入SelectStrategy-SELECT分支"><a href="#每次循环时，什么时候进入SelectStrategy-SELECT分支" class="headerlink" title="每次循环时，什么时候进入SelectStrategy.SELECT分支"></a>每次循环时，什么时候进入SelectStrategy.SELECT分支</h4><p>没有任务时进入，有任务时会调用selectNow方法，顺便拿到io事件</p><h4 id="何时会select阻塞，阻塞多久"><a href="#何时会select阻塞，阻塞多久" class="headerlink" title="何时会select阻塞，阻塞多久"></a>何时会select阻塞，阻塞多久</h4><p>没有定时任务时，selectDeadLineNanos（截止时间）&#x3D; 当前时间 + 1s<br>timeoutMillis（超时时间）&#x3D; 1s + 0.5ms</p><h4 id="nio的空轮询bug在哪里体现的，netty是如何解决的"><a href="#nio的空轮询bug在哪里体现的，netty是如何解决的" class="headerlink" title="nio的空轮询bug在哪里体现的，netty是如何解决的"></a>nio的空轮询bug在哪里体现的，netty是如何解决的</h4><p>空轮询bug的表现：调用 <code>Selector.select()</code>（或 <code>select(timeout)</code>）无故立即返回0，且连续调用总是如此，即使没有任何事件准备好</p><p>问题现象：CPU占用飙升（100%），但程序没有实际处理任何I&#x2F;O事件，处于所谓的“空轮询死循环”状态</p><h5 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h5><p>这个bug的本质在于<strong>Selector与其内部的selectedKey集合状态不一致</strong>，通常由以下原因触发：</p><ul><li><p>Channel被取消注册但未从epoll数据结构中清理：例如调用了<code>SelectionKey.cancel()</code>，但实际底层并没有完全从 epoll 中注销该事件</p></li><li><p>并发取消key（多线程中对selector操作）</p></li><li><p>Signal中断（signal中断了selector的阻塞）：某些native信号中断了<code>select()</code>调用，会让它提前返回</p></li></ul><p>正常的流程应该是这样的：</p><ol><li>注册 SocketChannel，关注 OP_READ（读事件）</li><li>内核通过 epoll 机制监听这个 fd 的读事件</li><li>当数据来了，<code>Selector.select()</code> 会返回</li><li>Selector 内部会把这个 key 放进 <code>selectedKeys</code> 集合</li><li>你拿到 key 之后就可以处理读事件了</li></ol><p>这时候，Selector 和底层 epoll 的状态是一致的</p><p>状态失衡：</p><ol><li>取消某个 SelectionKey（调用了 <code>key.cancel()</code>）</li><li>按理说，这个 Channel 不再需要监听，应从 epoll 中注销</li><li>但由于某些 bug 或 race condition，epoll 并<strong>没有真正移除它</strong></li><li>下次 <code>select()</code> 调用时，epoll 返回“有事件”（因为它还在监听）</li><li>但 Java NIO 的 <code>selectedKeys</code> 集合<strong>中没有把它加入</strong>，因为 Selector 认为这个 Key 已经无效</li><li>于是，Selector <code>select()</code> 调用返回了，<strong>但你没有事件可处理</strong></li></ol><p>这就造成了 <strong>Selector（Java 层）认为没事件，epoll（内核层）认为有事件</strong>，二者状态不一致</p><p>再进一步，连续多次这样的状态不一致：</p><ul><li>Selector 每次调用 <code>select()</code>，都会立刻返回 0</li><li><code>selectedKeys</code> 是空的，没有任何事件</li><li>但是底层仍然返回一个假的触发（因为 epoll 没删干净）</li><li>于是主线程进入空转，形成了所谓的 <strong>空轮询 bug</strong></li></ul><p>解决办法：netty内部维护了一个selectCnt，记录循环次数，当连续<code>select()</code>返回0的次数超过阈值，Netty会判断可能遇到空轮询 bug，主动重建一个新的Selector，将旧selector中所有注册的channel重新注册到新selector，再关闭旧selector</p><h4 id="ioRadio控制什么，设置100有什么作用"><a href="#ioRadio控制什么，设置100有什么作用" class="headerlink" title="ioRadio控制什么，设置100有什么作用"></a>ioRadio控制什么，设置100有什么作用</h4><p>ioRadio控制io事件所占用的时间比例，一般是50，如果设置成100，不会把所有时间都分给io事件，而是先把所有io事件处理完之后，在finally块中运行所有任务</p><h4 id="selectedKeys优化"><a href="#selectedKeys优化" class="headerlink" title="selectedKeys优化"></a>selectedKeys优化</h4><p>默认对selectedKeys遍历采用的是set形式，netty中会尝试使用数组的形式对selectedKeys进行管理，优化遍历时间</p><h3 id="accept流程"><a href="#accept流程" class="headerlink" title="accept流程"></a>accept流程</h3><ol><li>selector.select()阻塞直到事件发生</li><li>遍历处理selectedKeys</li><li>拿到一个key，判断事件类型是否为accept</li><li>创建SocketChannel，设置非阻塞</li><li>将SocketChannel注册至selector</li><li>关注selectionKey的read事件</li></ol><h3 id="read流程"><a href="#read流程" class="headerlink" title="read流程"></a>read流程</h3><ol><li>selector.select()阻塞直到事件发生</li><li>遍历处理selectedKeys</li><li>拿到一个key，判断事件类型是否为read</li><li>读取操作</li></ol>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty优化</title>
      <link href="/inori/25b752cd.html"/>
      <url>/inori/25b752cd.html</url>
      
        <content type="html"><![CDATA[<h2 id="扩展序列化算法"><a href="#扩展序列化算法" class="headerlink" title="扩展序列化算法"></a>扩展序列化算法</h2><p>序列化，反序列化主要用在消息正文的转换上</p><ul><li>序列化时，需要将Java对象变为要传输的数据（可以是byte[]，json等，最终都需要变成byte[]）</li><li>反序列化时，需要将传入的正文数据还原成Java对象，便于处理</li></ul><p>Java自带的序列化，反序列化机制，核心代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">byte</span>[] body = <span class="keyword">new</span> <span class="title class_">byte</span>[bodyLength];</span><br><span class="line">byteByf.readBytes(body);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(body));</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) in.readObject();</span><br><span class="line">message.setSequenceId(sequenceId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out).writeObject(message);</span><br><span class="line"><span class="type">byte</span>[] bytes = out.toByteArray();</span><br></pre></td></tr></table></figure><p>为了支持更多序列化算法，抽象一个Serializer接口，使用枚举类实现具体的算法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SerializerAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    Jdk(<span class="number">0</span>), Json(<span class="number">1</span>), Protostuff(<span class="number">2</span>), Kryo(<span class="number">3</span>), Hessian(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> type;</span><br><span class="line">    </span><br><span class="line">    SerializerAlgorithm(<span class="type">int</span> type) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Jdk</span></span><br><span class="line">    Jdk &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> in.readObject();</span><br><span class="line">                <span class="keyword">return</span> (T) object;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out).writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// Json 实现(引入了 Gson 依赖)</span></span><br><span class="line">    Json &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要从协议的字节中得到是哪种序列化算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SerializerAlgorithm <span class="title function_">getByInt</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[type];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Protostuff 实现</span></span><br><span class="line">    Protostuff &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取类对应的 schema（序列化元数据）</span></span><br><span class="line">            Schema&lt;T&gt; schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> schema.newMessage(); <span class="comment">// 创建对象实例</span></span><br><span class="line">            <span class="comment">// 将字节数据合并反序列化到对象中</span></span><br><span class="line">            ProtostuffIOUtil.mergeFrom(bytes, obj, schema);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="comment">// 获取运行时 schema</span></span><br><span class="line">            Schema&lt;T&gt; schema = RuntimeSchema.getSchema((Class&lt;T&gt;) object.getClass());</span><br><span class="line">            <span class="comment">// 创建缓冲区</span></span><br><span class="line">            <span class="type">LinkedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ProtostuffIOUtil.toByteArray(object, schema, buffer);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">// Kryo 实现</span></span><br><span class="line">    Kryo &#123;</span><br><span class="line">        <span class="comment">// 使用 ThreadLocal 确保 Kryo 在多线程中安全使用</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">            kryo.setRegistrationRequired(<span class="literal">false</span>); <span class="comment">// 允许动态类型注册</span></span><br><span class="line">            <span class="keyword">return</span> kryo;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">            <span class="comment">// 使用 Kryo 反序列化对象</span></span><br><span class="line">            <span class="keyword">return</span> kryo.readObject(input, clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(out);</span><br><span class="line">            <span class="comment">// 使用 Kryo 序列化对象</span></span><br><span class="line">            kryo.writeObject(output, object);</span><br><span class="line">            output.close();</span><br><span class="line">            <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Hessian 实现</span></span><br><span class="line">    Hessian &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建 Hessian 输入流</span></span><br><span class="line">                <span class="type">HessianInput</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianInput</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">                <span class="keyword">return</span> (T) input.readObject(); <span class="comment">// 反序列化对象</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Hessian 反序列化失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">                <span class="comment">// 创建 Hessian 输出流并序列化对象</span></span><br><span class="line">                <span class="type">HessianOutput</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianOutput</span>(out);</span><br><span class="line">                output.writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Hessian 序列化失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化类型编号（建议用于协议中）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SerializerAlgorithm <span class="title function_">getByInt</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[type];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加配置类和配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Config.class.getResourceAsStream(<span class="string">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class="line">            properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getServerPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;server.port&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8080</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Serializer.Algorithm <span class="title function_">getSerializerAlgorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;serializer.algorithm&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.Java;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.valueOf(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改编解码器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式</span></span><br><span class="line">        out.writeByte(Config.getSerializerAlgorithm().ordinal());</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(msg);</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerAlgorithm</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte(); <span class="comment">// 0,1,2...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到反序列化算法</span></span><br><span class="line">        Serializer.<span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Serializer.Algorithm.values()[serializerAlgorithm];</span><br><span class="line">        <span class="comment">// 确定具体消息类型</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Message</span>&gt; messageClass = Message.getMessageClass(messageType);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> algorithm.deserialize(messageClass, bytes);</span><br><span class="line"><span class="comment">//        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);</span></span><br><span class="line"><span class="comment">//        log.debug(&quot;&#123;&#125;&quot;, message);</span></span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul><li><p>属于SocketChannal参数</p></li><li><p>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p></li><li><p>与SO_TIMEOUT的区别：SO_TIMEOUT主要用在阻塞IO，阻塞IO中accept，read等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConnectionTimeout</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">300</span>)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            future.sync().channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.debug(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><ul><li>属于 ServerSocketChannal 参数</li><li>用于设置服务端监听套接字（ServerSocket）可接受的连接请求队列的长度</li></ul><p>回忆一下TCP的三次握手：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant c as client</span><br><span class="line">participant s as server</span><br><span class="line">participant sq as syns queue</span><br><span class="line">participant aq as accept queue</span><br><span class="line"></span><br><span class="line">s -&gt;&gt; s : bind()</span><br><span class="line">s -&gt;&gt; s : listen()</span><br><span class="line">c -&gt;&gt; c : connect()</span><br><span class="line">c -&gt;&gt; s : 1. SYN</span><br><span class="line">Note left of c : SYN_SEND</span><br><span class="line">s -&gt;&gt; sq : put</span><br><span class="line">Note right of s : SYN_RCVD</span><br><span class="line">s -&gt;&gt; c : 2. SYN + ACK</span><br><span class="line">Note left of c : ESTABLISHED</span><br><span class="line">c -&gt;&gt; s : 3. ACK</span><br><span class="line">sq -&gt;&gt; aq : put</span><br><span class="line">Note right of s : ESTABLISHED</span><br><span class="line">aq --&gt;&gt; s : </span><br><span class="line">s -&gt;&gt; s : accept()</span><br></pre></td></tr></table></figure><ol><li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li><li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li><li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li></ol><ul><li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p></li><li><p>sync queue - 半连接队列</p><ul><li>大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li><p>accept queue - 全连接队列</p><ul><li>其大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><p>netty中可以通过 option(ChannelOption.SO_BACKLOG, 值)来设置大小</p><h3 id="ulimit-n"><a href="#ulimit-n" class="headerlink" title="ulimit -n"></a>ulimit -n</h3><ul><li>属于操作系统参数</li><li>用于设置当前用户能打开的最大文件描述符数量</li></ul><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul><li>属于 SocketChannal 参数</li><li>禁用 Nagle 算法，牺牲带宽效率，换来低延迟</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">bootstrap.childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="SO-SNDBUF-SO-RCVBUF"><a href="#SO-SNDBUF-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul><li>SO_SNDBUF 属于 SocketChannal 参数，socket发送缓冲区大小</li><li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上），socket接受缓冲区大小</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">bootstrap.childOption(ChannelOption.SO_SNDBUF, <span class="number">1024</span> * <span class="number">64</span>); <span class="comment">// 64KB 发送缓冲区</span></span><br><span class="line">bootstrap.childOption(ChannelOption.SO_RCVBUF, <span class="number">1024</span> * <span class="number">64</span>); <span class="comment">// 64KB 接收缓冲区</span></span><br></pre></td></tr></table></figure><h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul><li>属于 SocketChannal 参数</li><li>用来内存分配和缓冲区管理，分配 ByteBuf，ctx.alloc()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">bootstrap</span><br><span class="line">    .group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT); <span class="comment">// 默认</span></span><br></pre></td></tr></table></figure><h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><p>默认情况下，Netty 会循环调用 <code>read()</code> 将数据从 socket 读取到内存，但：</p><ul><li>读太少 → 系统调用频繁，吞吐低；</li><li>读太多 → 无效分配，浪费内存，还可能引发 OOM。</li></ul><p>为此，Netty 引入了 <code>RecvByteBufAllocator</code> 接口，允许动态调整每次读取的字节数，提高效率。</p><ul><li>属于 SocketChannal 参数</li><li>控制 netty 接收缓冲区大小</li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">bootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AdaptiveRecvByteBufAllocator</span>(<span class="number">64</span>, <span class="number">1024</span>, <span class="number">65536</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty进阶篇</title>
      <link href="/inori/56930530.html"/>
      <url>/inori/56930530.html</url>
      
        <content type="html"><![CDATA[<h2 id="黏包和半包"><a href="#黏包和半包" class="headerlink" title="黏包和半包"></a>黏包和半包</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><ul><li><p>TCP以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p><p><img src="/inori/56930530/tcp.png"></p></li><li><p>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</p><p><img src="/inori/56930530/tcp_window.png"></p></li><li><p>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</p><ul><li>图中深色的部分即要发送的数据，高亮的部分即窗口</li><li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li><li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li><li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li></ul></li></ul><h4 id="MSS限制"><a href="#MSS限制" class="headerlink" title="MSS限制"></a>MSS限制</h4><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p><ul><li><p>以太网的 MTU 是 1500</p></li><li><p>FDDI（光纤分布式数据接口）的 MTU 是 4352</p></li><li><p>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</p></li><li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p></li><li><p>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 &#x3D; 1460</p></li><li><p>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</p></li><li><p>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</p></li></ul><p><img src="/inori/56930530/mss.jpg"></p><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp希望尽可能发送足够大的数据，这就是Nagle算法产生的缘由</p><ul><li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul><li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li><li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li><li>如果 TCP_NODELAY &#x3D; true，则需要发送</li><li>已发送的数据都收到 ack 时，则需要发送</li><li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li><li>除上述情况，延迟发送</li></ul></li></ul><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><p><strong>黏包</strong>：</p><ul><li>现象，发送abc和def，接收abcdef</li><li>原因：<ul><li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle算法：会造成黏包</li></ul></li></ul><p><strong>半包</strong>：</p><ul><li>现象，发送abcdef，接收abc和def</li><li>原因：<ul><li>应用层：接收方 ByteBuf 小于实际发送数据量</li><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li><li>MSS限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul><p><u>本质是因为TCP是流式协议，消息无边界</u></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>短连接</li></ol><p>发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;conneted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>半包用这种办法不好解决，因为接收方的缓冲区大小是有限的</p></blockquote><ol start="2"><li>每一条消息采用固定长度</li></ol><p>让所有数据包长度固定（假设长度为8字节），服务器端加入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));</span><br></pre></td></tr></table></figure><p>客户端测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; r.nextInt(<span class="number">8</span>); j++) &#123;</span><br><span class="line">                                    bytes[j] = (<span class="type">byte</span>) c;</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                                buffer.writeBytes(bytes);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点是，数据包的大小不好把握</p><ul><li>长度定的太大，浪费</li><li>长度定的太小，对某些数据包又显得不够</li></ul><ol start="3"><li>每一条消息采用分隔符，例如\n</li></ol><p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure><p>客户端在每条消息之后，加入 \n 分隔符</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p><ol start="4"><li>每一条消息分为 head 和 body，head 中包含 body 的长度</li></ol><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">byte</span>) (r.nextInt(<span class="number">16</span>) + <span class="number">1</span>);</span><br><span class="line">                                <span class="comment">// 先写入长度</span></span><br><span class="line">                                buffer.writeByte(length);</span><br><span class="line">                                <span class="comment">// 再</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= length; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协议的设计与解析"><a href="#协议的设计与解析" class="headerlink" title="协议的设计与解析"></a>协议的设计与解析</h2><p>TCP&#x2F;IP 中消息传输基于流的方式，没有边界。</p><p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p><h3 id="redis协议举例"><a href="#redis协议举例" class="headerlink" title="redis协议举例"></a>redis协议举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">byte</span>[] LINE = &#123;<span class="number">13</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">    bootstrap.group(worker);</span><br><span class="line">    bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="comment">// 会在连接 channel 建立成功后，会触发 active 事件</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    set(ctx);</span><br><span class="line">                    get(ctx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*2&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;get&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;bbb&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>).sync();</span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    worker.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><ul><li>魔数，用来在第一时间判定是否是无效数据包</li><li>版本号，可以支持协议的升级</li><li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li><li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li><li>请求序号，为了双工通信，提供异步能力</li><li>正文长度</li><li>消息正文</li></ul><h4 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h4><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(</span><br><span class="line">        <span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MessageCodec</span>()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// encode</span></span><br><span class="line"><span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//        channel.writeOutbound(message);</span></span><br><span class="line"><span class="comment">// decode</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>, message, buf);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s2</span> <span class="operator">=</span> buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">s1.retain(); <span class="comment">// 引用计数 2</span></span><br><span class="line">channel.writeInbound(s1); <span class="comment">// release 1</span></span><br><span class="line">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure><p>解读</p><p><img src="/inori/56930530/return.png"></p><h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><ul><li>当handler不保存状态时，就可以安全地在多线程下被共享</li><li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制</li><li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h2><p>原因</p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p>问题</p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><p>服务器端解决</p><ul><li>每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了读空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;已经 5s 没有读到数据了&quot;</span>);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端定时心跳</p><ul><li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了写空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">PingMessage</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty基础入门</title>
      <link href="/inori/62b8c227.html"/>
      <url>/inori/62b8c227.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Netty is an asynchronous event-driven network application framework</span><br><span class="line">for rapid development of maintainable high performance protocol servers &amp; clients.</span><br></pre></td></tr></table></figure><p>Netty是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>开发一个简单的服务器端和客户端</p><ul><li>客户端向服务器端发送HelloWorld</li><li>服务器仅接收，不返回</li></ul><p>加入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.100.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()); <span class="comment">// 5</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; <span class="comment">// 6</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>代码解读</p><ul><li><p>1 处，创建 NioEventLoopGroup，可以简单理解为<code>线程池 + Selector</code></p></li><li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现</p></li><li><p>3 处，childHandler是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p></li><li><p>4 处，ServerSocketChannel 绑定的监听端口</p></li><li><p>5 处，SocketChannel 的处理器，解码 ByteBuf &#x3D;&gt; String</p></li><li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p></li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">// 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>) <span class="comment">// 4</span></span><br><span class="line">    .sync() <span class="comment">// 5</span></span><br><span class="line">    .channel() <span class="comment">// 6</span></span><br><span class="line">    .writeAndFlush(HelloWorld!); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>代码解读</p><ul><li><p>1 处，创建NioEventLoopGroup，同Server</p></li><li><p>2 处，选择客户Socket实现类，NioSocketChannel表示基于NIO的客户端实现</p></li><li><p>3 处，添加SocketChannel的处理器，ChannelInitializer处理器（仅执行一次），它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</p></li><li><p>4 处，指定要连接的服务器和端口</p></li><li><p>5 处，Netty中很多方法都是异步的，如connect，这时需要使用sync方法等待connect建立连接完毕</p></li><li><p>6 处，获取channel对象，它即为通道抽象，可以进行数据读写操作</p></li><li><p>7 处，写入消息并清空缓冲区</p></li><li><p>8 处，消息会经过通道handler处理，这里是将String &#x3D;&gt; ByteBuf发出</p></li><li><p>数据经过网络传输，到达服务器端，服务器端5和6处的handler先后被触发，走完一个流程</p></li></ul><h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><p><img src="/inori/62b8c227/helloworld.png"></p><ul><li>把 channel 理解为数据的通道</li><li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li><li>把 handler 理解为数据的处理工序<ul><li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li><li>handler 分 Inbound 和 Outbound 两类</li></ul></li><li>把 eventLoop 理解为处理数据的工人<ul><li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li><li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li></ul></li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="EventLoop-EventLoopGroup"><a href="#EventLoop-EventLoopGroup" class="headerlink" title="EventLoop &amp; EventLoopGroup"></a>EventLoop &amp; EventLoopGroup</h3><p>EventLoop是一个单线程执行器（内部维护了一个 Selector），里面有run方法处理Channel上源源不断的io事件</p><p>继承关系：</p><ul><li>一条线是继承自j.u.c.ScheduledExecutorService因此包含了线程池中所有的方法</li><li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此EventLoop</li><li>提供了parent方法来看看自己属于哪个EventLoopGroup</li></ul></li></ul><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><p>关闭：</p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h4 id="handler内部的切换逻辑"><a href="#handler内部的切换逻辑" class="headerlink" title="handler内部的切换逻辑"></a>handler内部的切换逻辑</h4><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是，直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果两个handler绑定的是同一个线程，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个handler的线程来调用</li></ul><h4 id="NioEventLoop-处理普通任务"><a href="#NioEventLoop-处理普通任务" class="headerlink" title="NioEventLoop 处理普通任务"></a>NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.execute(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;normal task...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>可以用来执行耗时较长的任务</p></blockquote><h4 id="NioEventLoop-处理定时任务"><a href="#NioEventLoop-处理定时任务" class="headerlink" title="NioEventLoop 处理定时任务"></a>NioEventLoop 处理定时任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><blockquote><p>可以用来执行定时任务</p></blockquote><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel的常用api</p><ul><li>close()用来关闭 channel</li><li>closeFuture()用来处理 channel 的关闭<ul><li>sync方法作用是同步等待 channel 关闭</li><li>而addListener方法是异步等待 channel 关闭</li></ul></li><li>pipeline()方法添加处理器</li><li>write()方法将数据写入</li><li>writeAndFlush()方法将数据写入并刷出</li></ul><h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>刚才的客户端代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .sync()</span><br><span class="line">    .channel()</span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>拆开来看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">channelFuture.sync().channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象</li></ul><p>注意connect方法是异步的，意味着不等连接建立，方法执行就返回了。因此channelFuture对象中不能【立刻】获得到正确的 Channel 对象，需要调用sync方法同步等待连接建立完成</p><p>除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    System.out.println(future.channel()); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法）</li></ul><h4 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        NioEventLoopGroup group <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">                    channel.close(); <span class="comment">// close 异步操作 1s 之后</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;input&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        <span class="comment">/*log.debug(&quot;waiting close...&quot;);</span></span><br><span class="line"><span class="comment">        closeFuture.sync();</span></span><br><span class="line"><span class="comment">        log.debug(&quot;处理关闭之后的操作&quot;);*/</span></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 处理关闭之后的操作</span></span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步的提升"><a href="#异步的提升" class="headerlink" title="异步的提升"></a>异步的提升</h4><ol><li><strong>资源利用率</strong></li></ol><ul><li>同步 I&#x2F;O 模型中，每有一个连接就需要一个线程去阻塞等待读写结果，线程数量一多，就会导致上下文切换频繁、内存占用和调度开销增大</li><li>异步模型中，少量的 I&#x2F;O 线程（EventLoop）就能同时驱动很多连接，极大地减少了线程数量、上下文切换和系统资源消耗</li></ul><ol start="2"><li><strong>吞吐量与并发能力</strong></li></ol><ul><li>同步阻塞模式下，线程在等待网络或磁盘 I&#x2F;O 时无法做其它事情，导致CPU利用率不高</li><li>异步非阻塞模式下，线程在 I&#x2F;O 未就绪时立即返回去处理其它事件，可充分利用CPU，提升整体吞吐量和并发连接数</li></ul><ol start="3"><li><strong>响应时延</strong></li></ol><ul><li>同步调用常因线程排队和切换导致响应延迟抖动，尤其在高负载下更明显</li><li>异步调用通过回调或Future通知一旦I&#x2F;O就绪即可处理，减少了排队等待，响应更加及时和稳定</li></ul><ol start="4"><li><strong>可伸缩性</strong></li></ol><ul><li>同步模型在并发量增长时，需要线性增加线程池大小，最终受限于操作系统线程数和CPU核心数</li><li>异步模型中，固定数目的 EventLoop 线程即可水平扩展，连接层面几乎不受线程数量瓶颈限制，应用具有更好的可伸缩性</li></ul><ol start="5"><li>xxxxxxxxxx &#x2F;&#x2F; 用来判断是不是 读空闲时间过长，或 写空闲时间过长&#x2F;&#x2F; 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件ch.pipeline().addLast(new IdleStateHandler(0, 3, 0));&#x2F;&#x2F; ChannelDuplexHandler 可以同时作为入站和出站处理器ch.pipeline().addLast(new ChannelDuplexHandler() {    &#x2F;&#x2F; 用来触发特殊事件    @Override    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{        IdleStateEvent event &#x3D; (IdleStateEvent) evt;        &#x2F;&#x2F; 触发了写空闲事件        if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) {            ctx.writeAndFlush(new PingMessage());        }    }});java</li></ol><ul><li>异步模型能更好地隔离单个连接或单次 I&#x2F;O 的阻塞、慢启动等问题，一条慢连接不会拖垮整个线程池</li><li>通过超时、回调隔离等机制，更容易在网络波动时进行快速恢复和故障隔离</li></ul><h3 id="Future-Promise"><a href="#Future-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口</p><blockquote><p>netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p></blockquote><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li></ul><table><thead><tr><th>功能&#x2F;名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h3 id="Handler-Pipeline"><a href="#Handler-Pipeline" class="headerlink" title="Handler &amp; Pipeline"></a>Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p><ul><li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li><li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li></ul><p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">3</span>);</span><br><span class="line">                    ctx.channel().write(msg); <span class="comment">// 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">4</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">5</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">6</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 6</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">        future.channel().writeAndFlush(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>服务器端打印：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p><p><img src="/inori/62b8c227/handler1.png"></p><ul><li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul><li>如果注释掉 1 处代码，则仅会打印 1</li><li>如果注释掉 2 处代码，则仅会打印 1 2</li></ul></li><li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul><li>如果注释掉 3 处代码，则仅会打印 1 2 3</li></ul></li><li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul><li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li></ul></li><li>ctx.channel().write(msg) vs ctx.write(msg)<ul><li>都是触发出站处理器的执行</li><li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li><li>ctx.write(msg) 是从当前节点找上一个出站处理器</li><li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li><li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6自己</li></ul></li></ul><p>服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p><p><img src="/inori/62b8c227/handler2.png"></p><h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>对字节数据Bytebuffer的封装</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>log方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(ByteBuf buffer)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> buffer.readableBytes();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">        .append(<span class="string">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class="line">        .append(<span class="string">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class="line">        .append(<span class="string">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(buf, buffer);</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接内存-vs-堆内存"><a href="#直接内存-vs-堆内存" class="headerlink" title="直接内存 vs 堆内存"></a>直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><h4 id="池化-vs-非池化"><a href="#池化-vs-非池化" class="headerlink" title="池化 vs 非池化"></a>池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure><ul><li>Netty 4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>ByteBuf由四部分组成</p><p><img src="/inori/62b8c227/bytebuf.png"></p><p>最开始读写指针都在0位置</p><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td>用一字节 01|00 代表 true|false</td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian，即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian，即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 ByteBuffer</td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td></td></tr></tbody></table><blockquote><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li><li>网络传输，默认习惯是 Big Endian</li></ul></blockquote><p>先写入 4 个字节</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:4 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>再写入一个 int 整数，也是 4 个字节</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">5</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:8 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>默认初始容量为256字节，默认最大容量为Integer.MAX_VALUE</p><p>扩容规则是</p><ul><li>如何写入后数据大小未超过4MB，则每次扩容容量翻倍</li><li>如果写入后数据大小超过4MB，则每次增加4MB</li><li>扩容不能超过max capacity会报错</li></ul><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>例如读了 4 次，每次一个字节</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>如果需要重复读取 int 整数 5，怎么办？</p><p>可以在 read 前先做个标记 mark</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.markReaderIndex();</span><br><span class="line">System.out.println(buffer.readInt());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">read index:8 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 06                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时要重复读取的话，重置到标记位置 reset</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.resetReaderIndex();</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>这时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p><h4 id="retain-release"><a href="#retain-release" class="headerlink" title="retain &amp; release"></a>retain &amp; release</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等GC垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty采用了引用计数法来控制回收内存，每个ByteBuf都实现了ReferenceCounted接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><p>谁来负责 release 呢？</p><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong></p><ul><li>起点，对于NIO实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline</li><li>入站 ByteBuf 处理原则<ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li><li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li><li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li><li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li>出站 ByteBuf 处理原则<ul><li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li></ul></li><li>异常处理原则<ul><li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li></ul></li></ul><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>零拷贝的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p><p><img src="/inori/62b8c227/slice.png"></p><p>例如，原始 ByteBuf 进行一些初始操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">origin</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">origin.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">slice</span> <span class="operator">=</span> origin.slice();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class="line"><span class="comment">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 04                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时的 slice 不受影响，因为它有独立的读写指针</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>如果 slice 的内容发生了更改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slice.setByte(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 05                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 05                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h4 id="duplicate"><a href="#duplicate" class="headerlink" title="duplicate"></a>duplicate</h4><p>零拷贝的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p><p><img src="/inori/62b8c227/duplicate.png"></p><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p><h4 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h4><p>的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p><p>有两个 ByteBuf 如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p><p>方法1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT</span><br><span class="line">    .buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class="line">buf3.writeBytes(buf1);</span><br><span class="line">buf3.writeBytes(buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这种方法进行了数据的内存复制操作</p><p>方法2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line"><span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">buf3.addComponents(<span class="literal">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure><p>结果是一样的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p><ul><li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li><li>缺点，复杂了很多，多次操作会带来性能的损耗</li></ul><h4 id="Unpooled"><a href="#Unpooled" class="headerlink" title="Unpooled"></a>Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p><p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf4</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;);</span><br><span class="line">System.out.println(buf4.getClass());</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf4));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class io.netty.buffer.CompositeByteBuf</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h4 id="ByteBuf-优势"><a href="#ByteBuf-优势" class="headerlink" title="ByteBuf 优势"></a>ByteBuf 优势</h4><ul><li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li><li>可以自动扩容</li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络IO</title>
      <link href="/inori/fd4f4c4d.html"/>
      <url>/inori/fd4f4c4d.html</url>
      
        <content type="html"><![CDATA[<p>java中的IO可以分为BIO(blocking io,阻塞IO)、NIO(non-blocking io,非阻塞IO)、AIO(Asynchronous IO,异步IO)</p><h2 id="IO中的三大组件"><a href="#IO中的三大组件" class="headerlink" title="IO中的三大组件"></a>IO中的三大组件</h2><h3 id="Channel与Buffer"><a href="#Channel与Buffer" class="headerlink" title="Channel与Buffer"></a>Channel与Buffer</h3><p>channel有一点类似于stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">channel --&gt; buffer</span><br><span class="line">buffer --&gt; channel</span><br></pre></td></tr></table></figure><p>常见的Channel有</p><ul><li>FileChannel：用于对文件进行读写操作的通道，支持随机访问和映射文件</li><li>DatagramChannel：用于基于UDP进行无连接数据发送和接收的通道</li><li>SocketChannel：用于基于TCP的客户端网络通信，支持非阻塞连接与数据传输</li><li>ServerSocketChannel用于监听TCP连接请求的服务端通道，生成SocketChannel</li></ul><p>buffer则用来缓冲读写数据，常见的buffer有</p><ul><li>ByteBuffer：存储字节数据的基本缓冲区类型，是所有IO操作的核心<ul><li>MappedByteBuffer：可将文件内容直接映射到内存中进行读写</li><li>DirectByteBuffer：分配在堆外内存，用于高性能I&#x2F;O传输</li><li>HeapByteBuffer：分配在Java堆上，速度较慢但创建成本低</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector是一个可以同时监听多个Channel的I&#x2F;O就绪事件的组件，实现用一个线程处理多个连接</p><p>不用Selector时，如果我们使用多线程管理各个socket：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 多线程版</span><br><span class="line">t1(thread) --&gt; s1(socket1)</span><br><span class="line">t2(thread) --&gt; s2(socket2)</span><br><span class="line">t3(thread) --&gt; s3(socket3)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这种方式虽然可以同时管理多个socket，但是：</p><ul><li>内存占用高</li><li>线程上下文切换成本高</li><li>只适合连接数少的场景</li></ul><p>优化一下，使用线程池：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 线程池版</span><br><span class="line">t4(thread) --&gt; s4(socket1)</span><br><span class="line">t5(thread) --&gt; s5(socket2)</span><br><span class="line">t4(thread) -.-&gt; s6(socket3)</span><br><span class="line">t5(thread) -.-&gt; s7(socket4)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在这种设计下，我们使用线程池中的每个线程管理多个socket，但是这种方式也有缺点：</p><ul><li>阻塞模式下，线程仅能处理一个socket连接</li><li>仅适合短连接场景，如果是长连接，会造成socket饥饿现象</li></ul><p>现在引入Selector，用一个线程来管理多个channel，获取这些channel上发生的事件，这些channel工作在非阻塞模式下，不会让线程吊死在一个channel上。适合连接数特别多，但流量低的场景。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>调用selector的select()会阻塞直到channel发生了读写就绪事件，这些事件发生，select方法就会返回这些事件交给thread来处理</p><h2 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li>向buffer写入数据，例如调用 channel.read(buffer)</li><li>调用flip()切换至<strong>读模式</strong></li><li>从buffer读取数据，例如调用buffer.get()</li><li>调用clear()或compact()切换至<strong>写模式</strong></li><li>重复1~4步骤</li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>有一普通文本文件data.txt，内容为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234567890abcd</span><br></pre></td></tr></table></figure><p>使用FileChannel来读取文件内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;helloword/data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);<span class="comment">// 空间为10的bytebuffer</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 向 buffer 写入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                log.debug(<span class="string">&quot;读到字节数：&#123;&#125;&quot;</span>, len);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换 buffer 读模式</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, (<span class="type">char</span>)buffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换 buffer 写模式</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1</span><br></pre></td></tr></table></figure><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>ByteBuffer 有以下重要属性</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>初始状态：</p><p><img src="/inori/fd4f4c4d/bytebuffer1.png"></p><p>写模式下，position是写入位置，limit等于容量，下图表示写入了4个字节后的状态</p><p><img src="/inori/fd4f4c4d/bytebuffer2.png"></p><p>flip动作发生后，position切换为读取位置，limit切换为读取限制</p><p><img src="/inori/fd4f4c4d/bytebuffer3.png"></p><p>读取4个字节后，状态</p><p><img src="/inori/fd4f4c4d/bytebuffer4.png"></p><p>compact方法，是把未读完的部分向前压缩，然后切换至写模式。</p><p><img src="/inori/fd4f4c4d/bytebuffer5.png"></p><p>clear后，bytebuffer复原为初始状态。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>分配空间</li></ul><p>使用allocate方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Bytebuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li><p>向buffer写入数据</p><ul><li><p>调用channel的read方法</p></li><li><p>调用buffer的put方法</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buf);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">buf.put((<span class="type">byte</span>)<span class="number">127</span>);</span><br></pre></td></tr></table></figure><ul><li><p>从buffer读取数据</p><ul><li><p>调用channel的write方法</p></li><li><p>调用buffer的get方法</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buf);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buf.get();</span><br></pre></td></tr></table></figure><p>get方法会让position读指针向后走，如果想重复读取数据</p><ul><li>可以调用 rewind 方法将 position 重新置为 0</li><li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li></ul><ul><li>mark 和 reset</li></ul><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p><blockquote><p>rewind 和 flip 都会清除 mark 位置</p></blockquote><p>注意：</p><blockquote><p>⚠️ Buffer是<strong>非线程安全的</strong></p></blockquote><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>FileChannel 只能工作在阻塞模式下</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel 只能读</li><li>通过 FileOutputStream 获取的 channel 只能写</li><li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>会从channel读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1表示到达了文件的末尾</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>在while中调用channel.write是因为write方法并不能保证一次将buffer中的内容全部写入channel</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ...;</span><br><span class="line">buffer.put(...); <span class="comment">// 存入数据</span></span><br><span class="line">buffer.flip();   <span class="comment">// 切换读模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>channel必须关闭，调用了FileInputStream、FileOutputStream或者RandomAccessFile的close方法会间接地调用channel的close方法</p><h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用force(true)方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li><li>SocketChannel.read 会在没有数据可读时让线程暂停</li><li>阻塞的表现为线程暂停，暂停期间不会占用cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位jvm一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    log.debug(<span class="string">&quot;connecting...&quot;</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">    log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">    channels.add(sc);</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        log.debug(<span class="string">&quot;before read... &#123;&#125;&quot;</span>, channel);</span><br><span class="line">        channel.read(buffer); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        debugRead(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><ul><li>非阻塞模式下，相关方法都会不会让线程暂停<ul><li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li><li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept </li><li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li></ul></li><li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，浪费cpu</li><li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解非阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">        channels.add(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);<span class="comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugRead(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合Selector完成对多个Channel可读写事件的监控，这称之为多路复用</p><ul><li>多路复用仅针对网络IO、普通文件IO没法利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel未必时时可写，一旦Channel可写，会触发Selector的可写事件</li></ul></li></ul></li></ul><h3 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure><h4 id="绑定Channel事件"><a href="#绑定Channel事件" class="headerlink" title="绑定Channel事件"></a>绑定Channel事件</h4><p>也称之为注册事件，绑定的事件selector才会关心 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure><ul><li>channel 必须工作在非阻塞模式</li><li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的事件类型可以有<ul><li>connect - 客户端连接成功时触发</li><li>accept - 服务器端成功接受连接时触发</li><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul><h4 id="监听Channel事件"><a href="#监听Channel事件" class="headerlink" title="监听Channel事件"></a>监听Channel事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少channel发生了事件</p><p>方法1，阻塞直到绑定事件发生</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br></pre></td></tr></table></figure><p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select(<span class="type">long</span> timeout);</span><br></pre></td></tr></table></figure><p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.selectNow();</span><br></pre></td></tr></table></figure><h4 id="select何时不阻塞"><a href="#select何时不阻塞" class="headerlink" title="select何时不阻塞"></a>select何时不阻塞</h4><ul><li>事件发生时<ul><li>客户端发起连接请求，会触发 accept 事件</li><li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li><li>channel 可写，会触发 write 事件</li><li>在 linux 下 nio bug 发生时</li></ul></li><li>调用selector.wakeup()</li><li>调用selector.close()</li><li>selector所在线程interrupt</li></ul><h3 id="处理-accept-事件"><a href="#处理-accept-事件" class="headerlink" title="处理 accept 事件"></a>处理 accept 事件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果不处理，就取消掉</span></span><br><span class="line">                    <span class="comment">// key.cancel();</span></span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p></blockquote><h3 id="处理-read-事件"><a href="#处理-read-事件" class="headerlink" title="处理 read 事件"></a>处理 read 事件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        log.debug(<span class="string">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            sc.close();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debug(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为何要iter-remove"><a href="#为何要iter-remove" class="headerlink" title="为何要iter.remove()"></a>为何要iter.remove()</h4><blockquote><p>因为select在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p><ul><li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li><li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li></ul></blockquote><h4 id="cancel的作用"><a href="#cancel的作用" class="headerlink" title="cancel的作用"></a>cancel的作用</h4><blockquote><p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p></blockquote><h4 id="处理消息的边界"><a href="#处理消息的边界" class="headerlink" title="处理消息的边界"></a>处理消息的边界</h4><p><img src="/inori/fd4f4c4d/messageBound.png"></p><ul><li>固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li><li>按分隔符拆分，缺点是效率低</li><li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant c1 as 客户端1</span><br><span class="line">participant s as 服务器</span><br><span class="line">participant b1 as ByteBuffer1</span><br><span class="line">participant b2 as ByteBuffer2</span><br><span class="line">c1 -&gt;&gt; s: 发送 01234567890abcdef3333\r</span><br><span class="line">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 扩容</span><br><span class="line">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 第二次 read 存入 3333\r</span><br><span class="line">b2 -&gt;&gt; b2: 01234567890abcdef3333\r</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">        <span class="comment">// 找到一条完整消息</span></span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">            <span class="comment">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(length);</span><br><span class="line">            <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                target.put(source.get());</span><br><span class="line">            &#125;</span><br><span class="line">            debugAll(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact(); <span class="comment">// 0123456789abcdef  position 16 limit 16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 selector, 管理多个 channel</span></span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class="line">    <span class="comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// key 只关注 accept 事件</span></span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    log.debug(<span class="string">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        <span class="comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="comment">// accept, read</span></span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">            <span class="comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class="line">            iter.remove();</span><br><span class="line">            log.debug(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">            <span class="comment">// 5. 区分事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 如果是 accept</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>); <span class="comment">// attachment</span></span><br><span class="line">                <span class="comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                log.debug(<span class="string">&quot;scKey:&#123;&#125;&quot;</span>, scKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">// 如果是 read</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel(); <span class="comment">// 拿到触发事件的channel</span></span><br><span class="line">                    <span class="comment">// 获取 selectionKey 上关联的附件</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer); <span class="comment">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class="line">                    <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                        key.cancel();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        split(buffer);</span><br><span class="line">                        <span class="comment">// 需要扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            newBuffer.put(buffer); <span class="comment">// 0123456789abcdef3333\n</span></span><br><span class="line">                            key.attach(newBuffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    key.cancel();  <span class="comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ByteBuffer大小分配"><a href="#ByteBuffer大小分配" class="headerlink" title="ByteBuffer大小分配"></a>ByteBuffer大小分配</h4><ul><li>每个channel都需要记录可能被切分的消息，因为ByteBuffer不能被多个channel共同使用，因此需要为每个channel维护一个独立的ByteBuffer</li><li>ByteBuffer不能太大，比如一个ByteBuffer 1Mb的话，要支持百万连接就要1Tb内存，因此需要设计大小可变的ByteBuffer<ul><li>一种思路是首先分配一个较小的buffer，例如4k，如果发现数据不够，再分配8k的buffer，将4k buffer内容拷贝至8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能</li><li>另一种思路是用多个数组组成buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h3 id="处理-write-事件"><a href="#处理-write-事件" class="headerlink" title="处理 write 事件"></a>处理 write 事件</h3><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul><li>非阻塞模式下，无法保证把buffer中所有数据都写入channel，因此需要追踪write方法的返回值（代表实际写入字节数）</li><li>用selector监听所有channel的可写事件，每个channel都需要一个key来跟踪buffer，但这样又会导致占用内存过多，就有两阶段策略<ul><li>当消息处理器第一次写入消息时，才将channel注册到selector上</li><li>selector检查channel上的可写事件，如果所有的数据写完了，就取消channel的注册</li><li>如果不取消，会每次可写均会触发write事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sckey</span> <span class="operator">=</span> sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 1. 向客户端发送内容</span></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    <span class="comment">// 3. write 表示实际写了多少字节</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="comment">// 4. 如果有剩余未读字节，才需要关注写事件</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="comment">// read 1  write 4</span></span><br><span class="line">                        <span class="comment">// 在原有关注事件的基础上，多关注 写事件</span></span><br><span class="line">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 把 buffer 作为附件加入 sckey</span></span><br><span class="line">                        sckey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="comment">// 写完了</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                        key.attach(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write为何要取消"><a href="#write为何要取消" class="headerlink" title="write为何要取消"></a>write为何要取消</h4><p>只要向channel发送数据时，socket缓冲可写，这个事件会频繁触发，因此应当只在socket缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p><h3 id="利用多线程优化"><a href="#利用多线程优化" class="headerlink" title="利用多线程优化"></a>利用多线程优化</h3><p>前面的代码只有一个选择器，没有充分利用多核cpu，如何改进呢？</p><p>分两组选择器</p><ul><li>单线程配一个选择器，专门处理 accept 事件</li><li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BossEventLoop</span>().register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BossEventLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Selector boss;</span><br><span class="line">        <span class="keyword">private</span> WorkerEventLoop[] workers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">                ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">                ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                boss = Selector.open();</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">ssckey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                ssckey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">                workers = initEventLoops();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, <span class="string">&quot;boss&quot;</span>).start();</span><br><span class="line">                log.debug(<span class="string">&quot;boss start...&quot;</span>);</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;</span><br><span class="line">            WorkerEventLoop[] workerEventLoops = <span class="keyword">new</span> <span class="title class_">WorkerEventLoop</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerEventLoops.length; i++) &#123;</span><br><span class="line">                workerEventLoops[i] = <span class="keyword">new</span> <span class="title class_">WorkerEventLoop</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> workerEventLoops;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    boss.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            log.debug(<span class="string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                            workers[index.getAndIncrement() % workers.length].register(sc);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkerEventLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Selector worker;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WorkerEventLoop</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                worker = Selector.open();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, <span class="string">&quot;worker-&quot;</span> + index).start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sckey</span> <span class="operator">=</span> sc.register(worker, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    sckey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    worker.selectNow();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            worker.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    worker.select();</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> tasks.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">                                <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    key.cancel();</span><br><span class="line">                                    sc.close();</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    buffer.flip();</span><br><span class="line">                                    log.debug(<span class="string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                                    debugAll(buffer);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                key.cancel();</span><br><span class="line">                                sc.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        iter.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拿到-cpu-个数"><a href="#拿到-cpu-个数" class="headerlink" title="拿到 cpu 个数"></a>拿到 cpu 个数</h4><blockquote><ul><li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li><li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li></ul></blockquote><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h4 id="传统IO问题"><a href="#传统IO问题" class="headerlink" title="传统IO问题"></a>传统IO问题</h4><p>传统的IO将一个文件通过socket写出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure><p>内部工作流程是这样的：</p><p><img src="/inori/fd4f4c4d/tradIO.png"></p><ol><li><p>java本身并不具备IO读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p><blockquote><p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p></blockquote></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间cpu会参与拷贝，无法利用DMA</p></li><li><p>调用write方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入<strong>socket 缓冲区</strong>，cpu会参与拷贝</p></li><li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p></li></ol><p>可以看到中间环节较多，java的IO实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次</li><li>数据拷贝了共 4 次</li></ul><h4 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h4><p>通过 DirectByteBuf </p><ul><li>ByteBuffer.allocate(10) HeapByteBuffer 使用的是java堆内存</li><li>ByteBuffer.allocateDirect(10) DirectByteBuffer使用的是操作系统直接内存</li></ul><p><img src="/inori/fd4f4c4d/nio.png"></p><p>这种优化中，java可以使用 DirectByteBuf将堆外内存映射到jvm内存中来直接访问使用</p><ul><li>这块内存不受jvm垃圾回收的影响，因此内存地址固定，有助于IO读写</li><li>java中的DirectByteBuf对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuf对象被垃圾回收，将虚引用加入引用队列</li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li></ul><p>进一步优化（底层采用了linux 2.1后提供的sendFile方法），java中对应着两个channel调用transferTo&#x2F;transferFrom方法拷贝数据</p><p><img src="/inori/fd4f4c4d/sendFile.png"></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用cpu</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li></ol><p>可以看到</p><ul><li>只发生了一次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><p>进一步优化（linux 2.4）</p><p><img src="/inori/fd4f4c4d/zeroCopy.png"></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>只会将一些 offset 和 length 信息拷入<strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将<strong>内核缓冲区</strong>的数据写入网卡，不会使用cpu</li></ol><p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了2次。所谓零拷贝，并不是真正无拷贝，而是在不会拷贝重复数据到jvm内存中，零拷贝的优点有</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zookeeper基础入门</title>
      <link href="/inori/f8d5b7cd.html"/>
      <url>/inori/f8d5b7cd.html</url>
      
        <content type="html"><![CDATA[<p>Zookeeper是一个分布式的、开源的分布式应用程序的协调服务，基于ZAB协议（ZooKeeper Atomic Broadcast）实现分布式数据一致性</p><p>Zookeeper内部的数据模型类似文件系统的树形结构（ZNode），每个节点可存储不超过1MB的数据</p><p>Zookeeper提供的主要功能包括：</p><ul><li>服务注册与发现</li><li>配置管理</li><li>分布式锁</li><li>集群管理</li></ul><h2 id="Zookeeper数据模型"><a href="#Zookeeper数据模型" class="headerlink" title="Zookeeper数据模型"></a>Zookeeper数据模型</h2><p>ZooKeeper是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构</p><p>这里面的每一个节点都被称为ZNode，每个节点上都会保存自己的数据和节点信息</p><p>节点可以拥有子节点，同时也允许少量（1MB）数据存储在该节点之下（可以通过jute.maxbuffer修改单个节点数据大小限制）</p><p>节点可以分为四大类：</p><ul><li>PERSISTENT：持久化节点，创建后永久存在（除非显式删除）</li><li>EPHEMERAL：临时节点 -e，会话结束后自动删除（用于实现服务注册与心跳检测）</li><li>PERSISTENT_SEQUENTIAL：持久化顺序节点 -s，顺序节点的名称后面会自动追加单调递增序号（如 <code>/lock/seq-0000000001</code>）</li><li>EPHEMERAL_SEQUENTIAL ：临时顺序节点 -es</li><li>TTL节点：3.6.0+ 版本支持，设置存活时间后自动删除</li></ul><p><img src="/inori/f8d5b7cd/zookeeper.png"></p><h2 id="Zookeeper常用命令"><a href="#Zookeeper常用命令" class="headerlink" title="Zookeeper常用命令"></a>Zookeeper常用命令</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul><li>启动ZooKeeper服务: .&#x2F;zkServer.sh start</li><li>查看ZooKeeper服务状态: .&#x2F;zkServer.sh status</li><li>停止ZooKeeper服务: .&#x2F;zkServer.sh stop</li><li>重启ZooKeeper服务: .&#x2F;zkServer.sh restart</li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>连接ZooKeeper服务端：.&#x2F;zkCli.sh –server ip:port</li><li>断开连接：quit</li><li>设置节点值：set &#x2F;节点path value</li><li>删除单个节点：delete &#x2F;节点path</li><li>显示指定目录下节点：ls 目录</li><li>删除带有子节点的节点：deleteall &#x2F;节点path</li><li>创建节点：create &#x2F;节点path value</li><li>获取节点值：get &#x2F;节点path</li><li>创建临时节点：create -e &#x2F;节点path value</li><li>创建顺序节点：create -s &#x2F;节点path value</li><li>查询节点详细信息：ls –s &#x2F;节点path<ul><li>czxid：节点被创建的事务ID</li><li>ctime: 创建时间</li><li>mzxid: 最后一次被更新的事务ID</li><li>mtime: 修改时间</li><li>pzxid：子节点列表最后一次被更新的事务ID</li><li>cversion：子节点的版本号 </li><li>dataversion：数据版本号</li><li>aclversion：权限版本号</li><li>ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0</li><li>dataLength：节点存储的数据的长度</li><li>numChildren：当前节点的子节点个数</li></ul></li></ul><h2 id="ZooKeeper-JavaAPI-操作"><a href="#ZooKeeper-JavaAPI-操作" class="headerlink" title="ZooKeeper JavaAPI 操作"></a>ZooKeeper JavaAPI 操作</h2><p><strong>Curator</strong>是Netflix开源的高级客户端，可以简化ZooKeeper客户端的使用</p><p>Curator API常用操作有：</p><ul><li>建立连接</li><li>添加节点</li><li>删除节点</li><li>修改节点</li><li>查询节点</li><li>Watch事件</li><li>监听</li><li>分布式锁实现</li></ul><p>添加Maven依赖并启动Zookeeper服务：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Curator 核心库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Curator 扩展工具 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建客户端连接：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ZK_ADDRESS</span> <span class="operator">=</span> <span class="string">&quot;localhost:2181&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework <span class="title function_">createClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重试策略：初始等待1秒，最多重试3次</span></span><br><span class="line">        <span class="type">ExponentialBackoffRetry</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(ZK_ADDRESS)<span class="comment">// ip地址+端口</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)<span class="comment">// 会话超时时间（毫秒）</span></span><br><span class="line">                .connectionTimeoutMs(<span class="number">3000</span>)<span class="comment">// 连接建立超时时间（毫秒）</span></span><br><span class="line">            .namespace(<span class="string">&quot;/demo&quot;</span>)<span class="comment">// 设置命名空间（所有操作路径自动添加前缀）</span></span><br><span class="line">                .retryPolicy(retry)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> createClient();</span><br><span class="line">        client.start(); <span class="comment">// 启动连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ZooKeeper 连接状态: &quot;</span> + client.getState());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        client.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建持久节点（默认开放权限）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create()</span><br><span class="line">    .forPath(<span class="string">&quot;/persistent-node&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建临时顺序节点（会话结束后自动删除，名称追加序号）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">seqPath</span> <span class="operator">=</span> client.create()</span><br><span class="line">    .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)</span><br><span class="line">    .forPath(<span class="string">&quot;/temp-seq-&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>方法链</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>.withMode()</code></td><td>指定节点类型（共6种）</td><td><code>CreateMode.PERSISTENT_SEQUENTIAL</code></td></tr><tr><td><code>.withACL()</code></td><td>设置自定义权限列表</td><td><code>.withACL(ZooDefs.Ids.CREATOR_ALL_ACL)</code></td></tr><tr><td><code>.creatingParentsIfNeeded()</code></td><td>自动创建父节点（递归）</td><td>适用于深度路径如 <code>/a/b/c</code></td></tr><tr><td><code>.withTtl()</code></td><td>设置TTL（需ZK 3.5+，且需配置<code>ExtendedFeatureType.TTL</code>）</td><td><code>.withTtl(10000L)</code> &#x2F;&#x2F; 10秒后自动删除</td></tr><tr><td><code>.withProtection()</code></td><td>保护模式（防重放攻击）</td><td>配合临时顺序节点使用</td></tr></tbody></table><p>删除节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除叶子节点</span></span><br><span class="line">client.delete()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带版本号的删除（CAS）</span></span><br><span class="line">client.delete()</span><br><span class="line">    .withVersion(stat.getVersion())</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>方法链</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>.deletingChildrenIfNeeded()</code></td><td>递归删除子节点</td><td>用于删除非空目录</td></tr><tr><td><code>.guaranteed()</code></td><td>确保删除成功（持续重试直到ZK确认）</td><td>配合<code>.withVersion()</code>使用</td></tr><tr><td><code>.withVersion()</code></td><td>指定版本号（实现CAS删除）</td><td><code>.withVersion(5)</code></td></tr></tbody></table><p>修改节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础更新</span></span><br><span class="line">client.setData()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;new-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带版本号的原子更新（CAS操作）</span></span><br><span class="line"><span class="type">Stat</span> <span class="variable">newStat</span> <span class="operator">=</span> client.setData()</span><br><span class="line">    .withVersion(stat.getVersion()) <span class="comment">// 使用之前获取的版本号</span></span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;cas-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无条件强制更新</span></span><br><span class="line">client.setData()</span><br><span class="line">    .withVersion(-<span class="number">1</span>) <span class="comment">// 忽略版本冲突</span></span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;force-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调更新</span></span><br><span class="line">client.setData()</span><br><span class="line">    .inBackground((curator, event) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步更新结果: &quot;</span> + event.getResultCode());</span><br><span class="line">    &#125;)</span><br><span class="line">    .forPath(<span class="string">&quot;/async-path&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><p>获取节点数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本读取（返回byte[]）</span></span><br><span class="line"><span class="type">byte</span>[] data = client.getData()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带状态读取（获取Stat元信息）</span></span><br><span class="line"><span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line"><span class="type">byte</span>[] dataWithStat = client.getData()</span><br><span class="line">    .storingStatIn(stat) <span class="comment">// 存储节点状态</span></span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;版本号: &quot;</span> + stat.getVersion());</span><br></pre></td></tr></table></figure><p>子节点查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取子节点列表</span></span><br><span class="line">List&lt;String&gt; children = client.getChildren()</span><br><span class="line">    .forPath(<span class="string">&quot;/parent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带监听器的查询（子节点变化时触发）</span></span><br><span class="line">List&lt;String&gt; watchedChildren = client.getChildren()</span><br><span class="line">    .usingWatcher((CuratorWatcher) event -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子节点变化: &quot;</span> + event.getType());</span><br><span class="line">    &#125;).forPath(<span class="string">&quot;/parent&quot;</span>);</span><br></pre></td></tr></table></figure><p>存在性检查：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查节点是否存在（返回Stat或null）</span></span><br><span class="line"><span class="type">Stat</span> <span class="variable">existsStat</span> <span class="operator">=</span> client.checkExists()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带监听的存在检查</span></span><br><span class="line">client.checkExists()</span><br><span class="line">    .usingWatcher((CuratorWatcher) event -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getType() == Watcher.Event.EventType.NodeCreated) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点被创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forPath(<span class="string">&quot;/path-to-watch&quot;</span>);</span><br></pre></td></tr></table></figure><p>事务操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建事务</span></span><br><span class="line"><span class="type">CuratorTransactionFinal</span> <span class="variable">txFinal</span> <span class="operator">=</span> client.inTransaction()</span><br><span class="line">    .create().forPath(<span class="string">&quot;/txn-node1&quot;</span>, <span class="string">&quot;data1&quot;</span>.getBytes()).and()</span><br><span class="line">    .setData().forPath(<span class="string">&quot;/txn-node2&quot;</span>, <span class="string">&quot;data2&quot;</span>.getBytes()).and()</span><br><span class="line">    .delete().forPath(<span class="string">&quot;/txn-node3&quot;</span>).and()</span><br><span class="line">    .commit(); <span class="comment">// 原子化执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查结果</span></span><br><span class="line"><span class="keyword">for</span> (CuratorTransactionResult result : txFinal.getResults()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;操作类型: &quot;</span> + result.getType() + <span class="string">&quot;, 路径: &quot;</span> + result.getForPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>批量操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建批量操作</span></span><br><span class="line">List&lt;CuratorOp&gt; ops = Arrays.asList(</span><br><span class="line">    client.transactionOp().create().forPath(<span class="string">&quot;/batch/new&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes()),</span><br><span class="line">    client.transactionOp().setData().forPath(<span class="string">&quot;/batch/existing&quot;</span>, <span class="string">&quot;update&quot;</span>.getBytes()),</span><br><span class="line">    client.transactionOp().delete().forPath(<span class="string">&quot;/batch/old&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行批量操作</span></span><br><span class="line">List&lt;CuratorTransactionResult&gt; results = client.transaction().forOperations(ops);</span><br></pre></td></tr></table></figure><h2 id="Watch事件监听"><a href="#Watch事件监听" class="headerlink" title="Watch事件监听"></a>Watch事件监听</h2><p>ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。</p><p>ZooKeeper中引入了Watcher机制来实现了发布&#x2F;订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会通知所有订阅者。</p><p>ZooKeeper原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便，需要开发人员自己反复注册Watcher，比较繁琐。Curator引入了Cache来实现对 ZooKeeper服务端事件的监听。</p><p>ZooKeeper提供了三种Watcher：</p><ul><li>NodeCache:只是监听某一个特定的节点</li><li>PathChildrenCache:监控一个ZNode的子节点</li><li>TreeCache:可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</li></ul><p>一次侦听：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.api.CuratorWatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneTimeWatcherDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加一次性Watcher（触发后自动移除）</span></span><br><span class="line">        <span class="type">byte</span>[] data = client.getData()</span><br><span class="line">                .usingWatcher((CuratorWatcher) event -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;【一次性监听】事件类型: &quot;</span> + event.getType() + <span class="string">&quot;, 路径: &quot;</span> + event.getPath());</span><br><span class="line">                &#125;)</span><br><span class="line">                .forPath(<span class="string">&quot;/test-watch&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试触发（修改节点数据）</span></span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-watch&quot;</span>, <span class="string">&quot;new-data&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 再次修改不会触发，因为Watcher已被移除</span></span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-watch&quot;</span>, <span class="string">&quot;another-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathChildrenCache持续侦听：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistentWatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        client.create().creatingParentsIfNeeded().forPath(<span class="string">&quot;/test-parent&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建PathChildrenCache监听器</span></span><br><span class="line">        <span class="type">PathChildrenCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client, <span class="string">&quot;/test-parent&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听回调</span></span><br><span class="line">        cache.getListenable().addListener((client1, event) -&gt; &#123;</span><br><span class="line">            <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> CHILD_ADDED:</span><br><span class="line">                    System.out.println(<span class="string">&quot;【子节点新增】路径: &quot;</span> + event.getData().getPath());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CHILD_UPDATED:</span><br><span class="line">                    System.out.println(<span class="string">&quot;【子节点更新】路径: &quot;</span> + event.getData().getPath() + </span><br><span class="line">                                     <span class="string">&quot;, 数据: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(event.getData().getData()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CHILD_REMOVED:</span><br><span class="line">                    System.out.println(<span class="string">&quot;【子节点删除】路径: &quot;</span> + event.getData().getPath());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试操作</span></span><br><span class="line">        client.create().forPath(<span class="string">&quot;/test-parent/child1&quot;</span>, <span class="string">&quot;data1&quot;</span>.getBytes());</span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-parent/child1&quot;</span>, <span class="string">&quot;updated&quot;</span>.getBytes());</span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/test-parent/child1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        cache.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NodeCache节点全量监听:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCacheListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeCacheDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        client.create().forPath(<span class="string">&quot;/test-node&quot;</span>, <span class="string">&quot;init&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建NodeCache监听指定节点</span></span><br><span class="line">        <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client, <span class="string">&quot;/test-node&quot;</span>);</span><br><span class="line">        nodeCache.start(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听器</span></span><br><span class="line">        nodeCache.getListenable().addListener(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;【节点数据变更】当前数据: &quot;</span> + </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span>(nodeCache.getCurrentData().getData()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;【节点被删除】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试操作</span></span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-node&quot;</span>, <span class="string">&quot;changed&quot;</span>.getBytes());</span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/test-node&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        nodeCache.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeCache树形结构监听:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCacheEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeCacheDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        client.create().creatingParentsIfNeeded().forPath(<span class="string">&quot;/test-tree/sub1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建TreeCache监听子树</span></span><br><span class="line">        <span class="type">TreeCache</span> <span class="variable">treeCache</span> <span class="operator">=</span> TreeCache.newBuilder(client, <span class="string">&quot;/test-tree&quot;</span>).build();</span><br><span class="line">        treeCache.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听器</span></span><br><span class="line">        treeCache.getListenable().addListener((client1, event) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getData() != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;【树形事件】类型: %s, 路径: %s, 数据: %s\n&quot;</span>,</span><br><span class="line">                    event.getType(),</span><br><span class="line">                    event.getData().getPath(),</span><br><span class="line">                    event.getData().getData() != <span class="literal">null</span> ? </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">String</span>(event.getData().getData()) : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试操作</span></span><br><span class="line">        client.create().forPath(<span class="string">&quot;/test-tree/sub2&quot;</span>, <span class="string">&quot;sub2-data&quot;</span>.getBytes());</span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-tree/sub1&quot;</span>, <span class="string">&quot;update&quot;</span>.getBytes());</span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/test-tree/sub1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        treeCache.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>事件类型</strong></th><th><strong>触发条件</strong></th><th><strong>适用监听器</strong></th></tr></thead><tbody><tr><td>NodeCreated</td><td>节点被创建</td><td>Watcher&#x2F;NodeCache</td></tr><tr><td>NodeDeleted</td><td>节点被删除</td><td>所有监听器</td></tr><tr><td>NodeDataChanged</td><td>节点数据变更</td><td>所有监听器</td></tr><tr><td>NodeChildrenChanged</td><td>子节点数量变化（不包含数据变更）</td><td>PathChildrenCache</td></tr><tr><td>INITIALIZED</td><td>TreeCache初始化完成</td><td>TreeCache</td></tr><tr><td>CONNECTION_LOST</td><td>连接断开</td><td>所有监听器</td></tr></tbody></table><h2 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h2><p>核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点。</p><ol><li>客户端获取锁时，在lock节点下创建<strong>临时顺序</strong>节点。</li><li>然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。</li><li>如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。（每个节点只监听比自己小的、最大的那个节点）</li><li>如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。</li></ol><h3 id="锁类型及其应用"><a href="#锁类型及其应用" class="headerlink" title="锁类型及其应用"></a>锁类型及其应用</h3><p>互斥锁（InterProcessMutex）：基于临时顺序节点实现，通过竞争最小序号获得锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutexLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        </span><br><span class="line">        <span class="type">InterProcessMutex</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/locks/mutex&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取锁（阻塞等待，支持超时设置）</span></span><br><span class="line">            <span class="keyword">if</span> (lock.acquire(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得锁&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟业务处理</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock.isAcquiredInThisProcess()) &#123;</span><br><span class="line">                    lock.release();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁（InterProcessReadWriteLock）:</p><ul><li>读锁：共享锁，多个客户端可同时持有</li></ul><ul><li>写锁：独占锁，与其他所有锁互斥</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InterProcessReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(client, <span class="string">&quot;/locks/rwlock&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();</span><br><span class="line">readLock.acquire();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();</span><br><span class="line">writeLock.acquire();</span><br></pre></td></tr></table></figure><p>联锁（InterProcessMultiLock）:同时锁定多个路径，<strong>原子性</strong>获取&#x2F;释放多个锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;InterProcessLock&gt; locks = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/locks/lock1&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/locks/lock2&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">InterProcessMultiLock</span> <span class="variable">multiLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMultiLock</span>(locks);</span><br><span class="line">multiLock.acquire(); <span class="comment">// 所有锁同时获取</span></span><br><span class="line">multiLock.release(); <span class="comment">// 所有锁同时释放</span></span><br></pre></td></tr></table></figure><p>信号量（InterProcessSemaphoreV2）:控制同时访问资源的客户端数量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InterProcessSemaphoreV2</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreV2</span>(client, <span class="string">&quot;/locks/semaphore&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">Lease</span> <span class="variable">lease</span> <span class="operator">=</span> semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">semaphore.returnLease(lease);      <span class="comment">// 释放许可</span></span><br></pre></td></tr></table></figure><h2 id="Zookeeper集群"><a href="#Zookeeper集群" class="headerlink" title="Zookeeper集群"></a>Zookeeper集群</h2><p>节点角色：</p><table><thead><tr><th><strong>角色</strong></th><th><strong>职责</strong></th><th><strong>数量要求</strong></th></tr></thead><tbody><tr><td><strong>Leader</strong></td><td>处理所有写请求，发起提案投票</td><td>1（唯一活跃）</td></tr><tr><td><strong>Follower</strong></td><td>参与投票，处理读请求（可能返回旧数据）</td><td>≥1</td></tr><tr><td><strong>Observer</strong></td><td>仅同步数据，不参与投票（扩展读性能）</td><td>可选（可水平扩展）</td></tr></tbody></table><h3 id="Leader的选举（Fast-Leader-Election算法）"><a href="#Leader的选举（Fast-Leader-Election算法）" class="headerlink" title="Leader的选举（Fast Leader Election算法）"></a>Leader的选举（Fast Leader Election算法）</h3><p>Serverid：服务器ID，比如有三台服务器，编号分别是1,2,3。编号越大在选择算法中的权重越大。</p><p>Zxid：数据ID，服务器中存放的最大数据ID。值越大说明数据越新，在选举算法中数据越新权重越大。</p><p>在Leader选举的过程中，如果某台ZooKeeper获得了超过半数的选票，则此ZooKeeper就可以成为Leader了。</p><p>并且在选取leader后新增节点，只要leader节点不挂，就不会重新选举</p><h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><p>ZAB协议（ZooKeeper Atomic Broadcast）</p><ul><li>两种模式<ol><li>崩溃恢复：选举新Leader并同步数据</li><li>消息广播：Leader将写请求转化为Proposal广播给所有Follower</li></ol></li><li>数据一致性<ul><li>顺序一致性：所有请求按全局顺序执行</li><li>原子性：更新要么全部成功，要么全部失败</li></ul></li></ul><p>会话管理</p><ul><li>会话周期：客户端连接时创建，超时或断开时结束</li><li>临时节点：会话结束自动删除（用于实现服务注册）</li></ul><p>数据同步流程</p><ol><li>客户端向Leader发起写请求</li><li>Leader生成Proposal广播给所有Follower</li><li>Follower持久化Proposal后返回ACK</li><li>Leader收到半数以上ACK后提交Commit</li><li>Leader通知所有节点应用变更</li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>如果Leader挂了，其他节点没挂会怎么样？</li></ol><p>那么会在其他Follower中选取新Leader，如果节点数量过少，就直接显示不可用</p><ol start="2"><li>如果Follower挂了会怎么样？</li></ol><p>不怎么样，其他节点继续工作，但是如果剩余节点过少，就显示不可用</p>]]></content>
      
      
      <categories>
          
          <category> Zookeeper </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo基础入门</title>
      <link href="/inori/741a547a.html"/>
      <url>/inori/741a547a.html</url>
      
        <content type="html"><![CDATA[<p>Dubbo是一款高性能RPC(Remote Procedure Call，远程过程调用)框架，专注于分布式服务治理，提供服务发现、负载均衡、容错等能力</p><h2 id="Dubbo架构"><a href="#Dubbo架构" class="headerlink" title="Dubbo架构"></a>Dubbo架构</h2><p>Dubbo的架构包含5个核心角色：</p><ol><li>Provider：服务提供者，暴露服务接口</li><li>Consumer：服务消费者，调用远程服务</li><li>Registry（注册中心）：服务注册和发现的注册中心，存储服务元数据（如 IP、端口），支持 ZooKeeper&#x2F;Nacos&#x2F;Redis等注册中心</li><li>Monitor（监控中心）：统计服务调用次数和耗时</li><li>Config Center（配置中心）：动态调整参数（如超时时间）</li></ol><p><img src="/inori/741a547a/dubbo.png"></p><h2 id="Dubbo快速入门"><a href="#Dubbo快速入门" class="headerlink" title="Dubbo快速入门"></a>Dubbo快速入门</h2><p>采用SpringBoot+Dubbo+Zookeeper实现服务提供者和消费者之间的调用：</p><ul><li>dubbo-provider: 服务提供者</li><li>dubbo-consumer: 服务消费者</li></ul><p>由于提供者和消费者之间需要统一类，所以两者通常要依赖同一个公共接口，编写一个接口类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建提供者模块启动类<code>DubboProviderApplication.java</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboProviderApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DubboProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现类<code>GreetingServiceImpl.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.api.GreetingService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.DubboService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DubboService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot; from provider!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>application.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-demo-provider</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">20880</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建消费者模块启动类<code>DubboConsumerApplication.java</code>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboConsumerApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> com.example.api.GreetingService greetingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DubboConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> greetingService.sayHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Received: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>application.yml</code>:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-demo-consumer</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure><h2 id="Dubbo工作流程"><a href="#Dubbo工作流程" class="headerlink" title="Dubbo工作流程"></a>Dubbo工作流程</h2><ol><li><strong>服务暴露</strong>：<ul><li>Provider启动时向注册中心注册服务</li><li>注册中心存储服务元数据（如 <code>com.example.UserService</code> → <code>192.168.1.1:20880</code>）</li></ul></li><li><strong>服务发现</strong>：<ul><li>Consumer订阅注册中心，获取Provider地址列表</li><li>注册中心通过Watcher机制推送变更（如新增 Provider）</li></ul></li><li><strong>服务调用</strong>：<ul><li>Consumer通过负载均衡策略选择Provider</li><li>通过Netty发送序列化后的请求数据</li><li>Provider 执行本地方法并返回结果</li></ul></li><li><strong>监控上报</strong>：<ul><li>调用次数、耗时等数据异步上报到Monitor</li></ul></li></ol><h2 id="Dubbo高级特性"><a href="#Dubbo高级特性" class="headerlink" title="Dubbo高级特性"></a>Dubbo高级特性</h2><ol><li>序列化</li></ol><p>两个机器在传输数据时，如何传输Java对象？</p><p>答：Dubbo内部已经将序列化和反序列化的过程内部封装了，我们只需要在定义pojo类时实现<code>Serializable</code>接口即可，一般会定义一个公共的pojo模块，让生产者和消费者都依赖该模块。</p><ol start="2"><li>地址缓存</li></ol><p>注册中心挂了，服务是否可以正常访问？</p><p>答：可以，因为Dubbo服务消费者在第一次调用时，会将服务提供方地址缓存到本地，以后再调用则不会访问注册中心。当服务提供者地址发生变化时，注册中心会通知服务消费者。</p><ol start="3"><li>超时重试</li></ol><p>服务消费者在调用服务提供者的时候如果发生了阻塞、等待的情形，如果不做处理，服务消费者会一直等待下去，在某个峰值时刻，大量的请求都在同时请求服务消费者，会造成线程的大量堆积，势必会造成雪崩，Dubbo是如何解决的？</p><p>答：Dubbo利用超时机制来解决这个问题，设置一个超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。使用timeout属性配置超时时间，默认1000毫秒。如果出现网络抖动，则这一次请求就会失败。Dubbo还提供重试机制来避免类似问题的发生。通过retries属性来设置重试次数，默认为2次。</p><ol start="4"><li>多版本管理</li></ol><p>灰度发布：当出现新功能时，会让一部分用户先使用新功能，用户反馈没问题时，再将所有用户迁移到新功能。<br>Dubbo中使用<code>version</code>属性来设置和调用同一个接口的不同版本，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(version = &quot;1.0.0&quot;)</span><span class="comment">// 1.0版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User-&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dubbo服务治理"><a href="#Dubbo服务治理" class="headerlink" title="Dubbo服务治理"></a>Dubbo服务治理</h2><table><thead><tr><th>功能</th><th>实现方式</th></tr></thead><tbody><tr><td><strong>负载均衡</strong></td><td>Random（默认）&#x2F;RoundRobin&#x2F;LeastActive&#x2F;一致性 Hash</td></tr><tr><td><strong>集群容错</strong></td><td>Failover（自动重试其他节点）&#x2F;Failfast（快速失败）&#x2F;Failsafe（忽略错误）</td></tr><tr><td><strong>服务路由</strong></td><td>基于条件规则（如 tag 路由）或脚本路由</td></tr><tr><td><strong>服务降级</strong></td><td>Mock 机制（在调用失败时返回本地模拟数据）</td></tr></tbody></table><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><ul><li>Random：按权重随机，默认值。按权重设置随机概率</li><li>RoundRobin：按权重轮询</li><li>LeastActive：最少活跃调用数，相同活跃数的随机</li><li>ConsistentHash：一致性Hash，相同参数的请求总是发到同一提供者</li></ul><h3 id="集群容错策略"><a href="#集群容错策略" class="headerlink" title="集群容错策略"></a>集群容错策略</h3><ul><li>Failover Cluster：失败重试。默认值。当出现失败，重试其它服务器 ，默认重试2次，使用 retries 配置。一般用于读操作</li><li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于写操作</li><li>Failsafe Cluster：失败安全，出现异常时，直接忽略。返回一个空结果</li><li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作</li><li>Forking Cluster：并行调用多个服务器，只要一个成功即返回</li><li>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错。</li></ul>]]></content>
      
      
      <categories>
          
          <category> dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC线程池</title>
      <link href="/inori/e590136b.html"/>
      <url>/inori/e590136b.html</url>
      
        <content type="html"><![CDATA[<p>利用多线程，程序可以更加合理地使用CPU多核心资源，在同一时间完成更多的工作。但是，如果程序频繁地创建线程，由于线程的创建和销毁也需要占用系统资源，因此这样会降低整个程序的性能，利用线程池可以将已创建的线程复用，利用池化技术，就像数据库连接池一样，创建很多个线程，然后反复地使用这些线程，而不对它们进行销毁。</p><p>由于线程池可以反复利用已有线程执行多线程操作，所以它一般是有容量限制的，当所有的线程都处于工作状态时，那么新的多线程请求会被阻塞，直到有一个线程空闲出来为止，这里会用到阻塞队列</p><p><img src="/inori/e590136b/threadPool.png"></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>线程池的构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的参数：</p><ul><li>corePoolSize：<strong>核心线程池大小</strong>，每向线程池提交一个多线程任务都会创建一个新的<code>核心线程</code>，无论是否存在其他空闲线程，直到到达核心线程池大小为止，之后会尝试复用线程资源。也可以在一开始就全部初始化好，调用<code> prestartAllCoreThreads()</code>即可</li><li>maximumPoolSize：<strong>最大线程池大小</strong>，当目前线程池中所有的线程都处于运行状态，并且等待队列已满，那么就会直接尝试继续创建新的<code>非核心线程</code>运行，但是不能超过最大线程池大小</li><li>keepAliveTime：<strong>线程最大空闲时间</strong>，当一个<code>非核心线程</code>空闲超过一定时间，会自动销毁。</li><li>unit：<strong>线程最大空闲时间的时间单位</strong></li><li>workQueue：<strong>线程等待队列</strong>，当线程池中核心线程数已满时，就会将任务暂时存到等待队列中，直到有线程资源可用为止，这里可以使用我们上一章学到的阻塞队列</li><li>threadFactory：<strong>线程创建工厂</strong>，我们可以干涉线程池中线程的创建过程，进行自定义。</li><li>handler：<strong>拒绝策略</strong>，当等待队列和线程池都没有空间了，真的不能再来新的任务时，来了个新的多线程任务，那么只能拒绝了，这时就会根据当前设定的拒绝策略进行处理</li></ul><p>整体流程：<u>核心线程 -&gt; 核心线程满 -&gt; 剩余任务进入阻塞队列 -&gt; 阻塞队列满 -&gt; 开启非核心线程执行阻塞队列满后面到的任务 -&gt; 线程数量超过<code>maximumPoolSize</code> -&gt; 拒绝后续任务</u></p><p>线程池的拒绝策略默认有四个：</p><ul><li><code>AbortPolicy(默认)</code>：直接抛异常</li><li><code>CallerRunsPolicy</code>：直接让提交任务的线程运行这个任务，比如在主线程向线程池提交了任务，那么就直接由主线程执行</li><li><code>DiscardOldestPolicy</code>：丢弃队列中最近的一个任务，替换为当前任务</li><li><code>DiscardPolicy</code>：直接丢弃新提交的任务</li></ul><p>注意：如果任务在运行过程中出现异常了，会导致线程池中的线程被销毁,线程池会自动创建新的线程来替代被销毁的线程</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>,   <span class="comment">//2个核心线程，最大线程数为4个</span></span><br><span class="line">                    <span class="number">3</span>, TimeUnit.SECONDS,        <span class="comment">//最大空闲时间为3秒钟</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>));     <span class="comment">//这里使用容量为2的ArrayBlockingQueue队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;   <span class="comment">//开始6个任务</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 开始执行！（&quot;</span>+ finalI);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 已结束！（&quot;</span>+finalI);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="comment">//看看当前线程池中的线程数量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;线程池中线程数量：&quot;</span>+executor.getPoolSize());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);     <span class="comment">//等到超过空闲时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;线程池中线程数量：&quot;</span>+executor.getPoolSize());</span><br><span class="line"></span><br><span class="line">    executor.shutdownNow();    <span class="comment">//使用完线程池记得关闭，不然程序不会结束，它会取消所有等待中的任务以及试图中断正在执行的任务，关闭后，无法再提交任务，一律拒绝</span></span><br><span class="line">  <span class="comment">//executor.shutdown();     //同样可以关闭，但是会执行完等待队列中的任务再关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池类"><a href="#线程池类" class="headerlink" title="线程池类"></a>线程池类</h3><ol><li><code>newFixedThreadPool(int nThreads)</code></li></ol><ul><li>作用：创建一个<strong>固定大小</strong>的线程池</li><li>特点：<ul><li>线程池中的线程数量固定，不会动态变化</li><li>任务队列是无界的（<code>LinkedBlockingQueue</code>），如果任务数量超过线程数量，任务会排队等待</li></ul></li><li>适用场景：适用于负载比较稳定的服务器，或者需要限制线程数量的场景</li></ul><ol start="2"><li><code>newCachedThreadPool()</code></li></ol><ul><li>作用：创建一个<strong>可缓存</strong>的线程池</li><li>特点：<ul><li>线程池中的线程数量会根据任务数量动态调整，所有的线程都是<code>非核心线程</code></li><li>空闲线程会在60秒后被回收</li><li>任务队列是同步队列（<code>SynchronousQueue</code>），不会存储任务，新任务会立即执行或创建新线程</li></ul></li><li>适用场景：适用于执行大量短期异步任务，或者任务执行时间较短的场景</li></ul><ol start="3"><li><code>newSingleThreadExecutor()</code></li></ol><ul><li>作用：创建一个<strong>单线程</strong>的线程池</li><li>特点：<ul><li>线程池中只有一个线程，所有任务按顺序执行</li><li>任务队列是无界的（<code>LinkedBlockingQueue</code>）</li></ul></li><li>适用场景：适用于需要保证任务顺序执行的场景</li></ul><ol start="4"><li><code>newScheduledThreadPool(int corePoolSize)</code></li></ol><ul><li>作用：创建一个<strong>支持定时任务</strong>的线程池</li><li>特点：<ul><li>线程池可以执行定时任务或周期性任务</li><li>任务队列是延迟队列（<code>DelayedWorkQueue</code>）</li></ul></li><li>适用场景：适用于需要执行定时任务或周期性任务的场景</li></ul><h2 id="执行带返回值的任务"><a href="#执行带返回值的任务" class="headerlink" title="执行带返回值的任务"></a>执行带返回值的任务</h2><p>一个多线程任务不仅仅可以是void任务，也可以使用Future得到一个任务的返回值，可以通过它来获取任务的结果以及任务当前是否完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务，返回 Future 对象</span></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取任务结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务结果: &quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future还可以取消任务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCancelExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">cancelled</span> <span class="operator">=</span> future.cancel(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;任务是否被取消: &quot;</span> + cancelled);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查任务状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务是否完成: &quot;</span> + future.isDone());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务是否被取消: &quot;</span> + future.isCancelled());</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用<code>future.cancel(true)</code>取消任务，并中断任务执行</li><li><code>isDone()</code>和<code>isCancelled()</code>方法返回 <code>true</code>，表示任务已被取消</li></ul><h2 id="执行定时任务"><a href="#执行定时任务" class="headerlink" title="执行定时任务"></a>执行定时任务</h2><p>JDK5之后，可以使用<code>ScheduledThreadPoolExecutor</code>来提交定时任务，它继承自<code>ThreadPoolExecutor</code>，并且所有的构造方法都必须要求最大线程池容量为<code>Integer.MAX_VALUE</code>，并且都是采用的<code>DelayedWorkQueue</code>作为等待队列</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><ol><li><code>schedule(Runnable command, long delay, TimeUnit unit)</code></li></ol><ul><li>作用：提交一个延迟任务，在指定的延迟时间<code>delay</code>后执行</li><li>参数：<ul><li><code>command</code>：要执行的任务</li><li><code>delay</code>：延迟时间</li><li><code>unit</code>：时间单位</li></ul></li></ul><ol start="2"><li><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></li></ol><ul><li>作用：提交一个延迟任务，在指定的延迟时间<code>delay</code>后执行，并返回<code>Future</code>对象</li><li>参数：<ul><li><code>callable</code>：要执行的任务</li></ul></li></ul><ol start="3"><li><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></li></ol><ul><li>作用：提交一个周期性任务，在初始延迟时间后开始执行，之后按固定的时间间隔重复执行。</li><li>参数:<ul><li><code>command</code>：要执行的任务</li><li><code>initialDelay</code>：初始延迟时间</li><li><code>period</code>：任务执行的时间间隔</li></ul></li></ul><ol start="4"><li><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></li></ol><ul><li>作用：提交一个周期性任务，在初始延迟时间后开始执行，之后在上一次任务执行完成后，再延迟指定的时间执行下一次任务</li><li>参数：<ul><li><code>command</code>：要执行的任务</li><li><code>initialDelay</code>：初始延迟时间</li><li><code>delay</code>：任务执行完成后的延迟时间</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li>延迟任务</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExecutorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ScheduledThreadPoolExecutor</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交延迟任务</span></span><br><span class="line">        executor.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;延迟任务执行，线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 3 秒后执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>固定速率周期性任务</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledAtFixedRateExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交周期性任务</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;周期性任务执行，线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 1 秒后开始执行，每隔 2 秒执行一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>); <span class="comment">// 主线程休眠 10 秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>固定延迟周期性任务</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledWithFixedDelayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交周期性任务</span></span><br><span class="line">        executor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;周期性任务执行，线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 1 秒后开始执行，任务执行完成后延迟 2 秒执行下一次任务</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>); <span class="comment">// 主线程休眠 10 秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scheduleAtFixedRate</code>是如果任务执行时间不到<code>period</code>，就休息到<code>period</code>，否则立刻执行下一次；<code>scheduleWithFixedDelay</code>是无论任务执行用了多长时间，两次任务的时间间隔一定是<code>delay</code></p><h2 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h2><p>在<code>ThreadPoolExecutor</code>中，<code>ctl</code>变量是一个<code>AtomicInteger</code>类型的字段，用于同时表示线程池的状态和线程数量。它是线程池实现中的核心变量，通过位运算来高效地管理线程池的状态和线程数量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个变量比较关键，用到了原子AtomicInteger，用于同时保存线程池运行状态和线程数量（使用原子类是为了保证原子性）</span></span><br><span class="line"><span class="comment">//它是通过拆分32个bit位来保存数据的，前3位保存状态，后29位保存工作线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;    <span class="comment">//29位，线程数量位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;   <span class="comment">//计算得出最大容量（1左移29位，最大容量为2的29次方-1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的运行状态，都只占用前3位，不会占用后29位</span></span><br><span class="line"><span class="comment">// 接收新任务，并等待执行队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;   <span class="comment">//111 | 0000... (后29数量位，下同)</span></span><br><span class="line"><span class="comment">// 不接收新任务，但是依然等待执行队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;   <span class="comment">//000 | 数量位</span></span><br><span class="line"><span class="comment">// 不接收新任务，也不执行队列中的任务，并且还要中断正在执行中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;   <span class="comment">//001 | 数量位</span></span><br><span class="line"><span class="comment">// 所有的任务都已结束，线程数量为0，即将完全关闭</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;   <span class="comment">//010 | 数量位</span></span><br><span class="line"><span class="comment">// 完全关闭</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;   <span class="comment">//011 | 数量位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装和解析ctl变量的一些方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;   <span class="comment">//对CAPACITY取反就是后29位全部为0，前三位全部为1，接着与c进行与运算，这样就可以只得到前三位的结果了，所以这里是取运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//同上，这里是为了得到后29位的结果，所以这里是取线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;   </span><br><span class="line"><span class="comment">// 比如上面的RUNNING, 0，进行与运算之后：</span></span><br><span class="line"><span class="comment">// 111 | 0000000000000000000000000</span></span><br></pre></td></tr></table></figure><h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><p><code>execute</code> 方法是线程池的入口，用于提交任务到线程池，具体流程：</p><ol><li>任务提交<ul><li>将任务提交到线程池中执行</li></ul></li><li>线程池状态检查<ul><li>如果线程池状态不是 <code>RUNNING</code>，则拒绝任务</li></ul></li><li>线程数量检查<ul><li>如果线程数量小于 <code>corePoolSize</code>，则创建新的核心线程执行任务</li></ul></li><li>任务队列检查<ul><li>如果线程数量已达到 <code>corePoolSize</code>，则将任务放入任务队列中</li></ul></li><li>创建新线程<ul><li>如果任务队列已满且线程数量小于 <code>maximumPoolSize</code>，则创建新的非核心线程执行任务</li></ul></li><li>拒绝策略<ul><li>如果任务队列已满且线程数量已达到 <code>maximumPoolSize</code>，则执行拒绝策略</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里没加锁，所以ctl才会使用原子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();     <span class="comment">//如果任务为null，返回空指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();      <span class="comment">//获取ctl的值，读取信息</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;   <span class="comment">//判断工作线程数量是否小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))    <span class="comment">//直接加新的线程执行</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();    <span class="comment">//如果线程添加失败（有可能其他线程也在对线程池进行操作），就更新c的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;   <span class="comment">//继续判断，如果当前线程池是运行状态，那就尝试向阻塞队列中添加一个新的等待任务</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();   <span class="comment">//再次获取ctl的值</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))   <span class="comment">//这里是再次确认当前线程池是否关闭，如果添加等待任务后线程池关闭了，那就把刚刚加进去任务的又拿出来</span></span><br><span class="line">            reject(command);   <span class="comment">//然后直接拒绝当前任务的提交（会根据拒绝策略决定如何进行拒绝操作）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)   <span class="comment">//如果这个时候线程池依然在运行状态，那么就检查一下当前工作线程数是否为0，如果是那就直接添加新线程执行</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);   <span class="comment">//添加一个新的非核心线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))   <span class="comment">//这种情况要么就是线程池没有运行，要么就是队列满了，按照我们之前的规则，核心线程数已满且队列已满，那么会直接添加新的非核心线程，但是如果已经添加到最大数量，这里肯定会失败</span></span><br><span class="line">        reject(command);   <span class="comment">//确实装不下了，只能拒绝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><p><code>addWorker</code>方法用于创建新线程并执行任务。主要逻辑：</p><ol><li>线程数量检查<ul><li>如果线程数量已达到上限，则返回false</li></ul></li><li>创建线程<ul><li>创建新线程，并将其封装为Worker对象</li></ul></li><li>启动线程<ul><li>启动线程，开始执行任务</li></ul></li><li>线程池状态检查<ul><li>如果线程池状态不是<code>RUNNING</code>，则回滚线程的创建</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">  <span class="comment">//给最外层循环打了个标签，方便跳转操作</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//无限循环，全程没加锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();     <span class="comment">//获取ctl值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);    <span class="comment">//解析当前的运行状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;   <span class="comment">//判断线程池是否不是处于运行状态</span></span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;   <span class="comment">//如果不是运行状态，判断线程是SHUTDOWN状态并、任务不为null、等待队列不为空，只要有其中一者不满足，直接返回false，添加失败</span></span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;   </span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;   <span class="comment">//内层循环是为了将线程计数增加，然后才可以真正地添加一个新的线程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);    <span class="comment">//解析当前的工作线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))    <span class="comment">//判断一下还装得下不，如果装得下，看看是核心线程还是非核心线程，如果是核心线程，不能大于核心线程数的限制，如果是非核心线程，不能大于最大线程数限制</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))    <span class="comment">//CAS自增线程计数，如果增加成功，任务完成，直接跳出继续</span></span><br><span class="line">                <span class="keyword">break</span> retry;    <span class="comment">//注意这里要直接跳出最外层循环，所以用到了标签（类似于goto语句）</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// 如果CAS失败，更新一下c的值</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)    <span class="comment">//如果CAS失败的原因是因为线程池状态和一开始的不一样了，那么就重新从外层循环再来一次</span></span><br><span class="line">                <span class="keyword">continue</span> retry;    <span class="comment">//注意这里要直接从最外层循环继续，所以用到了标签（类似于goto语句）</span></span><br><span class="line">            <span class="comment">// 如果是其他原因导致的CAS失败，那只可能是其他线程同时在自增，所以重新再来一次内层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加新的工作线程了</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;   <span class="comment">//工作线程是否已启动</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="comment">//工作线程是否已添加</span></span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;     <span class="comment">//工作线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);     <span class="comment">//创建新的工作线程，传入提交的任务</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;    <span class="comment">//拿到工作线程中封装的Thread对象</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;      <span class="comment">//如果线程不为null，安排任务</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;      <span class="comment">//ReentrantLock加锁，只有一个线程能进入</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());    <span class="comment">//获取当前线程的运行状态</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;    <span class="comment">//只有当前线程池是正在运行状态，或是SHUTDOWN状态且firstTask为空，那么就继续</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 检查一下线程是否正在运行状态</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();   <span class="comment">//如果是就抛出异常</span></span><br><span class="line">                    workers.add(w);    <span class="comment">//直接将新创建的Work丢进workers集合中</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)   <span class="comment">//记录线程池运行以来，历史上的最多线程数</span></span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;   <span class="comment">//工作线程已添加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();   <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();   <span class="comment">//启动线程</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;  <span class="comment">//工作线程已启动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)    <span class="comment">//如果线程在上面的启动过程中失败了</span></span><br><span class="line">            addWorkerFailed(w);    <span class="comment">//将w移出workers并将计数器-1，最后如果线程池是终止状态，会尝试加速终止线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;   <span class="comment">//返回是否成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h3><p>继承自<code>AbstractQueuedSynchronizer</code>，也就是说，它本身就是一把锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//用来干活的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">//要执行的第一个任务，构造时就确定好了</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">//干活数量计数器，也就是这个线程完成了多少个任务</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// 执行Task之前不让中断，将AQS的state设定为-1</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);   <span class="comment">//通过预定义或是我们自定义的线程工厂创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);   <span class="comment">//真正开始干活，包括当前活干完了又要等新的活来</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//0就是没加锁，1就是已加锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><p><code>unWorker</code> 方法是线程执行任务的核心逻辑：</p><ol><li>任务执行<ul><li>从任务队列中获取任务并执行</li></ul></li><li>线程中断处理<ul><li>如果线程被中断，则退出执行</li></ul></li><li>任务完成处理<ul><li>任务执行完成后，更新线程池状态</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();   <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;    <span class="comment">//取出要执行的任务</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;   <span class="comment">//然后把Worker中的任务设定为null</span></span><br><span class="line">    w.unlock(); <span class="comment">// 因为一开始为-1，这里是通过unlock操作将其修改回0，只有state大于等于0才能响应中断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//只要任务不为null，或是任务为空但是可以从等待队列中取出任务不为空，那么就开始执行这个任务，注意这里是无限循环，也就是说如果当前没有任务了，那么会在getTask方法中卡住，因为要从阻塞队列中等着取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();    <span class="comment">//对当前Worker加锁，在shutdown时保护此任务的运行</span></span><br><span class="line">            </span><br><span class="line">          <span class="comment">//由于线程池在STOP状态及以上会禁止新线程加入并且中断正在进行的线程</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||   <span class="comment">//线程池是STOP及以上的状态，不能开始新任务</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp;       <span class="comment">//线程是否已经被打上中断标记并且线程一定是STOP及以上</span></span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())   <span class="comment">//再次确保线程被没有打上中断标记</span></span><br><span class="line">                wt.interrupt();     <span class="comment">//打中断标记</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);  <span class="comment">//开始之前的准备工作</span></span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();    <span class="comment">//开始执行任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);    <span class="comment">//执行之后的工作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;    <span class="comment">//任务已完成</span></span><br><span class="line">                w.completedTasks++;   <span class="comment">//任务完成数++</span></span><br><span class="line">                w.unlock();    <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//如果能走到这一步，那说明上面的循环肯定是跳出了，也就是说这个Worker可以丢弃了</span></span><br><span class="line">      <span class="comment">//所以这里会直接将Worker从workers里删除掉</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><p><code>getTask</code>方法用于从任务队列中获取任务：</p><ol><li>线程池状态检查<ul><li>如果线程池状态不是<code>RUNNING</code>，则返回<code>null</code></li></ul></li><li>任务队列检查<ul><li>从任务队列中获取任务</li></ul></li><li>线程超时处理<ul><li>如果线程空闲时间超过<code>keepAliveTime</code>，则返回<code>null</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//无限循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();   <span class="comment">//获取ctl </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);      <span class="comment">//解析线程池运行状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;      <span class="comment">//判断是不是没有必要再执行等待队列中的任务了，也就是处于关闭线程池的状态了</span></span><br><span class="line">            decrementWorkerCount();     <span class="comment">//直接减少一个工作线程数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;    <span class="comment">//返回null，runWorker直接结束</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);   <span class="comment">//如果线程池运行正常，那就获取当前的工作线程数量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;   <span class="comment">//如果线程数大于核心线程数或是允许核心线程等待超时，那么就标记为可超时的</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//超时或maximumPoolSize在运行期间被修改了，并且线程数大于1或等待队列为空，那也是不能获取到任务的</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))   <span class="comment">//如果CAS减少工作线程成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;    <span class="comment">//返回null</span></span><br><span class="line">            <span class="keyword">continue</span>;   <span class="comment">//否则开下一轮循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :   <span class="comment">//如果可超时，那么最多等到超时时间</span></span><br><span class="line">                workQueue.take();    <span class="comment">//如果不可超时，那就一直等着拿任务</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)    <span class="comment">//成功拿到任务就返回</span></span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;   <span class="comment">//否则就是超时了，下一轮循环将直接返回null</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shutdown和shutdownNow方法"><a href="#shutdown和shutdownNow方法" class="headerlink" title="shutdown和shutdownNow方法"></a>shutdown和shutdownNow方法</h3><p>shutdown会继续将等待队列中的线程执行完成后再关闭线程池:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//判断是否有权限终止</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      <span class="comment">//CAS将线程池运行状态改为SHUTDOWN状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">       <span class="comment">//让闲着的线程（比如正在等新的任务）中断，但是并不会影响正在运行的线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">//给ScheduledThreadPoolExecutor提供的钩子方法，就是等ScheduledThreadPoolExecutor去实现的，当前类没有实现</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();   <span class="comment">//最后尝试终止线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shutdownNow开始后，不仅不允许新的任务到来，也不会再执行等待队列的线程，而且会终止正在执行的线程:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      <span class="comment">//直接设定为STOP状态了</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">      <span class="comment">//中断所有工作线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">      <span class="comment">//取出仍处于阻塞队列中的线程</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;   <span class="comment">//最后返回还没开始的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h3><p><code>tryTerminate</code>方法用于尝试终止线程池：</p><ol><li>线程池状态检查<ul><li>如果线程池状态不是<code>SHUTDOWN</code>或<code>STOP</code>，则返回</li></ul></li><li>线程数量检查<ul><li>如果线程数量不为 0，则中断空闲线程</li></ul></li><li>状态转换<ul><li>如果线程池状态为 <code>TIDYING</code>，则调用 <code>terminated()</code> 方法，将状态转换为 <code>TERMINATED</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;     <span class="comment">//无限循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();    <span class="comment">//上来先获取一下ctl值</span></span><br><span class="line">      <span class="comment">//只要是正在运行 或 线程池基本关闭 或 处于SHUTDOWN状态且工作队列不为空，还不能关闭线程池，返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//处于SHUTDOWN状态且等待队列为空 或 STOP状态</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// 如果工作线程数不是0，中断空闲状态下的线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);   <span class="comment">//最多只中断一个空闲线程，然后返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//终止线程池</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;   <span class="comment">//先CAS将状态设定为TIDYING表示基本终止</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();   <span class="comment">//终止</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));   <span class="comment">//将状态设定为TERMINATED</span></span><br><span class="line">                    <span class="comment">//如果有线程调用了awaitTermination方法，会等待当前线程池终止，这里就可以唤醒那些等待线程池终止的线程</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//注意如果CAS失败会直接进下一轮循环重新判断</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC并发容器与并发工具</title>
      <link href="/inori/db6966ce.html"/>
      <url>/inori/db6966ce.html</url>
      
        <content type="html"><![CDATA[<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>在单线程模式下，集合类提供的容器可以说是非常方便了，比如链表、顺序表、哈希表等数据结构，但是这些容器在多线程环境下，并不能正常工作。要解决并发情况下的容器问题，可以给方法前面加个synchronzed，或者使用Vector或是Hashtable，但是它们的效率实在是太低了，完全依靠锁来解决问题。</p><p>JUC提供了专用于并发场景下的容器，比如可以代替<code>ArrayList</code>的<code>CopyOnWriteArrayList</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();  <span class="comment">//使用CopyOnWriteArrayList保证线程安全</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CopyOnWriteArrayList</code>对于读操作不加锁，而对于写操作是加锁的，类似于读写锁机制，这样就可以保证不丢失读性能的情况下，写操作不会出现问题:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();   <span class="comment">//直接加锁，保证同一时间只有一个线程进行添加操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();  <span class="comment">//获取当前存储元素的数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);   <span class="comment">//直接复制一份数组</span></span><br><span class="line">        newElements[len] = e;   <span class="comment">//修改复制出来的数组</span></span><br><span class="line">        setArray(newElements);   <span class="comment">//将元素数组设定为复制出来的数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于HashMap的并发容器<code>ConcurrentHashMap</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">                map.put(tmp * <span class="number">100</span> + j, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK7之前，<code>ConcurrentHashMap</code>的原理类似于LongAdder的压力分散思想，既然每个线程都想抢锁，那就多搞几把锁，让每个线程都能拿到，就不会存在等待的问题了，<code>ConcurrentHashMap</code>将所有数据分为一段一段地存储，先分很多段出来，每一段都给一把锁，当一个线程占锁访问时，只会占用其中一把锁，也就是仅仅锁了一小段数据，而其他段的数据依然可以被其他线程正常访问。</p><p>JDK8之后，<code>ConcurrentHashMap</code>采用了CAS算法配合锁机制实现，其底层与<code>HashMap</code>大差不差，<code>HashMap</code>利用了一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度提高</p><p><img src="/inori/db6966ce/hashmap.png"></p><p><code>ConcurrentHashMap</code>也是维护了一个哈希表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());    <span class="comment">//计算键的hash值，用于确定在哈希表中的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//记录链表长度</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">//CAS自旋锁</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();    <span class="comment">//如果数组（哈希表）为空要进行初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;   <span class="comment">//如果哈希表该位置为null，直接CAS插入结点作为头结即可（注意这里会将f设置当前哈希表位置上的头结点）</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))  </span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// 如果CAS成功，直接break结束put方法，失败那就继续下一轮循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)   <span class="comment">//头结点哈希值为-1，这里只需要知道是因为正在扩容即可</span></span><br><span class="line">            tab = helpTransfer(tab, f);   <span class="comment">//帮助进行迁移，完事之后再来下一次循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;     <span class="comment">//正常情况</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;   <span class="comment">//在前面的循环中f肯定是被设定为了哈希表某个位置上的头结点，这里直接把它作为锁加锁了，防止同一时间其他线程也在操作哈希表中这个位置上的链表或是红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;    <span class="comment">//头结点的哈希值大于等于0说明是链表，下面就是针对链表的一些列操作</span></span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;   <span class="comment">//针对红黑树的情况进行操作</span></span><br><span class="line">                      <span class="comment">//在ConcurrentHashMap并不是直接存储的TreeNode，而是TreeBin</span></span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//根据链表长度决定是否要进化为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);   <span class="comment">//这里只是可能会进化为红黑树，如果当前哈希表的长度小于64，会优先考虑对哈希表进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcurrentHashMap</code>的put操作，实际上是对哈希表上的所有头结点元素分别加锁，理论上来说哈希表的长度很大程度上决定了<code>ConcurrentHashMap</code>在同一时间能够处理的线程数量，这也是为什么<code>treeifyBin()</code>会优先考虑为哈希表进行扩容的原因</p><p><img src="/inori/db6966ce/concurrentHashMap.png"></p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>除了常用的容器类之外，JUC还提供了各种各样的阻塞队列，用于不同的工作场景。</p><p>阻塞队列本身也是队列，基于ReentrantLock实现，它的接口定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，返回false否则返回true（非阻塞）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，阻塞线程直到能入队为止</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，阻塞线程直到能入队或超时、中断为止，入队成功返回true否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，如果队列为空，阻塞线程直到能出队为止</span></span><br><span class="line">    E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，如果队列为空，阻塞线程直到能出队超时、中断为止，出队成功正常返回，否则返回null</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此队列理想情况下（在没有内存或资源限制的情况下）可以不阻塞地入队的数量，如果没有限制，则返回 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">remainingCapacity</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一次性从BlockingQueue中获取所有可用的数据对象（还可以指定获取数据的个数）</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c, <span class="type">int</span> maxElements)</span>;</span><br></pre></td></tr></table></figure><p>比如现在有一个容量为3的阻塞队列，这个时候一个线程<code>put</code>向其添加了三个元素，第二个线程接着<code>put</code>向其添加三个元素，那么这个时候由于容量已满，会直接被阻塞，而这时第三个线程从队列中取走2个元素，线程二停止阻塞，先丢两个进去，还有一个还是进不去，所以说继续阻塞。</p><p>可以理解为：当队列为空时，获取元素的操作会被阻塞；当队列已满时，添加元素的操作会被阻塞</p><h3 id="常用的实现类"><a href="#常用的实现类" class="headerlink" title="常用的实现类"></a>常用的实现类</h3><ol><li><code>ArrayBlockingQueue</code></li></ol><ul><li>基于数组实现的有界阻塞队列</li><li>初始化时需要指定队列容量:<code>BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(10)</code></li><li>支持公平锁和非公平锁</li></ul><ol start="2"><li><code>LinkedBlockingQueue</code></li></ol><ul><li>基于链表实现的可选有界阻塞队列</li><li>默认容量为<code>Integer.MAX_VALUE</code>，可以指定容量:<code>BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;(10)</code></li><li>吞吐量通常高于 <code>ArrayBlockingQueue</code></li></ul><ol start="3"><li><code>PriorityBlockingQueue</code></li></ol><ul><li>基于堆实现的优先级阻塞队列</li><li>元素按优先级排序，默认自然顺序或通过 <code>Comparator</code> 指定</li><li>无界队列，容量为<code>Integer.MAX_VALUE</code>:<code>PriorityBlockingQueue&lt;Integer&gt; queue = new PriorityBlockingQueue&lt;&gt;()</code></li></ul><ol start="4"><li><code>DelayQueue</code></li></ol><ul><li>基于优先级队列实现的延迟队列</li><li>元素必须实现 <code>Delayed</code> 接口，只有在延迟时间到达后才能被取出</li><li>无界队列:<code>DelayQueue&lt;DelayedTask&gt; queue = new DelayQueue&lt;&gt;()</code></li></ul><ol start="5"><li><code>SynchronousQueue</code></li></ol><ul><li>一种不存储元素的阻塞队列:<code>SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;&gt;()</code></li><li>每个插入操作必须等待另一个线程的移除操作，反之亦然</li><li>适用于线程之间的直接传递数据</li></ul><table><thead><tr><th><strong>阻塞队列</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong><code>ArrayBlockingQueue</code></strong></td><td>基于数组的有界队列，支持公平锁和非公平锁。</td><td>固定大小的队列，生产者-消费者模型。</td></tr><tr><td><strong><code>LinkedBlockingQueue</code></strong></td><td>基于链表的可选有界队列，默认无界，高吞吐量。</td><td>高吞吐量队列，生产者-消费者模型。</td></tr><tr><td><strong><code>PriorityBlockingQueue</code></strong></td><td>基于堆的优先级队列，无界。</td><td>按优先级处理任务，任务调度。</td></tr><tr><td><strong><code>DelayQueue</code></strong></td><td>延迟队列，元素必须实现 <code>Delayed</code> 接口。</td><td>延迟任务调度，缓存过期策略。</td></tr><tr><td><strong><code>SynchronousQueue</code></strong></td><td>不存储元素，直接传递数据。</td><td>线程间直接数据传递，高并发任务分发。</td></tr></tbody></table><h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="计数器锁-CountDownLatch"><a href="#计数器锁-CountDownLatch" class="headerlink" title="计数器锁 CountDownLatch"></a>计数器锁 CountDownLatch</h2><p>CountDownLatch允许一个或多个线程，等待其他线程完成工作。</p><p>比如有这样一个需求：</p><ul><li>有20个计算任务，需要将这些任务的结果全部计算出来后再汇总，每个任务的执行时间未知</li><li>当所有任务结束之后，立即整合统计最终结果</li></ul><p>使用CountDownLatch可以轻松实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">20</span>);  <span class="comment">//创建一个初始值为20的计数器锁</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (<span class="number">2000</span> * <span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble()));<span class="comment">//模拟任务执行耗时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();   <span class="comment">//每执行一次计数器都会-1</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始等待所有的线程完成，当计数器为0时，恢复运行</span></span><br><span class="line">    latch.await();   <span class="comment">//这个操作可以同时被多个线程执行，一起等待，这里只演示了一个</span></span><br><span class="line">    System.out.println(<span class="string">&quot;任务完成&quot;</span>);</span><br><span class="line">  <span class="comment">//注意这个计数器只能使用一次，用完只能重新创一个，没有重置的说法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在调用<code>await()</code>方法之后，实际上就是一个等待计数器衰减为0的过程，而进行自减操作则由各个子线程来完成，当子线程完成工作后，那么就将计数器-1，所有的子线程完成之后，计数器为0，结束等待</p><p>CountDownLatch的基本实现思路：</p><ul><li>利用共享锁实现，同一时刻能有多个线程拥有共享锁，如果一个线程刚获取了共享锁，那么在其之后等待的线程也很有可能能够获取到锁，所以得传播下去继续尝试唤醒后面的结点，并且如果一个线程刚释放了锁，不管是独占锁还是共享锁，都需要唤醒后续等待结点的线程</li><li>在一开始的时候就是已经上了count层锁的状态，也就是<code>state = count</code></li><li><code>await()</code>就是加共享锁，但是必须<code>state</code>为<code>0</code>才能加锁成功，否则按照AQS的机制，会进入等待队列阻塞，加锁成功后结束阻塞</li><li><code>countDown()</code>就是解<code>1</code>层锁，靠这个方法一点一点把<code>state</code>的值减到<code>0</code></li></ul><h2 id="循环屏障-CyclicBarrier"><a href="#循环屏障-CyclicBarrier" class="headerlink" title="循环屏障 CyclicBarrier"></a>循环屏障 CyclicBarrier</h2><p>CyclicBarrier用于让一组线程互相等待，直到所有线程都到达某个屏障点。它的底层实现基于 <code>ReentrantLock</code> 和 <code>Condition</code>，通过计数器机制和条件变量实现线程的等待和唤醒。</p><p>比如需要玩一个开房间游戏，不满足人数不能进，必须等待剩下的人到来之后才能开始游戏，并且保证游戏开始时所有玩家都是同时进入，就可以使用CyclicBarrier：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>,   <span class="comment">//创建一个初始值为10的循环屏障</span></span><br><span class="line">                () -&gt; System.out.println(<span class="string">&quot;准备开始&quot;</span>));   <span class="comment">//人等够之后执行的任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (<span class="number">2000</span> * <span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble()));</span><br><span class="line">                System.out.println(<span class="string">&quot;玩家 &quot;</span>+ finalI +<span class="string">&quot; 进入房间进行等待... (&quot;</span>+barrier.getNumberWaiting()+<span class="string">&quot;/10)&quot;</span>);</span><br><span class="line"></span><br><span class="line">                barrier.await();    <span class="comment">//调用await方法进行等待，直到等待的线程足够多为止</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//所有玩家一起进入</span></span><br><span class="line">                System.out.println(<span class="string">&quot;玩家 &quot;</span>+ finalI +<span class="string">&quot; 进入游戏！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环屏障会不断阻挡线程，直到被阻挡的线程足够多时，才能一起通过，并且屏障是可循环的，它在被冲破后，会重新开始计数，继续阻挡后续的线程，直到再次满足预定的线程数量。</p><p>除了自动重置之外，也可以调用<code>reset()</code>方法来手动进行重置操作，同样会重新计数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);   <span class="comment">//等上面的线程开始运行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前屏障前的等待线程数：&quot;</span>+barrier.getNumberWaiting());</span><br><span class="line"></span><br><span class="line">    barrier.reset();</span><br><span class="line">    System.out.println(<span class="string">&quot;重置后屏障前的等待线程数：&quot;</span>+barrier.getNumberWaiting());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用<code>reset()</code>之后，处于等待状态下的线程，全部被中断并且抛出<code>BrokenBarrierException</code>异常，循环屏障等待线程数归零。</p><h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>信号量可以决定某个资源同一时间能够被访问的最大线程数，它相当于对某个资源的访问进行了流量控制。简单来说，它就是一个可以被N个线程占用的排它锁（支持公平和非公平模式，默认是非公平模式），使用时可以在最开始设定Semaphore许可证的数量，每个线程都可以获得1个或n个许可证，当许可证耗尽或不足以供其他线程获取时，其他线程将被阻塞。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">//每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);   <span class="comment">//许可证配额设定为2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;<span class="comment">// 有3个线程抢这2个信号量</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();   <span class="comment">//申请一个许可证，默认申请1个，acquire(n)则表示申请n个</span></span><br><span class="line">                System.out.println(<span class="string">&quot;许可证申请成功！&quot;</span>);</span><br><span class="line">                semaphore.release();   <span class="comment">//归还一个许可证</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过Semaphore获取一些常规信息：</p><ul><li><code>availablePermits</code>：剩余许可证数量</li><li><code>hasQueuedThreads</code>：是否存在线程等待许可证</li><li><code>getQueueLength</code>：等待许可证线程数量</li><li><code>drainPermits</code>：回收全部许可证</li></ul><p>Semaphore可以控制对共享资源的并发访问数量，避免资源过载。可以管理数据库连接池、线程池等资源，确保资源的使用不超过限制。可以控制并发任务的数量，避免系统资源耗尽等。</p><h2 id="数据交换-Exchanger"><a href="#数据交换-Exchanger" class="headerlink" title="数据交换 Exchanger"></a>数据交换 Exchanger</h2><p>Exchanger底层实现基于CAS和等待队列，能够实现线程之间的数据交换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到主线程传递的交换数据：&quot;</span>+exchanger.exchange(<span class="string">&quot;AAAA&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    System.out.println(<span class="string">&quot;收到子线程传递的交换数据：&quot;</span>+exchanger.exchange(<span class="string">&quot;BBBB&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Exchanger</code>可以被重复使用，每次交换数据后，可以继续使用</p><p>在调用<code>exchange</code>方法后，当前线程会等待其他线程调用同一个exchanger对象的<code>exchange</code>方法，当另一个线程也调用之后，方法会返回对方线程传入的参数。如果一直没有另一个线程调用<code>exchanger</code>方法，当前线程会进入阻塞状态。</p><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h2><p>在JDK7时，出现了一个新的框架用于并行执行任务，它能够把大型任务拆分为多个小任务，最后汇总多个小任务的结果，得到整大任务的结果，并且这些小任务都是并行执行的。Fork就是拆分，Join就是合并。它通过工作窃取（Work-Stealing）算法利用多核CPU资源。</p><blockquote><p>工作窃取算法：是指某个线程从其他队列里窃取任务来执行。一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p></blockquote><p>Fork&#x2F;Join框架的核心类包括：</p><ol><li><code>ForkJoinPool</code>：任务执行的线程池，负责管理线程和任务队列</li><li><code>ForkJoinTask</code>：表示一个任务，通常使用其子类：<ul><li><code>RecursiveAction</code>：用于没有返回值的任务</li><li><code>RecursiveTask</code>：用于有返回值的任务</li></ul></li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>任务拆分：将一个大任务拆分为多个小任务，直到任务足够小，可以直接执行</li><li>任务执行：将小任务提交到 <code>ForkJoinPool</code> 中执行</li><li>结果合并：将小任务的执行结果合并，得到最终结果</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>计算数组中1~1000的总和：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinSumExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task); <span class="comment">// 提交任务并获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组元素和: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<span class="comment">//继承RecursiveTask，这样才可以作为一个任务，泛型就是计算结果类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> start;<span class="comment">// 限定范围</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">125</span>; <span class="comment">// 任务拆分的阈值，拆分成8组</span></span><br><span class="line"></span><br><span class="line">    SumTask(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小，直接计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 任务较大，拆分为两个子任务，类似于递归</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, start, mid);</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, mid, end);</span><br><span class="line">            leftTask.fork(); <span class="comment">// 将leftTask提交到ForkJoinPool中，由其他线程异步执行，如果范围仍然较大会继续拆分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.compute(); <span class="comment">// 在当前线程中执行右子任务，如果范围仍然较大会继续拆分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join(); <span class="comment">// 获取左子任务的结果</span></span><br><span class="line">            <span class="keyword">return</span> leftResult + rightResult; <span class="comment">// 合并结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Arrays工具类提供的并行排序也是利用了ForkJoinPool来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parallelSort</span><span class="params">(<span class="type">byte</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArraysParallelSortHelpers</span>.FJByte.Sorter</span><br><span class="line">            (<span class="literal">null</span>, a, <span class="keyword">new</span> <span class="title class_">byte</span>[n], <span class="number">0</span>, n, <span class="number">0</span>,</span><br><span class="line">             ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">             MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC锁类和原子类</title>
      <link href="/inori/4fdd9583.html"/>
      <url>/inori/4fdd9583.html</url>
      
        <content type="html"><![CDATA[<h1 id="锁类"><a href="#锁类" class="headerlink" title="锁类"></a>锁类</h1><p>在JDK 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，Lock接口提供了与synchronized关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。</p><h2 id="Lock和Condition接口"><a href="#Lock和Condition接口" class="headerlink" title="Lock和Condition接口"></a>Lock和Condition接口</h2><p>使用并发包中的锁和synchronized锁不太一样，这里的锁可以认为是一把真正意义上的锁，每个锁都是一个对应的锁对象，只需要向锁对象获取锁或是释放锁即可。Lock接口定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">  <span class="comment">//获取锁，拿不到锁会阻塞，等待其他线程释放锁，获取到锁后返回</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//同上，但是等待过程中会响应中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//尝试获取锁，但是不会阻塞，如果能获取到会返回true，不能返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//尝试获取锁，但是可以限定超时时间，如果超出时间还没拿到锁返回false，否则返回true，可以响应中断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//释放锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//暂时可以理解为替代传统的Object的wait()、notify()等操作的工具</span></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lock类来进行加锁和释放锁操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">testLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();   <span class="comment">//可重入锁ReentrantLock类是Lock类的一个实现</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">action</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;   <span class="comment">//自增</span></span><br><span class="line">                testLock.lock();    <span class="comment">//加锁，加锁成功后其他线程如果也要获取锁，会阻塞，等待当前线程释放</span></span><br><span class="line">                i++;</span><br><span class="line">                testLock.unlock();  <span class="comment">//解锁，释放锁之后其他线程就可以获取这把锁了（在这之前一定得加锁，不然报错）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(action).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(action).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);   <span class="comment">//等两个线程跑完</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前使用<code>synchronized</code>相比，我们这里是真正在操作一个”锁”对象，当我们需要加锁时，只需要调用<code>lock()</code>方法，而需要释放锁时，只需要调用<code>unlock()</code>方法。程序运行的最终结果和使用<code>synchronized</code>锁是一样的</p><p>如何像传统的加锁那样，调用对象的<code>wait()</code>和<code>notify()</code>方法呢，juc提供了Condition接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">  <span class="comment">//与调用锁对象的wait方法一样，会进入到等待状态，但是这里需要调用Condition的signal或signalAll方法进行唤醒（和普通对象的wait和notify类似）同时，等待状态下是可以响应中断的</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//同上，但不响应中断</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//等待指定时间，如果在指定时间（纳秒）内被唤醒，会返回剩余时间，如果超时，会返回0或负数，可以响应中断</span></span><br><span class="line">  <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//等待指定时间（可以指定时间单位），如果等待时间内被唤醒，返回true，否则返回false，可以响应中断</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//可以指定一个明确的时间点，如果在时间点之前被唤醒，返回true，否则返回false，可以响应中断</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//唤醒一个处于等待状态的线程，注意还得获得锁才能接着运行</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//唤醒所有等待线程</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">testLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> testLock.newCondition();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        testLock.lock();   <span class="comment">//必须持有锁的情况下才能使用await</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程1进入等待状态！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();   <span class="comment">//进入等待状态</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1等待结束！&quot;</span>);</span><br><span class="line">        testLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>); <span class="comment">//让线程1先运行</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        testLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2开始唤醒其他等待线程&quot;</span>);</span><br><span class="line">        condition.signal();   <span class="comment">//唤醒线程1，但是此时线程1还必须要拿到锁才能继续运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程2结束&quot;</span>);</span><br><span class="line">        testLock.unlock();   <span class="comment">//这里释放锁之后，线程1就可以拿到锁继续运行了</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>前面用到了<code>ReentrantLock</code>，它其实是锁的一种，叫做可重入锁，即同一个线程，可以反复进行加锁操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();   <span class="comment">//连续加锁2次</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2想要获取锁&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2成功获取到锁&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1释放了一次锁&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1再次释放了一次锁&quot;</span>);  <span class="comment">//释放两次后其他线程才能加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程连续进行了两次加锁操作（此操作是不会被阻塞的），在当前线程持有锁的情况下继续加锁不会被阻塞，并且，加锁几次，就必须要解锁几次，否则此线程依旧持有锁。</p><ul><li><p>可以使用<code>getHoldCount()</code>方法查看当前线程的加锁次数，当锁不再被任何线程持有时，值为<code>0</code>，并且通过<code>isLocked()</code>方法查询结果为<code>false</code></p></li><li><p>如果存在线程持有当前的锁，那么其他线程在获取锁时，会暂时进入到等待队列的，可以通过<code>getQueueLength()</code>方法获取等待中线程数量的预估值</p></li><li><p>可以通过<code>hasQueuedThread(Thread thread)</code>方法来判断某个线程是否正在等待获取锁状态</p></li><li><p>Condition也可以进行判断，通过使用<code>getWaitQueueLength()</code>方法能够查看同一个Condition目前有多少线程处于等待状态：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前Condition的等待线程数：&quot;</span>+lock.getWaitQueueLength(condition));</span><br><span class="line">    condition.signal();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前Condition的等待线程数：&quot;</span>+lock.getWaitQueueLength(condition));</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>如果线程之间争抢同一把锁，会暂时进入到等待队列中，那么多个线程获得锁的顺序是不是一定是根据线程调用<code>lock()</code>方法时间来定的？</p><p>锁分为公平锁和非公平锁，默认我们创建出来的<code>ReentrantLock</code>是采用的非公平锁作为底层锁机制。</p><ul><li>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li><li>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li></ul><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>除了可重入锁之外，还有一种类型的锁叫做读写锁，当然它并不是专门用作读写操作的锁，它和可重入锁不同的地方在于，可重入锁是一种排他锁，当一个线程得到锁之后，另一个线程必须等待其释放锁，否则一律不允许获取到锁。而读写锁在同一时间，是可以让多个线程获取到锁的，它其实就是针对于读写场景而出现的。读写锁维护了一个读锁和一个写锁：</p><ul><li>读锁：在没有任何线程占用写锁的情况下，同一时间可以有多个线程加读锁。</li><li>写锁：在没有任何线程占用读锁的情况下，同一时间只能有一个线程加写锁。</li></ul><p>读写锁也有一个专门的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    <span class="comment">//获取读锁</span></span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取写锁</span></span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口有一个实现类ReentrantReadWriteLock（实现的是ReadWriteLock接口，不是Lock接口，它本身并不是锁），注意我们操作ReentrantReadWriteLock时，不能直接上锁，而是需要获取读锁或是写锁，再进行锁操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(lock.readLock()::lock).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock不仅具有读写锁的功能，还保留了可重入锁和公平&#x2F;非公平机制，比如同一个线程可以重复为写锁加锁，并且必须全部解锁才真正释放锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功获取到写锁！&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    System.out.println(<span class="string">&quot;释放第一层锁！&quot;</span>);</span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;释放第二层锁！&quot;</span>);</span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁降级和锁升级"><a href="#锁降级和锁升级" class="headerlink" title="锁降级和锁升级"></a>锁降级和锁升级</h3><p>锁降级指的是写锁降级为读锁。当一个线程持有写锁的情况下，虽然其他线程不能加读锁，但是线程自己是可以加读锁的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;成功加读锁！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在同时加了写锁和读锁的情况下，释放写锁，其他的线程就可以一起加读锁，这种操作可以称之为”锁降级”（持有写锁的情况下申请读锁再释放写锁）</p><p>在仅持有读锁的情况下去申请写锁，属于”锁升级”，ReentrantReadWriteLock是<strong>不支持</strong>的</p><h2 id="队列同步器AbstractQueuedSynchronizer-AQS"><a href="#队列同步器AbstractQueuedSynchronizer-AQS" class="headerlink" title="队列同步器AbstractQueuedSynchronizer(AQS)"></a>队列同步器AbstractQueuedSynchronizer(AQS)</h2><p>AQS是实现锁机制的基础，它的内部封装了包括锁的获取、释放、以及等待队列</p><p>一个锁的基本功能就是获取锁、释放锁、当锁被占用时，其他线程来争抢会进入等待队列，AQS已经将这些基本的功能封装完成了，其中等待队列是核心内容，等待队列是由<strong>双向链表</strong>实现的，每个等待状态下的线程都可以被封装进结点中并放入双向链表中，而对于双向链表是以队列的形式进行操作的</p><p><img src="/inori/4fdd9583/clh.png" alt="clh"></p><p>AQS内部维护了两个关键变量：</p><ol><li>state（同步状态）</li></ol><ul><li>整数变量，表示资源的占用情况（例如：锁是否被占用，信号量剩余数量）</li><li>通过CAS操作进行更新，保证线程安全</li></ul><ol start="2"><li>FIFO等待队列（CLH队列）</li></ol><ul><li>线程获取资源失败时，会被加入等待队列，并阻塞</li><li>每个节点存储线程信息，便于后续唤醒</li></ul><p>AQS中有一个<code>head</code>字段和一个<code>tail</code>字段分别记录双向链表的头结点和尾结点，而之后的一系列操作都是围绕此队列来进行的。AQS的内部结构：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个处于等待状态的线程都可以是一个节点，并且每个节点有很多状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="comment">//每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待状态，这里都定义好了</span></span><br><span class="line">   <span class="comment">//唯一一个大于0的状态，表示已失效，可能是由于超时或中断，此节点被取消。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//此节点后面的节点被挂起（进入等待状态）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//在条件队列中的节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">  <span class="comment">//传播，一般用于共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;    <span class="comment">//等待状态值</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;   <span class="comment">//每一个线程都可以被封装进一个节点进入到等待队列</span></span><br><span class="line">  </span><br><span class="line">    Node nextWaiter;   <span class="comment">//在等待队列中表示模式，条件队列中作为下一个结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ol><li>获取锁（acquire）</li></ol><ul><li><p>尝试修改state（CAS操作），如果成功，直接获得锁</p></li><li><p>如果失败，则进入等待队列，并阻塞自己，等待前驱节点释放锁</p></li></ul><p>独占锁（ReentrantLock）acquire：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;<span class="comment">// arg表示资源数量，控制一次获取多个资源</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryAcquire(arg)</code>：尝试获取锁（由子类实现，如ReentrantLock）</li><li><code>addWaiter(Node.EXCLUSIVE)</code>：将当前线程加入等待队列</li><li><code>acquireQueued()</code>：阻塞当前线程，直到锁被释放</li></ul><ol start="2"><li>释放锁（release）</li></ol><ul><li>修改<code>state</code>变量，表示锁已释放</li><li>唤醒等待队列中的后继线程</li></ul><p>独占锁（ReentrantLock）release：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;<span class="comment">// arg表示资源数量，控制一次释放多个资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;  <span class="comment">// 尝试释放锁</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);  <span class="comment">// 唤醒后继线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryRelease(arg)</code>：释放锁（由子类实现）</li><li><code>unparkSuccessor(h)</code>：唤醒等待队列中的下一个线程</li></ul><p><img src="/inori/4fdd9583/aqs.png" alt="aqs"></p><h3 id="AQS的应用"><a href="#AQS的应用" class="headerlink" title="AQS的应用"></a>AQS的应用</h3><table><thead><tr><th>组件</th><th>模式</th><th>作用</th></tr></thead><tbody><tr><td><code>ReentrantLock</code></td><td>独占</td><td>可重入互斥锁</td></tr><tr><td><code>Semaphore</code></td><td>共享</td><td>控制并发访问数量</td></tr><tr><td><code>CountDownLatch</code></td><td>共享</td><td>线程同步（等待计数归零）</td></tr><tr><td><code>ReentrantReadWriteLock</code></td><td>共享&#x2F;独占</td><td>读写分离锁</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>基于AQS实现自定义独占锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; <span class="comment">// CAS 获取锁</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// AQS 提供的模板方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        release(<span class="number">1</span>); <span class="comment">// AQS 提供的模板方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程</p><ol><li>线程调用<code>lock()</code>，进入<code>acquire(1)</code></li><li>尝试<code>tryAcquire()</code>，如果 <code>state=0</code>，CAS设置为1</li><li>如果<code>tryAcquire()</code> 失败，则进入等待队列，阻塞等待唤醒</li><li>调用<code>unlock()</code> 时，执行 <code>release(1)</code>，并唤醒等待队列中的线程</li></ol><h3 id="公平锁的逻辑"><a href="#公平锁的逻辑" class="headerlink" title="公平锁的逻辑"></a>公平锁的逻辑</h3><p>在并发的情况下，公平锁一定公平吗？回顾一下<code>tryAcquire()</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;   <span class="comment">//公平锁的机制是，一开始会查看是否有节点处于等待</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;   <span class="comment">//如果前面的方法执行后发现没有等待节点，就直接进入占锁环节了</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>hasQueuedPredecessors()</code>这个环节对于公平锁的公平与否至关重要，否则会直接破坏掉公平性，假如现在出现了这样的情况：</p><p>线程1已经持有锁了，这时线程2来争抢这把锁，走到<code>hasQueuedPredecessors()</code>，判断出为<code>false</code>，线程2继续运行，然后线程2肯定获取锁失败（因为锁这时是被线程1占有的），因此就进入到等待队列中，而这个时候线程3也来抢锁了，按照正常流程走到了<code>hasQueuedPredecessors()</code>方法，因为线程2已经在等待队列中了，所以<code>head!=tail</code>，因此，线程3这时就紧接着准备开始CAS操作了，又碰巧，这时线程1释放锁了，现在的情况就是，线程3直接开始CAS判断，而线程2还在等待队列中，结果可想而知，居然是线程3先拿到了锁，这显然是违背了公平锁的公平机制。</p><p><img src="/inori/4fdd9583/fairLock_nonfair.png" alt="fairLock_nonfair"></p><p>所以公平锁，只有在等待队列存在节点时，才是真正公平的。</p><h3 id="Condition原理"><a href="#Condition原理" class="headerlink" title="Condition原理"></a>Condition原理</h3><p>Condition类实际上就是用于代替传统对象的wait&#x2F;notify操作的，同样可以实现等待&#x2F;通知模式，并且同一把锁下可以创建多个Condition对象。</p><p>在AQS中，Condition有一个实现类ConditionObject，也是使用了链表实现条件队列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** 条件队列的头结点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">/** 条件队列的尾结点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>这里是直接使用了AQS中的Node类，但是使用的是Node类中的nextWaiter字段连接节点，并且Node的status为CONDITION：</p><p><img src="/inori/4fdd9583/conditionHead.png" alt="conditionHead"></p><p>当一个线程调用<code>await()</code>方法时，会进入等待状态，直到其他线程调用<code>signal()</code>方法将其唤醒，而这里的条件队列，正是用于存储这些处于等待状态的线程。</p><p><code>await()</code>方法的目标：</p><ul><li>只有已经持有锁的线程才可以使用此方法</li><li>当调用此方法后，会直接释放锁，无论加了多少次锁</li><li>只有其他线程调用<code>signal()</code>或是被中断时才会唤醒等待中的线程</li><li>被唤醒后，需要等待其他线程释放锁，拿到锁之后才可以继续执行，并且会恢复到之前的状态（await之前加了几层锁唤醒后依然是几层锁）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();   <span class="comment">//如果在调用await之前就被添加了中断标记，那么会直接抛出中断异常</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();    <span class="comment">//为当前线程创建一个新的节点，并将其加入到条件队列中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);    <span class="comment">//完全释放当前线程持有的锁，并且保存一下state值，因为唤醒之后还得恢复</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//用于保存中断状态</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;   <span class="comment">//循环判断是否位于同步队列中，如果等待状态下的线程被其他线程唤醒，那么会正常进入到AQS的等待队列中</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);   <span class="comment">//如果依然处于等待状态，那么继续挂起</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)   <span class="comment">//看看等待的时候是不是被中断了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//出了循环之后，那线程肯定是已经醒了，这时就差拿到锁就可以恢复运行了</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="comment">//acquireQueued尝试拿锁</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();  <span class="comment">//将等待队列中，不是Node.CONDITION状态的节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)   <span class="comment">//依响应中断</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>signal()</code>方法的目标：</p><ul><li>只有持有锁的线程才能唤醒锁所属的Condition等待的线程</li><li>优先唤醒条件队列中的第一个，如果唤醒过程中出现问题，接着找往下找，直到找到一个可以唤醒的</li><li>唤醒操作本质上是将条件队列中的结点直接丢进AQS等待队列中，让其参与到锁的竞争中</li><li>拿到锁之后，线程才能恢复运行</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())    <span class="comment">//当前线程是不是持有锁的状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;    <span class="comment">//获取条件队列的第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)    <span class="comment">//如果队列不为空，获取到了，那么就可以开始唤醒操作</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)   <span class="comment">//如果当前节点在本轮循环没有后继节点了，条件队列就为空了</span></span><br><span class="line">            lastWaiter = <span class="literal">null</span>;   <span class="comment">//直接清空</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;   <span class="comment">//将给定节点的下一个结点设置为null，因为当前结点马上就会离开条件队列了</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);   <span class="comment">//能走到这里只能说明给定节点被设定为了取消状态，那就继续看下一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果这里CAS失败，那有可能此节点被设定为了取消状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CAS成功之后，结点的等待状态就变成了默认值0，接着通过enq方法直接将节点丢进AQS的等待队列中，相当于唤醒并且可以等待获取锁了</span></span><br><span class="line">  <span class="comment">//这里enq方法返回的是加入之后等待队列队尾的前驱节点，就是原来的tail</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;   <span class="comment">//保存前驱结点的等待状态</span></span><br><span class="line">  <span class="comment">//如果上一个节点的状态为取消, 或者尝试设置上一个节点的状态为SIGNAL失败（可能是在ws&gt;0判断完之后马上变成了取消状态，导致CAS失败）</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);  <span class="comment">//直接唤醒线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LockSupport.unpark(node.thread)</code>为什么要提前来一次unpark呢？</p><p>其实是为了进行优化而编写，直接unpark会有两种情况：</p><ul><li>如果插入结点前，AQS等待队列的队尾节点就已经被取消，则满足<code>wc &gt; 0</code></li><li>如果插入node后，AQS内部等待队列的队尾节点已经稳定，满足<code>tail.waitStatus == 0</code>，但在执行<code>ws &gt; 0</code>之后<code>!compareAndSetWaitStatus(p, ws,Node.SIGNAL)</code>之前被取消，则CAS也会失败，满足<code>compareAndSetWaitStatus(p, ws,Node.SIGNAL) == false</code></li></ul><p>如果这里被提前unpark，那么在<code>await()</code>方法中将可以被直接唤醒，并跳出while循环，直接开始争抢锁，因为前一个等待结点是被取消的状态，没有必要再等它了</p><p><img src="/inori/4fdd9583/await_signal.png" alt="await_signal"></p><h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>之前如果要保证某一个变量操作的原子性，那么我们的唯一选择就是加锁，现在除了加锁之外，JUC还为我们提供了原子类，底层采用CAS算法，它是一种用法简单、性能高效、线程安全地更新变量的方式。</p><p>所有的原子类都位于<code>java.util.concurrent.atomic</code>包下。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>常用基本数据类，有对应的原子类封装：</p><ul><li>AtomicInteger：原子更新int</li><li>AtomicLong：原子更新long</li><li>AtomicBoolean：原子更新boolean</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(i.getAndIncrement());  <span class="comment">//如果想实现i += 2这种操作，可以使用 addAndGet() 自由设置delta值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将int数值封装到此类中（注意必须调用构造方法，它不像Integer那样有装箱机制），并且通过调用此类提供的方法来获取或是对封装的int值进行自增：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++)</span><br><span class="line">                i.getAndIncrement();</span><br><span class="line">            System.out.println(<span class="string">&quot;自增完成！&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(i.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了基本类有原子类以外，基本类型的数组类型也有原子类：</p><ul><li>AtomicIntegerArray：原子更新int数组</li><li>AtomicLongArray：原子更新long数组</li><li>AtomicReferenceArray：原子更新引用数组</li></ul><p>可以对数组内的元素进行原子操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">            array.getAndAdd(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(array.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK8之后，新增了<code>DoubleAdder</code>和<code>LongAdder</code>，在高并发情况下，<code>LongAdder</code>的性能比<code>AtomicLong</code>的性能更好，主要体现在自增上，它的大致原理如下：在低并发情况下，和<code>AtomicLong</code>是一样的，对value值进行CAS操作，但是出现高并发的情况时，<code>AtomicLong</code>会进行大量的循环操作来保证同步，而<code>LongAdder</code>会将对value值的CAS操作分散为对数组<code>cells</code>中多个元素的CAS操作（内部维护一个Cell[] as数组，每个Cell里面有一个初始值为0的long型变量，在高并发时会进行分散CAS，就是不同的线程可以对数组中不同的元素进行CAS自增，这样就避免了所有线程都对同一个值进行CAS），只需要最后再将结果加起来即可。</p><p><img src="/inori/4fdd9583/automatic_adder.png" alt="automatic_adder"></p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">            adder.add(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();   <span class="comment">//100个线程</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(adder.sum());   <span class="comment">//最后求和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了对基本数据类型支持原子操作外，对于引用类型也可以实现原子操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    AtomicReference&lt;String&gt; reference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(a);</span><br><span class="line">    reference.compareAndSet(a, b);</span><br><span class="line">    System.out.println(reference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUC还提供了字段原子更新器，可以对类中的某个指定字段进行原子操作（字段必须添加volatile关键字）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;Student&gt; fieldUpdater =</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(Student.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(fieldUpdater.incrementAndGet(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>现在有这样一种场景：</p><p>线程1和线程2同时开始对<code>a</code>的值进行CAS修改，但是线程1的速度比较快，将a的值修改为2之后紧接着又修改回1，这时线程2才开始进行判断，发现a的值是1，所以CAS操作成功。</p><p>很明显，这里的1已经不是一开始的那个1了，而是被重新赋值的1，这也是CAS操作存在的问题，它只会机械地比较当前值是不是预期值，但是并不会关心当前值是否被修改过，这种问题称之为<code>ABA</code>问题。</p><p>对于ABA问题，JUC提供了带版本号的引用类型，只要每次操作都记录一下版本号，并且版本号不会重复：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(a, <span class="number">1</span>);  <span class="comment">//在构造时需要指定初始值和对应的版本号</span></span><br><span class="line">    reference.attemptStamp(a, <span class="number">2</span>);   <span class="comment">//可以中途对版本号进行修改，注意要填写当前的引用对象</span></span><br><span class="line">    System.out.println(reference.compareAndSet(a, b, <span class="number">2</span>, <span class="number">3</span>));   <span class="comment">//CAS操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM类与类加载</title>
      <link href="/inori/e45c1800.html"/>
      <url>/inori/e45c1800.html</url>
      
        <content type="html"><![CDATA[<p>java的类字节码文件如何加载到内存中的？</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="类加载的触发条件"><a href="#类加载的触发条件" class="headerlink" title="类加载的触发条件"></a>类加载的触发条件</h3><p>JVM并不会一次性加载所有类，而是采用<strong>“按需加载”</strong>策略，即在需要的时候才会进行类的加载。</p><h4 id="触发类加载的操作"><a href="#触发类加载的操作" class="headerlink" title="触发类加载的操作"></a>触发类加载的操作</h4><p>一般在这些情况下，如果类没有被加载，那么会被自动加载：</p><ul><li>使用 <code>new</code> 关键字创建对象时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure><ul><li>访问类的静态变量（包括读取或写入，不是 <code>final</code> 修饰的常量）时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> MyClass.staticField;</span><br></pre></td></tr></table></figure><ul><li>调用类的静态方法时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClass.staticMethod();</span><br></pre></td></tr></table></figure><ul><li>使用反射机制（如 <code>Class.forName()</code>、<code>Class.getMethod()</code> 等）时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>子类初始化时，如果父类尚未初始化，会先触发父类的加载</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>; &#125;</span><br><span class="line">System.out.println(B.b); <span class="comment">// 先加载 A，再加载 B</span></span><br></pre></td></tr></table></figure><ul><li>作为 <code>main</code> 方法所在的类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; &#125; <span class="comment">// Main 类被加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不会触发类加载的操作"><a href="#不会触发类加载的操作" class="headerlink" title="不会触发类加载的操作"></a>不会触发类加载的操作</h4><ul><li>访问 <code>final</code> 修饰的静态变量,<code>final</code> 变量在编译时已确定，不会触发类的初始化</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(A.CONSTANT);<span class="comment">// A 类不会被加载</span></span><br></pre></td></tr></table></figure><ul><li>通过数组定义类的引用,只是创建了一个引用类型数组，并未真正使用A类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A[] array = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">10</span>];<span class="comment">// A 类不会被加载</span></span><br></pre></td></tr></table></figure><ul><li>通过子类访问父类的静态变量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line">System.out.println(B.a);<span class="comment">// 只会触发 A 的加载，B 不会被加载</span></span><br></pre></td></tr></table></figure><h3 id="类加载过程-1"><a href="#类加载过程-1" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>Java 类的加载过程主要包括<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）</strong>五个阶段</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过类的全限定名查找字节码文件（如<code>.class</code>文件）</li><li>将字节码文件转换为内存中的二进制数据</li><li>在方法区（JDK 8之前）或元空间（JDK 8及之后）中创建类的运行时数据结构</li><li>在堆内存中生成一个<code>Class</code>对象，作为方法区或元空间中数据的访问入口</li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul><li>检查字节码文件的正确性和安全性，确保其符合JVM规范</li><li>包括文件格式验证、元数据验证、字节码验证和符号引用验证<ul><li>文件格式验证：是否符合 <code>.class</code> 文件规范（开头八位数，即魔数<code>CAFEBABE</code>）</li><li>元数据验证：类、方法、字段的定义是否合法</li><li>字节码检查：方法调用是否合法，是否越界访问</li><li>符号引用检查：解析阶段前，确保引用的类、方法、字段存在</li></ul></li><li>如果验证失败，会抛出 <code>VerifyError</code></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>为<strong>类的静态变量</strong>分配内存，并赋默认值（非初始化值）</li><li>变量赋的是<strong>默认值</strong>（<code>int</code> -&gt; <code>0</code>，<code>boolean</code> -&gt; <code>false</code>，<code>reference</code> -&gt; <code>null</code>）。</li><li>如果静态变量是常量（<code>final</code>），则直接赋值为指定的初始值</li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将常量池中的<u>符号引用</u>转换为<u>直接引用</u></p><p>符号引用：类的字段、方法的名称和描述符</p><ul><li><code>com/example/A</code> 之类的字符串引用类</li><li><code>A.f</code> 代表字段</li><li><code>A.m()</code> 代表方法</li></ul><p>直接引用：字段、方法在内存中的实际地址</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>执行类的初始化代码，包括静态变量的赋值和静态代码块的执行</p><p>按照<strong>定义顺序</strong>执行类的静态初始化代码，包括：</p><ul><li><strong>静态变量赋值</strong></li><li><strong>静态代码块</strong></li><li><strong>执行 <code>&lt;clinit&gt;()</code> 方法</strong></li></ul><p>执行顺序：</p><ol><li>父类静态变量 &amp; 静态代码块</li><li>子类静态变量 &amp; 静态代码块</li><li>父类实例变量 &amp; 构造代码块</li><li>父类构造方法</li><li>子类实例变量 &amp; 构造代码块</li><li>子类构造方法</li></ol><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>条件：</p><ul><li>类的 <code>ClassLoader</code> 被回收</li><li>该类的所有实例都不可达（GC）</li><li>没有其他类引用该类</li></ul><p>特点：</p><ul><li>只会卸载<strong>用户自定义类</strong>，JDK的核心类不会被卸载</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java提供了类加载器，以便更好地控制类加载，可以自定义类加载器，也可以使用官方自带的类加载器去加载类。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。也就是说，一个类可以由不同的类加载器加载，并且，不同的类加载器加载的出来的类，即使来自同一个Class文件，也是不同的，<strong>只有两个类来自同一个Class文件并且是由同一个类加载器加载的，才能判断为是同一个</strong>。</p><p>默认情况下，所有的类都是由JDK自带的类加载器进行加载，类加载器实现了类的动态加载、隔离和安全性控制。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>类加载器是JVM的一部分，用于查找、加载和定义Java类。主要负责：</p><ol><li><strong>加载类文件</strong>（从磁盘、网络、JAR包等）</li><li><strong>将字节码转换为 Class 对象</strong></li><li><strong>缓存已加载的类</strong>，避免重复加载</li></ol><p>Java采用双亲委派机制来组织多个类加载器，确保类的加载顺序和安全性</p><p>主要有三种由JDK提供的类加载器：</p><table><thead><tr><th>类加载器</th><th>作用</th><th>负责加载的类</th></tr></thead><tbody><tr><td><strong>Bootstrap ClassLoader（启动类加载器）</strong></td><td>最顶层的类加载器，由 JVM 实现</td><td><code>rt.jar</code>（如 <code>java.lang.String</code>、<code>java.util.List</code>）</td></tr><tr><td><strong>Extension ClassLoader（扩展类加载器）</strong></td><td>加载扩展库中的类</td><td><code>lib/ext</code> 目录下的 JAR</td></tr><tr><td><strong>Application ClassLoader（应用类加载器）</strong></td><td>加载应用程序的类</td><td><code>classpath</code> 指定的类</td></tr></tbody></table><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ol><li>检查缓存：如果类已加载，则直接返回Class对象（避免重复加载）</li><li>双亲委派<ul><li>先让父类加载器尝试加载类</li><li>如果找不到，再由当前类加载器加载</li></ul></li><li>转换&amp;解析<ul><li>将字节码转换成Class对象，并存入JVM方法区</li></ul></li><li>返回Class对象，允许实例化对象</li></ol><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><ol><li>当一个类加载器要加载某个类时，先让自己的“父加载器”尝试加载</li><li>如果父加载器找不到该类，才由当前类加载器自己加载</li></ol><p>工作流程：</p><ol><li>类加载请求从最底层的<code>ClassLoader</code>向上层传递。</li><li>顶层加载器（Bootstrap ClassLoader）先尝试加载</li><li>如果上层加载器找不到类，才交给当前类加载器进行加载</li><li>如果类已加载，直接返回<code>Class</code>对象</li></ol><p><img src="/inori/e45c1800/parents_.png" alt="parents_"></p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>Java允许自定义类加载器，用于加载网络、加密、动态生成的类，通过继承 <code>java.lang.ClassLoader</code> 类，可以实现自定义的类加载器。举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath; <span class="comment">// 类路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取字节码文件</span></span><br><span class="line">            <span class="type">byte</span>[] data = loadClassData(name);</span><br><span class="line">            <span class="comment">// 生成 Class 对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;类未找到: &quot;</span> + name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载字节码文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String name) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classPath + name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">             <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建自定义类加载器</span></span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;path/to/classes/&quot;</span>);</span><br><span class="line">        <span class="comment">// 加载类</span></span><br><span class="line">        Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;类加载器: &quot;</span> + clazz.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>findClass</code>方法：</p><ul><li>自定义类加载器需要重写<code>findClass</code>方法，用于加载类的字节码文件</li></ul><p><code>defineClass</code>方法：</p><ul><li>将字节码文件转换为<code>Class</code>对象</li></ul><p><code>loadClassData</code>方法：</p><ul><li>从指定路径读取字节码文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收机制</title>
      <link href="/inori/4af053c8.html"/>
      <url>/inori/4af053c8.html</url>
      
        <content type="html"><![CDATA[<p>Java会自动管理和释放内存，它不像C&#x2F;C++那样要求我们手动管理内存，JVM提供了一套全自动的内存管理机制，当一个Java对象不再用到时，JVM会自动将其进行回收并释放内存，那么对象所占内存在什么时候被回收，如何判定对象可以被回收，以及如何去进行回收工作也是JVM需要关注的问题。</p><h2 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h2><p>对象在什么情况下可以被判定为不再使用已经可以回收了？</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>如果要经常操作一个对象，那么首先一定会创建一个引用变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str就是一个引用类型的变量，它持有对后面字符串对象的引用，可以代表后面这个字符串对象本身</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>只要一个对象还有使用价值，就可以通过它的引用变量来进行操作，那么可否这样判断一个对象是否还需要被使用：</p><ul><li>每个对象都包含一个引用计数器，用于存放引用计数（存放被引用的次数）</li><li>每当有一个地方引用此对象时，引用计数<code>+1</code></li><li>当引用失效（比如离开了局部变量的作用域或是引用被设定为<code>null</code>）时，引用计数<code>-1</code></li><li>当引用计数为<code>0</code>时，表示此对象不可能再被使用，因为这时我们已经没有任何方法可以得到此对象的引用了</li></ul><p>但是这样存在一个问题，如果两个对象相互引用呢？                  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        a.another = b;</span><br><span class="line">        b.another = a;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里直接把a和b赋值为null，这样前面的两个对象我们不可能再得到了</span></span><br><span class="line">        a = b = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        Test another;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照引用计数算法，那么当出现以上情况时，虽然无法得到此对象的引用，并且此对象也无需再使用，但是由于这两个对象直接存在相互引用的情况，那么引用计数器的值将会永远是<code>1</code>，永远不会被回收，引用计数法并不是最好的解决方案。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>目前比较主流的编程语言，一般都会使用可达性分析算法来判断对象是否存活，它采用了类似于树结构的搜索机制。</p><p>首先每个对象的引用都有机会成为树的根节点（GC Roots），可以被选定作为根节点条件如下：</p><ul><li><strong>虚拟机栈中的局部变量</strong>：当前正在执行的方法中的局部变量引用的对象</li><li><strong>方法区中的静态变量</strong>：类的静态成员变量引用的对象。</li><li><strong>方法区中的常量</strong>：运行时常量池中的常量引用的对象（如字符串常量）</li><li><strong>本地方法栈中的 JNI 引用</strong>：Native 方法引用的对象</li><li><strong>被添加了锁的对象</strong>：比如synchronized关键字</li><li><strong>JVM 内部的特殊对象</strong>：如基本数据类型对应的 Class 对象、异常对象等</li></ul><p>一旦已经存在的根节点不满足存在的条件时，那么根节点与对象之间的连接将被断开。此时虽然对象1仍存在对其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。只要某个对象无法到达任何GC Roots，则证明此对象是不可能再被使用的，就可以被回收。</p><h3 id="最终判定"><a href="#最终判定" class="headerlink" title="最终判定"></a>最终判定</h3><p>虽然在经历了可达性分析算法之后基本可能判定哪些对象能够被回收，但是并不代表此对象一定会被回收，我们依然可以在最终判定阶段对其进行挽留。</p><p><code>finalize()</code>是 Java 中的一个对象生命周期方法，定义在<code>Object</code>类中。它允许对象在垃圾回收之前执行一些清理操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called by the garbage collector on an object when garbage collection</span></span><br><span class="line"><span class="comment"> * determines that there are no more references to the object.</span></span><br><span class="line"><span class="comment"> * A subclass overrides the &#123;<span class="doctag">@code</span> finalize&#125; method to dispose of</span></span><br><span class="line"><span class="comment"> * system resources or to perform other cleanup.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>如果子类重写了此方法，那么子类对象在被判定为可回收时，会进行二次确认，也就是执行<code>finalize()</code>方法，而在此方法中，当前对象是完全有可能重新建立GC Roots的。</p><p>所以，如果在二次确认后对象不满足可回收的条件，那么此对象不会被回收，巧妙地逃过了垃圾回收的命运。比如下面这个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里直接把a赋值为null，这样前面的对象不可能再得到了</span></span><br><span class="line">        a  = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动申请执行垃圾回收操作（注意只是申请，并不一定会执行，但是一般情况下都会执行）</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等垃圾回收</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(a);<span class="comment">// 仍然没有被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            a = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>finalize()</code>方法并不是在主线程调用的，而是虚拟机自动建立的一个<strong>低优先级</strong>的<code>Finalizer</code>线程进行处理。同一个对象的<code>finalize()</code>方法只会有一次调用机会，也就是说，如果连续两次这样操作，那么第二次，对象必定被回收：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    a = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    <span class="comment">// 再来一次</span></span><br><span class="line">    a = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(a);<span class="comment">// a没了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>finalize()</code>方法也并不是专门防止对象被回收的，我们可以使用它来释放一些程序使用中的资源等。<code>finalize()</code>方法的使用需要非常谨慎，因为它可能导致性能问题和不可预测的行为。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>垃圾收集器会不定期地检查堆中的对象，查看它们是否满足被回收的条件。我们该如何对这些对象进行回收？</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记清楚算法会标记出所有需要回收的对象，然后再依次回收掉被标记的对象，或是标记出所有不需要回收的对象，只回收未标记的对象。</p><p><img src="/inori/4af053c8/clear.png" alt="clear"></p><p>虽然此方法非常简单，但是缺点也是非常明显的 ，首先如果内存中存在大量的对象，那么可能就会存在大量的标记，并且大规模进行清除。</p><p>并且一次标记清除之后，连续的内存空间可能会出现许许多多的空隙，碎片化会导致连续内存空间利用率降低</p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>标记复制算法就是将内存区域划分为大小相同的两块区域，每次只使用其中的一块区域，每次垃圾回收结束后，将所有存活的对象全部复制到另一块区域中，并一次性清空当前区域。虽然浪费了一些时间进行复制操作，但是这样能够很好地解决对象大面积回收后空间碎片化严重的问题</p><p><img src="/inori/4af053c8/copy.png" alt="copy"></p><p>这种算法非常适用于新生代（因为新生代的回收效率极高，一般不会留下太多的对象）的垃圾回收，新生代Survivor区就是这个思路，包括8:1:1的比例也正是为了对标记复制算法进行优化而采取的</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>虽然标记-复制算法能够很好地应对新生代高回收率的场景，但是放到老年代，它就显得很鸡肋了。一般长期不回收的对象，才有机会进入到老年代，所以老年代一般都是些钉子户，可能一次GC后，仍然存留很多对象。而标记复制算法会在GC后完整复制整个区域内容，并且会折损50%的区域，显然这并不适用于老年代。</p><p>标记整理算法在标记所有待回收对象之后，不急着去进行回收操作，而是将所有待回收的对象整齐排列在一段内存空间中，而需要回收的对象全部往后丢，这样，前半部分的所有对象都是无需进行回收的，而后半部分直接一次性清除即可。</p><p><img src="/inori/4af053c8/mark_clean.png" alt="mark_clean"></p><p>虽然这样能保证内存空间充分使用，并且也没有标记复制算法那么繁杂，但是缺点是效率比前两者都低。甚至，由于需要修改对象在内存中的位置，此时程序必须要暂停才可以，在极端情况下，可能会导致整个程序发生停顿</p><p>一般将标记清除算法和标记整理算法混合使用，在内存空间还不是很凌乱的时候，采用标记清除算法，当内存空间凌乱到一定程度后，进行一次标记整理算法</p><h3 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h3><p>JVM将堆内存划分为<strong>新生代</strong>、<strong>老年代</strong>和<strong>永久代</strong>（其中永久代是HotSpot虚拟机特有的概念，在JDK8之前方法区实际上就是采用的永久代作为实现，而在JDK8之后，方法区由<strong>元空间</strong>实现，并且使用的是本地内存，容量大小取决于物理机实际大小）</p><p>不同的分代内存回收机制也存在一些不同之处，在HotSpot虚拟机中，新生代被划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1，老年代的GC评率相对较低，永久代一般存放类信息等（其实就是方法区的实现）</p><p><img src="/inori/4af053c8/heap_memo.png" alt="heap_memo"></p><p>新生代</p><ul><li>存放新创建的对象</li><li>特点：<ul><li>大多数对象的生命周期很短，因此新生代是垃圾回收最频繁的区域</li><li>新生代采用<u>标记-复制算法</u>进行垃圾回收</li></ul></li><li>分区：<ul><li><strong>Eden区</strong>：新创建的对象首先分配到 Eden 区</li><li><strong>Survivor区</strong>：分为 <code>From</code> 区和 <code>To</code> 区，用于存放经过垃圾回收后仍然存活的对象</li></ul></li></ul><p>老年代</p><ul><li>存放生命周期较长的对象</li><li>特点：<ul><li>对象在新生代经过多次垃圾回收后仍然存活，会被晋升到老年代</li><li>老年代的垃圾回收频率较低，但每次回收的时间较长</li><li>老年代采用<u>标记-清除算法</u>或<u>标记-整理算法</u>进行垃圾回收</li></ul></li></ul><p>新生代的垃圾回收称为<strong>Minor GC</strong>：</p><p>首先，所有新创建的对象，在一开始都会进入到新生代的Eden区（如果是大对象会被直接丢进老年代），在进行新生代区域的垃圾回收时，首先会对所有新生代区域的对象进行扫描，并回收那些不再使用对象</p><p>接着，在一次垃圾回收之后，Eden区域没有被回收的对象，会进入到Survivor区。在一开始From和To都是空的，而GC之后，所有Eden区域存活的对象都会直接被放入到To区，最后From和To会发生一次交换，即From区是有数据的，To区是空的</p><p>下一次垃圾回收操作与上面是一样的，不过这时由于我们From区域中已经存在对象了，所有From区的对象会进行一次年龄判定（每经历一轮GC年龄<code>+1</code>，如果对象的年龄大于<code>默认值为15</code>，会直接进入到老年代），在Eden区和From区的存活对象复制到To区之后，清空Eden区和From区，交换From区和To区</p><p><strong>Major GC</strong>是针对老年代（Old Generation）的垃圾回收：</p><p>当老年代空间不足时，从GC Roots开始，标记老年代中的存活对象，使用标记-清除算法清除未标记的对象，再用整理算法将存活对象整理到内存的一端，避免内存碎片</p><p>Full GC 是对整个堆内存（包括新生代、老年代和元空间的垃圾回收：</p><p>触发条件：</p><ul><li><strong>老年代空间不足</strong>：当老年代无法容纳从新生代晋升的对象时，触发 Full GC。</li><li><strong>元空间空间不足</strong>：当元空间无法分配新的类元数据时，触发 Full GC。</li><li>**显式调用 System.gc()**：调用 <code>System.gc()</code> 可能触发 Full GC，但 JVM 不保证立即执行。</li></ul><p>过程：</p><ol><li>新生代回收<ul><li>执行 Minor GC，回收新生代中的垃圾</li></ul></li><li>老年代回收<ul><li>执行 Major GC，回收老年代中的垃圾</li></ul></li><li>元空间回收<ul><li>回收不再使用的类元数据</li></ul></li></ol><table><thead><tr><th><strong>特性</strong></th><th><strong>Minor GC</strong></th><th><strong>Major GC</strong></th><th><strong>Full GC</strong></th></tr></thead><tbody><tr><td><strong>回收区域</strong></td><td>新生代（Eden 区、Survivor 区）。</td><td>老年代。</td><td>整个堆内存（新生代、老年代）和元空间。</td></tr><tr><td><strong>触发条件</strong></td><td>Eden 区空间不足。</td><td>老年代空间不足。</td><td>老年代空间不足、元空间空间不足、显式调用 <code>System.gc()</code>。</td></tr><tr><td><strong>频率</strong></td><td>高，因为大多数对象的生命周期很短。</td><td>低，因为老年代的对象生命周期较长。</td><td>低，触发条件较为严格。</td></tr><tr><td><strong>速度</strong></td><td>快，采用复制算法。</td><td>慢，采用标记-清除或标记-整理算法。</td><td>最慢，需要处理整个堆内存和元空间。</td></tr><tr><td><strong>暂停时间</strong></td><td>短，对应用程序的影响较小。</td><td>较长，对应用程序的影响较大。</td><td>最长，对应用程序的影响最大。</td></tr></tbody></table><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>思考一下，有没有这样一种极端情况（正常情况下新生代的回收率是很高的，所以说不用太担心会经常出现这种问题），在一次GC后，新生代Eden区仍然存在大量的对象超出Survivor区的容量，那么该怎么办？</p><p>这时就需要用到空间分配担保机制了，可以把Survivor区无法容纳的对象直接送到老年代，让老年代进行分配担保</p><p>要是老年代也装不下新生代的数据呢？</p><p>这样的话，首先会判断一下<u>之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间</u></p><ul><li>如果小于，那么说明<strong>也许</strong>可以放得下</li><li>否则，会先来一次Full GC，进行一次大规模垃圾回收，尝试腾出空间，再次判断老年代是否有空间存放</li><li>要是还是装不下，抛出Out Of Memory异常</li></ul><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>JDK8之前，Hotspot虚拟机的方法区是永久代实现的。在JDK8之后不再使用永久代，而是采用了全新的元空间，元空间主要用于存储以下内容：</p><ol><li><strong>类的元数据</strong><ul><li>类的全限定名</li><li>类的父类、接口信息</li><li>类的字段、方法、字节码等</li></ul></li><li><strong>运行时常量池</strong><ul><li>字符串常量、数字常量等</li></ul></li><li><strong>方法区内容</strong></li></ol><p>元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。元空间中的类元数据在类卸载时会被垃圾回收，且垃圾回收效率比永久代更高</p><p><img src="/inori/4af053c8/jvm2.png" alt="jvm2"></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>这是一款单线程的垃圾收集器，也就是说，当开始进行垃圾回收时，需要暂停所有的线程，直到垃圾收集工作结束。它的新生代收集算法采用的是标记复制算法，老年代采用的是标记整理算法。</p><img src="/inori/4af053c8/serial.png" alt="serial" style="zoom:50%;"><p>这个收集器的缺点是当进入到垃圾回收阶段时，所有的用户线程必须等待GC线程完成工作</p><p>但是在用户的桌面应用场景中，内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的，所以，在客户端模式（一般用于一些桌面级图形化界面应用程序）下的新生代中，默认垃圾收集器至今依然是Serial收集器</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>这款垃圾收集器相当于是Serial收集器的多线程版本，它能够支持多线程垃圾收集</p><img src="/inori/4af053c8/parnew.png" alt="parnew" style="zoom:50%;"><p>除了多线程支持以外，其他内容基本与Serial收集器一致，目前某些JVM默认的服务端模式新生代收集器就是使用的ParNew收集器</p><h3 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge&#x2F;Parallel Old收集器"></a>Parallel Scavenge&#x2F;Parallel Old收集器</h3><p>与ParNew收集器不同的是，它会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间，这种自适应机制，能够很好地权衡当前机器的性能，根据性能选择最优方案</p><p>吞吐量&#x3D;应用程序运行时间&#x2F;总时间（应用程序运行时间 + 垃圾回收时间)×100%，目标是尽可能提高吞吐量，即让应用程序的运行时间占比最大化。</p><ul><li>垃圾回收器会监控应用程序的运行时间和垃圾回收时间。</li><li>如果垃圾回收时间占比超过目标值，垃圾回收器会调整垃圾回收的频率和每次回收的时间，以确保吞吐量目标</li><li>如果吞吐量低于目标值，垃圾回收器可能会减少垃圾回收的频率，延长每次垃圾回收的时间</li><li>如果吞吐量高于目标值，垃圾回收器可能会增加垃圾回收的频率，缩短每次垃圾回收的时间</li></ul><img src="/inori/4af053c8/parallel.png" alt="parallel" style="zoom:50%;"><p>目前JDK8采用的就是这种 Parallel Scavenge + Parallel Old的垃圾回收方案</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是HotSpot虚拟机中第一款真正意义上的并发（注意这里的并发和之前的并行是有区别的，并发可以理解为同时运行用户线程和GC线程，而并行可以理解为多条GC线程同时工作）收集器，它第一次实现了让垃圾收集线程与用户线程同时工作，他主要采用标记清除算法。</p><img src="/inori/4af053c8/cms.png" alt="cms" style="zoom:50%;"><p>它的垃圾回收分为4个阶段：</p><ul><li>初始标记（需要暂停用户线程）：这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象，速度比较快，不用担心会停顿太长时间</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与应用程序并发运行</li><li>重新标记（需要暂停用户线程）：修正并发标记期间因应用程序运行而导致的标记变化</li><li>并发清除：最后就可以直接将所有标记好的无用对象进行删除，因为这些对象程序中也用不到了，所以可以与用户线程并发运行</li><li>并发重置：重置CMS收集器的内部状态，为下一次垃圾回收做准备</li></ul><p>虽然它的优点非常之大，但是缺点也是显而易见的，我们之前说过，标记清除算法会产生大量的内存碎片，导致可用连续空间逐渐变少，长期这样下来，会有更高的概率触发Full GC，并且在与用户线程并发执行的情况下，也会占用一部分的系统资源，导致用户线程的运行速度一定程度上减慢</p><p>从JDK9开始，CMS收集器被标记为弃用（Deprecated），在JDK14中完全移除</p><h3 id="Garbage-First-G1-收集器"><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First (G1) 收集器"></a>Garbage First (G1) 收集器</h3><p>它是一款主要面向于服务端的垃圾收集器，并且在JDK9时，取代了JDK8默认的Parallel Scavenge + Parallel Old的回收方案</p><p>垃圾回收分为<code>Minor GC</code>、<code>Major GC </code>和<code>Full GC</code>，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而G1收集器绕过了这些，它将整个Java堆划分成多个大小相同的独立<code>Region</code>块，每个<code>Region</code>块的大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且都为2的N次幂。所有的<code>Region</code>大小相同，且在JVM的整个生命周期内不会发生改变，G1优先回收垃圾最多的区域</p><p>每一个<code>Region</code>都可以根据需要，自由决定扮演哪个角色（Eden、Survivor和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1收集器还存在一个<code>Humongous</code>区域，它专门用于存放大对象（一般认为大小超过了Region容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的</p><img src="/inori/4af053c8/g1.png" alt="g1" style="zoom:50%;"><p>回收过程与CMS大体类似，分为以下四个步骤：</p><ul><li>初始标记（暂停用户线程）：仅仅只是标记GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿</li><li>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行</li><li>最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象</li><li>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的</li></ul><img src="/inori/4af053c8/g1_process.png" alt="g1_process" style="zoom:50%;"><h2 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h2><p>在Java中，如果变量是一个对象类型的，那么它实际上存放的是对象的引用，但是如果是一个基本类型，那么存放的就是基本类型的值。平时代码中类似于<code>Object o = new Object()</code>这样的的引用类型，细分之后可以称为<code>强引用</code>。</p><p>当JVM内存空间不足时，JVM宁愿抛出OutOfMemoryError使程序异常终止，也不会靠随意回收具有强引用的存活对象来解决内存不足的问题</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用不像强引用那样不可回收，当JVM认为内存不足时，会去试图回收软引用指向的对象，即JVM会确保在抛出<code>OutOfMemoryError</code>之前，清理软引用指向的对象。如果内存充足，是不会轻易被回收的</p><p>可以通过以下方式来创建一个软引用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//强引用写法：Object obj = new Object();</span></span><br><span class="line">        <span class="comment">//软引用写法：</span></span><br><span class="line">        SoftReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        <span class="comment">//使用get方法就可以获取到软引用所指向的对象了</span></span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软引用还存在一个带队列的构造方法，软引用可以和一个引用队列联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用本身加入到与之关联的引用队列中</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用比软引用的生命周期还要短，在进行垃圾回收时，不管当前内存空间是否充足，都会回收它的内存</p><p>创建一个弱引用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法和软引用是差不多的，但是如果在这之前进行一次GC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动GC</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;软引用对象：&quot;</span>+softReference.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;弱引用对象：&quot;</span>+weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弱引用对象被回收了，而软引用对象没有被回收。同样的，它也支持ReferenceQueue，和软引用用法一致。</p><p><code>WeakHashMap</code>是一种类似于弱引用的HashMap类，如果Map中的Key没有其他引用那么此Map会自动丢弃此键值对：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        WeakHashMap&lt;Integer, String&gt; weakHashMap = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">        weakHashMap.put(a, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line"></span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当变量a的引用断开后，这时只有WeakHashMap本身对此对象存在引用，所以在GC之后，这个键值对就自动被舍弃了。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用相当于没有引用，随时都有可能会被回收。虚引用是最弱的一种引用类型，主要用于跟踪对象被垃圾回收的时机，通常用于实现更精细的资源管理或清理机制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个虚引用，指向 obj，并关联引用队列</span></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虚引用的 get() 方法始终返回 null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;PhantomRef.get(): &quot;</span> + phantomRef.get()); <span class="comment">// 输出 null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 obj 置为 null，使其成为垃圾</span></span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查引用队列</span></span><br><span class="line">        <span class="keyword">if</span> (queue.poll() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象已被回收，虚引用被加入队列&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象未被回收&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虚引用的 <code>get()</code> 方法始终返回 <code>null</code>，因此无法通过虚引用访问对象</li><li>当对象被垃圾回收时，虚引用会被加入到引用队列中</li><li>通过检查引用队列，可以确定对象是否已被回收</li></ul><h3 id="四种引用对象对比"><a href="#四种引用对象对比" class="headerlink" title="四种引用对象对比"></a>四种引用对象对比</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>强引用</strong></th><th><strong>软引用</strong></th><th><strong>弱引用</strong></th><th><strong>虚引用</strong></th></tr></thead><tbody><tr><td><strong>引用强度</strong></td><td>最强</td><td>较强</td><td>较弱</td><td>最弱</td></tr><tr><td><strong>回收时机</strong></td><td>不会被垃圾回收</td><td>内存不足时回收</td><td>下一次垃圾回收时回收</td><td>对象被回收后加入引用队列</td></tr><tr><td><strong><code>get()</code> 方法</strong></td><td>返回对象</td><td>返回对象（如果未被回收）</td><td>返回对象（如果未被回收）</td><td>始终返回 <code>null</code></td></tr><tr><td><strong>使用场景</strong></td><td>默认引用类型</td><td>缓存</td><td>缓存、监听器</td><td>对象回收的跟踪、资源管理</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM概述与内存管理</title>
      <link href="/inori/a89a12f2.html"/>
      <url>/inori/a89a12f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="JVM启动流程"><a href="#JVM启动流程" class="headerlink" title="JVM启动流程"></a>JVM启动流程</h1><p>虚拟机的启动入口位于<code>jdk/src/share/bin/java.c</code>的<code>JLI_Launch</code>函数，整个流程分为如下几个步骤：</p><ol><li>配置JVM装载环境</li><li>解析虚拟机参数</li><li>设置线程栈大小</li><li>执行JavaMain方法</li></ol><p><code>JLI_Launch</code>函数的定义，在入口点的参数有很多个，其中包括当前的完整版本名称、简短版本名称、运行参数、程序名称、启动器名称等：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">JLI_Launch</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv,              <span class="comment">/* main argc, argc */</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> jargc, <span class="type">const</span> <span class="type">char</span>** jargv,          <span class="comment">/* java args */</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> appclassc, <span class="type">const</span> <span class="type">char</span>** appclassv,  <span class="comment">/* app classpath */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* fullversion,                <span class="comment">/* full version defined */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* dotversion,                 <span class="comment">/* dot version defined */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* pname,                      <span class="comment">/* program name */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* lname,                      <span class="comment">/* launcher name */</span></span></span><br><span class="line"><span class="params">        jboolean javaargs,                      <span class="comment">/* JAVA_ARGS */</span></span></span><br><span class="line"><span class="params">        jboolean cpwildcard,                    <span class="comment">/* classpath wildcard */</span></span></span><br><span class="line"><span class="params">        jboolean javaw,                         <span class="comment">/* windows-only javaw */</span></span></span><br><span class="line"><span class="params">        jint     ergo_class                     <span class="comment">/* ergnomics policy */</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>首先会进行一些初始化操作以及Debug信息打印配置等：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InitLauncher(javaw);</span><br><span class="line">DumpState();</span><br><span class="line"><span class="keyword">if</span> (JLI_IsTraceLauncher()) &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Command line args:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc ; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    AddOption(<span class="string">&quot;-Dsun.java.launcher.diag=true&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着选择合适的JRE版本：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sure the specified version of the JRE is running.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are three things to note about the SelectVersion() routine:</span></span><br><span class="line"><span class="comment"> *  1) If the version running isn&#x27;t correct, this routine doesn&#x27;t</span></span><br><span class="line"><span class="comment"> *     return (either the correct version has been exec&#x27;d or an error</span></span><br><span class="line"><span class="comment"> *     was issued).</span></span><br><span class="line"><span class="comment"> *  2) Argc and Argv in this scope are *not* altered by this routine.</span></span><br><span class="line"><span class="comment"> *     It is the responsibility of subsequent code to ignore the</span></span><br><span class="line"><span class="comment"> *     arguments handled by this routine.</span></span><br><span class="line"><span class="comment"> *  3) As a side-effect, the variable &quot;main_class&quot; is guaranteed to</span></span><br><span class="line"><span class="comment"> *     be set (if it should ever be set).  This isn&#x27;t exactly the</span></span><br><span class="line"><span class="comment"> *     poster child for structured programming, but it is a small</span></span><br><span class="line"><span class="comment"> *     price to pay for not processing a jar file operand twice.</span></span><br><span class="line"><span class="comment"> *     (Note: This side effect has been disabled.  See comment on</span></span><br><span class="line"><span class="comment"> *     bugid 5030265 below.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SelectVersion(argc, argv, &amp;main_class);</span><br></pre></td></tr></table></figure><p>接着创建JVM执行环境，例如需要确定数据模型，是32位还是64位，以及jvm本身的一些配置在jvm.cfg文件中读取和解析：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CreateExecutionEnvironment(&amp;argc, &amp;argv,</span><br><span class="line">                               jrepath, <span class="keyword">sizeof</span>(jrepath),</span><br><span class="line">                               jvmpath, <span class="keyword">sizeof</span>(jvmpath),</span><br><span class="line">                               jvmcfg,  <span class="keyword">sizeof</span>(jvmcfg));</span><br></pre></td></tr></table></figure><p>此函数只在头文件中定义，具体的实现是根据不同平台而定的。接着会动态加载jvm.so这个共享库，并把jvm.so中的相关函数导出并且初始化，而启动JVM的函数也在其中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!LoadJavaVM(jvmpath, &amp;ifn)) &#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是对JVM进行初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);</span><br></pre></td></tr></table></figure><p>初始化后在新的线程中执行<code>JavaMain</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize the virtual machine */</span></span><br><span class="line">start = CounterGet();</span><br><span class="line"><span class="keyword">if</span> (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123;</span><br><span class="line">    JLI_ReportErrorMessage(JVM_ERROR1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步初始化虚拟机，如果报错直接退出。</p><p>接着加载主类，因为主类Java程序的入口点：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the application&#x27;s main class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See bugid 5030265.  The Main-Class name has already been parsed</span></span><br><span class="line"><span class="comment"> * from the manifest, but not parsed properly for UTF-8 support.</span></span><br><span class="line"><span class="comment"> * Hence the code here ignores the value previously extracted and</span></span><br><span class="line"><span class="comment"> * uses the pre-existing code to reextract the value.  This is</span></span><br><span class="line"><span class="comment"> * possibly an end of release cycle expedient.  However, it has</span></span><br><span class="line"><span class="comment"> * also been discovered that passing some character sets through</span></span><br><span class="line"><span class="comment"> * the environment has &quot;strange&quot; behavior on some variants of</span></span><br><span class="line"><span class="comment"> * Windows.  Hence, maybe the manifest parsing code local to the</span></span><br><span class="line"><span class="comment"> * launcher should never be enhanced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hence, future work should either:</span></span><br><span class="line"><span class="comment"> *     1)   Correct the local parsing code and verify that the</span></span><br><span class="line"><span class="comment"> *          Main-Class attribute gets properly passed through</span></span><br><span class="line"><span class="comment"> *          all environments,</span></span><br><span class="line"><span class="comment"> *     2)   Remove the vestages of maintaining main_class through</span></span><br><span class="line"><span class="comment"> *          the environment (and remove these comments).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method also correctly handles launching existing JavaFX</span></span><br><span class="line"><span class="comment"> * applications that may or may not have a Main-Class manifest entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mainClass = LoadMainClass(env, mode, what);</span><br></pre></td></tr></table></figure><p>某些没有主方法的Java程序比如JavaFX应用，会获取<code>ApplicationMainClass</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In some cases when launching an application that needs a helper, e.g., a</span></span><br><span class="line"><span class="comment"> * JavaFX application with no main method, the mainClass will not be the</span></span><br><span class="line"><span class="comment"> * applications own main class but rather a helper class. To keep things</span></span><br><span class="line"><span class="comment"> * consistent in the UI we need to track and report the application main class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appClass = GetApplicationClass(env);</span><br></pre></td></tr></table></figure><p>初始化完成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PostJVMInit uses the class name as the application name for GUI purposes,</span></span><br><span class="line"><span class="comment"> * for example, on OSX this sets the application name in the menu bar for</span></span><br><span class="line"><span class="comment"> * both SWT and JavaFX. So we&#x27;ll pass the actual application class here</span></span><br><span class="line"><span class="comment"> * instead of mainClass as that may be a launcher or helper class instead</span></span><br><span class="line"><span class="comment"> * of the application class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PostJVMInit(env, appClass, vm);</span><br></pre></td></tr></table></figure><p>获取主类中的主方法:       </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The LoadMainClass not only loads the main class, it will also ensure</span></span><br><span class="line"><span class="comment"> * that the main method&#x27;s signature is correct, therefore further checking</span></span><br><span class="line"><span class="comment"> * is not required. The main method is invoked here so that extraneous java</span></span><br><span class="line"><span class="comment"> * stacks are not in the application stack trace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, <span class="string">&quot;main&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br></pre></td></tr></table></figure><p>在字节码中<code>void main(String[] args)</code>表示为<code>([Ljava/lang/String;)V</code>。接着调用主方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Invoke main method. */</span></span><br><span class="line">(*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br></pre></td></tr></table></figure><p>调用后，Java程序开始运行，直到走到主方法的最后一行返回：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The launcher&#x27;s exit code (in the absence of calls to</span></span><br><span class="line"><span class="comment"> * System.exit) will be non-zero if main threw an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = (*env)-&gt;ExceptionOccurred(env) == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">LEAVE();</span><br></pre></td></tr></table></figure><p>在最后LEAVE函数中会销毁JVM。</p><p><img src="/inori/a89a12f2/jvm_launch.png" alt="jvm_launch"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>在C&#x2F;C++中，经常通过使用申请内存的方式来创建对象或是存放某些数据，但是这样也带来了一些额外的问题，要在何时释放这些内存，怎么才能使得内存的使用最高效？</p><p>比如通过C语言动态申请内存，并存放数据：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//动态申请4个int大小的内存空间</span></span><br><span class="line">    <span class="type">int</span>* memory = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//修改第一个int空间的值</span></span><br><span class="line">    memory[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//修改第二个int空间的值</span></span><br><span class="line">    memory[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//遍历内存区域中所有的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, memory[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放指针所指向的内存区域</span></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">    <span class="comment">//最后将指针赋值为NULL</span></span><br><span class="line">    memory = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，这种操作实际上是不允许的，Java只支持直接使用基本数据类型和对象类型，至于内存到底如何分配，并不是由我们来处理，而是JVM帮助我们进行控制，这样可以节省很多内存上的工作，虽然带来了很大的便利，但是，一旦出现内存问题，我们就无法像C&#x2F;C++那样对所管理的内存进行合理地处理，因为所有的内存操作都是由JVM在进行，只有了解了JVM的内存管理机制，才能够在出现内存相关问题时找到解决方案。</p><h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p>JVM对内存的管理采用的是分区治理，不同的内存区域有着各自的职责所在。</p><p><img src="/inori/a89a12f2/jvm_memory.png" alt="jvm_memory"></p><p>内存区域一共分为5个区域：方法区，堆，虚拟机栈，本地方法栈，程序计数器。其中方法区和堆是所有线程共享的区域，随着虚拟机的创建而创建，虚拟机的结束而销毁，而虚拟机栈、本地方法栈、程序计数器都是线程之间相互隔离的，每个线程都有一个自己的区域，并且线程启动时会自动创建，结束之后会自动销毁。内存划分完成之后，JVM执行引擎和本地库接口，也就是Java程序开始运行之后就会根据分区合理地使用对应区域的内存了。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>JVM中的程序计数器是当前线程所执行字节码的指令地址指示器。字节码解释器在工作时会根据程序计数器的值执行指令，并在执行完毕后更新程序计数器的值，以指向下一条即将执行的指令。</p><p>在Java的多线程环境中，每个线程都有独立的程序计数器。JVM通过线程调度机制（如操作系统的时间片轮转算法）切换线程的执行。当一个线程被切换出去时，它的程序计数器会记录当前执行的字节码指令地址；当该线程再次被调度执行时，JVM会根据程序计数器的值继续执行后续指令。</p><p>程序计数器只需要记录当前线程执行的字节码指令地址，因此它占用的内存非常小，通常是JVM内存结构中占用最少的部分。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈就是一个非常关键的部分，看名字就知道它是一个栈结构，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（其实就是栈里面的一个元素），栈帧中包括了当前方法的一些信息，比如局部变量表、操作数栈、动态链接、方法出口等。</p><img src="/inori/a89a12f2/vmstack.png" alt="vmstack" style="zoom:70%;"><ul><li>其中局部变量表就是方法中的局部变量，局部变量表在class文件中就已经定义好了</li><li>操作数栈就是之前字节码执行时使用到的栈结构</li><li>每个栈帧保存了一个可以指向当前方法所在类的运行时常量池，当前方法中如果需要调用其他方法的时候，能够从<strong>运行时常量池</strong>中找到对应的符号引用，然后将符号引用转换为直接引用，然后就能直接调用对应方法，这就是动态链接</li><li>方法出口，也就是方法该如何结束，是抛出异常还是正常返回。</li></ul><p>举个例子：              </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> a();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们的主方法执行后，会依次执行三个方法<code>a() -&gt; b() -&gt; c() -&gt; 返回</code></p><p>首先是<code>main</code>方法调用：</p><ul><li>局部变量表：<code>args</code>（<code>main</code> 方法的参数）</li><li>操作数栈：空</li><li>动态链接：指向 <code>main</code> 方法的引用</li><li>返回地址：无（<code>main</code> 方法是程序的入口）</li></ul><p>然后<code>main</code>方法调用<code>a()</code>：</p><ul><li>局部变量表：空（<code>a()</code> 无参数）</li><li>操作数栈：空</li><li>动态链接：指向 <code>a()</code> 方法的引用</li><li>返回地址：<code>main</code> 方法中调用 <code>a()</code> 的下一条指令</li><li>栈状态，由顶到底：<code>a(),main()</code></li></ul><p>…</p><p>到<code>c()</code>调用后：</p><p>栈帧</p><ul><li>局部变量表：<code>a = 10</code>，<code>b = 20</code></li><li>操作数栈：存储 <code>a + b</code> 的计算结果</li><li>动态链接：指向 <code>c()</code> 方法的引用</li><li>返回地址：<code>b()</code> 方法中调用 <code>c()</code> 的下一条指令</li><li>栈状态，由顶到底：<code>c(),b(),a(),main()</code></li></ul><p>然后按照栈弹出顺序返回，最后输出结果。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈作用差不多，用于支持Native方法（非 Java 方法，通常用 C&#x2F;C++ 实现）的执行</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是整个Java应用程序共享的区域，它用于存储所有的类信息、常量、静态变量、动态编译缓存等数据，可以大致分为两个部分，一个是类信息表，一个是运行时常量池</p><img src="/inori/a89a12f2/jvm_method.png" alt="jvm_method" style="zoom:67%;"><p>主要用于存储以下内容：</p><ol><li><strong>类信息</strong>：<ul><li>类的全限定名</li><li>类的直接父类的全限定名</li><li>类的修饰符（如 <code>public</code>、<code>abstract</code>、<code>final</code> 等）</li><li>类的接口信息</li></ul></li><li><strong>字段信息</strong>：<ul><li>字段的名称、类型、修饰符（如 <code>public</code>、<code>private</code>、<code>static</code> 等）</li></ul></li><li><strong>方法信息</strong>：<ul><li>方法的名称、返回类型、参数列表、修饰符（如 <code>public</code>、<code>static</code> 等）</li><li>方法的字节码（Bytecode）、操作数栈、局部变量表等</li></ul></li><li><strong>运行时常量池（Runtime Constant Pool）</strong>：<ul><li>存储编译期生成的字面量（如字符串、数字常量）和符号引用（如类、方法、字段的引用）</li><li>运行时常量池是方法区的一部分，每个类或接口都有自己的运行时常量池</li></ul></li><li><strong>静态变量（Static Variables）</strong>：<ul><li>类的静态变量（<code>static</code> 修饰的变量）存储在方法区中</li></ul></li><li><strong>类加载器引用</strong>：<ul><li>存储加载该类的类加载器的引用</li></ul></li><li><strong>方法代码</strong>：<ul><li>存储方法的字节码和相关的元数据</li></ul></li></ol><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是整个Java应用程序共享的区域，也是整个虚拟机最大的一块内存空间，此区域的职责就是存放和管理对象和数组，后续提到的垃圾回收机制也是主要作用于这一部分内存区域</p><h2 id="爆堆与爆栈"><a href="#爆堆与爆栈" class="headerlink" title="爆堆与爆栈"></a>爆堆与爆栈</h2><p>在Java程序运行时，内存容量不可能是无限制的，当我们的对象创建过多或是数组容量过大时，就会导致我们的堆内存不足以存放更多新的对象或是数组，这时就会出现错误，比如： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOverflowExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 不断创建对象，耗尽堆内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后JVM会抛出 <code>java.lang.OutOfMemoryError: Java heap space</code> 错误，也就是堆内存溢出错误。</p><p>当程序在栈内存中分配的栈帧过多，导致栈内存耗尽时，就会发生爆栈。栈内存用于存储方法调用的栈帧，包括局部变量、操作数栈、方法返回地址等，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        infiniteRecursion(); <span class="comment">// 无限递归，导致爆栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">infiniteRecursion</span><span class="params">()</span> &#123;</span><br><span class="line">        infiniteRecursion(); <span class="comment">// 递归调用自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后JVM会抛出<code>java.lang.StackOverflowError</code>错误。</p><table><thead><tr><th><strong>特性</strong></th><th><strong>爆堆（Heap Overflow）</strong></th><th><strong>爆栈（Stack Overflow）</strong></th></tr></thead><tbody><tr><td><strong>内存区域</strong></td><td>堆内存</td><td>栈内存</td></tr><tr><td><strong>存储内容</strong></td><td>对象实例、数组</td><td>方法调用的栈帧（局部变量、操作数栈、方法返回地址等）</td></tr><tr><td><strong>错误类型</strong></td><td><code>java.lang.OutOfMemoryError: Java heap space</code></td><td><code>java.lang.StackOverflowError</code></td></tr><tr><td><strong>常见原因</strong></td><td>内存泄漏、对象过多、堆内存设置过小</td><td>递归调用过深、栈内存设置过小</td></tr><tr><td><strong>解决方法</strong></td><td>检查内存泄漏、增加堆内存、优化代码</td><td>检查递归终止条件、增加栈内存、优化代码</td></tr></tbody></table><h2 id="申请堆外内存"><a href="#申请堆外内存" class="headerlink" title="申请堆外内存"></a>申请堆外内存</h2><p>除了堆内存可以存放对象数据以外，我们也可以申请堆外内存（直接内存），也就是不受JVM管控的内存区域，这部分区域的内存需要我们自行去申请和释放，实际上本质就是JVM通过C&#x2F;C++调用<code>malloc</code>函数申请的内存。直接内存会受到本机最大内存的限制，有可能抛出<code>OutOfMemoryError</code>异常</p><p>这里需要提到一个堆外内存操作类：<code>Unsafe</code>，这个类不让new，也没有直接获取方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">        sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, <span class="string">&quot;getUnsafe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Unsafe</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);   <span class="comment">//不是JDK的类，不让用。</span></span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过反射拿到Unsafe类之后，就可以开始申请堆外内存了，比如现在要申请一个int大小的内存空间，并在此空间中存放一个int类型的数据：                   </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">    <span class="comment">// 通过反射拿到Unsafe类</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请4字节大小的内存空间，并得到对应位置的地址</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">address</span> <span class="operator">=</span> unsafe.allocateMemory(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//在对应的地址上设定int的值</span></span><br><span class="line">    unsafe.putInt(address, <span class="number">6666666</span>);</span><br><span class="line">    <span class="comment">//获取对应地址上的Int型数值</span></span><br><span class="line">    System.out.println(unsafe.getInt(address));<span class="comment">// 输出666666</span></span><br><span class="line">    <span class="comment">//释放申请到的内容</span></span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于内存已经释放，这时数据就没了</span></span><br><span class="line">    System.out.println(unsafe.getInt(address));<span class="comment">// 野指针，输出随机数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式——行为型模式</title>
      <link href="/inori/ec6efbf1.html"/>
      <url>/inori/ec6efbf1.html</url>
      
        <content type="html"><![CDATA[<p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式分为：</p><ul><li>模板方法模式</li><li>策略模式</li><li>命令模式</li><li>职责链模式</li><li>状态模式</li><li>观察者模式</li><li>中介者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li><li>解释器模式</li></ul><p>以上11种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式</p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器顾名思义，就是对语言进行解释，根据不同的语义来做不同的事情。笼统点来讲就是给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。</p><p>比如计算器就是根据输入的算式，去进行解析，并根据不同的运算符来不断进行计算。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当语言的文法较为简单，且执行效率不是关键问题时</li><li>当问题重复出现，且可以用一种简单的语言来进行表达时</li><li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候</li></ul><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在浏览器中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p><p>不过备忘录模式为了去保存对象的状态，会占用大量的资源，尤其是那种属性很多的对象，需要合理的使用才能保证程序稳定运行。</p><h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><p>模板方法模式可以定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但另外一些步骤的具体实现还未知，或者说另外一些步骤的实现与具体的环境相关，暂时还不能在这个类中实现。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BankClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">workProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.getNum();<span class="comment">//取号</span></span><br><span class="line">        <span class="built_in">this</span>.queue();<span class="comment">// 排队</span></span><br><span class="line">        <span class="built_in">this</span>.businessHandling();<span class="comment">// 具体业务办理</span></span><br><span class="line">        <span class="built_in">this</span>.evaluate();<span class="comment">// 工作人员评价</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取号都是一样的，直接在该类中写好逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;取号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;排队&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个人办理业务的逻辑和流程可能是不一样的，要在子类中实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">businessHandling</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evaluate</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对工作人员打分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonA</span> <span class="keyword">extends</span> <span class="title class_">BankClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">businessHandling</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;取钱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonB</span> <span class="keyword">extends</span> <span class="title class_">BankClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;存钱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//A来办理业务</span></span><br><span class="line">        <span class="type">AbstractBank</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonA</span>();</span><br><span class="line">        A.workProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//B来办理业务</span></span><br><span class="line">        <span class="type">AbstractBank</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonB</span>();</span><br><span class="line">        B.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：为防止恶意操作，一般模板方法都加上<code>final</code>关键字</p></blockquote><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，提高了代码阅读的难度</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制</li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p><p>举例，现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 numStart 及以上的所有天数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(numStart, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 numStart 到 numEnd 的天数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leave.getNum() &gt;= <span class="built_in">this</span>.numStart &amp;&amp; leave.getNum() &lt;= <span class="built_in">this</span>.numEnd) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line">            System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != <span class="built_in">this</span>.nextHandler) &#123;</span><br><span class="line">            <span class="built_in">this</span>.nextHandler.submit(leave);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无更高权限领导处理，流程终止&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//请假条</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导</span></span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><p>降低了对象之间的耦合度</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的if或者if···else语句</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用</li></ul><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理</p><p>举例，去餐厅点单时，顾客只需要把订单交给服务器，然后等待上菜即可，不用关心菜是如何做出来的，是谁做的，对于厨师也相同，只需要按照订单做菜即可，不需要关心是谁点的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;<span class="comment">//只需要定义一个统一的执行方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有接受者对象</span></span><br><span class="line">    <span class="keyword">private</span> SeniorChef receiver;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCommand</span><span class="params">(SeniorChef receiver, Order order)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">        <span class="built_in">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>  &#123;</span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的订单：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = order.getFoodDic().keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            receiver.makeFood(order.getFoodDic().get(key),key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);<span class="comment">//停顿一下 模拟做饭的过程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的饭弄好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">// 餐桌号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> diningTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来存储餐名并记录份数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDiningTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDiningTable</span><span class="params">(<span class="type">int</span> diningTable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.diningTable = diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">getFoodDic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foodDic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoodDic</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        foodDic.put(name,num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资深大厨类 是命令的Receiver</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeniorChef</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">(<span class="type">int</span> num,String foodName)</span> &#123;</span><br><span class="line">        System.out.println(num + <span class="string">&quot;份&quot;</span> + foodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Command&gt; commands;<span class="comment">//可以持有很多的命令对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Waitor</span><span class="params">()</span> &#123;</span><br><span class="line">        commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command cmd)</span>&#123;</span><br><span class="line">        commands.add(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发出命令 喊 订单来了，厨师开始执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderUp</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新订单来了.......&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; commands.size(); i++) &#123;</span><br><span class="line">            <span class="type">Command</span> <span class="variable">cmd</span> <span class="operator">=</span> commands.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">                cmd.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建2个order</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order1.setDiningTable(<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;西红柿鸡蛋面&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;小杯可乐&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order2.setDiningTable(<span class="number">3</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;尖椒肉丝盖饭&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;小杯雪碧&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建接收者</span></span><br><span class="line">        SeniorChef receiver=<span class="keyword">new</span> <span class="title class_">SeniorChef</span>();</span><br><span class="line">        <span class="comment">//将订单和接收者封装成命令对象</span></span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order1);</span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order2);</span><br><span class="line">        <span class="comment">//创建调用者 waitor</span></span><br><span class="line">        <span class="type">Waitor</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waitor</span>();</span><br><span class="line">        invoker.setCommand(cmd1);</span><br><span class="line">        invoker.setCommand(cmd2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将订单带到柜台 并向厨师喊 订单来了</span></span><br><span class="line">        invoker.orderUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，满足“开闭原则”，对扩展比较灵活</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复</li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类</li><li>系统结构更加复杂</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。</p><p>策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><p>举例，一家百货公司在定年度的促销活动。针对不同的节日推出不同的促销活动，由促销员将促销活动展示给客户</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义百货公司所有促销活动的共同接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体策略角色,每个节日具体的促销活动</span></span><br><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义环境角色，用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SalesMan</span> <span class="variable">salesMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SalesMan</span>(<span class="keyword">new</span> <span class="title class_">StrategyA</span>);</span><br><span class="line">        salesMan.salesManShow();<span class="comment">// 推销</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合开闭原则</p></li><li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想</p></li></ul><p><strong>缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量</li></ul><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为</li></ul><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</p><p>举例，定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现:-</p><p>定义迭代器接口，声明hasNext、next方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Student <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的迭代器类，重写所有的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">currentStudent</span> <span class="operator">=</span> list.get(position);</span><br><span class="line">        position ++;</span><br><span class="line">        <span class="keyword">return</span> currentStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的容器类，重写所有的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();  <span class="comment">// 学生列表</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.add(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentIteratorImpl</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足开闭原则要求</li></ul><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当需要为聚合对象提供多种遍历方式时</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时</li></ul><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式也叫做调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p><p>比如我们想要去外面租房，但是我们怎么知道哪里有可以租的房子呢？于是我们就会上各大租房APP上去找房源，同样的，如果我们现在有房子需要出租，我们也不知道谁会想要租房子，同样的我们也会把房子挂在租房APP上展示，而当我们去租房时或是出租时，就会有一个称为中介的人来跟我们对接，实际上就是一种中介者模式。</p><p>案例实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;   <span class="comment">//房产中介</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, User&gt; userMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();   <span class="comment">//在出售的房子需要存储一下</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String address, User user)</span>&#123;   <span class="comment">//出售房屋的人，需要告诉中介他的房屋在哪里</span></span><br><span class="line">        userMap.put(address, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(String address)</span>&#123;   <span class="comment">//通过此方法来看看有没有对应的房源</span></span><br><span class="line">        <span class="keyword">return</span> userMap.get(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户有两种角色，一种是租房者，一种是出租者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;   <span class="comment">//用户可以是出售房屋的一方，也可以是寻找房屋的一方</span></span><br><span class="line">    String name;</span><br><span class="line">    String tel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String tel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(String address, Mediator mediator)</span>&#123;   <span class="comment">//找房子的话，需要一个中介和你具体想找的地方</span></span><br><span class="line">        <span class="keyword">return</span> mediator.find(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot; (电话：&quot;</span>+tel+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：                   </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;10086&quot;</span>);   <span class="comment">//出租人</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小红&quot;</span>, <span class="string">&quot;10010&quot;</span>);   <span class="comment">//找房人</span></span><br><span class="line">    <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mediator</span>();   <span class="comment">// 中介</span></span><br><span class="line"></span><br><span class="line">    mediator.register(<span class="string">&quot;地址A&quot;</span>, user0);   <span class="comment">// 先把房子给中介挂上去</span></span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> user1.find(<span class="string">&quot;地址B&quot;</span>, mediator);  <span class="comment">//开始找房子</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line"></span><br><span class="line">    user = user1.find(<span class="string">&quot;地址A&quot;</span>, mediator);  <span class="comment">//开始找房子</span></span><br><span class="line">    System.out.println(user);   <span class="comment">//成功找到对应房源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中介者模式优化了原有的复杂多对多关系，而是将其简化为一对多的关系。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在Java中，一个对象的状态发生改变，可能就会影响到其他的对象，与之相关的对象可能也会联动的进行改变。还有我们之前遇到过的监听器机制，当具体的事件触发时，我们在一开始创建的监听器就可以执行相关的逻辑。可以使用观察者模式来实现这样的功能，当对象发生改变时，观察者能够立即观察到并进行一些联动操作。</p><p>观察者模式又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p>我们先定义一个观察者接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;   <span class="comment">//观察者接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;   <span class="comment">//当对象有更新时，会回调此方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来写一个支持观察者的实体类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Observer&gt; observerSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(Observer observer)</span> &#123;   <span class="comment">//添加观察者</span></span><br><span class="line">        observerSet.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123;   <span class="comment">//模拟对象进行修改</span></span><br><span class="line">        observerSet.forEach(Observer::update);   <span class="comment">//当对象发生修改时，会通知所有的观察者，并进行方法回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们就可以测试一下了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    subject.observe(() -&gt; System.out.println(<span class="string">&quot;我是一号观察者！&quot;</span>));</span><br><span class="line">    subject.observe(() -&gt; System.out.println(<span class="string">&quot;我是二号观察者！&quot;</span>));</span><br><span class="line">    subject.modify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就简单实现了一下观察者模式，JDK也提供了实现观察者模式相关的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;    <span class="comment">//java.util包下提供的观察者抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;   <span class="comment">//继承此抽象类表示支持观察者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对对象进行修改！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setChanged();    <span class="comment">//当对对象修改后，需要setChanged来设定为已修改状态</span></span><br><span class="line">        <span class="built_in">this</span>.notifyObservers(<span class="keyword">new</span> <span class="title class_">Date</span>());   <span class="comment">//使用notifyObservers方法来通知所有的观察者</span></span><br><span class="line">      <span class="comment">//注意只有已修改状态下通知观察者才会有效，并且可以给观察者传递参数，这里传递了一个时间对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    <span class="comment">// 添加subject为观察者</span></span><br><span class="line">    subject.addObserver((o, arg) -&gt; System.out.println(<span class="string">&quot;观察者1：监听到变化，并得到参数：&quot;</span> + arg));</span><br><span class="line">    subject.addObserver((o, arg) -&gt; System.out.println(<span class="string">&quot;观察者1：监听到变化，并得到参数：&quot;</span> + arg));</span><br><span class="line">    subject.addObserver((o, arg) -&gt; System.out.println(<span class="string">&quot;观察者1：监听到变化，并得到参数：&quot;</span> + arg));</span><br><span class="line">  <span class="comment">//注意这里的Observer是java.util包下提供的</span></span><br><span class="line">    subject.modify();   <span class="comment">//进行修改操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在标准大气压下，水在0度时会结冰变成固态，在0-100度之间时，会呈现液态，100度以上会变成气态，水这种物质在不同的温度下呈现出不同的状态，而Java中的对象，可能也会像这样存在很多种状态，甚至在不同的状态下会有不同的行为，就可以通过状态模式来实现。</p><p>状态模式可以对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><p>举例，假设有一个电灯开关，电灯有两种状态：开和关。按下开关时，电灯会根据当前状态切换行为：</p><p>如果电灯是“开”状态，按下开关后会关闭电灯。</p><p>如果电灯是“关”状态，按下开关后会打开电灯。</p><p>状态抽象类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>; <span class="comment">// 定义与状态相关的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体状态类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电灯已打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OffState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电灯已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电灯开关：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightSwitch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State currentState; <span class="comment">// 当前状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState = <span class="keyword">new</span> <span class="title class_">OffState</span>(); <span class="comment">// 初始状态为关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下开关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        currentState.handle(); <span class="comment">// 委托给当前状态处理</span></span><br><span class="line">        <span class="keyword">if</span> (currentState <span class="keyword">instanceof</span> OffState) &#123;</span><br><span class="line">            setState(<span class="keyword">new</span> <span class="title class_">OnState</span>()); <span class="comment">// 切换到开状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentState <span class="keyword">instanceof</span> OnState) &#123;</span><br><span class="line">            setState(<span class="keyword">new</span> <span class="title class_">OffState</span>()); <span class="comment">// 切换到关状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LightSwitch</span> <span class="variable">lightSwitch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightSwitch</span>();</span><br><span class="line">        lightSwitch.pressSwitch(); <span class="comment">// 打开电灯</span></span><br><span class="line">        lightSwitch.pressSwitch(); <span class="comment">// 关闭电灯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态模式更加强调当前的对象所处的状态，我们需要根据对象不同的状态决定其他的处理逻辑。</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p><p>举例，现在养宠物的人特别多，宠物分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p><p>创建抽象访问者接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建不同的具体访问者角色（主人和其他人），都需要实现 <code>Person</code>接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Owner</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Someone</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象节点——宠物：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义实现<code>Animal</code>接口的具体节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义对象结构，即主人的家：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal node : nodeList) &#123;</span><br><span class="line">            node.accept(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        nodeList.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Home</span> <span class="variable">home</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Home</span>();</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>();</span><br><span class="line">        home.action(owner);</span><br><span class="line"></span><br><span class="line">        <span class="type">Someone</span> <span class="variable">someone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Someone</span>();</span><br><span class="line">        home.action(someone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的访问者对于某一件事务的处理可能会不同。访问者模式把数据结构和作用于结构上的操作解耦，使得操作集合可相对自由地演化。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式——结构型模式</title>
      <link href="/inori/6b3cc4f4.html"/>
      <url>/inori/6b3cc4f4.html</url>
      
        <content type="html"><![CDATA[<p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下7种：</p><ul><li>代理模式</li><li>适配器模式</li><li>装饰者模式</li><li>桥接模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>火车站买票案例，如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。火车站是目标对象，代售点是代理对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代售点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object object;   <span class="comment">//这里需要保存一下被代理的对象，下面需要用到</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用代理对象的对应方法时会进入，需要编写如何进行代理</span></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//method是调用的代理对象的方法，args是实参数组</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(object, args);   <span class="comment">//在代理中调用被代理对象原本的方法</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(station);</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxy</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),    <span class="comment">//需要传入被代理的类的类加载器</span></span><br><span class="line">            station.getClass().getInterfaces(),    <span class="comment">//需要传入被代理的类的接口列表</span></span><br><span class="line">            handler);    <span class="comment">//最后传入我们实现的代理处理逻辑实现类</span></span><br><span class="line">    proxy.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>JDK提供的动态代理只能使用接口，如果换成我们一开始的抽象类就不可以了，这时我们可以使用一些第三方框架来实现更多方式的动态代理，比如Spring都在使用的CGLib框架，Maven依赖如下：                      </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于CGlib底层使用ASM框架进行字节码编辑，所以能够实现不仅仅局限于对接口的代理:          </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//火车站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation)enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o： 代理对象</span></span><br><span class="line"><span class="comment">            method： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();<span class="comment">// 代理对象的sell方法被调用时，CGLib会自动调用intercept方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂度</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>远程（Remote）代理</p><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节</p></li><li><p>防火墙（Firewall）代理</p><p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器</p></li><li><p>保护（Protect or Access）代理</p><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p></li></ul><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求了解现有组件库中的相关组件的内部结构。</p><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>想定场景：现有一台电脑只能读取SD卡，现在需要读取TF卡中的内容</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;sd card read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;tf card read msg : hello word tf card&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义适配器类（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>();</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式需要占用一个继承位，如果此时Target不是接口而是抽像类的话，由于Java不支持多继承，那么就无法实现了，且类适配器模式违背了合成复用原则。</p><p>类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>类适配器模式的代码，只需要修改适配器类（SDAdapterTF）和测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TFCard</span> <span class="variable">tfCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TFCardImpl</span>();</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将对象以组合的形式存放在<code>SDAdapterTF</code>中，通过存放的对象调用具体实现</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式的核心在于不改变一个对象本身功能的基础上，给对象添加额外的行为，并且它是通过组合的形式完成的，而不是传统的继承关系。</p><p>比如有一个普通的功能类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;   <span class="comment">//顶层抽象类，定义了一个test方法执行业务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;                     </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseImpl</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是业务方法&quot;</span>);   <span class="comment">//具体的业务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过现在的实现类太单调了，添加一点装饰上去：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;   <span class="comment">//装饰者需要将装饰目标组合到类中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Base base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Base base)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        base.test();    <span class="comment">//这里暂时还是使用目标的原本方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorImpl</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span>&#123;   <span class="comment">//装饰实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecoratorImpl</span><span class="params">(Base base)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;    <span class="comment">//对原本的方法进行装饰，我们可以在前后都去添加额外操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;装饰方法：我是操作前逻辑&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.test();</span><br><span class="line">        System.out.println(<span class="string">&quot;装饰方法：我是操作后逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就通过装饰模式对类的功能进行了扩展：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaseImpl</span>();</span><br><span class="line">    <span class="type">Decorator</span> <span class="variable">decorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecoratorImpl</span>(base);  <span class="comment">//将Base实现装饰一下</span></span><br><span class="line">    <span class="type">Decorator</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecoratorImpl</span>(decorator);  <span class="comment">//装饰者还可以嵌套</span></span><br><span class="line">    decorator.test();</span><br><span class="line">    outer.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了装饰模式</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系，可以发现有很多的类，假如再增加几个形状或再增加一种颜色，就需要创建更多的类。在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p><p>桥接模式可以将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><p>例如需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//视频文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//avi文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVIFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;avi视频文件：&quot;</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmvb文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">REVBBFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rmvb文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作系统版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;<span class="comment">// 桥接：通过组合连接视频文件格式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OperatingSystemVersion</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Windows</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mac版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mac</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OperatingSystem</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>(<span class="keyword">new</span> <span class="title class_">AVIFile</span>());</span><br><span class="line">        os.play(<span class="string">&quot;视频&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统</p><p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当一个类存在多个独立变化的维度，且这些维度都需要进行扩展时</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系</li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p>外观模式是“迪米特法则”的典型应用</p><p>举例，小明每次起床时都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来比较麻烦。所以小明买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//灯类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能音箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartAppliancesFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartAppliancesFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        airCondition = <span class="keyword">new</span> <span class="title class_">AirCondition</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(message.contains(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            on();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(message.contains(<span class="string">&quot;关闭&quot;</span>)) &#123;</span><br><span class="line">            off();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//起床后一键开电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床了&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//睡觉一键关电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建外观对象</span></span><br><span class="line">        <span class="type">SmartAppliancesFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartAppliancesFacade</span>();</span><br><span class="line">        <span class="comment">//客户端直接与外观对象进行交互</span></span><br><span class="line">        facade.say(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">        facade.say(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处：</strong></p><p>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类</p><p>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易</p><p><strong>缺点：</strong></p><p>不符合开闭原则，修改麻烦</p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性</li></ul><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式又名部分整体模式，用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次，它创建了对象组的树形结构。</p><p>实际上就是将多个组件进行组合，让用户可以对它们进行一致性处理。比如我们的文件夹，一个文件夹中可以有很多个子文件夹或是文件。像一个树形结构一样，有分支有叶子，组合模式可以对整个树形结构上的所有节点进行递归处理。</p><p>举例，使用文件和文件夹例子：                    </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先创建一个组件抽象，组件可以包含组件，组件有自己的业务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span>;    <span class="comment">//添加子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span>;   <span class="comment">//删除子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span>;   <span class="comment">//获取子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;   <span class="comment">//执行对应的业务方法，比如修改文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写两种实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;   <span class="comment">//目录可以包含多个文件或目录</span></span><br><span class="line"></span><br><span class="line">    List&lt;Component&gt; child = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();   <span class="comment">//这里我们使用List来存放目录中的子组件</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> child.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称修改成功！&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">        child.forEach(Component::test);   <span class="comment">//将继续调用所有子组件的test方法执行业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;   <span class="comment">//文件就相当于是树叶</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();   <span class="comment">//不支持这些操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称修改成功！&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>();   <span class="comment">//新建一个外层目录</span></span><br><span class="line">    <span class="type">Directory</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>();   <span class="comment">//新建一个内层目录</span></span><br><span class="line">    outer.addComponent(inner);</span><br><span class="line">    outer.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());   <span class="comment">//在内层目录和外层目录都添加点文件</span></span><br><span class="line">    inner.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());</span><br><span class="line">    inner.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());</span><br><span class="line">    outer.test();    <span class="comment">//开始文件名称修改操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享原模式"><a href="#享原模式" class="headerlink" title="享原模式"></a>享原模式</h2><p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><p>举例，比如现在有两个服务都需要使用数据库操作，实际上这个工具类没必要创建多个，这时就可以使用享元模式，让数据库类作为享元类，通过享元工厂来提供一个共享的数据库工具类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectDB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtilFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DBUtil</span> <span class="variable">UTIL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBUtil</span>();   <span class="comment">//享元对象被存放在工厂中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DBUtil <span class="title function_">getFlyweight</span><span class="params">()</span>&#123;   <span class="comment">//获取享元对象</span></span><br><span class="line">        <span class="keyword">return</span> UTIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要使用享元对象时，调用享元工厂类：                 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DBUtil</span> <span class="variable">util</span> <span class="operator">=</span> DBUtilFactory.getFlyweight();</span><br><span class="line">        util.selectDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式——创建型模式</title>
      <link href="/inori/b8618489.html"/>
      <url>/inori/b8618489.html</url>
      
        <content type="html"><![CDATA[<p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p><p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><p>创建型模式分为：</p><ul><li>单例模式</li><li>工厂方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>即在整个程序中，同一个类始终只会有一个对象来进行操作。比如数据库连接类，实际上只需要创建一个对象或是直接使用静态方法就可以了，没必要去创建多个对象。</p><p>单例设计模式分类两种：</p><ul><li>饿汉式：类加载就会导致该单实例对象被创建</li><li>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</li></ul><p>饿汉式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> * 静态变量创建类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p><ul><li>懒汉式-方式1</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p><ul><li>懒汉式-方式2（双重检查锁）</li></ul><p>再来讨论一下懒汉模式中加锁的问题，对于<code>getInstance()</code>方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用<code>volatile</code>关键字, <code>volatile</code>关键字可以保证可见性和有序性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加<code>volatile</code>关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题</p><ul><li>懒汉式-方式3（静态内部类方式）</li></ul><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><p>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的。所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>需求：设计一个咖啡店点餐系统</p><p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;  <span class="comment">// 获取咖啡名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;     <span class="comment">// 准备咖啡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备美式咖啡：加水，加咖啡豆&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备拿铁咖啡：加牛奶，加咖啡豆&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过工厂创建咖啡对象</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> CoffeeFactory.createCoffee(type);</span><br><span class="line">        <span class="comment">// 准备咖啡</span></span><br><span class="line">        coffee.prepare();</span><br><span class="line">        <span class="comment">// 返回咖啡</span></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂（factory）处理创建对象的细节，一旦有了<code>SimpleCoffeeFactory</code>，<code>CoffeeStore</code>类中的<code>orderCoffee()</code>就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><p>利用对扩展开放，对修改关闭的性质，定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。改进：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;  <span class="comment">// 获取咖啡名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;     <span class="comment">// 准备咖啡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备美式咖啡：加水，加咖啡豆&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备拿铁咖啡：加牛奶，加咖啡豆&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;  <span class="comment">// 创建咖啡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory coffeeFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeStore</span><span class="params">(CoffeeFactory coffeeFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coffeeFactory = coffeeFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过工厂创建咖啡对象</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> coffeeFactory.createCoffee();</span><br><span class="line">        <span class="comment">// 准备咖啡</span></span><br><span class="line">        coffee.prepare();</span><br><span class="line">        <span class="comment">// 返回咖啡</span></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程，并且在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则。</p><p>但是这种方法每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机等。</p><p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p>抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p><p><img src="/inori/b8618489/project.png" alt="project"></p><p>假设上面案例中，咖啡工厂不止生成咖啡，还生产甜点，我们可以用抽象工厂模式扩展：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CafeFactory</span> &#123;</span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;  <span class="comment">// 创建咖啡</span></span><br><span class="line">    Dessert <span class="title function_">createDessert</span><span class="params">()</span>; <span class="comment">// 创建甜点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCafeFactory</span> <span class="keyword">implements</span> <span class="title class_">CafeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cake</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCafeFactory</span> <span class="keyword">implements</span> <span class="title class_">CafeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pudding</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stone类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CafeFactory cafeFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeStore</span><span class="params">(CafeFactory cafeFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cafeFactory = cafeFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> cafeFactory.createCoffee();</span><br><span class="line">        coffee.prepare();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">orderDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Dessert</span> <span class="variable">dessert</span> <span class="operator">=</span> cafeFactory.createDessert();</span><br><span class="line">        dessert.serve();</span><br><span class="line">        <span class="keyword">return</span> dessert;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。这样当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p>缺点是当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象</p><p>原型模式的克隆分为浅克隆和深克隆。</p><blockquote><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址</p><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址</p></blockquote><p>Java中的Object类中提供了 <code>clone()</code>方法来实现浅克隆。 Cloneable接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。举例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    Address(String city) &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    Person(String name, Address address) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, address);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.address.city); <span class="comment">// 输出: Beijing</span></span><br><span class="line">        System.out.println(person2.address.city); <span class="comment">// 输出: Beijing</span></span><br><span class="line"></span><br><span class="line">        person2.address.city = <span class="string">&quot;Shanghai&quot;</span>; <span class="comment">// 修改 person2 的地址</span></span><br><span class="line">        System.out.println(person1.address.city); <span class="comment">// 输出: Shanghai（person1 也受到影响）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这两者不是同一对象，但是这两者指向的对象是同一个，修改任意一方的数据，对另一方也生效。</p><p>深克隆就需要把克隆对象的内部字段也克隆一遍：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    Address(String city) &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    Person(String name, Address address) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">cloned</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            cloned.address = <span class="built_in">this</span>.address.clone(); <span class="comment">// 递归克隆引用类型字段</span></span><br><span class="line">            <span class="keyword">return</span> cloned;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, address);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.address.city); <span class="comment">// 输出: Beijing</span></span><br><span class="line">        System.out.println(person2.address.city); <span class="comment">// 输出: Beijing</span></span><br><span class="line"></span><br><span class="line">        person2.address.city = <span class="string">&quot;Shanghai&quot;</span>; <span class="comment">// 修改 person2 的地址</span></span><br><span class="line">        System.out.println(person1.address.city); <span class="comment">// 输出: Beijing（person1 不受影响）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示，适用于某个对象的构建过程复杂的情况</p><ul><li>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象</li><li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用</li><li>可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节</li></ul><p>举例，假如有一个学生类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">    String name;</span><br><span class="line">    String college;</span><br><span class="line">    String profession;</span><br><span class="line">    List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, <span class="type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.college = college;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">        <span class="built_in">this</span>.awards = awards;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们通过new去创建：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot;计算机科学与技术&quot;</span>, Arrays.asList(<span class="string">&quot;A奖&quot;</span>, <span class="string">&quot;B奖&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，光是填参数就非常麻烦，这种情况下就可以使用建造者模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 使用建造者来创建，不对外直接开放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, <span class="type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentBuilder <span class="title function_">builder</span><span class="params">()</span>&#123;   <span class="comment">//通过builder方法直接获取建造者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentBuilder</span>&#123;   <span class="comment">// 创建内部类</span></span><br><span class="line">        <span class="comment">// Builder也需要将所有的参数都进行暂时保存，所以Student怎么定义的这里就怎么定义</span></span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> grade;</span><br><span class="line">        String name;</span><br><span class="line">        String college;</span><br><span class="line">        String profession;</span><br><span class="line">        List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">id</span><span class="params">(<span class="type">int</span> id)</span>&#123;    <span class="comment">//直接调用建造者对应的方法，为对应的属性赋值</span></span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;   <span class="comment">//为了支持链式调用，这里直接返回建造者本身，下同</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">awards</span><span class="params">(String... awards)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.awards = Arrays.asList(awards);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">build</span><span class="params">()</span>&#123;    <span class="comment">//最后我们只需要调用建造者提供的build方法即可根据我们的配置返回一个对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(id, age, grade, name, college, profession, awards);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们就可以使用建造者来为我们生成对象了：                     </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder()   <span class="comment">//获取建造者</span></span><br><span class="line">            .id(<span class="number">1</span>)    <span class="comment">//逐步配置各个参数</span></span><br><span class="line">            .age(<span class="number">18</span>)</span><br><span class="line">            .grade(<span class="number">3</span>)</span><br><span class="line">            .name(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">            .awards(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">            .build();   <span class="comment">//最后直接建造我们想要的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以让这些参数对号入座了，并且也比之前的方式优雅许多。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式——设计原则</title>
      <link href="/inori/4c95ffe2.html"/>
      <url>/inori/4c95ffe2.html</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><ul><li><p><strong>创建型模式</strong></p><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。含有单例、原型、工厂方法、抽象工厂、建造者5种创建型模式</p></li><li><p><strong>结构型模式</strong></p><p>用于描述如何将类或对象按某种布局组成更大的结构，即类或对象的组合，含有代理、适配器、桥接、装饰、外观、享元、组合7种结构型模式</p></li><li><p><strong>行为型模式</strong></p><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责，即类或对象之间的交互和通信。含有模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器11种行为型模式</p></li></ul><table><thead><tr><th align="center"><strong>类别</strong></th><th align="center"><strong>模式</strong></th><th align="center"><strong>核心思想</strong></th><th align="center"><strong>典型应用场景</strong></th></tr></thead><tbody><tr><td align="center"><strong>创建型</strong></td><td align="center">单例模式</td><td align="center">确保一个类只有一个实例</td><td align="center">全局唯一对象（如配置管理器）</td></tr><tr><td align="center"></td><td align="center">工厂方法模式</td><td align="center">由子类决定实例化哪个类</td><td align="center">框架中对象的创建</td></tr><tr><td align="center"></td><td align="center">抽象工厂模式</td><td align="center">创建相关对象的家族</td><td align="center">跨平台的 UI 组件库</td></tr><tr><td align="center"></td><td align="center">建造者模式</td><td align="center">分离复杂对象的构建与表示</td><td align="center">复杂对象的创建（如 HTML 文档生成器）</td></tr><tr><td align="center"></td><td align="center">原型模式</td><td align="center">通过复制现有对象创建新对象</td><td align="center">对象的创建成本较高时</td></tr><tr><td align="center"><strong>结构型</strong></td><td align="center">适配器模式</td><td align="center">将一个接口转换成客户端期望的另一个接口</td><td align="center">兼容旧系统、第三方库的集成</td></tr><tr><td align="center"></td><td align="center">桥接模式</td><td align="center">将抽象与实现分离</td><td align="center">多维度的类扩展（如形状和颜色）</td></tr><tr><td align="center"></td><td align="center">组合模式</td><td align="center">表示“部分-整体”的层次结构</td><td align="center">文件系统、UI 组件树</td></tr><tr><td align="center"></td><td align="center">装饰器模式</td><td align="center">动态地给对象添加额外的职责</td><td align="center">动态扩展对象功能（如 Java I&#x2F;O 流）</td></tr><tr><td align="center"></td><td align="center">外观模式</td><td align="center">提供一个统一的接口访问子系统</td><td align="center">简化复杂系统的调用</td></tr><tr><td align="center"></td><td align="center">享元模式</td><td align="center">通过共享技术支持大量细粒度对象</td><td align="center">文本编辑器中的字符对象</td></tr><tr><td align="center"></td><td align="center">代理模式</td><td align="center">控制对其他对象的访问</td><td align="center">远程代理、虚拟代理</td></tr><tr><td align="center"><strong>行为型</strong></td><td align="center">责任链模式</td><td align="center">解耦请求的发送者和接收者</td><td align="center">审批流程、异常处理</td></tr><tr><td align="center"></td><td align="center">命令模式</td><td align="center">将请求封装为对象</td><td align="center">撤销操作、任务队列</td></tr><tr><td align="center"></td><td align="center">解释器模式</td><td align="center">定义语言的文法并解释句子</td><td align="center">编译器、正则表达式</td></tr><tr><td align="center"></td><td align="center">迭代器模式</td><td align="center">顺序访问聚合对象中的元素</td><td align="center">集合类的遍历</td></tr><tr><td align="center"></td><td align="center">中介者模式</td><td align="center">封装一系列对象的交互</td><td align="center">聊天室、GUI 组件交互</td></tr><tr><td align="center"></td><td align="center">备忘录模式</td><td align="center">捕获并外部化对象的内部状态</td><td align="center">撤销操作、游戏存档</td></tr><tr><td align="center"></td><td align="center">观察者模式</td><td align="center">定义对象间的一对多依赖关系</td><td align="center">事件驱动系统、MVC 框架</td></tr><tr><td align="center"></td><td align="center">状态模式</td><td align="center">允许对象在其内部状态改变时改变其行为</td><td align="center">订单状态机、游戏角色状态</td></tr><tr><td align="center"></td><td align="center">策略模式</td><td align="center">定义一系列可互换的算法</td><td align="center">排序算法、支付方式</td></tr><tr><td align="center"></td><td align="center">模板方法模式</td><td align="center">定义算法的框架，将一些步骤延迟到子类中</td><td align="center">框架中的钩子方法</td></tr><tr><td align="center"></td><td align="center">访问者模式</td><td align="center">在不改变元素类的前提下定义作用于这些元素的新操作</td><td align="center">编译器中的语法树操作</td></tr></tbody></table><h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，要尽量根据7条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则（Simple Responsibility Pinciple，SRP）是最简单的面向对象设计原则，它用于控制类的粒度大小。该原则要求一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String email, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 发送邮件逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>User</code>类承担了登录和发送邮件两个职责，如果登录逻辑或邮件发送逻辑需要修改，都需要修改<code>User</code>类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String email, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 发送邮件逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>User</code>类的职责分离为两个类：<code>User</code>负责登录，<code>EmailSender</code>负责发送邮件，这样就符合了单一职责原则</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><p>简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们需要使用接口和抽象类。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>比如银行有农业银行，交通银行，建设银行等，而他们都是银行，而具体是什么银行则是另外一回事，我们可以将银行抽象成一个统一的接口或是抽象类，这样我们就满足了开闭原则的第一个要求：对扩展开放；不同的银行可以自由地决定他们的业务。而具体哪个银行开设了哪种业务，不需要其他银行干涉，所以满足第二个要求：对修改关闭</p><h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p>任何基类可以出现的地方，子类一定可以出现。通俗理解：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大</p><p>比如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = width; <span class="comment">// 修改了父类的行为</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = height; <span class="comment">// 修改了父类的行为</span></span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Square</code> 类修改了 <code>Rectangle</code> 类的行为（设置宽高时强制宽高相等），导致 <code>Square</code> 无法替换 <code>Rectangle</code></p><p>修正:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> side;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSide</span><span class="params">(<span class="type">int</span> side)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.side = side;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> side * side;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Square</code>和<code>Rectangle</code>都继承自<code>Shape</code>，但各自实现自己的行为，互不影响</p><p>里氏替换也是实现开闭原则的重要方式之一</p><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合</p><p>举例，在Spring之前，我们的业务实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//CRUD...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserMapper</span>();</span><br><span class="line">        <span class="comment">//业务....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">//业务....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果业务需求变化，Service变化，就会导致Controller层也发生变化，</p><p>有Spring框架之后，我们的开发模式变为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//CRUD定义</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//CRUD</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">        <span class="comment">//业务定义....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">        <span class="meta">@Resource</span>   <span class="comment">//现在由Spring来为我们选择一个指定的实现类，然后注入，而不是由我们在类中硬编码进行指定</span></span><br><span class="line">        UserMapper mapper;</span><br><span class="line">        <span class="comment">//业务...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        <span class="meta">@Resource</span></span><br><span class="line">        UserService service;   <span class="comment">//直接使用接口</span></span><br><span class="line">        <span class="comment">//业务...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上</p><p>举例，我们需要创建一个A品牌的保险箱，该保险箱具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SafetyBox</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASafetyBox</span> <span class="keyword">implements</span> <span class="title class_">SafetyBox</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个B品牌的安全门，而该安全门只具有防盗、防水功能，很显然如果实现SafetyBox接口就违背了接口隔离原则，改正后代码如下：</p><p><strong>AntiTheft（接口）：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AntiTheft</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Fireproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fireproof</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Waterproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Waterproof</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ASafetyBox（类）：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASafetyBox</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>,Fireproof,Waterproof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BSafetyBox（类）：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSafetyBox</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>,Fireproof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p><strong>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong>。</p><p>通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>举例，B类需要使用A类中的某些功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AFunction</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;    <span class="comment">//直接通过继承的方式，得到A的逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是B的方法，我需要A&quot;</span>);</span><br><span class="line">        AFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这样看起来可行，但是耦合度太高了</p><p>可以看到通过继承的方式实现复用，我们是将类B直接指定继承自类A的，那么如果有一天，由于业务的更改，现有业务不再由A来负责，而是由新来的C去负责，那么这个时候，我们就不得不将需要复用A中方法的子类全部进行修改。并且还有一个问题就是，通过继承子类会得到一些父类中的实现细节，比如某些字段或是方法，这样直接暴露给子类，并不安全。</p><p>所以，我们要实现复用时，可以优先考虑引入一个A参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AFunction</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span>&#123;   <span class="comment">//在构造时指定</span></span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是B的方法，我需要A&quot;</span>);</span><br><span class="line">        a.AFunction();   <span class="comment">//通过对象A去执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则又叫最少知识原则，是对程序内部数据交互的限制。</p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的直接通信对象是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>简单来说就是，一个类&#x2F;模块对其他的类&#x2F;模块有越少的交互越好。当一个类发生改动，那么，与其相关的类（比如用到此类啥方法的类）需要尽可能少的受影响（比如修改了方法名、字段名等，可能其他用到这些方法或是字段的类也需要跟着修改）这样我们在维护项目的时候会更加轻松一些。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployeeCity</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        <span class="comment">// 违反迪米特法则：与间接对象通信</span></span><br><span class="line">        System.out.println(employee.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Company</code> 类通过 <code>Employee</code> 对象间接访问了 <code>Address</code> 对象，违反了迪米特法则</p><p>可以使用中介对象获取信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Employee employee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.employee = employee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployeeCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过中介对象 Employee 获取信息</span></span><br><span class="line">        System.out.println(employee.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Company</code> 通过中介对象 <code>Employee</code> 获取 <code>Address</code> 的信息，减少直接依赖</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis内存回收</title>
      <link href="/inori/228807ea.html"/>
      <url>/inori/228807ea.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis内存回收机制"><a href="#Redis内存回收机制" class="headerlink" title="Redis内存回收机制"></a>Redis内存回收机制</h1><p>Redis中的内存策略主要包含下列四点：</p><ol><li>内存清除策略（Eviction Policy）：当Redis内存空间不足时，会根据特定的算法删除一些key来释放内存。其中，常用的算法有LRU（最少最近使用）、LFU（最少使用频率）和随机算法</li><li>内存淘汰策略（Expiration）：在插入或更新key的时候，可以指定key的过期时间（expire）时间。过期后，Redis会自动将key删除，释放内存</li><li>内存回收策略（Memory Reclamation）：在使用Redis时，可能会因为未正确释放内存而导致内存泄漏。Redis针对这种情况实现了自动内存回收机制来防止内存泄漏的问题</li><li>内存优化策略（Memory Optimization）：Redis提供了各种内存优化策略，例如使用压缩（压缩整数值、压缩非常短的字符串）、使用哈希对象来优化内存使用等，以最大限度地减少内存使用。Redis也使用专门的数据结构来实现某些特定的数据类型，例如基数计数器和位数组，这些也是为了优化内存使用而设计的</li></ol><h2 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h2><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：Key过期策略.可以通过<code>expire key 5</code>命令（设置TTL为5秒）给Redis的key设置TTL（存活时间），当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。</p><h3 id="Redis如何Key是否过期"><a href="#Redis如何Key是否过期" class="headerlink" title="Redis如何Key是否过期"></a>Redis如何Key是否过期</h3><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在Dict结构中</p><p>Redis判断一个key是否过期：<strong>在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    dict *dict;<span class="comment">/*存放所有key及value，也被称为keyspace*/</span></span><br><span class="line">    dict *expires;<span class="comment">/*存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key*/</span></span><br><span class="line">    dict *blocking_keys;<span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;<span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;<span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="type">int</span> id;<span class="comment">/* Database ID, 0~15 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;<span class="comment">/*记录平均TTL时长*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires_cursor;<span class="comment">/*expire检查时在dict中抽样的索引|位置*/</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;<span class="comment">/*等待碎片整理的key列表*/</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h3 id="TTL到期后的删除策略"><a href="#TTL到期后的删除策略" class="headerlink" title="TTL到期后的删除策略"></a>TTL到期后的删除策略</h3><p><strong>惰性删除</strong>：并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。也就是在增删改查的时候才会去检查这个key去判断这个key是否有过期</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找一个key执行写操作</span></span><br><span class="line">robj *<span class="title function_">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span>&#123;</span><br><span class="line">    <span class="comment">// 检查key是否过期</span></span><br><span class="line">    expirelfNeeded(db, key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找一个key执行读操作</span></span><br><span class="line">robj *<span class="title function_">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    robj *val;</span><br><span class="line">    <span class="comment">// 检查key是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (expirelfNeeded(db,key) == <span class="number">1</span>) (</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expirelfNeeded</span><span class="params">(redisDb *db, robj *key)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否过期，如果未过期直接结束并返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!keylsExpired(db,key)) <span class="keyword">return</span> O;</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">    <span class="comment">// 删除过期key</span></span><br><span class="line">    deleteExpiredKeyAndPropagate(db,key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>周期删除</strong>：通过一个定时任务，周期性的抽样部分过期的key，执行删除，执行周期有两种：</p><ol><li>在Redis服务初始化函数initServer()中设置定时任务serverCron()，按照server.hz的频率来执行过期key清理，模式为SLOW</li><li>在Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</li></ol><p>SLOW模式：</p><ul><li>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</li><li>执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</li><li>逐个遍历db，逐个遍历db中的bucket（可以理解为hash列表中的每个下标），抽取20个key判断是否过期</li><li>如果没达到时间上限（25ms）并且过期key比例大于10%(就是过期的key和数据库中总的key进行对比)，再进行一次抽样，否则结束</li></ul><p>FAST模式规则（过期key比例小于10%不执行）：</p><ul><li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li><li>执行清理耗时不超过1ms</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期，如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果服务器设置了server.maxmemory属性，并且没有执行lua脚本</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="comment">//尝试进行内存淘汰performEvictions</span></span><br><span class="line">        <span class="type">int</span> out_of_memory = (performEvictions()) == EVICT_FAIL);</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis支持8种不同策略来选择要删除的key：</p><ol><li>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略</li><li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</li><li>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选</li><li>allkeys-lru： 对全体key，基于LRU算法进行淘汰</li><li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</li><li>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰。</li><li>LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高</li><li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高</li></ol><p>之前记录过的RedisObject：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type: <span class="number">4</span>;<span class="comment">//对象类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding: <span class="number">4</span>; <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">unsigned</span> lru: LRU_BITS;<span class="comment">//LRU:以秒为单位记录最近一次访问时间，长度24bit</span></span><br><span class="line">    <span class="comment">//LFU：高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数</span></span><br><span class="line">    <span class="type">int</span> refcount;<span class="comment">//引用计数，计数为0则可以回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;<span class="comment">//数据指针，指向真实数据</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p><ol><li>生成0~1之间的随机数R</li><li>计算旧次数*lfu_log_factor+1&#96;，记录为P</li><li>如果R&lt;P ，则计数器+1，且最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间每隔<code>lfu_decay_time</code>分钟，计数器-1</li></ol><blockquote><p>当Redis使用的内存超出maxmemory设置时，会根据指定的淘汰策略在键空间中选择要删除的键值对。在删除键值对时，Redis会先检查该键值对是否在使用中（例如，有没有客户端正在访问该键值对），然后再根据具体的淘汰策略选择一个待删除的键值对，并将其从缓存中清除。</p></blockquote><p><img src="/inori/228807ea/Blog\source\img\elimination.png" alt="elimination"></p><p>如果把redis全部的key都拿出来进行比较再淘汰，消耗的时间就会大大的增加。所以这里就引入了一个叫<code>eviction_pool</code>（驱逐池）它会抽取的一些样本，将样本放到池子里，再去比较看看谁应该被淘汰，这里<code>maxmemory_samples</code>默认值是5，但是策略不同淘汰的方式不同，这样实现就会比较麻烦所以这里进行了统一，就是按照key其中的某一个值的升序排列，值越大的优先淘汰</p><p>例如LFU最少频率使用，使用的越少就应该越早被淘汰，但是是升序排列的，那么就用255-LFU计算，LFU越少255-LFU就越大越应该被淘汰</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis网络模型</title>
      <link href="/inori/e34c024b.html"/>
      <url>/inori/e34c024b.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux网络模型"><a href="#Linux网络模型" class="headerlink" title="Linux网络模型"></a>Linux网络模型</h1><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p><ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>信号驱动IO（Signal Driven IO）</li><li>异步IO（Asynchronous IO）</li></ul><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p><p><img src="/inori/e34c024b/redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%5CBlocking_IO.png" alt="Blocking_IO"></p><p>用户去读取数据时，会去先发起recvform一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO</p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程</p><p>阶段一：</p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户进程</li><li>用户进程拿到error后，再次尝试读取</li><li>循环往复，直到数据就绪</li></ul><p>阶段二：</p><ul><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li></ul><p>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增</p><p><img src="/inori/e34c024b/redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%5CNonblocking_IO.png" alt="Nonblocking_IO"></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p><ul><li>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用</li><li>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</li></ul><p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能表现很差</p><p>想要提高IO事件效率，可以使用多线程，或者即时通知（哪个数据就绪，用户进程就读取这个数据）</p><p>那么用户进程如何知道内核中数据是否就绪呢？</p><p>这个问题的解决依赖于提出的文件描述符。</p><p>文件描述符（File Descriptor）：简称FD，是一个从0开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）</p><p>通过FD，我们的网络模型可以利用一个线程监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源</p><p>用IO复用模式，可以确保去读数据的时候，数据是一定存在的，他的效率比原来的阻塞IO和非阻塞IO性能都要高</p><p>IO多路复用即线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：</p><ol><li>select</li><li>poll</li><li>epoll</li></ol><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select是Linux最早是由的I&#x2F;O多路复用技术。</p><p>具体可以描述为：我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据</p><p>比如要监听的数据，是1,2,5三个数据，此时会执行select函数，然后将整个fd发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再将处理掉没有准备好的数据，最后再将这个FD集合写回到用户态中去，此时用户态就知道有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点，再去发起读请求</p><p>seletc模式存在的问题：</p><ul><li>需要将整个fd_set用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</li><li>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</li><li>fd_set监听的fd数量不能超过1024</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll模式对select模式做了简单改进，但性能提升不明显，IO流程：</p><ol><li>创建pollfd数组，向其中添加关注的fd信息，<strong>数组大小自定义</strong></li><li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历fd，判断是否就绪</li><li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li><li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd</li></ol><p>与select对比：</p><ul><li><p>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</p></li><li><p>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</p></li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll模式是对select和poll的改进，它提供了三个函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span><span class="comment">// 一颗红黑树，记录要监听的FD</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span><span class="comment">// 一个链表，记录就绪的FD</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个epoll实例,内部是event poll，返回对应的句柄epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将一个FD添加到epoll的红黑树中，并设置ep_pollL_callback</span></span><br><span class="line"><span class="comment">// callback触发时，就把对应的FD加入到rdlist这个就绪列表中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd; <span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> op;<span class="comment">//要执行的操作，包括：ADD、MOD、DEL</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> fd; <span class="comment">//要监听的FD</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *event;<span class="comment">//要监听的事件类型:读、写、异常等</span></span></span><br><span class="line"><span class="params">&#125;;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 3.检查rdlist列表是否为空，不为空则返回就绪的FD的数量</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> epoll_wait(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd;<span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *events;<span class="comment">//空event数组，用于接收就绪的FD</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents;<span class="comment">//events数组的最大长度</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout;<span class="comment">// 超时时间，-1用不超时，0不阻塞；大于0为阻塞时间</span></span></span><br><span class="line"><span class="params">&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>使用epoll_create创建epoll实例</li><li>紧接着调用epoll_ctl操作，将要监听的数据添加到红黑树上去，并且给每个fd设置一个监听函数，这个函数会在fd数据就绪时触发，把fd数据添加到list_head中去，epoll_ctl中的epfd表明要将监听的fd添加到eventepoll中</li><li>使用epoll_wait等待fd就绪，在用户态创建一个空的events数组，当就绪之后，我们的回调函数会把数据添加到list_head中去，当调用这个函数的时候，会去检查list_head，如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将数据放入到events数组中，并且返回对应的操作的数量</li><li>用户态的此时收到响应后，从events中拿到对应准备好的数据的节点，再去调用方法去拿数据</li></ol><h4 id="epoll中的事件通知模式"><a href="#epoll中的事件通知模式" class="headerlink" title="epoll中的事件通知模式"></a>epoll中的事件通知模式</h4><p>当FD有数据可读时，我们调用epoll_wait可以得到通知。但是事件通知的模式有两种：</p><ul><li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li><li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li></ul><p>假设一个客户端socket对应的FD已经注册到了epoll实例中，客户端socket发送了2kb的数据，服务端调用epoll_wait，得到通知说FD就绪，服务端从FD读取了1kb数据</p><ul><li>如果我们采用LT模式，因为FD中仍有1kb数据，调用epoll_wait依然会返回结果，并且得到通知</li><li>如果我们采用ET模式，因为已经消费了FD可读事件，后续FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时</li></ul><table><thead><tr><th><strong>特性</strong></th><th><strong>LT 模式</strong></th><th><strong>ET 模式</strong></th></tr></thead><tbody><tr><td><strong>触发条件</strong></td><td>只要条件满足，持续通知。</td><td>只有状态变化时通知一次。</td></tr><tr><td><strong>通知频率</strong></td><td>高</td><td>低</td></tr><tr><td><strong>性能</strong></td><td>较低，适合低并发场景。</td><td>较高，适合高并发场景。</td></tr><tr><td><strong>编程复杂度</strong></td><td>简单，无需担心事件丢失。</td><td>复杂，需要确保一次性处理完数据。</td></tr><tr><td><strong>适用场景</strong></td><td>简单的 I&#x2F;O 操作或初学者。</td><td>高并发、高性能的网络服务器。</td></tr></tbody></table><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>流程：</p><ol><li>用户进程调用sigaction，注册信号处理函数</li><li>内核返回成功，开始监听FD</li><li>用户进程不阻塞等待，可以执行其它业务</li><li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li><li>收到SIGIO回调信号后，用户进程调用recvfrom，读取</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ol><p>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p><p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态</p><p><img src="/inori/e34c024b/redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%5CasyncIO.png" alt="asyncIO"></p><p>异步IO避免了同步I&#x2F;O中的等待时间，提高了CPU和I&#x2F;O设备的利用率，但是这种方式对内核的负载很大，在高并发场景下可能会因为内存占用过多出现崩溃现象。如果要使用必须要做并发访问的限流</p><h1 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h1><p><strong>Redis到底是单线程还是多线程？</strong></p><ul><li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li><li>如果是聊整个Redis，那么答案是多线程</li></ul><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redis v4.0：引入多线程异步处理一些耗时较久的任务，例如异步删除命令unlink</li><li>Redis v6.0 ：在核心网络模型中引入多线程，进一步提高对多核cpu的利用率</li></ul><p>因此，对于Redis的核心网络模型，在Redis6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况</p><p><strong>为什么Redis要选择单线程？</strong></p><ul><li>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能会降低</li></ul><h2 id="Redis单线程网络模型执行流程"><a href="#Redis单线程网络模型执行流程" class="headerlink" title="Redis单线程网络模型执行流程"></a>Redis单线程网络模型执行流程</h2><ol><li>监听端口：Redis服务器开始监听指定的端口，等待客户端连接。</li><li>接收客户端连接：当有客户端请求连接到Redis服务器时，服务器会接受连接请求，并创建一个客户端套接字，用于与客户端通信。</li><li>接收命令：一旦客户端与服务器建立连接，客户端可以发送命令请求到服务器。Redis服务器通过套接字接收到客户端发送的命令。</li><li>命令解析：服务器会对接收到的命令进行解析，以确定客户端请求的具体操作。</li><li>执行命令：根据解析的结果，服务器会执行相应的命令操作。由于Redis使用单线程模型，每个命令都会按顺序依次执行，不会并发执行。</li><li>数据读写：在执行命令期间，如果需要读取或修改数据，服务器会从内存中读取数据或将修改后的数据写回内存。</li><li>命令回复：执行完命令后，服务器会将执行结果封装为响应，并通过套接字发送回客户端。</li><li>关闭连接：命令执行完成后，服务器会关闭与客户端的连接，等待下一个连接请求</li></ol><p><img src="/inori/e34c024b/redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%5Credis_netModel.png" alt="redis_netModel"></p><h3 id="多线程改进"><a href="#多线程改进" class="headerlink" title="多线程改进"></a>多线程改进</h3><p>由于影响网络模型速率的是IO操作，所以可以在命令请求处理器的请求数据写入部分使用多线程和将数据写入buf或reply部分使用多线程来提高速度</p><h1 id="Redis通信协议"><a href="#Redis通信协议" class="headerlink" title="Redis通信协议"></a>Redis通信协议</h1><p>Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p><ol><li>客户端（client）向服务端（server）发送一条命令</li><li>服务端解析并执行命令，返回响应结果给客户端</li></ol><p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p><p>而在Redis中采用的是RESP（Redis Serialization Protocol）协议：</p><ol><li>Redis 1.2版本引入了RESP协议</li><li>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</li><li>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存</li></ol><p>但目前，默认使用的依然是RESP2协议。</p><p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p><ol><li>单行字符串：首字节是 <code>&#39;+&#39;</code> ，后面跟上单行字符串，以CRLF（ <code>&quot;\r\n&quot;</code> ）结尾。例如返回”OK”： <code>&quot;+OK\r\n&quot;</code></li><li>错误（Errors）：首字节是 <code>&#39;-&#39; </code>，与单行字符串格式一样，只是字符串是异常信息，例如：<code>&quot;-Error message\r\n&quot;</code></li><li>数值：首字节是 <code>&#39;:&#39; </code>，后面跟上数字格式的字符串，以CRLF结尾。例如：<code>&quot;:10\r\n&quot;</code></li><li>多行字符串：首字节是 <code>&#39;$&#39;</code> ，表示二进制安全的字符串，最大支持512MB：<ol><li>如果大小为0，则代表空字符串：<code>&quot;$0\r\n\r\n&quot;</code></li><li>如果大小为-1，则代表不存在：<code>&quot;$-1\r\n&quot;</code></li></ol></li><li>数组：首字节是 <code>&#39;*&#39;</code>， 后面跟上数组元素个数，再跟上元素，元素数据类型不限，如：</li></ol><blockquote><p>*3\r\n</p><p>:10\r\n</p><p>$5\r\nhello\r\n</p><p>*2\r\n$3\r\nage\r\n:10\r\n</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构</title>
      <link href="/inori/abcb1f8f.html"/>
      <url>/inori/abcb1f8f.html</url>
      
        <content type="html"><![CDATA[<h2 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h2><p>Redis中保存的key是字符串，value往往是字符串或者字符串的集合。可以说字符串是Redis中最常见的数据结构。</p><p>不过Redis中没有直接使用C语言中的字符串，而是构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String）。</p><p>比如我们执行命令<code>set name Jack</code>，那么Redis将在底层创建两个SDS，其中一个是包含<code>name</code>的SDS，另一个是包含<code>Jack</code>的SDS。</p><p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len;<span class="comment">// buf已保存的字符串字节数，不包含结束标示\0</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc;<span class="comment">// buf申请的总字节数，不包含结束标示\0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;<span class="comment">// 不同的SDS的头类型，用来控制SDS头大小</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>flag对应的种类有五五种</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_8 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_64 4</span></span><br></pre></td></tr></table></figure><p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如有一个内容为<code>abc</code>的SDS，其中<code>len=2,alloc=2,flag=1,h,i,\0</code>，我们要给他追加一段字符串<code>defgh</code>，首先会申请新的内存空间：</p><ul><li>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1</li><li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1</li></ul><p><strong>动态字符串优点</strong>：</p><ol><li>获取字符串长度的时间复杂度为0(1)[因为长度已经存在于结构体中]</li><li>支持动态扩容</li><li>减少内存分配次数</li><li>二进制安全（可以存储特殊字符，无需考虑结束符的问题）</li></ol><h2 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h2><p>Redis为了优化内存和性能，会根据Set中元素的特性自动选择底层实现：</p><ol><li>所有元素都是整数</li><li>元素数量不超过配置的阈值</li></ol><ul><li>Redis配置项<code>set-max-intset-entries</code>定义了IntSet的最大元素数量，默认值为512</li><li>如果元素数量超过该阈值，Redis 会将IntSet转换为HashTable</li></ul><p>IntSet基于整数数组来实现，具备长度可变，有序（便于查找）等特性。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding; <span class="comment">// 编码方式（int16_t、int32_t、int64_t）</span></span><br><span class="line">    <span class="type">uint32_t</span> length;   <span class="comment">// 集合中元素的数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];  <span class="comment">// 存储整数的数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>其中的encoding包含三种模式，表示存储的整数大小不同：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))<span class="comment">/*2字节整数,范围类似java的short */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))<span class="comment">/* 4字节整数,范围类似java的int */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))<span class="comment">/* 8字节整数,范围类似java的long */</span></span></span><br></pre></td></tr></table></figure><p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，内部结构类似于<code>encoding:INTSET_ENC_INT16,length:3,5,10,15</code>。</p><blockquote><p>寻址公式：startPtr【开始的起始地址为0】+（sizeof(int16) 【数据类型的字节大小】* index【它对应的下标】）就可以快速找到对应的数据</p></blockquote><h3 id="IntSet升级"><a href="#IntSet升级" class="headerlink" title="IntSet升级"></a>IntSet升级</h3><p>现在，假设有一个intset,元素为{5,10,20}，采用的编码为INTSET_ENC_INT16，则每个整数占2字节。如果现在我想添加50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。</p><p>以当前案例来说流程如下：</p><ol><li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li><li>倒序依次将数组中的元素拷贝到扩容后的正确位置（倒叙放是为了防止字节扩大时将后面的数据给覆盖掉）</li><li>将待添加的元素放入数组末尾</li><li>将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li></ol><p>如果插入的元素位于IntSet中间或者开头，底层会使用二分查找确定插入位置，然后再执行移动和插入操作。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>IntSet可以看做是特殊的整数数组</li></ul><ul><li>IntSet中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><p>Redis是一个键值型的数据库，我们可以根据键实现快速的增删改查，而键与值的映射关系正是通过Dict来实现的</p><p>Dict由三部分组成：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>每个哈希表由数个entry组成，每个桶是一个链表，用于解决哈希冲突</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      <span class="comment">// entry数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;     <span class="comment">// 哈希表的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">// 用于计算索引的掩码（size - 1）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;     <span class="comment">// 已使用的entry数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><h3 id="哈希节点"><a href="#哈希节点" class="headerlink" title="哈希节点"></a>哈希节点</h3><p>每个键值对存储在一个 <code>dictEntry</code> 结构中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;              <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;          <span class="comment">// 值</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个节点（解决哈希冲突）</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h3 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h3><p>Dict 包含两个哈希表（<code>ht[0]</code>和<code>ht[1]</code>），以及Rehash相关的状态信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;         <span class="comment">// dict类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;         <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht;          <span class="comment">// 两个哈希表，一个是当前数据，另一个一般是空，rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx;         <span class="comment">// Rehash 的进度（-1 表示未进行 Rehash）</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash;<span class="comment">// rehash是否暂停，1表示暂停，0则继续</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用<code>h&amp;sizemask</code>来计算元素应该存储到数组中的哪个索引位置。我们存储k1&#x3D;v1，假设k1的哈希值h&#x3D;1，则1&amp;3&#x3D;1，因此k1&#x3D;v1要存储到数组角标1位置，键值对内部结构使用的是链表，新插入的节点使用的是头插法。</p><h3 id="Dict的扩容和收缩"><a href="#Dict的扩容和收缩" class="headerlink" title="Dict的扩容和收缩"></a>Dict的扩容和收缩</h3><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p><p>Dict在每次新增键值对时都会检查负载因子（<code>LoadFactor = used/size</code>），满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的LoadFactor &gt;&#x3D; 1，并且服务器没有执行BGSAVE或者BGREWRITEAOF等后台进程（因为这种操作对性能要求高，如果我再进行rehash的操作就可能导致阻塞）</li><li>哈希表的LoadFactor &gt; 5</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 检查是否需要扩容 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d) &#123;</span><br><span class="line">    <span class="comment">// 如果正在进行 Rehash，则不需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    <span class="comment">// 如果哈希表为空，则初始化为默认大小（4）</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht.size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果负载因子超过1并且没有进行bgrewrite等子进程操作，则触发扩容</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht.used &gt;= d-&gt;ht.size &amp;&amp;</span><br><span class="line">        (dict_can_resize || d-&gt;ht.used/d-&gt;ht.size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当哈希表的负载因子低于<code>0.1</code>，并且<code>size &gt; 4</code>时，Redis会触发收缩操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 检查是否需要收缩 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正在进行 Rehash 或 dict_can_resize 为 0，则不能收缩</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取used，也就是entry个数</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="comment">// 如果used小于4，则重置为4</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 dictExpand 进行收缩，值为第一个大于等于minimal的2^n</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h3><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ul><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：<ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul></li><li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx &#x3D; 0，标示开始rehash</li><li>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将<code>dict.ht[0].table[rehashidx]</code>的entry链表rehash到dict.ht[1]，并且将<code>rehashidx ++</code>。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><h2 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h2><p>ZipList是一种特殊的“双端链表”（其实不是链表），由一系列特殊编码的连续内存块组成。可以在任意一端进行压入&#x2F;弹出操作, 并且该操作的时间复杂度为O(1)</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>Ziplist由三部分组成：</p><ol><li>头部</li></ol><ul><li><code>zlbytes</code>：Ziplist的总字节数（4字节）</li><li><code>zltail</code>：最后一个节点的偏移量（4字节），便于定位到最后一个entry节点</li><li><code>zllen</code>：entry节点的数量（2字节）</li></ul><ol start="2"><li>entry节点(长度不固定)</li></ol><ul><li>每个entry节点包含以下字段：<ul><li><code>previous_entry_len</code>：前一个节点的长度（1或5字节）<ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为<code>0xfe</code>，后四个字节才是真实长度数据</li></ul></li><li><code>encoding</code>：当前节点的编码方式（1、2或5字节）</li><li><code>content</code>：实际存储的数据（字符串或整数）</li></ul></li></ul><ol start="3"><li>尾部</li></ol><ul><li><code>zlend</code>：Ziplist的结束标志（1字节，固定值<code>0xff</code>）</li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p><h3 id="Encodeing编码"><a href="#Encodeing编码" class="headerlink" title="Encodeing编码"></a>Encodeing编码</h3><p>ZipListEntry中的encoding编码分为字符串和整数两种：<br>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p><table><thead><tr><th align="center">编码</th><th align="center">编码长度</th><th>字符串大小</th></tr></thead><tbody><tr><td align="center">|00pppppp|</td><td align="center">1 bytes</td><td>&lt;&#x3D; 63 bytes</td></tr><tr><td align="center">|01pppppp|qqqqqqqq|</td><td align="center">2 bytes</td><td>&lt;&#x3D; 16383 bytes</td></tr><tr><td align="center">|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td><td align="center">5 bytes</td><td>&lt;&#x3D; 4294967295 bytes</td></tr></tbody></table><p>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</p><table><thead><tr><th align="center">编码</th><th align="center">编码长度</th><th align="center">整数类型</th></tr></thead><tbody><tr><td align="center">11000000</td><td align="center">1</td><td align="center">int16_t（2 bytes）</td></tr><tr><td align="center">11010000</td><td align="center">1</td><td align="center">int32_t（4 bytes）</td></tr><tr><td align="center">11100000</td><td align="center">1</td><td align="center">int64_t（8 bytes）</td></tr><tr><td align="center">11110000</td><td align="center">1</td><td align="center">24位有符整数(3 bytes)</td></tr><tr><td align="center">11111110</td><td align="center">1</td><td align="center">8位有符整数(1 bytes)</td></tr><tr><td align="center">1111xxxx</td><td align="center">1</td><td align="center">直接在xxxx位置保存数值，范围从0001~1101，减1后结果为实际值</td></tr></tbody></table><h3 id="连锁更新问题"><a href="#连锁更新问题" class="headerlink" title="连锁更新问题"></a>连锁更新问题</h3><p>前面提到过，ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：</p><ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul><p>当插入或删除节点时，可能导致后续节点的<code>prevlen</code>字段发生变化。如果<code>prevlen</code>的长度从1字节变为5字节，则需要扩展当前节点的空间，这可能导致后续节点的<code>prevlen</code>字段也需要更新，从而引发连锁更新</p><p>不过发生的可能性较低，redis并没有解决这个问题</p><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，链表中的每个节点都是一个ZipList。可以用多个ZipList来分片存储数据</p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5CQuickList.png" alt="QuickList"></p><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：<code>list-max-ziplist-size</code></p><ul><li>如果值为正，则代表ZipList的允许的entry个数的最大值</li><li>如果值为负，则代表ZipList的最大内存大小，分5种情况：<ul><li>-1：每个ZipList的内存占用不能超过4kb</li><li>-2：每个ZipList的内存占用不能超过8kb（默认值）</li><li>-3：每个ZipList的内存占用不能超过16kb</li><li>-4：每个ZipList的内存占用不能超过32kb</li><li>-5：每个ZipList的内存占用不能超过64kb</li></ul></li></ul><p>QuickList源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头节点指针</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    <span class="comment">// 尾节点指针</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="comment">// 所有ziplist的entry的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">// ziplists总数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">// ziplist的entry上限，默认值 -2</span></span><br><span class="line">    <span class="type">int</span> fill: QL_FILL_BITS;</span><br><span class="line">    <span class="comment">// 首尾不压缩的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress:QL_COMP_BITS;</span><br><span class="line">    <span class="comment">// 内存重分配时的书签数量及数组，一般用不到</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><p>QuickListNode源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 下一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 当前节点的ZipList指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="comment">// 当前节点的Ziplist的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="comment">// 当前节点的ZipList的entry个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count: <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 编码方式:1.ZipList; 2.lzf压缩模式</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding: <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 数据容器类型(预留):1.其它; 2.ZipList</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container: <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 是否被解压缩。1说明被解压了，将来要重新压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress: <span class="number">1</span>; <span class="comment">//测试用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra: <span class="number">10</span>;<span class="comment">/*预留字段*/</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><p>ZipList的压缩可以选择头尾几个链表不压缩，一般crud都在头尾，只压缩中间的ZipList</p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Cquicklist_ziplist.png" alt="quicklist_ziplist"></p><h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>SkipList是链表，但是与传统链表有些差异，具有以下特点：</p><ul><li>节点按照score值排序，score值一样则按照ele字典排序</li><li>节点可能包含多个指针，指针跨度不同</li><li>查找、插入和删除操作的平均时间复杂度为O(logn)</li><li>SkipList的索引层级是动态调整的，插入新元素时会随机生成其层级</li><li>跳跃表是一个双向链表，每一个节点都包含score和ele值</li></ul><p>SkipList的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span><span class="comment">// 头尾节点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;<span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">int</span> level;<span class="comment">// 最大的索引层级，默认是1</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>SkipListNode的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;                      <span class="comment">// 元素值</span></span><br><span class="line">    <span class="type">double</span> score;                   <span class="comment">// 分值，排序、查找用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;             <span class="comment">// 索引跨度</span></span><br><span class="line">    &#125; level[];                        <span class="comment">// 多级索引数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Cskiplist.png" alt="skiplist"></p><h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，它是Redis数据存储的基础，通过封装数据的类型、编码方式和实际值，提供了统一的接口来操作各种数据类型。源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type: <span class="number">4</span>;<span class="comment">// 5种数据结构类型，占4bit</span></span><br><span class="line">    <span class="type">unsigned</span> encoding: <span class="number">4</span>;<span class="comment">// 底层编码方式，共11种，占4bit</span></span><br><span class="line">    <span class="type">unsigned</span> lru： LRU_BITS;<span class="comment">// lru表示该对象最后一次被访问的时间，占24bit,便于判断空闲时间太久的key</span></span><br><span class="line">    <span class="type">int</span> refcount;<span class="comment">// 对象引用计数器，计数器为0则说明对象无人引用，可以被回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;<span class="comment">// 指针，指向存放实际数据的空间</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h3 id="Redis的编码方式"><a href="#Redis的编码方式" class="headerlink" title="Redis的编码方式"></a>Redis的编码方式</h3><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><table><thead><tr><th align="center">编号</th><th align="center">编码方式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OBJ_ENCODING_RAW</td><td align="center">raw编码动态字符串</td></tr><tr><td align="center">1</td><td align="center">OBJ_ENCODING_INT</td><td align="center">long类型的整数的字符串</td></tr><tr><td align="center">2</td><td align="center">OBJ_ENCODING_HT</td><td align="center">hash表（字典dict）</td></tr><tr><td align="center">3</td><td align="center">OBJ_ENCODING_ZIPMAP</td><td align="center">已废弃</td></tr><tr><td align="center">4</td><td align="center">OBJ_ENCODING_LINKEDLIST</td><td align="center">双端链表</td></tr><tr><td align="center">5</td><td align="center">OBJ_ENCODING_ZIPLIST</td><td align="center">压缩列表</td></tr><tr><td align="center">6</td><td align="center">OBJ_ENCODING_INTSET</td><td align="center">整数集合</td></tr><tr><td align="center">7</td><td align="center">OBJ_ENCODING_SKIPLIST</td><td align="center">跳表</td></tr><tr><td align="center">8</td><td align="center">OBJ_ENCODING_EMBSTR</td><td align="center">embstr的动态字符串</td></tr><tr><td align="center">9</td><td align="center">OBJ_ENCODING_QUICKLIST</td><td align="center">快速列表</td></tr><tr><td align="center">10</td><td align="center">OBJ_ENCODING_STREAM</td><td align="center">Stream流</td></tr></tbody></table><h3 id="五种数据结构对应的编码"><a href="#五种数据结构对应的编码" class="headerlink" title="五种数据结构对应的编码"></a>五种数据结构对应的编码</h3><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p><table><thead><tr><th align="center">数据类型</th><th align="center">编码方式</th></tr></thead><tbody><tr><td align="center">OBJ_STRING</td><td align="center">int、embstr、raw</td></tr><tr><td align="center">OBJ_LIST</td><td align="center">LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td></tr><tr><td align="center">OBJ_SET</td><td align="center">intset、HT</td></tr><tr><td align="center">OBJ_ZSET</td><td align="center">ZipList、HT、SkipList</td></tr><tr><td align="center">OBJ_HASH</td><td align="center">ZipList、HT</td></tr></tbody></table><h2 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String是Redis中最常见的数据存储类型</p><ul><li>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512MB</li><li>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高</li><li>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码，直接将数据保存在RedisObject的ptr指针位置(刚好8字节)，不需要SDS</li></ul><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p><code>OBJ_ENCODING_RAW</code>的实现就是<code>RedisObject</code>中的ptr指向一个SDS</p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Craw.png" alt="raw"></p><p><code>EMBSTR</code>的形式为RedisObject后直接跟SDS，而不是两个分开的地址空间</p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Cembstr.png" alt="embstr"></p><p><code>INT</code>形式删除了SDS，直接把数据保存在ptr位置</p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5CINT.png" alt="INT"></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis的List类型可以从首、尾操作列表中的元素，哪一个数据结构能满足上述特征？</p><ul><li>LinkedList：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li><li>ZipList：压缩列表，可以从双端访问，内存占用低，存储上限低</li><li>QuickList：<code>LinkedList + ZipList</code>，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li></ul><p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量<code>&lt;512</code>并且元素大小<code>&lt;64字节</code>时使用ZipList编码，超过则采用LinkedList编码</p><p>在3.2版本之后，Redis统一采用QuickList来实现List</p><p>创建List：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushGenericCommand</span><span class="params">(client *c, <span class="type">int</span> where, <span class="type">int</span> xx)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">// 尝试找到KEY对应的list</span></span><br><span class="line">    robj *lobj= lookupKeyWrite(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 检查类型是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (checkType(c, lobj, OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) &#123;</span><br><span class="line">        addReply(c, shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为空，则创建新的QuickList</span></span><br><span class="line">        lobj= createQuicklistObject();</span><br><span class="line">        quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size, server.list_compress_depth);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Quicklist：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createQuicklistObject</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 申请内存并初始化QuickList</span></span><br><span class="line">    quicklist *l = quicklistCreate();</span><br><span class="line">    <span class="comment">// 创建RedisObject，type为OBJ_LIST</span></span><br><span class="line">    <span class="comment">// ptr指向QuickList</span></span><br><span class="line">    robj *o = createObject(OBJ_LIST,l);</span><br><span class="line">    <span class="comment">// 设置编码为 QuickList</span></span><br><span class="line">    <span class="number">0</span>-&gt;encoding = OBJ_ENCODING_QUICKLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Credis_List.png" alt="redis_List"></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set是Redis中的单列集合，满足下列特点：</p><ul><li>不保证有序性</li><li>保证元素唯一</li><li>支持求交集、并集、差集</li></ul><p>可以看出，Set对查询元素的效率要求非常高，所以底层使用了IntSet和Dict实现。</p><p>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。</p><p>当存储的所有数据都是整数，并且元素数量不超过<code>set-max-intset-entries(默认512)</code>时，Set会采用IntSet编码，以节省内存</p><p>创建Set的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">setTypeCreate</span><span class="params">(sds value)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断value是否是数值类型long long</span></span><br><span class="line">    <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value, <span class="literal">NULL</span>)==C_OK)</span><br><span class="line">    <span class="comment">// 如果是数值类型，则采用IntSet编码</span></span><br><span class="line">    <span class="keyword">return</span> createIntsetObject();</span><br><span class="line">    <span class="comment">//否则采用默认编码，也就是HT</span></span><br><span class="line">    <span class="keyword">return</span> createSetObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是数值类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createIntsetobject</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 初始化INTSET并申请内存空间</span></span><br><span class="line">    intset *is= intsetNew();</span><br><span class="line">    <span class="comment">// 创建RedisObject</span></span><br><span class="line">    robj *o= createObject(OBJ_SET, is);</span><br><span class="line">    <span class="comment">// 指定编码为INTSET</span></span><br><span class="line">    <span class="number">0</span>-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认编码HT：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createSetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化Dict类型，并申请内存</span></span><br><span class="line">    dict *d = dictCreate(&amp;setDictType, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建RedisObject</span></span><br><span class="line">    robj *o= createObject(OBJ_SET, d);</span><br><span class="line">    <span class="comment">// 设置encoding为HT</span></span><br><span class="line">    <span class="number">0</span>-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果原本set中存储的元素使5,10,20，然后执行命令<code>sadd s1 m1</code>，因为新插入的元素是字符串，redis需要转换编码，会新建一个Dict，把原本IntSet中的元素和m1都存入Dict中，然后转换RedisObject中的ptr，指向Dict，最后更改encoding为<code>OBJ_ENCODING_HT</code></p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Credis_set.png" alt="redis_set"></p><h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p><ul><li>可以根据score值排序后</li><li>member必须唯一</li><li>可以根据member查询分数</li></ul><p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。</p><ul><li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li><li>HT（Dict）：可以键值存储，并且可以根据key找value</li></ul><p>zset会同时使用两个结构，需要查找，维护键唯一时使用HT，需要排序时使用SkipList</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zset结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    <span class="comment">// Dict指针</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// SkipList指针</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createZsetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line"><span class="comment">// 创建Dict</span></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建SkipList</span></span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(OBJ_ZSET, zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Czset.png" alt="zset"></p><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件:</p><ul><li>元素数量小于zset_max_ziplist_entries，默认值128</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64</li></ul><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry，element在前，score在后(当我们查询的时候就可以直接遍历即可，当我们要找m1的score，只需要找到m1在找下一个即可)</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash结构与Redis中的Zset非常类似：</p><ul><li>都是键值存储</li><li>都需求根据键获取值</li><li>键必须唯一</li></ul><p>区别：</p><ul><li>zset的键是member，值是score，hash的键和值都是任意值</li><li>zset要根据score排序；hash则无需排序</li></ul><p>Hash的底层实现也与zset类似，只不过不需要用于排序的SkipList。</p><p>Hash结构默认采用ZipList编码，用以节省内存。ZipList中相邻的两个entry分别保存key和value，随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下：</p><ul><li><code>hash-max-ziplist-entries &gt; 512</code></li><li><code>hash-max-ziplist-value &gt; 64</code></li></ul><p>当满足上面两个条件其中之一的时候，Redis就使用dict字典来实现hash。Redis的hash之所以这样设计，是因为当ziplist变得很大的时候，它有如下几个缺点：</p><ul><li>每次插入或修改引发的realloc操作会有更大的概率造成内存拷贝，从而降低性能</li><li>一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据</li><li>当ziplist数据项过多的时候，在它上面查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历</li></ul><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Credis_hash.png" alt="redis_hash"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis分布式缓存</title>
      <link href="/inori/1e2438b1.html"/>
      <url>/inori/1e2438b1.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>之前学的都是单点Redis，而这种单点Redis存在一些问题：</p><ul><li>数据丢失</li><li>并发能力差</li><li>存储量小</li><li>故障恢复能力弱</li></ul><p>我们可以使用Redis分布式缓存解决以上问题。</p><h2 id="Redis持久化解决数据丢失问题"><a href="#Redis持久化解决数据丢失问题" class="headerlink" title="Redis持久化解决数据丢失问题"></a>Redis持久化解决数据丢失问题</h2><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB全称 <code>Redis Database Backup file</code>（Redis数据备份文件），也可以称为叫<strong>Redis数据快照</strong>。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为<strong>RDB文件</strong>，默认是保存在<strong>当前运行目录</strong>。</p><p>RDB持久化的执行条件有<strong>save命令</strong>、<strong>bfsave命令</strong>、<strong>Redis手动停机</strong>、<strong>触发系统内置RDB条件时</strong>。</p><h4 id="save命令"><a href="#save命令" class="headerlink" title="save命令"></a>save命令</h4><p>使用<code>redis-cli</code>链接到redis中后使用<code>save</code>命令可以立刻执行一次RDB。save命令会导致<strong>主进程执行RDB</strong>，这个过程中<strong>其它所有命令都会被阻塞</strong>。只有在数据迁移时可能用到。</p><h4 id="bgsave命令"><a href="#bgsave命令" class="headerlink" title="bgsave命令"></a>bgsave命令</h4><p>与<code>save</code>命令的执行步骤相同，但<code>bgsave</code>命令执行是异步的，执行后会<strong>开启独立进程完成RDB</strong>，主进程可以持续处理用户请求，不受影响。</p><h4 id="停机"><a href="#停机" class="headerlink" title="停机"></a>停机</h4><p>主动停机时会自动执行一次RDB</p><h4 id="Redis内置RDB条件"><a href="#Redis内置RDB条件" class="headerlink" title="Redis内置RDB条件"></a>Redis内置RDB条件</h4><p>Redis内部有触发RDB的机制，可以在<code>redis.conf</code>文件中找到（保持默认即可），格式如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">900秒内，如果至少有1个key被修改，则执行bgsave， 如果是save <span class="string">&quot;&quot;</span> 则表示禁用RDB</span></span><br><span class="line">save 900 1  </span><br><span class="line">save 300 10  </span><br><span class="line">save 60 10000 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否压缩,建议不开启</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RDB文件名称</span></span><br><span class="line">dbfilename dump.rdb  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件保存的路径目录</span></span><br><span class="line">dir ./ </span><br></pre></td></tr></table></figure><h4 id="RDB原理"><a href="#RDB原理" class="headerlink" title="RDB原理"></a>RDB原理</h4><p>当 bgsave 执行时，主进程会 fork（<u>fork()是unix和linux这种操作系统的一个api</u>）一个子进程，子进程共享主进程的内存数据，完成fork后子进程读取内存数据并写入 RDB 文件。</p><p>当子进程读取内存数据写入 RDB 文件时，主进程可以继续进行工作，依靠的是 <code>copy-on-write</code> 技术。</p><ul><li>当主进程执行读操作时，直接访问共享内存</li><li>当主进程执行写操作时，则会在内存中拷贝一份数据，对拷贝的数据执行写操作，这样不会影响到子进程读取的内存数据</li></ul><h4 id="如果不使用copy-on-write会怎么样？"><a href="#如果不使用copy-on-write会怎么样？" class="headerlink" title="如果不使用copy-on-write会怎么样？"></a>如果不使用copy-on-write会怎么样？</h4><p>不使用copy-on-write，就意味着子进程在进行写RDB文件时，主进程可以修改子进程要读取的内存数据，那么就无法保证某一时刻数据的一致性。</p><h4 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h4><ul><li>RDB执行间隔时间长，两次RDB之间写入数据有丢失风险</li><li>fork子进程、压缩、写出RDB文件都比较耗时</li></ul><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF全称为<code>Append Only File</code>（追加文件）。Redis处理的<strong>每一个写命令都会记录在AOF文件</strong>，可以看做是命令日志文件。（<strong>由主进程先写入到缓冲区，之后由后台线程将缓冲区中的数据写入到AOF文件</strong>）</p><h4 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h4><p>AOF在<code>redis.conf</code>中默认是关闭的，需要修改<code>redis.conf</code>配置文件开启AOF:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否开启AOF功能，默认是no</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件的名称</span></span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示每执行一次写命令，立即记录到AOF文件</span></span><br><span class="line">appendfsync always </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line">appendfsync everysec </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></table></figure><p><code>appendfsync</code>三种策略对比：</p><table><thead><tr><th align="center">配置项</th><th align="center">刷盘实机</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">always</td><td align="center">同步刷盘</td><td align="center">可靠性高，几乎不丢失数据</td><td align="center">性能影响大</td></tr><tr><td align="center">everysec</td><td align="center">每秒刷盘</td><td align="center">性能适中</td><td align="center">可能会丢失1秒内的数据</td></tr><tr><td align="center">no</td><td align="center">操作系统控制</td><td align="center">性能最好</td><td align="center">可靠性较差，可能丢失大量数据</td></tr></tbody></table><h4 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h4><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对<strong>同一个key的多次写操作</strong>，但只有最后一次写操作才有意义。通过执行<code>bgrewriteaof</code>命令，可以<strong>让AOF文件执行重写功能</strong>，用最少的命令达到相同效果。</p><p>如果一直没执行此命令，Redis也会在触发阈值时自动重写AOF文件（<strong>异步执行</strong>）。阈值也可以在<code>redis.conf</code>中配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件体积最小多大以上才触发重写</span> </span><br><span class="line">auto-aof-rewrite-min-size 64mb </span><br></pre></td></tr></table></figure><h3 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h3><p>在实际开发中往往会结合两者来使用</p><table><thead><tr><th></th><th>RDB</th><th>AOF</th></tr></thead><tbody><tr><td>持久化方式</td><td>定时对整个内存做快照</td><td>每一次执行的命令</td></tr><tr><td>数据完整性</td><td>不完整，两次备份之间会丢失</td><td>相对完整，取决于刷盘策略</td></tr><tr><td>文件大小</td><td>会有压缩，文件体积小</td><td>记录命令，文件体积很大</td></tr><tr><td>宕机恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据恢复优先级</td><td>低，数据完整性不如AOF</td><td>高，因为数据完整性更高</td></tr><tr><td>系统资源占用</td><td>高，大量CUP和内存消耗</td><td>低，主要是磁盘IO占用，但AOF重写时会占用大量CPU和内存资源</td></tr><tr><td>使用场景</td><td>可容忍数分钟的数据丢失，追求更快的启动速度</td><td>对数据安全性要求较高</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><ul><li>RDB是一种快照持久化方法，它会在指定的时间间隔内生成数据的完整快照</li><li>适合于灾难恢复，可以很方便的被迁移到另一个数据中心</li><li>RDB在保存快照时速度快，恢复时也非常迅速，适合用作备份</li><li>最后一次快照之后的数据可能会丢失，因为这部分数据还没有被写入快照</li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><ul><li>AOF记录每一条写命令</li><li>AOF提供了更好的数据安全性，可以配置为每秒同步一次，或者每写入一条命令就同步一次</li><li>AOF文件通常会比RDB文件更大，且恢复速度可能会更慢，但可以通过AOF文件重写进行压缩</li><li>AOF在系统崩溃时能最大化数据恢复，最多只丢失几秒钟的数据</li></ul><p>如果需要<strong>快速恢复</strong>且可以<strong>接受少量数据丢失</strong>，RDB可能是更好的选择。如果<strong>注重数据完整性</strong>且<strong>可以接受较慢的恢复速度</strong>，则应该使用AOF。在很多场景下，结合使用RDB和AOF能提供更为可靠的数据保护机制。</p><h2 id="主从集群解决并发问题"><a href="#主从集群解决并发问题" class="headerlink" title="主从集群解决并发问题"></a>主从集群解决并发问题</h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p><p>主从集群可以是一台Redis服务器作为主节点(master)，数台服务器作为从节点(slave)，主节点只负责写数据，从节点只负责读数据。</p><h3 id="数据同步原理"><a href="#数据同步原理" class="headerlink" title="数据同步原理"></a>数据同步原理</h3><p>主从之间的第一次同步<strong>全量同步</strong>，既要加载RDB文件，又要读取并执行repl_baklog中的命令。</p><p><img src="/inori/1e2438b1/redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%5Cmaster&slave.png" alt="master&amp;slave"></p><p><strong>如何判断是不是第一次同步？</strong></p><ul><li><strong>replication id</strong>：简称replid，数据集标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li><strong>offset</strong>：偏移量，随着记录在<code>repl_baklog</code>中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id和offset，master才可以判断到底需要同步哪些数据</p><p>一般来讲，如果id能对上就不用做全量同步，但是<code>repl_baklog</code>大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法同步基于log做增量同步，只能再次做全量同步。</p><h3 id="优化主从集群性能"><a href="#优化主从集群性能" class="headerlink" title="优化主从集群性能"></a>优化主从集群性能</h3><ul><li>在master中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li><li>适当提高<code>repl_baklog</code>的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li></ul><h2 id="Redis哨兵解决故障恢复问题"><a href="#Redis哨兵解决故障恢复问题" class="headerlink" title="Redis哨兵解决故障恢复问题"></a>Redis哨兵解决故障恢复问题</h2><p><code>slave</code>节点宕机恢复后可以找<code>master</code>节点同步数据，那<code>master</code>节点宕机怎么办?</p><p>这就需要指定一个<code>slave</code>节点为新的<code>master</code>，执行写操作。这个操作不需要人工手动执行，因为Redis提供了哨兵(Sentinel)机制来实现主从集群的自动故障恢复。<u>哨兵本身也是一个集群</u>。</p><h3 id="哨兵的结构和作用"><a href="#哨兵的结构和作用" class="headerlink" title="哨兵的结构和作用"></a>哨兵的结构和作用</h3><ul><li><strong>监控</strong>：Sentinel会不断检查master和slave是否按预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li><li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新消息推送给Redis的客户端</li></ul><h3 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h3><p><code>Sentinel</code>基于心跳机制检测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li>主观下线：如果<code>Sentinel</code>节点发现某实例未在规定时间相应，则认为该实例主观下线</li><li>客观下线：若超过指定数量（<code>quorum</code>）的<code>Sentinel</code>都认为该实例主观下线，则该实例客观下线。<code>quorum</code>的取值最好超过<code>Sentinel</code>数量的一半</li></ul><h3 id="选举新的master"><a href="#选举新的master" class="headerlink" title="选举新的master"></a>选举新的master</h3><p>一旦发现<code>master</code>故障，<code>Sentinel</code>需要在<code>salve</code>中选择一个作为新的<code>master</code>，选择依据是这样的:</p><ul><li>首先会判断<code>slave</code>节点与<code>master</code>节点断开时间长短，如果超过指定值(down-after-miliseconds*10)则会排除该<code>slave</code>节点</li><li>然后判断<code>slave</code>节点的<code>slave-priority</code>值，越小优先级越高，如果是<u>0</u>则永不参与选举</li><li>如果<code>slave-prority</code>一样，则判断<code>slave</code>节点的<code>offset</code>值，越大说明数据越新，优先级越高</li><li>最后是判断<code>slave</code>节点的运行id大小，越小优先级越高</li></ul><h4 id="实现故障转移"><a href="#实现故障转移" class="headerlink" title="实现故障转移"></a>实现故障转移</h4><p>当选中了其中一个<code>slave</code>为新的<code>master</code>后：</p><ul><li><code>Sentinel</code>给备选的<code>slave</code>节点发送<code>slaveof no one</code>命令，让该节点成为<code>master</code></li><li><code>Sentinel</code>给所有其它<code>slave</code>发送<code>slaveof IP地址 端口</code>命令，让这些<code>slave</code>成为新<code>master</code>的从节点，开始从新的<code>master</code>上同步数据</li><li>最后，<code>Sentinel</code>将故障节点标记为<code>slave</code>，当故障节点恢复后会自动成为新的<code>master</code>的<code>slave</code>节点</li></ul><h3 id="脑裂问题与解决方案"><a href="#脑裂问题与解决方案" class="headerlink" title="脑裂问题与解决方案"></a>脑裂问题与解决方案</h3><p>脑裂问题是指在分布式系统中，由于网络分区导致集群被分割成多个独立的部分，每个部分都可能认为自己是唯一正常运行的集群，从而导致数据不一致或服务冲突。</p><p>原因：</p><ol><li><strong>网络分区</strong>：集群节点之间的网络通信中断，导致部分节点无法互相通信</li><li><strong>主从切换</strong>：在网络分区后，部分节点可能选举出新的主节点，导致同一集群中出现多个主节点</li><li><strong>数据不一致</strong>：不同主节点可能同时接收写请求，导致数据冲突或丢失</li></ol><p>表现：</p><ul><li>集群被分割为多个独立子集群，每个子集群可能都有自己的主节点</li><li>客户端可能连接到不同的子集群，读取或写入不一致的数据</li><li>网络恢复后，集群可能无法自动合并，导致数据冲突</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>集群配置参数</li></ol><ul><li><code>min-slaves-to-write</code>：主节点至少需要多少个从节点才能接收写请求。如<code>min-slaves-to-write 1</code>表示主节点至少需要1个从节点才能写入数据。在网络分区后，如果主节点失去足够多的从节点，则停止写入，避免数据不一致</li><li><code>min-slaves-max-lag</code>：从节点与主节点的最大延迟时间（秒）。如<code>min-slaves-max-lag 10</code>表示从节点的复制延迟不能超过10秒。如果从节点延迟过高，主节点会停止写入，确保数据同步</li></ul><ol start="2"><li>数据分片</li></ol><ul><li>Redis集群将数据划分为16384个哈希槽，每个主节点负责一部分槽</li><li>在网络分区后，只有持有完整槽信息的分区才能提供服务，避免数据冲突</li></ul><h3 id="Java中使用RedisTemplate配置哨兵集群"><a href="#Java中使用RedisTemplate配置哨兵集群" class="headerlink" title="Java中使用RedisTemplate配置哨兵集群"></a>Java中使用RedisTemplate配置哨兵集群</h3><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置Redis</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">io.lettuce.core:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">MM-dd</span> <span class="string">HH:mm:ss:SSS</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">master:</span> <span class="string">mymaster</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口2</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口3</span></span><br></pre></td></tr></table></figure><p>配置主从读写分离</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisDemoApplication</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(RedisDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 配置主从读写分离</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="title function_">configurationBuilderCustomizer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.MASTER_PREFERRED);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReadForm</code>函数是配置Redis的读取策略，有以下选择：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可使用才读取slave</li><li>REPLICA：从slave节点读取</li><li>REPLICA_PREFERRED：优先从slave节点读取，所有的slave都不可用才读取master</li></ul><h2 id="Redis分片集群解决海量数据存储问题"><a href="#Redis分片集群解决海量数据存储问题" class="headerlink" title="Redis分片集群解决海量数据存储问题"></a>Redis分片集群解决海量数据存储问题</h2><p>分片集群特征：</p><ul><li>集群中有多个<code>master</code>，每个<code>master</code>保存不同数据</li><li>每个<code>master</code>都可以有多个<code>slave</code>节点</li><li><code>master</code>之间通过ping监测彼此健康状态</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><h3 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h3><p>Redis会把每一个master节点映射到<code>0~16384</code>个插槽上，通过查看集群信息时即可看到每个节点插槽的区间</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></table></figure><h3 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h3><p>redis-cli –cluster提供很多操作集群的命令，可以通过下面的命令查看：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster help</span><br></pre></td></tr></table></figure><h3 id="故障迁移"><a href="#故障迁移" class="headerlink" title="故障迁移"></a>故障迁移</h3><p>如果集群中某个master宕机了，则该master下优先级最高的slave节点会变成master，选举出的新master会接管原master的槽位（slot）和数据，继续对外提供服务。其他节点会更新自己的路由表，将请求转发到新的master。如果原master重新上线，它会成为新master的slave节点，开始同步数据。</p><p><img src="/inori/1e2438b1/redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%5Cfailover.png" alt="failover"></p><h3 id="Redis访问分片集群"><a href="#Redis访问分片集群" class="headerlink" title="Redis访问分片集群"></a>Redis访问分片集群</h3><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致:</p><ol><li>引入redis的starter依赖</li><li>配置分片集群地址</li><li>配置读写分离</li><li>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下:</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">cluster:</span></span><br><span class="line">      <span class="attr">nodes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口1</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口2</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口3</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口4</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口5</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">IP地址</span> <span class="string">端口6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找算法入门</title>
      <link href="/inori/6b525bdc.html"/>
      <url>/inori/6b525bdc.html</url>
      
        <content type="html"><![CDATA[<p>二分查找可以有几种写法：</p><ul><li>闭区间</li><li>开区间</li><li>半开半闭区间（左开右闭&#x2F;左闭右开）</li></ul><p>所谓开闭区间，指的是二分查找中的<code>left</code>和<code>right</code>的值，如果取值在数组内部（大部分情况下），就可以成为闭区间，反之为开区间。</p><p>展示这三种写法，我们从一道<a href="https://leetcode.cn/problems/binary-search/description/">题目</a>开始：</p><hr><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><hr><p>这道题就是纯粹的二分查找板子题，数组有序，数组中无重复元素。</p><p>这里使用<code>Java</code>进行展示，首先是<code>闭区间</code>写法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);<span class="comment">// 防止爆int</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于全程需要<code>left</code>和<code>right</code>处于闭区间内，所以更新后的取值一定是<code>mid+1</code>或<code>mid-1</code>。<code>left=right</code>时，<code>mid</code>也等于<code>right</code>，会陷入死循环，所以要在边界条件的判断中加入<code>=</code>，即<code>while(l &lt;= r)</code>，最后<code>right+1</code>也就是<code>left</code>为所求答案。</p><p>然后是<code>半开半闭</code>区间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n;<span class="comment">// 左闭右开</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>半开半闭写法中，谁是开区间，谁更新后就要等于<code>mid</code>。结束时<code>left=right</code>，两者返回其一即可。</p><p>最后是<code>开区间</code>写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> -<span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r == n) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// 由于是开区间，r有可能等于nums.length，所以要特判</span></span><br><span class="line">        <span class="keyword">return</span> nums[r] == target ? r : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种写法只有代码上的区别，最后答案都是一样的，选一个顺眼的写法就好。</p><p>我们来做几道扩展题，提升对二分查找的熟练度：</p><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></p><hr><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><hr><p>这道题要求我们在数组中找到一段等于<code>target</code>的子数组，返回其起点和终点的下标，如果没有返回<code>[-1, -1]</code>。</p><p>起始位置很好找，套用二分模板即可。</p><p>终点如何找呢？</p><p>这就要讨论不同的要求了</p><ul><li>如果要求我们寻找<code>&gt;= x</code>时，就直接使用二分模板</li><li>如果要求我们寻找<code>&gt; x</code>时，可以将题目转化为<code>&gt;= x+1</code></li><li>如果要求我们寻找<code>&lt; x</code>时，可以将题目转化为<code>(&gt;= x) - 1</code></li><li>如果要求我们寻找<code>&lt;= x</code>某个值时，可以将题目转化为<code>(&gt; x) - 1</code> -》 <code>(&gt;= x + 1) - 1</code></li></ul><p>要寻找终点，也就是<code>&gt; x</code>的情况。</p><p>题解代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private int[] nums;</span><br><span class="line"></span><br><span class="line">    private int lowerBound(int target) &#123;</span><br><span class="line">        int l = 0, r = nums.length - 1;</span><br><span class="line">        while(l &lt;= r)&#123;</span><br><span class="line">            int mid = l + ((r - l) &gt;&gt; 1);</span><br><span class="line">            if(nums[mid] &lt; target) l = mid + 1;</span><br><span class="line">            else r = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int[] searchRange(int[] nums, int target) &#123;</span><br><span class="line">        this.nums = nums;</span><br><span class="line">        int start = lowerBound(target);</span><br><span class="line">        if(start == nums.length || nums[start] != target) return new int[]&#123;-1, -1&#125;;</span><br><span class="line">        int end = lowerBound(target + 1) - 1;</span><br><span class="line">        return new int[]&#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分不止能用在有序数组中，也能用在部分有序的数组中。</p><p>比如<a href="https://leetcode.cn/problems/find-peak-element/solution/by-endlesscheng-9ass/">寻找峰值</a>：</p><hr><p>峰值元素是指其值严格大于左右相邻值的元素。</p><p>给你一个整数数组 <code>nums</code>，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 <strong>任何一个峰值</strong> 所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code> 。</p><p>你必须实现时间复杂度为 <code>O(log n)</code> 的算法来解决此问题。</p><hr>这道题给定的数组是由很多部分有序的数组组成的，峰值可能有多个，我们只需要找到其中一个即可。<p>这道题为什么能够使用二分查找呢？</p><p>因为我们要找到一个峰值，而峰值是一定比周围两个值高的（如果是边界则为一个值），这里可以使用二分查找来逐渐逼近这个点。</p><p>由于要找峰值，<code>target</code>的选择可以是<code>nums[mid+1]</code>或<code>nums[mid-1]</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(mid + <span class="number">1</span> == nums.length) <span class="keyword">return</span> mid;<span class="comment">// 特殊判断，防止越界</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[mid + <span class="number">1</span>]) l = mid + <span class="number">1</span>;<span class="comment">// 如果mid的下一个比mid大，则峰值一定在mid后面，更新l</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>; <span class="comment">// 反之更新r</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">搜索旋转排序数组</a></p><hr><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><hr><p>这道题给定是一个有序无重复数组经过数次旋转后得到的数组，要求我们在其中找到<code>target</code>并返回其下标，如果没有返回<code>-1</code>。</p><p>我们可以用两次二分来解决这道题，首先类似于上一道题的查找峰值，我们先使用二分找到数组中的最小值，也就是找到两段递增数组的分界点，然后比较<code>target</code>与数组中最后一位数<code>last</code>的大小，如果<code>target</code>比<code>last</code>小，则说明其在第二段递增数组中，否则在第一段。然后最相应的数组再做一次二分即可。</p><p>题解代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; last) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &lt;= last)&#123;</span><br><span class="line">            r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(l == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = l - <span class="number">1</span>;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target) l = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在寻找低谷时，我们将比较对象定为<code>last</code>，这是因为我们要寻找最小值，如果<code>mid</code>比<code>last</code>要大，则说明数组一定被分割过并且<code>mid</code>在最小值左侧，移动<code>left</code>，反之移动<code>right</code>。并且由于我们的比较对象是<code>last</code>，所以二分时不需要考虑它，<code>r</code>直接定为<code>n-2</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习基础知识</title>
      <link href="/inori/64d6f53b.html"/>
      <url>/inori/64d6f53b.html</url>
      
        <content type="html"><![CDATA[<p>记录一些强化学习基础名词解释，理解的不深</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>强化学习（Reinforcement Learning，RL）是一种机器学习方法，旨在通过与环境的交互来学习如何采取行动以最大化累积奖励。与监督学习不同，强化学习没有预先标注的输入输出对，而是通过试错和从反馈中学习</p><p><code>Agent</code>：做出动作的角色，即智能体</p><p><code>state(状态)</code>：智能体当前所处的环境，包含环境当前的全部或部分信息，在玩游戏时，state就是当前的游戏画面，如果状态，动作，奖励等变量被观测到了，用s表示；没观测到就表示随机变量，用S表示</p><p><code>action(动作)</code>：智能体在每个时间步可以采取的操作</p><p><code>policy(决策)</code>：agent在当前做出的动作</p><p><code>policy function(策略函数)</code>：在某种state下，agent采取某种action的概率$\pi(s.a)$，函数值范围为[0,1]</p><p><code>Reward(奖励)</code>：是指采取动作后，环境给agent的奖励，它可能为正、负、0</p><p><code>state transition(状态转移)</code>：agent在某个状态采取某个动作后，可能发生的状态变化</p><p>强化学习是agent与环境互动的过程。我们观测到状态$s_t$，然后根据策略$\pi(a|s)$选择一个动作$a_t$并执行它，环境会给出一个新的状态$s_{t+1}$和奖励r</p><p><code>Return(回报)</code>：也叫做未来累计奖励，即$U_t&#x3D;R_t+R_{t+1}+R_{t+2}+…+R_n$</p><p>由于现在的奖励可能比未来的奖励更重要，所以定义<code>Discounted Return(折扣回报)</code>：$U_t&#x3D;R_t+\gamma R_{t+1}+\gamma^2 R_{t+2}+…+\gamma^n R_n$，$\gamma$意为折扣因子，是我们设定的超参数</p><p><code>Action-Value Function(动作值函数)</code>：用Q(s,a)表示，用于评估在给定状态s下采取某个动作a所能获得的累积奖励的期望值</p><p><code>State-Value Function(状态值函数)</code>：用V(s)表示，用于评估智能体在给定状态s下，从该状态开始到未来所能获得的累积奖励的期望值</p><p><code>Q值</code>：表示在状态s下采取动作a的return</p><p><code>model-based</code>：基于模型的方法涉及构建环境的模型，即尝试估计或学习环境的动态（状态转移概率和奖励函数）。这些方法可以在模型上进行规划，从而选择最佳行动。</p><p><code>model-free</code>：不直接构建环境的模型，而是通过与环境的交互来学习最优策略或价值函数，直接从经验中学习如何行动</p><p><code>policy-based</code>：利用策略梯度优化策略函数，来选择最优行动，直接学习映射状态到行动的策略函数。可以更自然地应用于连续动作空间问题。</p><p><code>value-based</code>：基于价值的方法对价值函数进行建模和优化。通过估计每个状态或状态-动作对的价值来选择最优行动。主要特点包括：</p><ul><li>优化价值函数：学习状态价值函数或动作价值函数。</li><li>间接确定策略：通过选择具有最大价值的动作来确定策略。</li><li>例子：Q-learning，SARSA，DQN</li></ul><h1 id="Value-Based-Reinforcement-Learning"><a href="#Value-Based-Reinforcement-Learning" class="headerlink" title="Value-Based Reinforcement Learning"></a>Value-Based Reinforcement Learning</h1><p>定义Optimal action-value function$Q^*(s_t,a_t)&#x3D;maxQ_\pi(s_t,a_t)$，$Q^*(s_t,a_t)$就是最优情况下的$U_t$</p><p>在价值学习中我们要训练的函数就是$Q(s_t,a_t)$，训练的目标是$Q^*(s_t,a_t)$，采取的最佳动作就是$a^*&#x3D;argmaxQ^*(s_t,a_t)$</p><h2 id="Temporal-Difference-Learning算法"><a href="#Temporal-Difference-Learning算法" class="headerlink" title="Temporal Difference Learning算法"></a>Temporal Difference Learning算法</h2><p>时序差分算法的思想为用局部基于真实观测的数据来更新全局预测的数据，因为它的可信度大于完全基于预测的数据</p><p>TD target：相比于当前估计来说更准确的估计，使用$V(s)←V(s)+α[r+γV(s^′)−V(s)]$更新</p><p>TD error：之前的估计与当前估计的损失值</p><h2 id="Deep-Q-Network"><a href="#Deep-Q-Network" class="headerlink" title="Deep Q Network"></a>Deep Q Network</h2><p>DQN是使用一个神经网络$Q(s,a;w)$来估计action-value function$Q(s,a)$，我们基于TD算法来训练这个神经网络，从而得到Optimal action-value function$Q^*(s_t,a_t)$的估计</p><p>由于$U_t&#x3D;R_t+\gamma R_{t+1}+\gamma^2 R_{t+2}+…+\gamma^n R_n&#x3D;R_t+\gamma U_{t+1}$</p><p>基于这种思想,做一下蒙特卡洛近似，得出DQN的更新公式为$Q(s_t,a_t;w)&#x3D;r_t+\gamma Q(s_{t+1},a_{t+1};w)$</p><p>Loss也与TD算法相似:$L_t&#x3D;\frac{1}{2}[Q(s_t,a_t;w)-y_t]^2 $</p><p>流程总结：</p><ul><li>从当前状态s中选择一个动作a</li><li>执行动作a，获得奖励r并转移到新状态s′</li><li>将经历（s,a,r,s′）存储到回放缓冲区</li><li>从回放缓冲区中随机抽取一个小批量样本</li><li>对每个样本，计算目标Q值(TD target)并更新Q网络参数</li><li>每隔一定步数，更新目标网络参数</li></ul><h1 id="Policy-Based-Reinforcement-Learning"><a href="#Policy-Based-Reinforcement-Learning" class="headerlink" title="Policy-Based Reinforcement Learning"></a>Policy-Based Reinforcement Learning</h1><h2 id="Policy-Function"><a href="#Policy-Function" class="headerlink" title="Policy Function"></a>Policy Function</h2><p>策略函数$π(a|s)$是一个概率密度函数，其输入是某个状态s，输出是在该状态下可能产生的动作a的概率值。假设在状态$s_t$下，Agent可能做出的动作$a_t$可能有n个，那么$π(a_t|s_t)$即输出一个n维向量，其元素对应每个可能做出动作at的概率值。有了这n个概率值，Agent就会在这个向量中做一次随机抽样并做出所得到的动作$a_i$</p><h2 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a>Policy Gradient</h2><p>定义状态值函数近似函数$V(s;\theta)&#x3D;\Sigma_a\pi(a|s;\theta)Q_\pi(s,a)$，其中$\theta$是神经网络中的参数。V可以评价状态s和策略网络$π(a|s_t;θ)$的好坏。若给定状态s，策略网络越好，那么V的值越大。因此，我们采用V关于$θ$的随机梯度上升的方法更新参数θ，即策略梯度就是函数V对$\theta$的导数</p><p>大致流程：</p><ul><li>观测状态s</li><li>根据策略函数$\pi$随机采样一个a</li><li>根据$Q(s_tr,a_t)$近似$q_t$</li><li>对策略网络求导</li><li>近似策略梯度$g(a_t,\theta_t)&#x3D;q_t*d_{\theta,t}$</li><li>更新策略网络参数</li></ul><p>那么我们如何估计动作价值函数Q？</p><p>这里有两种方法：</p><p><code>REINFORCE算法</code>：必须获取到一个完整的采样trajectory才能进行一次模型参数的更新，也就是蒙特卡罗方法（MC Method）来估计Q</p><p><code>Actor-Critic（AC）</code>：使用另一个神经网络来近似Qπ</p><h2 id="Actor-Critic-Method"><a href="#Actor-Critic-Method" class="headerlink" title="Actor-Critic Method"></a>Actor-Critic Method</h2><p>Actor-Critic方法，是策略学习和价值学习结合的一种方法</p><p>Actor是策略网络，用来控制Agent运动，可以看做“演员”</p><p>Critic是价值网络，用来给演员打分，可以看做“评论家”</p><h3 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h3><p>Actor网络的输入为状态s</p><p>价值网络中包含：卷积层，将画面变成特征向量；全连接层，将特征向量转变为相对于动作空间（Action Space）中元素个数对应的向量；再采用Softmax激活函数将其转换为一策略的概率密度</p><h3 id="Critic"><a href="#Critic" class="headerlink" title="Critic"></a>Critic</h3><p>Critic网络的输入为状态s和动作a</p><p>对于两个不同的输入，处理方法如下：</p><p>针对于状态s，从输入中提取特征，获得一个状态特征向量</p><p>针对于动作a，采用全连接层提取特征，获得一个动作特征向量</p><p>然后将两个特征向量进行concat，得到一个更高维的特征向量，再通过一个全连接层输出一个实数$q(s,a;w)$，即Critic对于Agent处于状态s下做出动作a的评价</p><h3 id="训练神经网络"><a href="#训练神经网络" class="headerlink" title="训练神经网络"></a>训练神经网络</h3><ul><li>观测状态s</li><li>根据策略函数$\pi$随机采样一个a</li><li>执行动作a，获取下一个状态$s_{t+1}$和奖励r</li><li>使用TD算法更新Critic网络的参数</li><li>使用策略梯度更新Actor的参数</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>观测旧状态$s_t$，用策略网络$\pi$计算概率分布，随机采样动作$a_t$</li><li>执行$a_t$，得到新状态$s_{t+1}$和奖励$r_t$</li><li>根据新状态，随机采样动作$a_{t+1}$(假想的动作，并不会真的做)</li><li>计算价值网络$q_t&#x3D;q(s_t,a_t;w_t)$和$q_{t+1}&#x3D;q(s_{t+1},a_{t+1};w_t)$</li><li>计算TD error：$\delta_t&#x3D;q_t-(r_t+\gamma q_{t+1})$</li><li>对Critic参数求导，更新其参数$w_{t+1}&#x3D;w_t-\alpha \delta_t d_{w,t}$</li><li>对Actor参数求导，更新其参数$\theta_{t+1}&#x3D;\theta_t-\beta q_t d_{\theta,t}$</li></ul><h1 id="Monte-Carlo方法"><a href="#Monte-Carlo方法" class="headerlink" title="Monte Carlo方法"></a>Monte Carlo方法</h1><p>蒙特卡洛是一类通过随机采样和统计分析来估计问题解的方法，在强化学习中用于评估策略和估计价值函数</p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>随机采样</strong>：通过从可能的结果中随机采样，来估计某个数量的期望值或概率分布。</p><p><strong>经验回报</strong>：在每个episode中，通过累积获得的实际回报来估计状态或状态-动作对的价值。</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><p><strong>生成轨迹</strong>：根据当前策略，从起始状态开始，生成多条轨迹，每条轨迹包含一系列状态、动作和奖励，直到达到终止状态</p><p><strong>计算回报</strong>：对每条轨迹，计算每个时间步Return</p><p><strong>更新价值估计</strong>：根据每个状态或状态-动作对的回报，更新价值函数或Q值函数</p><h1 id="Sarsa算法"><a href="#Sarsa算法" class="headerlink" title="Sarsa算法"></a>Sarsa算法</h1><p>SARSA（State-Action-Reward-State-Action）是一种基于TD方法的强化学习算法，用于学习状态-动作价值函数。SARSA是一个on-policy算法，直接使用当前策略选择的动作来更新Q值</p><h2 id="表格形式的Sarsa"><a href="#表格形式的Sarsa" class="headerlink" title="表格形式的Sarsa"></a>表格形式的Sarsa</h2><p>如果agent的状态和动作是有限的，那么可以画一个表格，一行对应一个状态$s_i$，一列对应一个动作$a_j$，那么表中的每个元素则对应着在该状态和该动作下的动作价值$Q_π(s_i,a_j)$。我们要做的就是用Sarsa算法去更新表格，每次更新一个元素。</p><p>当我们观测到一个四元组$（s_t,a_t,r_t,s_{t+1}）$，这样的一个四元组被称为transition。然后采用策略函数$π$去采样一个$a_{t+1}$，接着计算TD target $y_t&#x3D;r_t+\gamma Q(s_{t+1},a_{t+1})$，Q值可以直接通过查表获得。同时我们也能计算出TD error $δ_t$，然后利用$δ_t$更新$Q_π(st,at)$，其中α是学习率</p><h2 id="神经网络形式的Sarsa"><a href="#神经网络形式的Sarsa" class="headerlink" title="神经网络形式的Sarsa"></a>神经网络形式的Sarsa</h2><p>采用价值网络来近似$Q_π(s,a)$，记为$q(s,a;w)$。动作价值函数Qπ和价值网络q都与策略π有关，策略π的好坏会影响这两个函数</p><p>神经网络$q(s,a;w)$被称为价值网络，它的输入是一个状态s，输出是状态s下对应动作的价值。如果有n个动作，那么价值网络q就会输出一个n维向量，向量元素对应在状态s下，各动作a的价值</p><p>TD target就变成了$y_t&#x3D;r_t+\gamma q(s_{t+1},a_{t+1};w)$，TD error变成$δ_t&#x3D;q(s_t,a_t;w)-y_t$</p><p>然后计算Loss，求梯度，更新网络参数w即可</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Sarsa算法主要是用于学习动作价值函数$Q_π(s,a)$</p><ul><li>表格形式（直接学习Qπ）</li></ul><p>适合有限个状态和动作且数量不大的情况。通过一张表格记录每种状态和动作对应的$Q_π(s,a)$的值，通过采用TD算法更新表中Q值。</p><ul><li>神经网络形式（采用函数近似）</li></ul><p>这种形式并不是直接获取Q，而是通过价值网络q(s,a;w)来近似动作价值函数Q</p><h1 id="Q-Learning算法"><a href="#Q-Learning算法" class="headerlink" title="Q-Learning算法"></a>Q-Learning算法</h1><p>Q-Learning是用于学习最优动作价值函数$Q^*(s,a)$</p><p>TD target的更新函数为$y_t&#x3D;r_t+\gamma maxQ^*(s_{t+1},a)$，对Q*求最大化</p><p>其他部分与Sarsa相同，只是Sarsa算法是学习动作价值函数Qπ；而Q-Learning是学习最优动作价值函数Q*</p><h1 id="Experience-Replay"><a href="#Experience-Replay" class="headerlink" title="Experience Replay"></a>Experience Replay</h1><p>我们通常使用TD算法来训练DQN，回顾一下TD算法的步骤：</p><ul><li>Agent在t时刻观测到一个状态st并做出动作at</li><li>Agent与环境交互获得了一个新的状态st+1并且获得了一个奖励rt</li><li>得到TD Target yt</li><li>计算TD error δt</li></ul><p>我们的目标是让qt接近yt，即TD error δt尽量的小，因此TD算法就是寻找一个神经网络参数w使损失函数（Loss Function）L(w)尽可能的小</p><ul><li>采用梯度下降来使$w_t$不断逼近w*</li></ul><p>$（s_t,a_t,r_t,s_{t+1}）$是一个transition，可以认为是一条训练数据，传统算法在使用完该训练数据后就把它丢掉，不再使用，这种对于DQN的训练效果并不好</p><h2 id="Replay-Buffer"><a href="#Replay-Buffer" class="headerlink" title="Replay Buffer"></a>Replay Buffer</h2><p>我们在使用完一个transition时，会把一个transition放入一个队列里，这个队列被称之为回放缓冲区（Replay Buffer），它的容量是一个超参数n，Replay Buffer可以存储n条transitions。如果Replay Buffer满了，那么新来的transition会替代老的transition</p><h3 id="TD算法中经验回放"><a href="#TD算法中经验回放" class="headerlink" title="TD算法中经验回放"></a>TD算法中经验回放</h3><p>我们通过找到神经网络参数w来最小化损失函数Loss Function。</p><p>使用随机梯度下降（Stochastic Gradient Descent SGD）来最小化Loss Function：从buffer中随机抽取一批transition，计算TD error δi，再算出随机梯度gi，调整神经网络参数w</p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="Prioritized-Experience-Replay"><a href="#Prioritized-Experience-Replay" class="headerlink" title="Prioritized Experience Replay"></a>Prioritized Experience Replay</h2><p>对于Agent而言，并不是所有的transition都同等重要，有些state较难遇见，统一抽样的话难以抽到，训练出的DQN对于数量较少的场景不熟悉，所以预测就会偏离TD Target，因此产生的TD error就比较大，即|δt|就大。正因为DQN不熟悉数量较少的场景，所以要让DQN给这些场景更高的优先级，让它更好的应对这样的场景。</p><p>优先经验回放的核心在于：使用非均匀抽样代替均匀抽样</p><p>这里有两种抽样方式：</p><ul><li>抽样概率pt正比于|δt|+ε：即TD error越大，被抽到的概率就越大</li><li>对|δt|排序：|δt|越大越靠前，容易被抽到</li></ul><h3 id="学习率调整"><a href="#学习率调整" class="headerlink" title="学习率调整"></a>学习率调整</h3><p>TD算法采用SGD来更新神经网络参数w，α是学习率，如果做均匀抽样，所有的transitions的学习率α都相同；如果做非均匀抽样，那么就要根据每个transition的重要性来调整学习率。</p><p>如果一个transition有一个较大的抽样概率pt，那么对这个transition的学习率就应该调小，可以采用如下圈出的方法来自适应调整学习率的因子：如果pt很大，那么学习率就会变小，学习率减小可以减小训练过程中的波动，提高收敛速度和精度，设置学习率为$\alpha(np_t)^{-\beta}$</p><h3 id="更新TD-Error"><a href="#更新TD-Error" class="headerlink" title="更新TD Error"></a>更新TD Error</h3><p>为了做优先经验回放，我们要对每一个transition标记上TD error δt。δt决定了这条transition的重要性，决定了它被抽样的概率。</p><p>如果一个transition刚刚被收集到，我们并不知道它的δt，那么我们就直接把它的δt设置为最大值，让它有最高的优先级。</p><p>每次从buffer中抽取一个transition，都要对它的δt进行一次更新</p><h2 id="缓解高估问题"><a href="#缓解高估问题" class="headerlink" title="缓解高估问题"></a>缓解高估问题</h2><p>由于DQN选择的是$maxQ^*(s_{t+1},a)$，而且原始的DQN使用Bootstrapping方式更新自己的参数，会导致严重的非均匀高估问题。</p><p>这里有两种方法用于缓解高估问题：</p><ul><li><p>使用目标网络（Target Network）</p></li><li><p>Double DQN</p></li></ul><h3 id="Target-Network"><a href="#Target-Network" class="headerlink" title="Target Network"></a>Target Network</h3><p>相比于DQN，Target Network是独立于DQN的。它与DQN有着相同的神经网络结构，但有不同的参数，记作w-。</p><p>我们使用Q(s,a;w)来控制Agent并且收集transition</p><p>使用Q(s,q;w-)来选择动作和计算TD target。</p><p>以前使用DQN来计算yt，用yt来更新DQN的参数。这会产生自举。现在我们使用Target Network，用Target Network来计算yt。这样就可以缓解高估问题。</p><h3 id="Double-DQN"><a href="#Double-DQN" class="headerlink" title="Double DQN"></a>Double DQN</h3><p>DDQN在选择动作时使用的是DQN原始的网络，在计算TD target时使用的是target network，这样相比原始DQN和target network可以更加缓解高估问题</p><h1 id="离散动作空间与连续动作空间"><a href="#离散动作空间与连续动作空间" class="headerlink" title="离散动作空间与连续动作空间"></a>离散动作空间与连续动作空间</h1><p>离散动作空间是一个集合，其中包含有限个动作。比如在玩2D横版过关游戏时，agent的动作空间只能是上下左右四种动作。对于动作空间是离散的agent可以使用传统的SARSA、DQN算法进行训练</p><p>连续动作空间就像是gym的摆杆子环境，或者机械臂控制，由于可以[0,360]度旋转，所以有无穷多种动作空间。对于连续的动作空间，可以使用离散化将连续动作空间变成离散的，但是对于自由度很高的agent，离散化的点就会很多，这会导致维度灾难，离散化只适合较小的连续动作空间</p><h2 id="Deterministic-Policy-Gradient"><a href="#Deterministic-Policy-Gradient" class="headerlink" title="Deterministic Policy Gradient"></a>Deterministic Policy Gradient</h2><p>DPG是策略梯度的变体，专门用于处理确定性策略。与传统的基于随机策略的策略梯度方法不同，DPG直接优化确定性策略，可以处理连续动作空间的问题。</p><p>在DPG中，策略$\mu(s; \theta)$是确定性的，即给定一个状态s，策略直接输出一个具体的动作a：$a &#x3D; \mu(s; \theta))$</p><p>DPG是属于AC方法，有一个策略网络，有一个价值网络</p><p>策略网络是一个确定性的网络，它的输入是状态s，它的输出不是概率分布，而是一个确定性的动作。只要给定状态s，那么对应的动作a就是一个具体的动作</p><p>价值网络有两个输入，一个是状态s一个是动作a，基于状态s，Critic对a进行打分。</p><h3 id="DPG的更新策略"><a href="#DPG的更新策略" class="headerlink" title="DPG的更新策略"></a>DPG的更新策略</h3><p>训练策略网络需要价值网络的帮忙，改善策略网络的参数θ以至于动作a可以依靠策略网络变得更好，而更新参数θ是要根据价值网络q(s,a;w)&#x3D;q(s,π(s;θ);w)的增加而决定的。</p><p>因而我们训练策略网络的目标是让价值网络q的输出变的更大。价值网络的输入是状态s,a，对于确定的状态，确定性策略网络会输出对应的动作a。</p><p>如果输入的状态s是固定的，Critic也是固定的，那么唯一会影响q（Critic的打分）的因素，就是Actor的参数θ。我们想要更新θ，让q变大，那么就可以求取q对θ的梯度，然后使用梯度上升来更新参数θ，这样就可以让价值q变大。这个梯度就叫做确定策略梯度DPG，它是价值q关于Actor参数θ的梯度</p>]]></content>
      
      
      <categories>
          
          <category> ReinforceLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReinforceLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch基础入门</title>
      <link href="/inori/8f832495.html"/>
      <url>/inori/8f832495.html</url>
      
        <content type="html"><![CDATA[<h1 id="两个实用函数"><a href="#两个实用函数" class="headerlink" title="两个实用函数"></a>两个实用函数</h1><p>假如pytorch是一个大型工具箱，我们想查看工具箱中有什么工具，这时就可以使用<code>dir()</code>函数查看，如果我们想知道某一个工具是如何使用的，就可以使用<code>help()</code>函数查看</p><ul><li><code>dir()</code>：可以查看指定对象包含的全部内容，包括变量、方法、函数和类等。不仅包含可供我们调用的模块成员，还包含所有名称以双下划线“__”开头和结尾的“特殊”命名的私有成员，这些成员是在本模块中使用的，不能在类的外部调用。</li><li><code>help()</code>：查看指定对象（类型、模块、变量、方法等）的详细使用说明</li></ul><h1 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h1><p>在学习和使用pytorch时，要经常使用<a href="https://pytorch.org/docs/stable/index.html">官方文档</a>，里面有详细的使用说明</p><h2 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h2><h3 id="加载数据方法及label形式"><a href="#加载数据方法及label形式" class="headerlink" title="加载数据方法及label形式"></a>加载数据方法及label形式</h3><p>Pytorch中加载数据需要Dataset、Dataloader</p><ul><li>Dataset提供一种方式去获取每个数据及其对应的label和编号，以及总共有多少个数据</li><li>Dataloader为后面的网络提供不同的数据形式，可以将数据进行打包</li></ul><p>label形式</p><ul><li>文件夹名即为label。文件夹中存放若干条数据</li><li>一个文件夹存放数据，数据有编号，另一个文件夹存放数据对应编号的说明文本（txt），文本中有label</li><li>直接把label写在数据的名称上</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br></pre></td></tr></table></figure><h3 id="通过路径加载数据"><a href="#通过路径加载数据" class="headerlink" title="通过路径加载数据"></a>通过路径加载数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img_path = <span class="string">&quot;数据路径/train/ants/0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure><h3 id="python特殊方法补充"><a href="#python特殊方法补充" class="headerlink" title="python特殊方法补充"></a>python特殊方法补充</h3><p>Python中有很多特殊方法，这些特殊方法的命名都以双下划线 <code>__</code>开头和结尾，它们是Python中常用的特殊方法。通过定义这些方法，我们可以自定义对象的行为和操作，使得对象能够更好地适应我们的需求</p><ul><li><code>__init__(self[, args...])</code>: 构造函数，用于在创建对象时进行初始化。即Java中的构造器</li><li><code>__repr__(self)</code>: 用于定义对象的字符串表示形式，通常用于调试和记录日志</li><li><code>__str__(self)</code>: 用于定义对象的字符串表示形式，通常用于显示给终端用户。即Java中的toString</li><li><code>__len__(self)</code>: 用于返回对象的长度，通常在对像被视为序列或集合时使用</li><li><code>__getitem__(self, key)</code>: 用于实现索引操作，可以通过索引或切片访问对象中的元素</li><li><code>__setitem__(self, key, value)</code>: 用于实现索引赋值操作，可以通过索引或切片为对象中的元素赋值</li><li><code>__delitem__(self, key)</code>: 用于实现删除某个元素的操作，可以通过索引或切片删除对象中的元素</li><li><code>__contains__(self, item)</code>: 用于检查对象是否包含某个元素，可以通过 in 关键字使用</li><li><code>__enter__(self)</code>: 用于实现上下文管理器的进入操作，通常与 with 语句一起使用</li><li><code>__exit__(self, exc_type, exc_value, traceback)</code>: 用于实现上下文管理器的退出操作，通常与 with 语句一起使用</li><li><code>__call__(self[, args...])</code>: 用于使对象能够像函数一样被调用，通常在创建可调用的类时使用</li><li><code>__eq__(self, other)</code>: 用于定义对象相等的比较操作，可以通过 &#x3D;&#x3D; 运算符使用</li><li><code>__lt__(self, other)</code>: 用于定义对象小于的比较操作，可以通过 &lt; 运算符使用</li><li><code>__gt__(self, other)</code>: 用于定义对象大于的比较操作，可以通过 &gt; 运算符使用</li><li><code>__add__(self, other)</code>: 用于实现对象加法操作，可以通过 + 运算符使用</li><li><code>__sub__(self, other)</code>: 用于实现对象减法操作，可以通过 - 运算符使用</li><li><code>__mul__(self, other)</code>: 用于实现对象乘法操作，可以通过 * 运算符使用</li><li><code>__truediv__(self, other)</code>: 用于实现对象除法操作，可以通过 &#x2F; 运算符使用</li></ul><h3 id="Dataset加载数据示例"><a href="#Dataset加载数据示例" class="headerlink" title="Dataset加载数据示例"></a>Dataset加载数据示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义数据集类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir  <span class="comment"># 记录数据集根目录的路径</span></span><br><span class="line">        self.label_dir = label_dir  <span class="comment"># 记录数据集标签目录的名称</span></span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)  <span class="comment"># os.path.join可将两个字符串拼接成一个完整路径，以获取数据集标签目录的完整路径</span></span><br><span class="line">        self.img_path = os.listdir(self.path)  <span class="comment"># os.listdir() 函数用于获取指定目录下的所有文件和文件夹的名称列表，以获取数据集标签目录下所有图像文件的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):  <span class="comment"># 获取数据集中指定索引位置的数据项</span></span><br><span class="line">        img_name = self.img_path[idx]  <span class="comment"># 获取图像文件名</span></span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)  <span class="comment"># 获取该图像文件的完整路径</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)  <span class="comment"># 打开图像文件</span></span><br><span class="line">        label = self.label_dir  <span class="comment"># 获取该图像文件所属的标签</span></span><br><span class="line">        <span class="keyword">return</span> img, label  <span class="comment"># 返回图像和标签</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;data/train&quot;</span>   <span class="comment"># 数据集根目录的路径</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span>     <span class="comment"># 蚂蚁标签目录的名称</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span>     <span class="comment"># 蜜蜂标签目录的名称</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)  <span class="comment"># 创建蚂蚁数据集对象</span></span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)   <span class="comment"># 创建蜜蜂数据集对象</span></span><br><span class="line">train_dataset = ants_dataset + bees_dataset  <span class="comment"># 合并蚂蚁和蜜蜂数据集，得到训练集</span></span><br><span class="line">img, label = train_dataset[<span class="number">200</span>]  <span class="comment"># 自动调用__getitem__() 方法，获取训练集中第 200 个数据项的图像和标签 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;label：&quot;</span>, label)   <span class="comment"># 查看该数据项的标签</span></span><br><span class="line">img.show()   </span><br></pre></td></tr></table></figure><h2 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h2><p>Tensorboad可以用来查看loss是否按照预想的变化，或者查看训练到某一步输出的图像是什么样</p><h3 id="Tensorboard使用示例"><a href="#Tensorboard使用示例" class="headerlink" title="Tensorboard使用示例"></a>Tensorboard使用示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)<span class="comment"># 创建一个 SummaryWriter 对象，指定日志存储目录为 &quot;logs&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># 将 y=x 的函数值添加到 TensorBoard 中</span></span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=x&quot;</span>, i, i)</span><br><span class="line">writer.close()<span class="comment"># 关闭 SummaryWriter 对象</span></span><br></pre></td></tr></table></figure><p>运行完后会在当前目录下创建一个logs文件夹</p><p>在终端运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=logs --port=6007</span><br></pre></td></tr></table></figure><h2 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h2><p>Transforms当成工具箱的话，里面的class就是不同的工具。例如像totensor、resize这些工具。Transforms拿一些特定格式的图片，经过Transforms里面的工具，获得我们想要的结果</p><h3 id="transforms-Totensor"><a href="#transforms-Totensor" class="headerlink" title="transforms.Totensor"></a>transforms.Totensor</h3><p>Tensor包装了神经网络需要的一些属性，比如反向传播、梯度等属性</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;/bees/10870992_eebeeb3a12.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line">tensor_trans = transforms.ToTensor()  <span class="comment"># 创建 transforms.ToTensor类 的实例化对象</span></span><br><span class="line">tensor_img = tensor_trans(img)  <span class="comment"># 调用 transforms.ToTensor类的__call__方法   </span></span><br><span class="line"></span><br><span class="line">writer.add_image(<span class="string">&quot;Temsor_img&quot;</span>,tensor_img)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h3 id="transforms-Resize"><a href="#transforms-Resize" class="headerlink" title="transforms.Resize()"></a>transforms.Resize()</h3><p>调整图像的大小到指定的尺寸</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;data/Images/1.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图片转为totensor类型</span></span><br><span class="line">trans_totensor = transforms.ToTensor() </span><br><span class="line">img_tensor = trans_totensor(img)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># resize图片，PIL数据类型的 img -&gt; resize -&gt; PIL数据类型的 img_resize</span></span><br><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>,<span class="number">512</span>))  <span class="comment"># 调整尺寸为512*512</span></span><br><span class="line">img_resize = trans_resize(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL 数据类型的 PIL -&gt; totensor -&gt; img_resize tensor</span></span><br><span class="line">img_resize = trans_totensor(img_resize)</span><br><span class="line"><span class="built_in">print</span>(img_resize.size()) </span><br></pre></td></tr></table></figure><h4 id="transforms-Compose"><a href="#transforms-Compose" class="headerlink" title="transforms.Compose"></a>transforms.Compose</h4><p>transforms.Compose 的作用是将多个数据预处理操作组合在一起，方便地对数据进行一次性处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;data/Images/1.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line">tensor_trans = transforms.ToTensor() </span><br><span class="line">img_tensor = tensor_trans(img)  </span><br><span class="line"></span><br><span class="line">trans_resize_2 = transforms.Resize(<span class="number">512</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL —— resize -&gt; PIL ——  totensor -&gt; tensor</span></span><br><span class="line">trans_compose = transforms.Compose([trans_resize_2, trans_totensor]) <span class="comment"># Compose函数中前面一个参数的输出为后面一个参数的输入，即trans_resize_2输出了pil，作为trans_totensor的输入</span></span><br><span class="line">img_resize_2 = trans_compose(img)</span><br><span class="line"><span class="built_in">print</span>(img_resize_2.size()) </span><br></pre></td></tr></table></figure><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>DataLoader可以将数据集进行批量处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备的测试数据集</span></span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor())    </span><br><span class="line"></span><br><span class="line"><span class="comment"># batch_size=4 使得 img0, target0 = dataset[0]、img1, target1 = dataset[1]、img2, target2 = dataset[2]、img3, target3 = dataset[3]，然后这四个数据作为Dataloader的一个返回      </span></span><br><span class="line">test_loader = DataLoader(dataset=test_data,batch_size=<span class="number">4</span>,shuffle=<span class="literal">True</span>,num_workers=<span class="number">0</span>,drop_last=<span class="literal">True</span>)      </span><br><span class="line"><span class="comment"># 用for循环取出DataLoader打包好的四个数据</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">        imgs, targets = data <span class="comment"># 每个data都是由4张图片组成，imgs.size 为 [4,3,32,32]，四张32×32图片三通道，targets由四个标签组成             </span></span><br><span class="line">        writer.add_images(<span class="string">&quot;Epoch：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch), imgs, step) <span class="comment"># 注意是images</span></span><br><span class="line">        step = step + <span class="number">1</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="nn-Module"><a href="#nn-Module" class="headerlink" title="nn.Module"></a>nn.Module</h3><p>orch.nn.Module是所有神经网络基本骨架，需要重写<code>__init__</code>和forward（前向传播）函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()  <span class="comment"># 继承</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):           <span class="comment"># 前向传播</span></span><br><span class="line">        output = <span class="built_in">input</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line">m = Module()</span><br><span class="line">x = torch.tensor(<span class="number">1.0</span>)  <span class="comment"># 创建一个值为 1.0 的tensor</span></span><br><span class="line">output = m(x)</span><br><span class="line"><span class="built_in">print</span>(output) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h3 id="卷积函数"><a href="#卷积函数" class="headerlink" title="卷积函数"></a>卷积函数</h3><p>convolution卷积，conv2d表示二维</p><p>weight卷积核的大小，bias偏置，stride步长，padding填充，group是分组卷积，对不同的通道使用不同的卷积核，言外之意一般是对每个通道使用相同卷积核</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()</span><br><span class="line">        self.conv1 = Conv2d(in_channels=<span class="number">3</span>,out_channels=<span class="number">6</span>,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">0</span>) <span class="comment"># 彩色图像输入为3层，我们想让它的输出为6层，选3 * 3 的卷积                </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">m = Module()</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = m(imgs)</span><br><span class="line">    <span class="built_in">print</span>(imgs.shape)   <span class="comment"># 输入为3通道32×32的64张图片</span></span><br><span class="line">    <span class="built_in">print</span>(output.shape) <span class="comment"># 输出为6通道30×30的64张图片</span></span><br></pre></td></tr></table></figure><h3 id="最大池化"><a href="#最大池化" class="headerlink" title="最大池化"></a>最大池化</h3><p>nn.MaxPool2d最大池化（下采样，最常用），nn.MaxUnpool2d（上采样），nn.AdaptiveMaxPool2d（自适应最大池化），ceil_mode&#x3D;True表示进位，默认为False，写论文会用到公式可以在官网查阅</p><p>最大池化的作用：保留输入的特征，同时把数据量减少，比如视频变720P</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn </span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> MaxPool2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()</span><br><span class="line">        self.maxpool = MaxPool2d(kernel_size=<span class="number">3</span>, ceil_mode=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        output = self.maxpool(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">m = Module()  <span class="comment"># 即调用forward()</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    output = m(imgs)</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step = step + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="非线性激活"><a href="#非线性激活" class="headerlink" title="非线性激活"></a>非线性激活</h3><p>作用：神经网络中引入非线性的特质，才能训练出符合各种特征的模型</p><p>nn.ReLU()小于0进行截断，大于0不变，nn.Sigmoid非线性缩放到[0,1]，1&#x2F;1+exp-x，inplace&#x3D;True表示把原来的值也改变（本来是通过返回值获取值）</p><h3 id="线性层及其它层"><a href="#线性层及其它层" class="headerlink" title="线性层及其它层"></a>线性层及其它层</h3><ul><li>Normalization Layers正则化层：加快神经网络的训练速度</li><li>Recurrent Layers用于文字识别，特定的网络结构，用的不多</li><li>Linear Layers：全连接层，用的较多</li><li>Dropout Layers随机将一些数设为0，防止过拟合</li><li>Distance Functions计算两个值之间的误差，常用余弦相似度</li><li>Loss Functions损失函数，常用值nn.MSELoss，nn.CrossEntropyLoss，nn.BCELoss，分布nn.NLLLoss，nn.KLDivLoss</li><li>torch.flatten()把输入展成一行，与reshape不同</li></ul><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><ul><li>Loss损失函数一方面计算实际输出和目标之间的差距</li><li>Loss损失函数另一方面为我们更新输出提供一定的依据(反向传播)</li></ul><p><strong>L1loss</strong>:差值的绝对值之和，再求平均值</p><p><strong>MSE</strong>:平方差</p><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度下降是一种优化算法，用于最小化损失函数（Loss Function）。神经网络的训练目标是通过不断调整网络的参数（即权重和偏置）来最小化损失函数的值。梯度下降算法通过计算损失函数相对于网络参数的梯度来指导参数更新的方向和步幅。</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>反向传播是一种高效计算梯度的方法，适用于多层神经网络。反向传播算法通过链式法则（Chain Rule）逐层计算损失函数对每个参数的梯度。</p><p><strong>反向传播和梯度下降的关系</strong></p><ol><li><strong>目标一致</strong>：两者的目标都是通过调整神经网络的参数来最小化损失函数</li><li><strong>互补</strong>：反向传播计算损失函数对参数的梯度，而梯度下降利用这些梯度更新参数</li><li><strong>训练过程</strong>：在神经网络的训练过程中，反向传播和梯度下降是交替进行的。首先进行前向传播，计算损失并通过反向传播计算梯度，然后使用梯度下降更新参数</li></ol><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>使用优化器时，首先需要optim.zero_grad()，把上一步的梯度清零，否则会累加，然后进行反向传播，再optimizer.step()，对weight参数进行更新</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear, Sequential</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                       download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loss = nn.CrossEntropyLoss()  <span class="comment"># 交叉熵</span></span><br><span class="line">m = Module()</span><br><span class="line">optim = torch.optim.SGD(tudui.parameters(), lr=<span class="number">0.01</span>)  <span class="comment"># 随机梯度下降优化器 lr为学习率,学习率太大不稳定,太小收敛慢</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化20轮</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        outputs = m(imgs)</span><br><span class="line">        result_loss = loss(outputs, targets) <span class="comment"># 计算实际输出与目标输出的差距</span></span><br><span class="line">        optim.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">        result_loss.backward() <span class="comment"># 反向传播，计算损失函数的梯度</span></span><br><span class="line">        optim.step()   <span class="comment"># 根据梯度，对网络的参数进行调优</span></span><br><span class="line">        running_loss = running_loss + result_loss</span><br><span class="line">    <span class="built_in">print</span>(running_loss) <span class="comment"># 每轮误差的总和</span></span><br></pre></td></tr></table></figure><h3 id="train-和tudui-eval-方法"><a href="#train-和tudui-eval-方法" class="headerlink" title="train()和tudui.eval()方法"></a>train()和tudui.eval()方法</h3><p>分别用于训练步骤和测试步骤，对特定层起作用，最好可以在训练和评估之前加上这个方法</p><h2 id="网络模型的保存和读取"><a href="#网络模型的保存和读取" class="headerlink" title="网络模型的保存和读取"></a>网络模型的保存和读取</h2><p>使用<code>save</code>方法保存网络模型的结构和参数，<code>load</code>加载时候要把模型定义给复制过来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(SimpleModel, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.fc(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">model = SimpleModel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存权重</span></span><br><span class="line">torch.save(model.state_dict(), <span class="string">&#x27;model_weights.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载权重</span></span><br><span class="line">loaded_model = SimpleModel()</span><br><span class="line">loaded_model.load_state_dict(torch.load(<span class="string">&#x27;model_weights.pth&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保模型和加载的权重一致</span></span><br><span class="line">loaded_model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以继续使用加载的模型进行预测等操作</span></span><br></pre></td></tr></table></figure><h2 id="利用GPU训练"><a href="#利用GPU训练" class="headerlink" title="利用GPU训练"></a>利用GPU训练</h2><p>在程序之前定义:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后找到</p><ul><li>网络模型</li><li>数据（输入、标注）</li><li>损失函数</li></ul><p>后面加上<code>to(device)</code>即可转到GPU训练</p><h2 id="完整版实战"><a href="#完整版实战" class="headerlink" title="完整版实战"></a>完整版实战</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义训练的设备</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()        </span><br><span class="line">        self.model1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),  <span class="comment"># 输入通道3，输出通道32，卷积核尺寸5×5，步长1，填充2    </span></span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Flatten(),  <span class="comment"># 展平后变成 64*4*4 了</span></span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>,<span class="number">64</span>),</span><br><span class="line">            nn.Linear(<span class="number">64</span>,<span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据集</span></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">True</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line"></span><br><span class="line"><span class="comment"># length 长度</span></span><br><span class="line">train_data_size = <span class="built_in">len</span>(train_data)</span><br><span class="line">test_data_size = <span class="built_in">len</span>(test_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 Dataloader 来加载数据集</span></span><br><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>)        </span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网络模型</span></span><br><span class="line">m = Module() </span><br><span class="line">m = m.to(device) <span class="comment"># 也可以不赋值，直接m.to(device) </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss() <span class="comment"># 交叉熵</span></span><br><span class="line">loss_fn = loss_fn.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化器</span></span><br><span class="line">learning = <span class="number">0.01</span></span><br><span class="line">optimizer = torch.optim.SGD(tudui.parameters(),learning)   <span class="comment"># 随机梯度下降优化器  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置网络的一些参数</span></span><br><span class="line"><span class="comment"># 记录训练的次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 记录测试的次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练的轮次</span></span><br><span class="line">epoch = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 tensorboard</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----第 &#123;&#125; 轮训练开始-----&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练步骤开始</span></span><br><span class="line">    tudui.train() <span class="comment"># 当网络中有dropout层、batchnorm层时，这些层能起作用</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, targets = data            </span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        targets = targets.to(device)</span><br><span class="line">        outputs = tudui(imgs)</span><br><span class="line">        loss = loss_fn(outputs, targets) <span class="comment"># 计算实际输出与目标输出的差距</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 优化器对模型调优</span></span><br><span class="line">        optimizer.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">        loss.backward() <span class="comment"># 反向传播，计算损失函数的梯度</span></span><br><span class="line">        optimizer.step()   <span class="comment"># 根据梯度，对网络的参数进行调优</span></span><br><span class="line">        </span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            <span class="built_in">print</span>(end_time - start_time) <span class="comment"># 运行训练一百次后的时间间隔</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;训练次数：&#123;&#125;，Loss：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_train_step,loss.item()))  <span class="comment"># 方式二：获得loss值</span></span><br><span class="line">            writer.add_scalar(<span class="string">&quot;train_loss&quot;</span>,loss.item(),total_train_step)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试步骤开始（每一轮训练后都查看在测试数据集上的loss情况）</span></span><br><span class="line">    tudui.<span class="built_in">eval</span>()  <span class="comment"># 当网络中有dropout层、batchnorm层时，这些层不能起作用</span></span><br><span class="line">    total_test_loss = <span class="number">0</span></span><br><span class="line">    total_accuracy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 没有梯度了</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader: <span class="comment"># 测试数据集提取数据</span></span><br><span class="line">            imgs, targets = data <span class="comment"># 数据放到cuda上</span></span><br><span class="line">            imgs = imgs.to(device) <span class="comment"># 也可以不赋值，直接 imgs.to(device)</span></span><br><span class="line">            targets = targets.to(device) <span class="comment"># 也可以不赋值，直接 targets.to(device)</span></span><br><span class="line">            outputs = tudui(imgs)</span><br><span class="line">            loss = loss_fn(outputs, targets) <span class="comment"># 仅data数据在网络模型上的损失</span></span><br><span class="line">            total_test_loss = total_test_loss + loss.item() <span class="comment"># 所有loss</span></span><br><span class="line">            accuracy = (outputs.argmax(<span class="number">1</span>) == targets).<span class="built_in">sum</span>()</span><br><span class="line">            total_accuracy = total_accuracy + accuracy</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的Loss：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_test_loss))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的正确率：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_accuracy/test_data_size))</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_loss&quot;</span>,total_test_loss,total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_accuracy&quot;</span>,total_accuracy/test_data_size,total_test_step)  </span><br><span class="line">    total_test_step = total_test_step + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    torch.save(m, <span class="string">&quot;./model/m_&#123;&#125;.pth&quot;</span>.<span class="built_in">format</span>(i)) <span class="comment"># 保存每一轮训练后的结果</span></span><br><span class="line">    <span class="comment">#torch.save(m.state_dict(),&quot;m_&#123;&#125;.path&quot;.format(i)) # 保存方式二         </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型已保存&quot;</span>)</span><br><span class="line">    </span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><p>**with torch.no_grad()**表示在训练数据集的同时进行验证，可以让之后的代码不影响目前的梯度</p>]]></content>
      
      
      <categories>
          
          <category> pytorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy常用api</title>
      <link href="/inori/e0d16fd2.html"/>
      <url>/inori/e0d16fd2.html</url>
      
        <content type="html"><![CDATA[<p>NumPy，全称Numerical Python，是一个开源的Python库，它为Python提供了强大的多维数组对象和用于处理这些数组的函数。NumPy的核心是ndarray，它是一个高效的多维数组容器，用于存储和处理大规模的数据。NumPy还提供了许多数学函数，用于数组之间的操作，以及用于线性代数、傅立叶变换和随机数生成等功能。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h3><p><code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p><p>上面的构造器接受以下参数：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">object</td><td align="left">返回一个数组或任何（嵌套）序列</td></tr><tr><td align="left">dtype</td><td align="left">数组的所需数据类型，可选</td></tr><tr><td align="left">copy</td><td align="left">可选，默认为<code>true</code>，对象是否被复制</td></tr><tr><td align="left">order</td><td align="left"><code>C</code>（按行）、<code>F</code>（按列）或<code>A</code>（任意，默认）</td></tr><tr><td align="left">subok</td><td align="left">默认情况下，返回的数组被强制为基类数组。 如果为<code>true</code>，则返回子类</td></tr><tr><td align="left">ndmin</td><td align="left">指定返回数组的最小维数</td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  </span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">c = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], ndmin =  <span class="number">2</span>) </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a = [1, 2, 3]</span></span><br><span class="line"><span class="string">b = [[1, 2] ,[3, 4]]</span></span><br><span class="line"><span class="string">c = [[1,2,3,4,5]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><p>创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组</p><p><code>numpy.empty(shape, dtype = float, order = &#39;C&#39;)</code></p><h3 id="zeros"><a href="#zeros" class="headerlink" title="zeros"></a>zeros</h3><p>创建指定大小的数组，数组元素以 0 来填充：</p><p><code>numpy.zeros(shape, dtype = float, order = &#39;C&#39;)</code></p><h3 id="ones"><a href="#ones" class="headerlink" title="ones"></a>ones</h3><p>创建指定形状的数组，数组元素以 1 来填充：</p><p><code>numpy.ones(shape, dtype = None, order = &#39;C&#39;)</code></p><h3 id="zeros-like"><a href="#zeros-like" class="headerlink" title="zeros_like"></a>zeros_like</h3><p>创建一个与给定数组具有相同形状的数组，数组元素以 0 来填充</p><p><code>numpy.zeros_like(a, dtype=None, order=&#39;K&#39;, subok=True, shape=None)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个 3x3 的二维数组</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个与 arr 形状相同的，所有元素都为 0 的数组</span></span><br><span class="line">zeros_arr = np.zeros_like(arr)</span><br><span class="line"><span class="built_in">print</span>(zeros_arr)</span><br></pre></td></tr></table></figure><h3 id="asarray"><a href="#asarray" class="headerlink" title="asarray"></a>asarray</h3><p>类似numpy.array，但参数只有三个</p><p><code>numpy.asarray(a, dtype = None, order = None)</code></p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line">a = np.asarray(x)  <span class="comment"># [1,2,3] </span></span><br><span class="line"></span><br><span class="line">x =  (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line">a = np.asarray(x) <span class="comment"># [1,2,3]</span></span><br><span class="line"></span><br><span class="line">x =  [(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>)] </span><br><span class="line">a = np.asarray(x) <span class="comment"># [1,2,3] </span></span><br></pre></td></tr></table></figure><h3 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h3><p>创建数值范围并返回ndarray对象</p><p><code>numpy.arange(start, stop, step, dtype)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">起始值，默认为<code>0</code></td></tr><tr><td align="left"><code>stop</code></td><td align="left">终止值（不包含）</td></tr><tr><td align="left"><code>step</code></td><td align="left">步长，默认为<code>1</code></td></tr><tr><td align="left"><code>dtype</code></td><td align="left">返回<code>ndarray</code>的数据类型，如果没有提供，则会使用输入数据的类型。</td></tr></tbody></table><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(x)<span class="comment"># [10  12  14  16  18]</span></span><br></pre></td></tr></table></figure><h3 id="linspace"><a href="#linspace" class="headerlink" title="linspace"></a>linspace</h3><p>用于创建一个一维数组，数组是一个等差数列构成的</p><p><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">序列的起始值</td></tr><tr><td align="left"><code>stop</code></td><td align="left">序列的终止值，如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td align="left"><code>num</code></td><td align="left">要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td align="left"><code>endpoint</code></td><td align="left">该值为<code>true</code>时，数列中包含<code>stop</code>值，反之不包含，默认是True</td></tr><tr><td align="left"><code>retstep</code></td><td align="left">如果为<code>true</code>时，生成的数组中会显示间距，反之不显示</td></tr><tr><td align="left"><code>dtype</code></td><td align="left">数据类型</td></tr></tbody></table><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 设置起始点为 1 ，终止点为 10，数列个数为 10</span></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># [ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]</span></span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">10</span>, <span class="number">20</span>,  <span class="number">5</span>, endpoint =  <span class="literal">False</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># [10. 12. 14. 16. 18.]</span></span><br></pre></td></tr></table></figure><h3 id="logspace"><a href="#logspace" class="headerlink" title="logspace"></a>logspace</h3><p>用于创建一个等比数列</p><p><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">序列的起始值为：$base^{start}$</td></tr><tr><td align="left"><code>stop</code></td><td align="left">序列的终止值为：$base^{stop}$。如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td align="left"><code>num</code></td><td align="left">要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td align="left"><code>endpoint</code></td><td align="left">该值为 <code>true</code> 时，数列中中包含<code>stop</code>值，反之不包含，默认是<code>true</code></td></tr><tr><td align="left"><code>base</code></td><td align="left">对数 log 的底数，默认底数是 10</td></tr><tr><td align="left"><code>dtype</code></td><td align="left">数据类型</td></tr></tbody></table><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 默认底数是 10</span></span><br><span class="line">a = np.logspace(<span class="number">1.0</span>,  <span class="number">2.0</span>, num =  <span class="number">10</span>)  </span><br><span class="line"><span class="built_in">print</span> (a)<span class="comment"># [ 10. 12.91549665 16.68100537 21.5443469  27.82559402 35.93813664  46.41588834  59.94842503  77.42636827  100.]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数的底数设置为 2 </span></span><br><span class="line">a = np.logspace(<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,base=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (a)<span class="comment"># [  1.   2.   4.   8.  16.  32.  64. 128. 256. 512.]</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>NumPy支持比Python更多种类的数值类型</p><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bool_</code></td><td align="left">存储为一个字节的布尔值（真或假）</td></tr><tr><td align="left"><code>int_</code></td><td align="left">默认整数，相当于 C 的<code>long</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left"><code>intc</code></td><td align="left">相当于 C 的<code>int</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left"><code>intp</code></td><td align="left">用于索引的整数，相当于 C 的<code>size_t</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left"><code>int8</code></td><td align="left">字节（-128 ~ 127）</td></tr><tr><td align="left"><code>int16</code></td><td align="left">16 位整数（-32768 ~ 32767）</td></tr><tr><td align="left"><code>int32</code></td><td align="left">32 位整数（-2147483648 ~ 2147483647）</td></tr><tr><td align="left"><code>int64</code></td><td align="left">64 位整数（-9223372036854775808 ~ 9223372036854775807）</td></tr><tr><td align="left"><code>uint8</code></td><td align="left">8 位无符号整数（0 ~ 255）</td></tr><tr><td align="left"><code>uint16</code></td><td align="left">16 位无符号整数（0 ~ 65535）</td></tr><tr><td align="left"><code>uint32</code></td><td align="left">32 位无符号整数（0 ~ 4294967295）</td></tr><tr><td align="left"><code>uint64</code></td><td align="left">64 位无符号整数（0 ~ 18446744073709551615）</td></tr><tr><td align="left"><code>float_</code></td><td align="left"><code>float64</code>的简写</td></tr><tr><td align="left"><code>float16</code></td><td align="left">半精度浮点：符号位，5 位指数，10 位尾数</td></tr><tr><td align="left"><code>float32</code></td><td align="left">单精度浮点：符号位，8 位指数，23 位尾数</td></tr><tr><td align="left"><code>float64</code></td><td align="left">双精度浮点：符号位，11 位指数，52 位尾数</td></tr><tr><td align="left"><code>complex_</code></td><td align="left"><code>complex128</code>的简写</td></tr><tr><td align="left"><code>complex64</code></td><td align="left">复数，由两个 32 位浮点表示（实部和虚部）</td></tr><tr><td align="left"><code>complex128</code></td><td align="left">复数，由两个 64 位浮点表示（实部和虚部）</td></tr></tbody></table><p>NumPy数字类型是<code>dtype</code>（数据类型）对象的实例，每个对象具有唯一的特征。这些类型可以是<code>np.bool_</code>，<code>np.float32</code>等。</p><p>数据类型对象描述了对应于数组的固定内存块的解释，取决于以下方面：</p><ul><li>数据类型（整数、浮点或者Python对象）</li><li>数据大小</li><li>字节序（小端或大端）</li><li>在结构化类型的情况下，字段的名称，每个字段的数据类型，和每个字段占用的内存块部分</li><li>如果数据类型是子序列，它的形状和数据类型</li></ul><p>字节顺序取决于数据类型的前缀<code>&lt;</code>或<code>&gt;</code>。 <code>&lt;</code>意味着编码是小端（最小有效字节存储在最小地址中）。 <code>&gt;</code>意味着编码是大端（最大有效字节存储在最小地址中）。</p><p><code>dtype</code>可由以下语法构造：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br></pre></td></tr></table></figure><ul><li><code>Object</code>：被转换为数据类型的对象</li><li><code>align</code>：向字段添加间隔，填充字段使其类似结构体</li><li><code>copy</code>：生成<code>dtype</code>对象的新副本，如果为<code>false</code>，结果是内建数据类型对象的引用</li></ul><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 使用标量类型</span></span><br><span class="line">dt = np.dtype(np.int32)</span><br><span class="line"><span class="comment"># int8, int16, int32, int64 四种数据类型可以使用字符串 &#x27;i1&#x27;, &#x27;i2&#x27;,&#x27;i4&#x27;,&#x27;i8&#x27; 代替</span></span><br><span class="line">dt = np.dtype(<span class="string">&#x27;i4&#x27;</span>)</span><br><span class="line"><span class="comment"># 将数据类型应用于 ndarray 对象</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype = dt) </span><br><span class="line"></span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]) </span><br><span class="line">a = np.array([(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="comment"># [(&#x27;abc&#x27;, 21, 50.0), (&#x27;xyz&#x27;, 18, 75.0)]</span></span><br></pre></td></tr></table></figure><h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><p>数组的维数称为秩（rank），秩就是轴的数量，一维数组的秩为1，二维数组的秩为2</p><p>在NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是NumPy中的轴，第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量秩，就是数组的维数。</p><p>很多时候可以声明axis。axis&#x3D;0，表示沿着第0轴进行操作，即对每一列进行操作；axis&#x3D;1，表示沿着第1轴进行操作，即对每一行进行操作</p><p>NumPy的数组中比较重要ndarray对象属性有：</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.ndim</td><td align="left">秩，即轴的数量或维度的数量</td></tr><tr><td align="left">ndarray.shape</td><td align="left">数组的维度，对于矩阵，n行m列</td></tr><tr><td align="left">ndarray.size</td><td align="left">数组元素的总个数，相当于<code>.shape</code>中n*m的值</td></tr><tr><td align="left">ndarray.dtype</td><td align="left">元素类型</td></tr><tr><td align="left">ndarray.itemsize</td><td align="left">每个元素的大小，以字节为单位</td></tr><tr><td align="left">ndarray.flags</td><td align="left">内存信息</td></tr><tr><td align="left">ndarray.real</td><td align="left">实部</td></tr><tr><td align="left">ndarray.imag</td><td align="left">虚部</td></tr></tbody></table><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">24</span>)  </span><br><span class="line"><span class="built_in">print</span> (a.ndim)<span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整大小</span></span><br><span class="line">b = a.reshape(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span> (b.ndim)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span> (a.shape)<span class="comment"># (2, 3)</span></span><br><span class="line"><span class="comment"># 调整数组大小</span></span><br><span class="line">a.shape =  (<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span> (a)<span class="comment"># [[1 2],[3 4],[5 6]]</span></span><br></pre></td></tr></table></figure><h2 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h2><p>ndarray对象的内容可以通过索引或切片来访问和修改，与Python中list的切片操作一样。</p><p>ndarray数组可以基于0-n的下标进行索引，切片对象可以通过内置的slice函数，并设置start, stop及step参数进行，从原数组中切割出一个新数组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)   <span class="comment"># 从索引 2 开始到索引 7 停止，间隔为2</span></span><br><span class="line"><span class="built_in">print</span> (a[s])<span class="comment"># [2  4  6]</span></span><br><span class="line"></span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>]   <span class="comment"># 从索引 2 开始到索引 7 停止，间隔为 2</span></span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment"># [2  4  6]</span></span><br></pre></td></tr></table></figure><p>多维数组同样适用上述索引提取方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 从某个索引处开始切割</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;从数组索引 a[1:] 处开始切割&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    [[1 2 3]</span></span><br><span class="line"><span class="string">     [3 4 5]</span></span><br><span class="line"><span class="string">     [4 5 6]]</span></span><br><span class="line"><span class="string">    从数组索引 a[1:] 处开始切割</span></span><br><span class="line"><span class="string">    [[3 4 5]</span></span><br><span class="line"><span class="string">     [4 5 6]]</span></span><br><span class="line"><span class="string"> &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>切片还可以包括省略号<code>**…**</code>，如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>])   <span class="comment"># 第2列元素</span></span><br><span class="line"><span class="built_in">print</span> (a[<span class="number">1</span>,...])   <span class="comment"># 第2行元素</span></span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>:])  <span class="comment"># 第2列及剩下的所有元素</span></span><br></pre></td></tr></table></figure><ul><li><code>a[..., 1]</code> 的意思是：选择数组 <code>a</code> 的所有行，并选取每行的第2个元素（索引1处的元素）</li><li><code>a[1, ...]</code> 的意思是：选取数组 <code>a</code> 的第2行（索引1处的整行），并保留该行的所有列</li><li><code>...</code> 表示取所有剩余维度</li></ul><h3 id="高级索引"><a href="#高级索引" class="headerlink" title="高级索引"></a>高级索引</h3><h4 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h4><p>整数数组索引是指使用一个数组来访问另一个数组的元素。这个数组中的每个元素都是目标数组中某个维度上的索引值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([[<span class="number">1</span>,  <span class="number">2</span>],  [<span class="number">3</span>,  <span class="number">4</span>],  [<span class="number">5</span>,  <span class="number">6</span>]]) </span><br><span class="line"><span class="comment"># 获取数组中 (0,0)、(1,1)和(2,0)位置处的元素</span></span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]  </span><br><span class="line"><span class="built_in">print</span> (y)</span><br></pre></td></tr></table></figure><p><code>x[[0, 1, 2], [0, 1, 0]]</code>的意思是：</p><ul><li>选取<code>x</code>中的元素，其行索引由第一个数组 <code>[0, 1, 2]</code> 指定</li><li>列索引由第二个数组 <code>[0, 1, 0]</code> 指定</li></ul><p>具体选取的元素为：</p><ul><li><code>x[0, 0]</code> -&gt; 第0行第0列的元素，值为1</li><li><code>x[1, 1]</code> -&gt; 第1行第1列的元素，值为4</li><li><code>x[2, 0]</code> -&gt; 第2行第0列的元素，值为5</li></ul><h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h4><p>可以通过一个布尔数组来索引目标数组，布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([[  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],[  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],[  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],[  <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span> (x)</span><br><span class="line"><span class="comment"># 打印出大于5的元素  </span></span><br><span class="line"><span class="built_in">print</span>  (<span class="string">&#x27;大于 5 的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (x[x &gt;  <span class="number">5</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[ 0  1  2]</span></span><br><span class="line"><span class="string"> [ 3  4  5]</span></span><br><span class="line"><span class="string"> [ 6  7  8]</span></span><br><span class="line"><span class="string"> [ 9 10 11]]</span></span><br><span class="line"><span class="string">大于 5 的元素是：</span></span><br><span class="line"><span class="string">[ 6  7  8  9 10 11]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播(Broadcast)是numpy对不同形状(shape)的数组（a.shape !&#x3D; b.shape）进行数值计算的方式，对数组的算术运算通常在相应的元素上进行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[ 0  1  2]</span></span><br><span class="line"><span class="string"> [10 11 12]</span></span><br><span class="line"><span class="string"> [20 21 22]</span></span><br><span class="line"><span class="string"> [30 31 32]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>3x3的二维数组与长为3的一维数组相加，等效于把一维数组在二维上重复3次再运算</p><h3 id="广播规则"><a href="#广播规则" class="headerlink" title="广播规则"></a>广播规则</h3><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加1补齐</li><li>输出数组的形状是输入数组形状的各个维度上的最大值</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为1时，这个数组能够用来计算，否则出错</li><li>当输入数组的某个维度的长度为1时，沿着此维度运算时都用此维度上的第一组值</li></ul><p><strong>简单理解：</strong></p><p>对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li>数组拥有相同形状</li><li>当前维度的值相等</li><li>当前维度的值有一个是 1</li></ul><p>若条件不满足，抛出 <strong>“ValueError: frames are not aligned”</strong> 异常</p><h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><p>NumPy提供了很多统计函数，用于从数组中查找最小元素，最大元素，百分位标准差和方差等</p><h3 id="numpy-amin-和-numpy-amax"><a href="#numpy-amin-和-numpy-amax" class="headerlink" title="numpy.amin() 和 numpy.amax()"></a>numpy.amin() 和 numpy.amax()</h3><p>用于计算数组中的元素沿指定轴的最小值</p><p><code>numpy.(amin|amax)(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></p><ul><li><code>a</code>: 输入的数组，可以是一个NumPy数组或类似数组的对象</li><li><code>axis</code>: 可选参数，用于指定在哪个轴上计算最值。如果不提供此参数，则返回整个数组的最小值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴</li><li><code>out</code>: 可选参数，用于指定结果的存储位置</li><li><code>keepdims</code>: 可选参数，如果为True，将保持结果数组的维度数目与输入数组相同。如果为False（默认值），则会去除计算后维度为1的轴</li><li><code>initial</code>: 可选参数，用于指定一个初始值，然后在数组的元素上计算最值</li><li><code>where</code>: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素</li></ul><h3 id="numpy-ptp"><a href="#numpy-ptp" class="headerlink" title="numpy.ptp()"></a>numpy.ptp()</h3><p>计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><p><code>numpy.ptp(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></p><ul><li><code>axis</code>: 可选参数，用于指定在哪个轴上计算峰值。如果不提供此参数，则返回整个数组的峰值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴</li><li><code>initial</code>: 可选参数，用于指定一个初始值，然后在数组的元素上计算峰值</li></ul><h3 id="numpy-percentile"><a href="#numpy-percentile" class="headerlink" title="numpy.percentile()"></a>numpy.percentile()</h3><p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比</p><p><code>numpy.percentile(a, q, axis)</code></p><ul><li>a: 输入数组</li><li>q: 要计算的百分位数，在0~100之间</li><li>axis: 沿着它计算百分位数的轴</li></ul><p><strong>百分位数：</strong></p><p>第p个百分位数是这样一个值，它使得至少有p%的数据项小于或等于这个值，且至少有(100-p)%的数据项大于或等于这个值</p><h3 id="numpy-median"><a href="#numpy-median" class="headerlink" title="numpy.median()"></a>numpy.median()</h3><p>用于计算数组a中元素的中位数（中值）</p><p><code>numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=&lt;no value&gt;)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line">wt = np.array([<span class="number">3</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span> (np.average(a, axis =  <span class="number">1</span>, weights = wt))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (np.average(a, axis =  <span class="number">1</span>, weights = wt, returned =  <span class="literal">True</span>))</span><br></pre></td></tr></table></figure><h3 id="numpy-mean"><a href="#numpy-mean" class="headerlink" title="numpy.mean()"></a>numpy.mean()</h3><p>返回数组中元素的平均值，如果提供了轴，则沿其计算，算术平均值是沿轴的元素的总和除以元素的数量</p><p><code>numpy.mean(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)</code></p><h3 id="numpy-average"><a href="#numpy-average" class="headerlink" title="numpy.average()"></a>numpy.average()</h3><p>根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值，该函数可以接受一个轴参数。如果没有指定轴，则数组会被展开</p><p><code>numpy.average(a, axis=None, weights=None, returned=False)</code></p><p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数</p><p>考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值</p><p><code>加权平均值 = (1*4+2*3+3*2+4*1)/(4+3+2+1)</code></p><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方的平均数</p><p><code>numpy.var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;, *, where=&lt;no value&gt;, mean=&lt;no value&gt;)</code></p><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h3><p>标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。</p><p><code>numpy.std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></p><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>NumPy 提供了标准的三角函数：sin()、cos()、tan()</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">0</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">60</span>,<span class="number">90</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;含有正弦值的数组：&#x27;</span>)</span><br><span class="line">sin = np.sin(a*np.pi/<span class="number">180</span>)</span><br><span class="line"><span class="built_in">print</span>(sin)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;计算角度的反正弦，返回值以弧度为单位：&#x27;</span>)</span><br><span class="line">inv = np.arcsin(sin)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;通过转化为角度制来检查结果：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arccos 和 arctan 函数行为类似：&#x27;</span>)</span><br><span class="line">cos = np.cos(a*np.pi/<span class="number">180</span>)  </span><br><span class="line"><span class="built_in">print</span>(cos)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;反余弦：&#x27;</span>)</span><br><span class="line">inv = np.arccos(cos)  </span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;角度制单位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;tan 函数：&#x27;</span>)</span><br><span class="line">tan = np.tan(a*np.pi/<span class="number">180</span>)  </span><br><span class="line"><span class="built_in">print</span>(tan)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;反正切：&#x27;</span>)</span><br><span class="line">inv = np.arctan(tan)  </span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;角度制单位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br></pre></td></tr></table></figure><h3 id="舍入函数"><a href="#舍入函数" class="headerlink" title="舍入函数"></a>舍入函数</h3><p>返回指定数字的四舍五入值</p><p><code>numpy.around(a,decimals)</code></p><ul><li>a: 数组</li><li>decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1.0</span>,<span class="number">5.55</span>,  <span class="number">123</span>,  <span class="number">0.567</span>,  <span class="number">25.532</span>])  </span><br><span class="line"><span class="built_in">print</span>  (<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;舍入后：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (np.around(a))</span><br><span class="line"><span class="built_in">print</span> (np.around(a, decimals =  <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span> (np.around(a, decimals =  -<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">原数组：</span></span><br><span class="line"><span class="string">[  1.      5.55  123.      0.567  25.532]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">舍入后：</span></span><br><span class="line"><span class="string">[  1.   6. 123.   1.  26.]</span></span><br><span class="line"><span class="string">[  1.    5.6 123.    0.6  25.5]</span></span><br><span class="line"><span class="string">[  0.  10. 120.   0.  30.]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="矩阵库"><a href="#矩阵库" class="headerlink" title="矩阵库"></a>矩阵库</h2><p>NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象</p><p>一个<code>m*n</code>的矩阵是一个由m行n列元素排列成的矩形阵列,矩阵里的元素可以是数字、符号或数学式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;转置数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a.T)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">原数组：</span></span><br><span class="line"><span class="string">[[ 0  1  2  3]</span></span><br><span class="line"><span class="string"> [ 4  5  6  7]</span></span><br><span class="line"><span class="string"> [ 8  9 10 11]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">转置数组：</span></span><br><span class="line"><span class="string">[[ 0  4  8]</span></span><br><span class="line"><span class="string"> [ 1  5  9]</span></span><br><span class="line"><span class="string"> [ 2  6 10]</span></span><br><span class="line"><span class="string"> [ 3  7 11]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="matlib-empty"><a href="#matlib-empty" class="headerlink" title="matlib.empty()"></a>matlib.empty()</h3><p>返回一个新的矩阵，矩阵内的元素为未初始化的值:</p><p><code>numpy.matlib.empty(shape, dtype, order)</code></p><ul><li><strong>shape</strong>: 定义新矩阵形状的整数或整数元组</li><li><strong>Dtype</strong>: 可选，数据类型</li><li><strong>order</strong>: C（行序优先） 或者 F（列序优先）</li></ul><h3 id="matlib-zeros"><a href="#matlib-zeros" class="headerlink" title="matlib.zeros()"></a>matlib.zeros()</h3><p>创建一个以 0 填充的矩阵</p><h3 id="matlib-ones"><a href="#matlib-ones" class="headerlink" title="matlib.ones()"></a>matlib.ones()</h3><p>创建一个以 1 填充的矩阵</p><h3 id="matlib-eye"><a href="#matlib-eye" class="headerlink" title="matlib.eye()"></a>matlib.eye()</h3><p>返回一个矩阵，对角线元素为1，其他位置为零</p><p><code>numpy.matlib.eye(n, M,k, dtype)</code></p><ul><li><strong>n</strong>: 返回矩阵的行数</li><li><strong>M</strong>: 返回矩阵的列数，默认为 n</li><li><strong>k</strong>: 对角线的索引</li><li><strong>dtype</strong>: 数据类型</li></ul><h3 id="matlib-identity"><a href="#matlib-identity" class="headerlink" title="matlib.identity()"></a>matlib.identity()</h3><p>返回给定大小的单位矩阵</p><h3 id="matlib-rand"><a href="#matlib-rand" class="headerlink" title="matlib.rand()"></a>matlib.rand()</h3><p>创建一个给定大小的矩阵，数据是随机填充的</p><h2 id="numpy线性代数"><a href="#numpy线性代数" class="headerlink" title="numpy线性代数"></a>numpy线性代数</h2><p>NumPy 提供了线性代数函数库 <strong>linalg</strong>，该库包含了线性代数所需的所有功能</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>dot</code></td><td align="left">两个数组的点积，即元素对应相乘。</td></tr><tr><td align="left"><code>vdot</code></td><td align="left">两个向量的点积</td></tr><tr><td align="left"><code>inner</code></td><td align="left">两个数组的内积</td></tr><tr><td align="left"><code>matmul</code></td><td align="left">两个数组的矩阵积</td></tr><tr><td align="left"><code>determinant</code></td><td align="left">数组的行列式</td></tr><tr><td align="left"><code>solve</code></td><td align="left">求解线性矩阵方程</td></tr><tr><td align="left"><code>inv</code></td><td align="left">计算矩阵的乘法逆矩阵</td></tr></tbody></table><h3 id="numpy-dot"><a href="#numpy-dot" class="headerlink" title="numpy.dot()"></a>numpy.dot()</h3><p>对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为向量点积)；</p><p>对于二维数组，计算的是两个数组的矩阵乘积；</p><p>对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是数组a的最后一维上的所有元素与数组b的倒数第二维上的所有元素的乘积和：<code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] \* b[k,:,m])</code></p><p><code>numpy.dot(a, b, out=None) </code></p><ul><li><strong>a</strong>:ndarray 数组</li><li><strong>b</strong>:ndarray 数组</li><li><strong>out</strong>:ndarray, 可选，用来保存dot()的计算结果</li></ul><h3 id="numpy-vdot"><a href="#numpy-vdot" class="headerlink" title="numpy.vdot()"></a>numpy.vdot()</h3><p>计算两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]]) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># vdot 将数组展开计算内积</span></span><br><span class="line"><span class="built_in">print</span> (np.vdot(a,b))</span><br><span class="line"><span class="comment"># 1*11 + 2*12 + 3*13 + 4*14 = 130</span></span><br></pre></td></tr></table></figure><h3 id="numpy-inner"><a href="#numpy-inner" class="headerlink" title="numpy.inner()"></a>numpy.inner()</h3><p>numpy.inner() 函数返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p><h3 id="numpy-matmul"><a href="#numpy-matmul" class="headerlink" title="numpy.matmul"></a>numpy.matmul</h3><p>返回两个数组的矩阵乘积。 </p><p>虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。</p><p>另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。</p><p>对于二维数组，它就是矩阵乘法</p><h3 id="numpy-linalg-det"><a href="#numpy-linalg-det" class="headerlink" title="numpy.linalg.det()"></a>numpy.linalg.det()</h3><p>计算输入矩阵的行列式</p><h3 id="numpy-linalg-solve"><a href="#numpy-linalg-solve" class="headerlink" title="numpy.linalg.solve()"></a>numpy.linalg.solve()</h3><p>矩阵形式的线性方程的解。</p><p>考虑以下线性方程：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">x + y + z = 6</span><br><span class="line"></span><br><span class="line">2y + 5z = -4</span><br><span class="line"></span><br><span class="line">2x + 5y - z = 27</span><br></pre></td></tr></table></figure><p>可以使用矩阵表示为：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1  1  1   x      6</span><br><span class="line">0  2  5   y  =  -4</span><br><span class="line">2  5 -1   z   27</span><br></pre></td></tr></table></figure><p>如果矩阵成为A、X和B，方程变为：<code>AX = B</code>或<code>X = A^(-1)B</code></p><h3 id="numpy-linalg-inv"><a href="#numpy-linalg-inv" class="headerlink" title="numpy.linalg.inv()"></a>numpy.linalg.inv()</h3><p>计算矩阵的逆矩阵。</p><p><strong>逆矩阵（inverse matrix）</strong>：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得：AB&#x3D;BA&#x3D;E，则我们称B是A的逆矩阵，而A则被称为可逆矩阵</p>]]></content>
      
      
      <categories>
          
          <category> numpy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习基础知识</title>
      <link href="/inori/54da7039.html"/>
      <url>/inori/54da7039.html</url>
      
        <content type="html"><![CDATA[<p>机器学习是人工智能的重要技术基础，涉及的内容十分广泛。由于我是以发强化学习方向论文为导向，所以机器学习部分知识点不做深入学习，了解为主，本文主要涵盖机器学习入门的基础知识。</p><p>机器学习的核心元素：<strong>数据、模型、算法</strong></p><p>机器学习工作流程一般为数据预处理（Processing）、模型学习（Learning）、模型评估（Evaluation）、新样本预测（Prediction）几个步骤</p><p><strong>数据预处理：</strong>输入（未处理的数据 + 标签）-&gt; 处理过程 -&gt;（特征处理+幅度缩放、特征选择、维度约减、采样）-&gt; 输出（测试集 + 训练集）</p><p><strong>模型学习：</strong>模型选择、交叉验证、结果评估、超参选择。</p><p><strong>模型评估：</strong>了解模型对于数据集测试的得分。</p><p><strong>新样本预测：</strong>预测测试集</p><h1 id="基本名词"><a href="#基本名词" class="headerlink" title="基本名词"></a>基本名词</h1><p><strong>示例&#x2F;样本：</strong>一条数据集中的一条数据</p><p><strong>属性&#x2F;特征：</strong>判断样本好坏的根据，如「色泽」「根蒂」</p><p><strong>属性空间&#x2F;样本空间&#x2F;输入空间X：</strong>由全部属性张成的空间</p><p><strong>特征向量：</strong>空间中每个点对应的一个坐标向量</p><p><strong>标记：</strong>关于示例结果的信息，如（（色泽&#x3D;青绿，根蒂&#x3D;蜷缩，敲声&#x3D;浊响），好瓜），其中「好瓜」称为标记</p><p><strong>分类：</strong>若要预测的是离散值，如「好瓜」，「坏瓜」，此类学习任务称为分类</p><p><strong>假设：</strong>学得模型对应了关于数据的某种潜在规律</p><p><strong>真相：</strong>潜在规律自身</p><p><strong>学习过程：</strong>是为了找出或逼近真相</p><p><strong>泛化能力：</strong>学得模型适用于新样本的能力。一般来说，训练样本越大，越有可能通过学习来获得具有强泛化能力的模型</p><p><strong>训练集</strong>：帮助训练模型，简单的说就是通过训练集的数据让确定拟合曲线的参数</p><p><strong>测试集</strong>：为了测试已经训练好的模型的精确度</p><p><strong>过拟合</strong>：模型在训练集上表现的很好，但是在交叉验证集合测试集上表现一般，也就是说模型对未知样本的预测表现一般，泛化能力较差</p><p><strong>经验误差</strong>：模型在训练集上的误差称为「经验误差」（Empirical Error），经验误差并不是越小越好，因为我们希望在新的没有见过的数据上，也能有好的预估结果</p><p><strong>偏差</strong>：模型拟合的偏差程度。给定无数套训练集而期望拟合出来的模型就是平均模型，偏差就是真实模型和平均模型的差异</p><p><strong>二分类</strong>：类别中只有两个类，是 or 否，且只有一个类别，即一个label为0或者1</p><h1 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h1><p>机器学习算法有：监督学习，无监督学习，半监督学习，强化学习</p><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习是从标记的训练数据中学习并建立模型，然后基于该模型预测未知的样本。其中，模型的输入是某个样本数据的特征，而函数的输出是与该样本相对应的标签。</p><p>常见的监督学习算法：回归分析、分类预测</p><ul><li>回归分析：线性回归，决策树，随机森林等</li><li>分类预测：逻辑回归，KNN，支持向量机，朴素贝叶斯等</li></ul><h3 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h3><p>KNN算法即K最近邻近算法。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。KNN的输入基于实例的学习（instance-based learning），没有显式的学习过程，也就是说没有训练阶段，数据集事先已有了分类和特征值，待收到新样本后直接进行处理，<strong>KNN通过测量不同特征值之间的距离进行分类</strong></p><p>思路：如果一个样本在特征空间中的k个最邻近的样本中的大多数属于某一个类别，则该样本也划分为这个类别。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ol><li>计算测试数据与各个训练数据之间的距离</li><li>按照距离的递增关系进行排序</li><li>选取距离最小的K个点</li><li>确定前K个点所在类别的出现频率</li><li>返回前K个点中出现频率最高的类别作为测试数据的预测分类</li></ol><h4 id="K的取值"><a href="#K的取值" class="headerlink" title="K的取值"></a>K的取值</h4><p>K：临近数，即在预测目标点时取几个临近的点来预测。</p><p>K值得选取非常重要：</p><ul><li>如果K的取值过小，一旦有噪声存在将会对预测产生比较大影响，例如取K值为1时，一旦最近的一个点是噪声，那么就会出现偏差</li><li>如果K的取值过大，就相当于用较大邻域中的训练实例进行预测，学习的近似误差会增大。这时与输入目标点较远实例也会对预测起作用，使预测发生错误</li></ul><p>K的取值尽量要取<strong>奇数</strong>，以保证在计算结果最后会产生一个较多的类别，如果取偶数可能会产生相等的情况，不利于预测。</p><p>常用的方法是从k&#x3D;1开始，使用检验集估计分类器的误差率。重复该过程，每次K增值1，允许增加一个近邻。选取产生最小误差率的K。一般k的取值不超过20，上限是n的开方，随着数据集的增大，K的值也要增大</p><h3 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h3><p>朴素贝叶斯算法是一种基于概率论和统计学的算法。它的核心思想是概率，通过计算条件概率来预测或分类数据</p><h4 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h4><p>贝叶斯定理是朴素贝叶斯算法的核心，它是一个概率公式，用于计算一个事件的后验概率。根据贝叶斯定理，事件 A 的后验概率等于先验概率 P(A)，与另一个事件 B 发生的联合概率 P(B|A) 乘以一个正则因子，即：<br>$$<br>P(Y|X) &#x3D; \frac{P(X|Y)P(Y)}{P(X)}<br>（X：特征向量， Y：类别）<br>$$<br>**先验概率P(X)**：先验概率是指根据以往经验和分析得到的概率</p><p>**后验概率P(Y|X)**：事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，后验分布P(Y|X)表示事件X已经发生的前提下，事件Y发生的概率，叫做事件X发生下事件Y的条件概率</p><p>**后验概率P(X|Y)**：在已知Y发生后X的条件概率，也由于知道Y的取值而被称为X的后验概率</p><h4 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h4><p>朴素贝叶斯算法是假设各个特征之间相互独立，也是朴素这词的意思，那么贝叶斯公式中的P(X|Y)可写成：<br>$$<br>P(X|Y)&#x3D;P(x_1|Y)P(x_2|Y)…P(x_n|Y)<br>$$<br>即朴素贝叶斯公式：<br>$$<br>P(Y|X) &#x3D; \frac{P(x_1|Y)P(x_2|Y)…P(x_n|Y)P(Y)}{P(X)}<br>$$</p><h4 id="贝叶斯算法"><a href="#贝叶斯算法" class="headerlink" title="贝叶斯算法"></a>贝叶斯算法</h4><p>贝叶斯方法源于决一个“逆概”问题：</p><p><strong>正向概率</strong>：假设袋子里面有N个白球，M个黑球，伸手进去摸一把，摸出黑球的概率是多大</p><p><strong>逆向概率</strong>：如果事先不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或者几个）球，观察这些取出来的球的颜色之后，那么可以就此对袋子里面的黑白球的比例做出什么样的推测</p><p>什么是贝叶斯？</p><ul><li>现实世界本身就是不确定的，人类的观察能力是有局限性的</li><li>我们日常观察到的只是事物表明上的结果，因此我们需要提供一个猜测</li></ul><p>朴素贝叶斯算法的朴素：特征条件独立；贝叶斯：基于贝叶斯定理。属于监督学习的生成模型，实现监督，没有迭代，并有坚实的数学理论（即贝叶斯定理）作为支撑。在大量样本下会有较好的表现，不适用于输入向量的特征条件有关联的场景</p><p>朴素贝叶斯会单独考量每一维独立特征被分类的条件概率，进而综合这些概率并对其所在的特征向量做出分类预测。因此，朴素贝叶斯的基本数据假设是：各个维度上的特征被分类的条件概率之间是相互独立的。它经常被用于文本分类中，包括互联网新闻的分类，垃圾邮件的筛选</p><p>朴素贝叶斯的思想：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，即认为此待分类项属于哪个类别</p><h3 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h3><p>决策树算法是一种逼近离散函数值的方法。它是一种典型的分类方法，首先对数据进行处理，利用归纳算法生成可读的规则和决策树，然后使用决策对新数据进行分析。本质上决策树是通过一系列规则对数据进行分类的过程，适用于类别和连续输入（特征）和输出（预测）变量。基于树的方法把特征空间划分成一系列矩形，然后给每一个矩形安置一个简单的模型（像一个常数）</p><p>决策树构造可以分两步进行：</p><ol><li>生成：由训练样本集生成决策树的过程。一般情况下，训练样本数据集是根据实际需要有历史的、有一定综合程度的，用于数据分析处理的数据集</li><li>剪枝：对上一阶段生成的决策树进行检验和校正，主要是用新的样本数据集（测试数据集）中的数据校验决策树生成过程中产生的初步规则，将那些影响预衡准确性的分枝剪除</li></ol><p>决策树学习的算法通常是一个递归地决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。包含特征选择、决策树的生成和决策树的剪枝过程。选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。包含特征选择、决策树的生成和决策树的剪枝过程。</p><p><strong>剪枝：</strong>将树变得更简单，从而使它具有更好的泛化能力。</p><p>步骤：去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。</p><p>决策树的生成对应模型的局部选择，决策树的剪枝对应于模型的全局选择。决策树的生成只考虑局部最优，决策树的剪枝则考虑全局最优。</p><p><strong>特征选择：</strong>如果特征数量很多，在决策树学习开始时对特征进行选择，只留下对训练数据有足够分类能力的特征</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>树以代表训练样本的单个结点开始</li><li>如果样本都在同一类．则该结点成为树叶，并用该类标记</li><li>否则，算法选择最有分类能力的属性作为决策树的当前结点</li><li>根据当前决策结点属性取值的不同，将训练样本数据集分为若干子集，每个取值形成一个分枝，有几个取值形成几个分枝。针对上一步得到的一个子集，重复进行先前步骤，递归形成每个划分样本上的决策树。一旦一个属性出现在一个结点上，就不必在该结点的任何后代考虑它</li><li>递归划分步骤仅当下列条件之一成立时停止：<ul><li>给定结点的所有样本属于同一类</li><li>没有剩余属性可以用来进一步划分样本．在这种情况下．使用多数表决，将给定的结点转换成树叶，并以样本中元组个数最多的类别作为类别标记，同时也可以存放该结点样本的类别分布</li><li>如果某一分枝tc，没有满足该分支中已有分类的样本，则以样本的多数类创建一个树叶</li></ul></li></ol><h3 id="SVM算法"><a href="#SVM算法" class="headerlink" title="SVM算法"></a>SVM算法</h3><p>SVM即支持向量机（support vector machine，SVM），支持向量机是一种二分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。支持向量机的学习算法是求解凸二次规划的最优化算法。基础的SVM算法是一个二分类算法，至于多分类任务，可以通过多次使用SVM进行解决</p><h4 id="线性可分"><a href="#线性可分" class="headerlink" title="线性可分"></a>线性可分</h4><p>对于一个数据集合可以画一条直线将两组数据点分开，这样的数据成为线性可分（linearly separable）</p><p><img src="/inori/54da7039/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%5Csmv_linearly_separable.png" alt="smv_linearly_separable"></p><ul><li>分割超平面：将上述数据集分隔开来的直线成为分隔超平面。对于二维平面来说，分隔超平面就是一条直线。对于三维及三维以上的数据来说，分隔数据的是个平面，称为超平面，也就是分类的决策边界</li><li>间隔：点到分割面的距离，称为点相对于分割面的间隔。数据集所有点到分隔面的最小间隔的2倍，称为分类器或数据集的间隔。论文中提到的间隔多指这个间隔。SVM分类器就是要找最大的数据集间隔</li><li>支持向量：离分隔超平面最近的那些点</li></ul><p>SVM所做的工作就是找这样的超平面，能够将两个不同类别的样本划分开来，但是这种平面是不唯一的，即可能存在无数个超平面都可以将两种样本分开，那么我们如何才能确定一个分类效果最好的超平面呢？<br>对每一种可能的超平面，我们将它进行平移，直到它与空间中的样本向量相交。我们称这两个向量为支持向量，之后我们计算支持向量到该超平面的距离d，分类效果最好的超平面应该使d最大</p><p>支持向量机的核心思想：最大间隔化，最不受到噪声的干扰</p><h4 id="优缺点及应用场景"><a href="#优缺点及应用场景" class="headerlink" title="优缺点及应用场景"></a>优缺点及应用场景</h4><ol><li>SVM的优点：</li></ol><ul><li>高效的处理高维特征空间：SVM通过将数据映射到高维空间中，可以处理高维特征，并在低维空间中进行计算，从而有效地处理高维数据</li><li>适用于小样本数据集：SVM是一种基于边界的算法，它依赖于少数支持向量，因此对于小样本数据集具有较好的泛化能力</li><li>可以处理非线性问题：SVM使用核函数将输入数据映射到高维空间，从而可以解决非线性问题。常用的核函数包括线性核、多项式核和径向基函数（RBF）核</li><li>避免局部最优解：SVM的优化目标是最大化间隔，而不是仅仅最小化误分类点。这使得SVM在解决复杂问题时能够避免陷入局部最优解</li><li>对于噪声数据的鲁棒性：SVM通过使用支持向量来定义决策边界，这使得它对于噪声数据具有一定的鲁棒性</li></ul><ol start="2"><li>SVM的缺点：</li></ol><ul><li>对大规模数据集的计算开销较大：SVM的计算复杂度随着样本数量的增加而增加，特别是在大规模数据集上的训练时间较长</li><li>对于非线性问题选择合适的核函数和参数较为困难：在处理非线性问题时，选择适当的核函数和相应的参数需要一定的经验和领域知识</li><li>对缺失数据敏感：SVM在处理含有缺失数据的情况下表现不佳，因为它依赖于支持向量的定义</li><li>难以解释模型结果：SVM生成的模型通常是黑盒模型，难以直观地解释模型的决策过程和结果</li></ul><ol start="3"><li>SVM主要应用场景：</li></ol><ul><li>文本分类：如垃圾邮件分类、情感分析和文档分类等</li><li>图像识别：可用于图像分类、目标识别和人脸识别等任务。它可以通过提取图像的特征向量，并将其作为输入来训练SVM模型</li><li>金融领域：可用于信用评分、风险评估和股票市场预测等金融任务</li><li>医学诊断：可以应用于医学图像分析，如疾病检测、癌症诊断和医学影像分类等</li><li>视频分类：可以用于视频分类、行为识别和运动检测等任务，通过提取视频帧的特征并将其输入SVM模型进行分类</li><li>推荐系统：可以用于个性化推荐和用户分类等推荐系统任务，通过分析用户行为和特征来预测用户的兴趣和偏好</li></ul><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>逻辑回归虽然名字中带有回归，其实是分类模型，主要用于二分类问题，通过给定的n组数据（训练集）来训练模型，并在训练结束后对给定的一组或多组数据（测试集）进行分类。其中每一组数据都是由p个指标构成。</p><p>由于二分类问题分成两类，可以让其中一类标签为0，另一类为1。我们需要一个函数，对于输入的每一组数据，都能映射成0~1之间的数。并且如果函数值大于0.5，就判定属于1，否则属于0。而且函数中需要待定参数，通过利用样本训练，使得这个参数能够对训练集中的数据有很准确的预测。</p><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><p>逻辑回归的模型包含两个模块：线性部分和激活函数</p><p>线性部分的数学模型写为<code>h(x)=wx+b</code>，x表示样本的输入特征向量，w是权重，b是偏置</p><p>激活函数是sigmoid函数：<br>$$<br>\sigma(h(x))&#x3D; \frac{1}{1+e^{−h(x)}}<br>&#x3D; \frac{1}{1+e^{−(wx+b)}}<br>$$</p><p>这个函数的曲线是一条值域为(0,1)的曲线，当输入值趋近于无穷大时，输出结果会趋近于1，输入值趋近于无穷小时，输出结果会趋近于-1</p><p>逻辑回归不仅是一个二分类模型，也是一个线性分类模型，h(x)作为决策函数，通过判断样本落在决策函数的哪一边，区分出不同的类别</p><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>该类算法的输入样本不需要标记，而是自动地从样本中学习这种特征以实现预测。</p><p>常见的非监督学习算法：聚类和降维</p><ul><li>聚类：Kmeans、Apriori、DBSCAN等</li><li>降维：主成分分析(PCA)等</li></ul><h3 id="Kmeans算法"><a href="#Kmeans算法" class="headerlink" title="Kmeans算法"></a>Kmeans算法</h3><p>k均值聚类算法（k-means）是一种迭代求解的聚类分析算法，其步骤是，预将数据分为K组，则随机选取K个对象作为初始的聚类中心，然后计算每个对象与各个种子聚类中心之间的距离，把每个对象分配给距离它最近的聚类中心。聚类中心以及分配给它们的对象就代表一个聚类。每分配一个样本，聚类的聚类中心会根据聚类中现有的对象被重新计算。这个过程将不断重复直到满足某个终止条件。终止条件可以是没有（或最小数目）对象被重新分配给不同的聚类，没有（或最小数目）聚类中心再发生变化，误差平方和局部最小。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li>从N个数据文档（样本）随机选取K个数据文档作为质心（聚类中心）。</li><li>对每个数据文档测量其到每个质心的距离，并把它归到最近的质心的类。</li><li>重新计算已经得到的各个类的质心。</li><li>迭代2~3步直至新的质心与原质心相等或小于指定阈值，算法结束。 本文采用所有样本所属的质心都不再变化时，算法收敛。</li></ol><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p>每一个样本经过模型后会得到一个预测值，然后得到的预测值和真实值的差值就成为损失（损失值越小证明模型越成功），有许多不同种类的损失函数，这些函数<strong>本质上就是计算预测值和真实值的差距的一类型函数</strong>，经过库的封装形成了有具体名字的函数</p><p>输入的feature（或称为x）需要通过模型（model）预测出y，此过程称为向前传播（forward pass），而要将预测与真实值的差值减小需要更新模型中的参数，这个过程称为向后传播（backward pass），其中损失函数（lossfunction）就基于这两种传播之间，起到一种有点像<strong>承上启下</strong>的作用，<strong>承上指：接収模型的预测值，启下指：计算预测值和真实值的差值，为下面反向传播提供输入数据</strong></p><p>常用的损失函数有：均方误差(MSE)、平均绝对误差(MAE)、均方根误差(RMSE)、平均偏差误差(MBE)、Huber损失、最大似然损失(Likelihood Loss&#x2F;LHL)、二元交叉熵（BCE）、交叉熵（CE）、Kullback-Leibler 散度 (KLD)等</p>]]></content>
      
      
      <categories>
          
          <category> MachineLearning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL运维篇</title>
      <link href="/inori/592cf81.html"/>
      <url>/inori/592cf81.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志记录了当mysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，应当首先查看此日志</p><p>该日志默认开启，默认存放目录<code>/var/log/</code>，默认的日志文件名为<code>mysqld.log</code>，查看日志位置:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志（BINLOG）记录了所有的 DDL和 DML语句，不包括数据查询（SELECT、SHOW）语句</p><p>作用：</p><ul><li>灾难时的数据恢复</li><li>MySQL的主从复制</li></ul><p>在MySQL8中，默认二进制日志是开启的，查看日志参数：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>log_bin_basename</code>：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文件名需要在该basename的基础上加上编号(编号从000001开始)</li><li><code>log_bin_index</code>：binlog的索引文件，记录了当前服务器关联的binlog文件有哪些</li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录SQL语句，对数据进行修改的SQL都会记录在日志文件中</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录每一行的数据变更</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录</td></tr></tbody></table><p>可以使用命令查看格式：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果需要配置二进制日志的格式，要在<code>/etc/my.cnf</code>中配置<code>binlog_format</code>参数</p><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具<code>mysqlbinlog</code>来查看，详情查看进阶篇中此部分</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志：</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>reset master</td><td>删除全部 binlog日志，删除之后，日志编号，将从<code>binlog.000001</code>重新开始</td></tr><tr><td>purge master logs to ‘binlog.*’</td><td>删除 * 编号之前的所有日志</td></tr><tr><td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’</td><td>删除日志为<code>yyyy-mm-dd hh24:mi:ss</code>之前产生的所有日志</td></tr></tbody></table><p>也可以在mysql的配置文件中配置二进制日志的过期时间，设置后二进制日志过期会自动删除:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_expire_logs_seconds%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志中记录了客户端的所有操作语句。如果需要开启查询日志，可以修改MySQL的配置文件<code>/etc/my.cnf</code>文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#该选项用来开启查询日志 ， 可选值：0或者1，0代表关闭，1代表开启</span><br><span class="line">general_log=1</span><br><span class="line">#设置日志的文件名，如果没有指定，默认的文件名为host_name.log</span><br><span class="line">general_log_file=mysql_query.log</span><br></pre></td></tr></table></figure><p>开启了查询日志之后，在MySQL的数据存放目录，也就是 <code>/var/lib/mysql/</code>目录下就会出现mysql_query.log文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运行后，日志文件将会非常大。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过参数<code>long_query_time</code>设置值并且扫描记录数不小于<code>min_examined_row_limit</code>的所有的SQL语句的日志，默认未开启。<code>long_query_time</code>默认为10秒，最小为0，精度可以到微秒。</p><p>如果需要开启慢查询日志，需要在MySQL的配置文件<code>/etc/my.cnf</code>中配置如下参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#慢查询日志</span><br><span class="line">slow_query_log=1</span><br><span class="line">#执行时间参数</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用<code>log_slow_admin_statements</code>和更改此行为<code>log_queries_not_using_indexes</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements = 1</span><br><span class="line">#记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes = 1</span><br></pre></td></tr></table></figure><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制，MySQL复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务</li><li>实现读写分离，降低主库的访问压力</li><li>可以在从库中执行备份，以避免备份期间影响主库服务</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MySQL主从复制的核心为bin log，具体的过程如下：</p><p><img src="/inori/592cf81/Blog\source\img\mysql_master&slave.png" alt="mysql_master&amp;slave"></p><p>复制分成三步：</p><ol><li><p>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</p></li><li><p>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</p></li><li><p>slave重做中继日志中的事件，将改变反映它自己的数据</p></li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="主库"><a href="#主库" class="headerlink" title="主库"></a>主库</h4><p>修改配置文件<code>/etc/my.cnf</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1</span><br><span class="line">server-id=1</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=0</span><br><span class="line">#忽略的数据, 指不需要同步的数据库</span><br><span class="line">#binlog-ignore-db=mysql</span><br><span class="line">#指定同步的数据库</span><br><span class="line">#binlog-do-db=db01</span><br></pre></td></tr></table></figure><p>重启mysql服务器后，登录并创建远程连接的账号，授予主从复制权限：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br><span class="line">#为 <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> 用户分配主从复制权限</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查看二进制坐标：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p>字段含义说明：</p><ul><li><code>file</code>:从哪个日志文件开始推送日志文件</li><li><code>position</code>:从哪个位置开始推送日志</li><li><code>binlog_ignore_db</code>:指定不需要同步的数据库</li></ul><h4 id="从库"><a href="#从库" class="headerlink" title="从库"></a>从库</h4><p>修改配置文件<code>/etc/my.cnf</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure><p>重启mysql服务器后，登录设置主库配置：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE <span class="keyword">TO</span> SOURCE_HOST<span class="operator">=</span><span class="string">&#x27;IP地址&#x27;</span>, SOURCE_USER<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">SOURCE_PASSWORD<span class="operator">=</span><span class="string">&#x27;Root@123456&#x27;</span>, SOURCE_LOG_FILE<span class="operator">=</span><span class="string">&#x27;binlog.000004&#x27;</span>, SOURCE_LOG_POS<span class="operator">=</span><span class="number">663</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>含义</th><th>老版本参数</th></tr></thead><tbody><tr><td>SOURCE_HOST</td><td>主库IP地址</td><td>MASTER_HOST</td></tr><tr><td>SOURCE_USER</td><td>连接主库的用户名</td><td>MASTER_USER</td></tr><tr><td>SOURCE_PASSWORD</td><td>连接主库的密码</td><td>MASTER_PASSWORD</td></tr><tr><td>SOURCE_LOG_FILE</td><td>binlog日志文件名</td><td>MASTER_LOG_FILE</td></tr><tr><td>SOURCE_LOG_POS</td><td>binlog日志文件位置</td><td>MASTER_LOG_POS</td></tr></tbody></table><p>开启同步：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> replica;</span><br></pre></td></tr></table></figure><p>查看同步状态：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status;</span><br></pre></td></tr></table></figure><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p><ul><li>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多，带宽不够，网络IO瓶颈</li><li>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈</li></ul><p>为了解决上述问题，需要对数据库进行分库分表处理</p><p>分库分表的中心思想都是将<strong>数据分散存储</strong>，使得单一数据库&#x2F;表的数据量变小来缓解单一数据库的性能问题，从而提升数据库性能</p><h3 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h3><p>分库分表的形式，主要是两种：垂直拆分和水平拆分。按照拆分粒度又分为分库和分表。</p><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p><strong>垂直分库</strong>：以表为依据，根据业务将不同表拆分到不同库中。</p><p>特点：</p><ul><li>每个库的表结构都不一样</li><li>每个库的数据也不一样</li><li>所有库的并集是全量数据</li></ul><p><strong>垂直分表</strong>：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p>特点：</p><ul><li>每个表的结构都不一样</li><li>每个表的数据也不一样，一般通过一列（主键&#x2F;外键）关联</li><li>所有表的并集是全量数据</li></ul><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p><strong>水平分库</strong>：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中</p><p>特点：</p><ul><li>每个库的表结构都一样</li><li>每个库的数据都不一样</li><li>所有库的并集是全量数据</li></ul><p><strong>水平分表</strong>：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中</p><p>特点：</p><ul><li>每个表的表结构都一样</li><li>每个表的数据都不一样</li><li>所有表的并集是全量数据</li></ul><h3 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h3><ul><li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言</li><li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言</li></ul><h3 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h3><p>Mycat是开源的基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat。开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数据，都无需关心。具体的分库分表的策略，只需要在MyCat中配置即可。</p><p>在MyCat的整体结构中，分为两个部分：上面的逻辑结构、下面的物理结构</p><p><img src="/inori/592cf81/mysql_mycat.png" alt="mysql_mycat"></p><p>在MyCat的逻辑结构主要负责逻辑库、逻辑表、分片规则、分片节点等逻辑结构的处理，而具体的数据存储还是在物理结构，也就是数据库服务器中存储的</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><h5 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h5><p>配置逻辑库、逻辑表、数据节点、节点主机等相关信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;DB01&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;TB_ORDER&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址1:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址2:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址3:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要包含以下三组标签：</p><ul><li>schema标签</li><li>datanode标签</li><li>datahost标签</li></ul><h6 id="schema标签"><a href="#schema标签" class="headerlink" title="schema标签"></a>schema标签</h6><p>用于定义MyCat实例中的逻辑库,一个MyCat实例中,可以有多个逻辑库,可以通过schema标签来划分不同的逻辑库。MyCat中的逻辑库的概念，等同于MySQL中的database概念, 需要操作某个逻辑库下的表时, 也需要切换逻辑库(use xxx)。</p><p>核心属性：</p><ul><li>name：指定自定义的逻辑库库名</li><li>checkSQLschema：在SQL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去除，false：不自动去除</li><li>sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录</li></ul><p><strong>table标签</strong></p><p>定义了MyCat中逻辑库schema下的逻辑表,所有需要拆分的表都需要在table标签中定义。核心属性：</p><ul><li>name：定义逻辑表表名，在该逻辑库下唯一</li><li>dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔</li><li>rule：分片规则的名字，分片规则名字是在rule.xml中定义的</li><li>primaryKey：逻辑表对应真实表的主键</li><li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表，全局表需要配置为global</li></ul><h6 id="datanode标签"><a href="#datanode标签" class="headerlink" title="datanode标签"></a>datanode标签</h6><p>核心属性：</p><ul><li>name：定义数据节点名称</li><li>dataHost：数据库实例主机名称，引用自 dataHost 标签中name属性</li><li>database：定义分片所属数据库</li></ul><h6 id="datahost标签"><a href="#datahost标签" class="headerlink" title="datahost标签"></a>datahost标签</h6><p>该标签在MyCat逻辑库中作为底层标签, 定义了具体的数据库实例、读写分离、心跳语句。核心属性：</p><ul><li>name：唯一标识，供上层标签使用</li><li>maxCon&#x2F;minCon：最大连接数&#x2F;最小连接数</li><li>balance：负载均衡策略，取值 0,1,2,3</li><li>writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）</li><li>dbDriver：数据库驱动，支持 native、jdbc</li></ul><h5 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h5><p>rule.xml中定义所有拆分表的规则, 在使用过程中可以灵活的使用分片算法, 或者对同一个分片算法使用不同的参数, 它让分片过程可配置化。主要包含两类标签：tableRule、Function</p><h5 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h5><p>配置用户名、密码，以及用户的访问权限信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表级 DML 权限设置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;privileges check=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;</span></span><br><span class="line"><span class="comment">                &lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;# 对应IUSD为增改查删</span></span><br><span class="line"><span class="comment">            &lt;/schema&gt;</span></span><br><span class="line"><span class="comment">        &lt;/privileges&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述的配置表示，定义了两个用户root和user，两个用户都可以访问DB01逻辑库，访问密码都是123456，但是root用户访问DB01逻辑库，既可以读，又可以写，但是user用户访问逻辑库是只读的</p><p>主要有两个标签：system、user</p><h6 id="system标签"><a href="#system标签" class="headerlink" title="system标签"></a>system标签</h6><p>主要配置MyCat中的系统配置信息，对应的系统配置项及其含义</p><table><thead><tr><th>属性</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>charset</td><td>utf8</td><td>设置Mycat的字符集, 字符集需要与MySQL的字符集保持一致</td></tr><tr><td>nonePasswordLogin</td><td>0,1</td><td>0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户</td></tr><tr><td>useSqlStat</td><td>0,1</td><td>开启SQL实时统计,1 为开启,0 为关闭；开启之后, MyCat会自动统计SQL语句的执行情况</td></tr><tr><td>useGlobleTableCheck</td><td>0,1</td><td>是否开启全局表的一致性检测。1为开启，0为关闭</td></tr><tr><td>sequnceHandlerType</td><td>0,1,2</td><td>用来指定Mycat全局序列类型，0 为本地文件，1 为数据库方式，2 为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试</td></tr><tr><td>idleTimeout</td><td>30</td><td>指定连接的空闲时间的超时长度;如果超时,将关闭资源并回收, 默认30分钟</td></tr><tr><td>serverPort</td><td>8066</td><td>定义MyCat的管理端口, 默认8066</td></tr><tr><td>managerPort</td><td>9066</td><td>定义MyCat的管理端口, 默认9066</td></tr><tr><td>sqlExecuteTimeout</td><td>300</td><td>执行SQL的超时时间, 如果SQL语句执行超时,将关闭连接; 默认300秒;</td></tr></tbody></table><h6 id="user标签"><a href="#user标签" class="headerlink" title="user标签"></a>user标签</h6><p>配置MyCat中的用户、访问密码，以及用户针对于逻辑库、逻辑表的权限信息</p><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>切换到Mycat的安装目录，执行指令启动Mycat：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">bin/mycat start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止</span></span><br><span class="line">bin/mycat stop</span><br></pre></td></tr></table></figure><p>Mycat启动之后，占用端口号8066</p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h IP地址 <span class="operator">-</span>P <span class="number">8066</span> <span class="operator">-</span>uroot <span class="operator">-</span>p123456</span><br></pre></td></tr></table></figure><p>通过MySQL的指令来连接的MyCat，因为MyCat在底层实际上是模拟了MySQL的协议</p><h4 id="MyCat管理"><a href="#MyCat管理" class="headerlink" title="MyCat管理"></a>MyCat管理</h4><p>在MyCat中，当执行一条SQL语句时，MyCat需要进行SQL解析、分片分析、路由分析、读写分离分析等操作，最终经过一系列的分析决定将当前的SQL语句到底路由到那几个(或哪一个)节点数据库，数据库将数据执行完毕后，如果有返回的结果，则将结果返回给MyCat，最终还需要在MyCat中进行结果合并、聚合处理、排序处理、分页处理等操作，最终再将结果返回给客户端。</p><p><img src="/inori/592cf81/mysql_mycat_frame.png" alt="mysql_mycat_frame"></p><p>Mycat默认开通2个端口，可以在server.xml中进行修改。</p><ul><li>8066 数据访问端口，即进行 DML 和 DDL 操作。</li><li>9066 数据库管理端口，即 mycat 服务管理控制功能，用于管理mycat的整个集群状态</li></ul><p>连接MyCat的管理控制台：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h IP地址 <span class="operator">-</span>p <span class="number">9066</span> <span class="operator">-</span>uroot <span class="operator">-</span>p123456</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>show @@help</td><td>查看Mycat管理工具帮助文档</td></tr><tr><td>show @@version</td><td>查看Mycat的版本</td></tr><tr><td>reload @@config</td><td>重新加载Mycat的配置文件</td></tr><tr><td>show @@datasource</td><td>查看Mycat的数据源信息</td></tr><tr><td>show @@datanode</td><td>查看MyCat现有的分片节点信息</td></tr><tr><td>show @@threadpool</td><td>查看Mycat的线程池信息</td></tr><tr><td>show @@sql</td><td>查看执行的SQL</td></tr><tr><td>show @@sql.sum</td><td>查看执行的SQL统计</td></tr></tbody></table><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</p><p>通过MyCat可实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</p><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><p><img src="/inori/592cf81/MySQL%5Cmysql_1m1s.png" alt="mysql_1m1s"></p><p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控制。</p><p>schema.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置逻辑库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;RW&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn7&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn7&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">database</span>=<span class="string">&quot;itcast&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p>writeHost代表的是写操作对应的数据库，readHost代表的是读操作对应的数据库。所以我们要想实现读写分离，就得配置writeHost关联的是主库，readHost关联的是从库。</p><p>而仅仅配置好了writeHost以及readHost还不能完成读写分离，还需要配置一个负责均衡的参数balance，取值有4种，具体含义如下：</p><table><thead><tr><th>参数值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>不开启读写分离机制,所有读操作都发送到当前可用的writeHost上</td></tr><tr><td>1</td><td>全部的readHost与备用的writeHost都参与select语句的负载均衡（主要针对于双主双从模式）</td></tr><tr><td>2</td><td>所有的读写操作都随机在writeHost,readHost上分发</td></tr><tr><td>3</td><td>所有的读请求随机分发到writeHost对应的readHost上执行,writeHost不负担读压力</td></tr></tbody></table><p>在一主一从模式的读写分离中，balance配置1或3都是可以完成读写分离的。</p><h3 id="双主双从"><a href="#双主双从" class="headerlink" title="双主双从"></a>双主双从</h3><p>一个主机Master1用于处理所有写请求，它的从机Slave1和另一台主机Master2还有它的从机Slave2负责所有读请求。当Master1主机宕机后，Master2主机负责写请求，Master1、Master2互为备机</p><p><img src="/inori/592cf81/MySQL%5Cmysql_2m2s.png" alt="mysql_2m2s"></p><p>schema.xml配置</p><p>配置逻辑库</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;RW2&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn7&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置数据节点</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn7&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>配置节点主机</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址1:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址2:3306? useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址3:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址4:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性说明：</p><ul><li><p>balance&#x3D;”1”：代表全部的readHost与stand by writeHost参与 select 语句的负载均衡，简单的说，当双主双从模式(M1 -&gt; S1，M2-&gt; S2，并且M1与M2互为主备)，正常情况下，M2,S1,S2都参与select语句的负载均衡</p></li><li><p>writeType</p><ul><li>0:写操作都转发到第1台writeHost, writeHost1挂了, 会切换到writeHost2上</li><li>1:所有的写操作都随机地发送到配置的writeHost上</li></ul></li><li><p>switchType</p><ul><li>-1:不自动切换</li><li>1:自动切换</li></ul></li></ul><p>user.xml配置：配置root用户可以访问到逻辑库RW2</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>SHOPPING,TEST,RW2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch基础入门(二)</title>
      <link href="/inori/65068962.html"/>
      <url>/inori/65068962.html</url>
      
        <content type="html"><![CDATA[<h1 id="DSL语句"><a href="#DSL语句" class="headerlink" title="DSL语句"></a>DSL语句</h1><p>DSL(Domain Specific Language)，中文翻译为特定领域语言，在这里代表ES中的查询语言。</p><p>Elasticsearch的查询可以分为两大类：</p><ul><li><strong>叶子查询（Leaf</strong> <strong>query</strong> <strong>clauses）</strong>：一般是在特定的字段里查询特定值，属于简单查询，很少单独使用。</li><li><strong>复合查询（Compound</strong> <strong>query</strong> <strong>clauses）</strong>：以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式。</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>语法结构：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// .. 查询条件</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>GET /索引库名/_search</code>：其中的<code>_search</code>是固定路径，不能修改</li></ul><p>以最简单的无条件查询为例，无条件查询的类型是：match_all，因此其查询语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>虽然是match_all，但是响应结果中并不会包含索引库中的所有文档，而是仅有10条。这是因为处于安全考虑，elasticsearch设置了默认的查询页数。</p><h2 id="叶子查询"><a href="#叶子查询" class="headerlink" title="叶子查询"></a>叶子查询</h2><p>叶子查询的类型也可以做进一步细分，详情可以查看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/query-dsl.html">官方文档</a></p><p>这里列举一些常见的：</p><ul><li><strong>全文检索查询（Full Text Queries）</strong>：利用分词器对用户输入搜索条件先分词，得到词条，然后再利用倒排索引搜索词条。例如：<ul><li><code>match</code>：</li><li><code>multi_match</code></li></ul></li><li><strong>精确查询（Term-level queries）</strong>：不对用户输入搜索条件分词，根据字段内容精确值匹配。但只能查找keyword、数值、日期、boolean类型的字段。例如：<ul><li><code>ids</code></li><li><code>term</code></li><li><code>range</code></li></ul></li><li><strong>地理坐标查询：</strong>用于搜索地理位置，搜索方式很多，例如：<ul><li><code>geo_bounding_box</code>：按矩形搜索</li><li><code>geo_distance</code>：按点和半径搜索</li></ul></li></ul><h2 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询</h2><p>全文检索的种类也很多，详情可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/full-text-queries.html">官方文档</a></p><p>以全文检索中的<code>match</code>为例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与<code>match</code>类似的还有<code>multi_match</code>，区别在于可以同时对多个字段搜索，而且多个字段都要满足，语法示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;字段1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;字段2&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p>精确查询，英文是<code>Term-level query</code>，顾名思义，词条级别的查询。也就是说不会对用户输入的搜索条件再分词，而是作为一个词条，与搜索的字段内容精确值匹配。因此推荐查找<code>keyword</code>、数值、日期、<code>boolean</code>类型的字段。例如：</p><ul><li>id</li><li>price</li><li>城市</li><li>地名</li><li>人名</li></ul><p>详情可以查看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/term-level-queries.html">官方文档</a></p><p>以<code>term</code>查询为例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>range</code>查询：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>最小值<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>最大值<span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>range</code>是范围查询，对于范围筛选的关键字有：</p><ul><li><code>gte</code>：大于等于</li><li><code>gt</code>：大于</li><li><code>lte</code>：小于等于</li><li><code>lt</code>：小于</li></ul><h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><p>复合查询大致可以分为两类：</p><ul><li>第一类：基于逻辑运算组合叶子查询，实现组合条件，例如<ul><li>bool</li></ul></li><li>第二类：基于某种算法修改查询时的文档相关性算分，从而改变文档排名。例如：<ul><li>function_score</li><li>dis_max</li></ul></li></ul><p>其它复合查询及相关语法可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/compound-queries.html">官方文档</a></p><h3 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h3><p>bool查询，即布尔查询。就是利用逻辑运算来组合一个或多个查询子句的组合。bool查询支持的逻辑运算有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>bool查询的语法例如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vivo&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小米&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span> <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">10000</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与搜索关键字无关的查询尽量采用must_not或filter逻辑运算，避免参与相关性算分。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>elasticsearch默认是根据相关度算分（<code>_score</code>）来排序，但是也支持自定义方式对搜索结果排序。不过分词字段无法排序，能参与排序字段类型有：<code>keyword</code>类型、数值类型、地理坐标类型、日期类型等。</p><p>语法说明：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;排序字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;排序方式asc和desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。</p><h3 id="基础分页"><a href="#基础分页" class="headerlink" title="基础分页"></a>基础分页</h3><p>elasticsearch中通过修改<code>from</code>、<code>size</code>参数来控制要返回的分页结果：</p><ul><li><code>from</code>：从第几个文档开始</li><li><code>size</code>：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span>  <span class="comment">// 每页文档数量，默认10</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h3><p>elasticsearch的数据一般会采用分片存储，也就是把一个索引中的数据分成N份，存储到不同节点上。这种存储方式比较有利于数据扩展，但给分页带来了一些麻烦。</p><p>比如一个索引库中有100000条数据，分别存储到4个分片，每个分片25000条数据。现在每页查询10条，查询第99页。那么分页查询的条件如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">990</span><span class="punctuation">,</span> <span class="comment">// 从第990条开始查询</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 每页查询10条</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>从语句来分析，要查询第990~1000名的数据。</p><p>从实现思路来分析，肯定是将所有数据排序，找出前1000名，截取其中的990~1000的部分。但问题来了，我们如何才能找到所有数据中的前1000名呢？</p><p>要知道每一片的数据都不一样，第1片上的第900-1000，在另1个节点上并不一定依然是900-1000名。所以我们只能在每一个分片上都找出排名前1000的数据，然后汇总到一起，重新排序，才能找出整个索引库中真正的前1000名，此时截取990-1000的数据即可。假如我们现在要查询的是第999页数据呢，是不是要找第9990~10000的数据，那岂不是需要把每个分片中的前10000名数据都查询出来，汇总在一起，在内存中排序？</p><p>由此可知，当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力。</p><p><strong>因此elasticsearch会禁止<code>from+ size </code>超过10000的请求。</strong></p><p>针对深度分页，elasticsearch提供了两种解决方案：</p><ul><li><code>search after</code>：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li><code>scroll</code>：原理将排序后的文档id形成快照，保存下来，基于快照做分页。官方已经不推荐使用。</li></ul><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/paginate-search-results.html">详情见文档</a></p><p>大多数情况下，我们采用普通分页就可以了。一般我们采用限制分页深度的方式即可，无需实现深度分页。</p><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><p>实现高亮的思路为：</p><ul><li>用户输入搜索关键字搜索数据</li><li>服务端根据搜索关键字到elasticsearch搜索，并给搜索结果中的关键字词条添加<code>html</code>标签</li><li>前端提前给约定好的<code>html</code>标签添加<code>CSS</code>样式</li></ul><p>elasticsearch已经提供了给搜索关键字加标签的语法。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;搜索字段&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索关键字&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;高亮字段名称&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;em&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/em&gt;&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>搜索必须有查询条件，而且是全文检索类型的查询条件，例如<code>match</code></li><li>参与高亮的字段必须是<code>text</code>类型的字段</li><li>默认情况下参与高亮的字段要与搜索字段一致，除非添加：<code>required_field_match=false</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p><ul><li><code>query</code>：查询条件</li><li><code>from</code>和<code>size</code>：分页条件</li><li><code>sort</code>：排序条件</li><li><code>highlight</code>：高亮条件</li></ul><h1 id="RestClient查询"><a href="#RestClient查询" class="headerlink" title="RestClient查询"></a>RestClient查询</h1><p>查询的基本步骤如为：</p><p>1）创建<code>request</code>对象，这次是搜索，所以是<code>SearchRequest</code></p><p>2）准备请求参数，查询DSL对应的JSON参数</p><p>3）发起请求</p><p>4）解析响应，响应结果相对复杂，需要逐层解析</p><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><p>之前说过，由于Elasticsearch对外暴露的接口都是Restful风格的接口，因此JavaAPI调用就是在发送Http请求。而我们核心要做的就是利用<strong>利用Java代码组织请求参数</strong>，<strong>解析响应结果</strong>。</p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名 </p><p>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等 </p><ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个<code>match_all</code>查询的DSL</li></ul><p>第三步，利用<code>client.search()</code>发送请求，得到响应 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关键的API有两个，一个是<code>request.source()</code>，它构建的就是DSL中的完整JSON参数。其中包含<code>query</code>、<code>sort</code>、<code>from</code>、<code>size</code>、<code>highlight</code>等所有功能</p><p><img src="/inori/65068962/ElasticSearch%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%BA%8C)%5Crequest_source.png" alt="request_source"></p><p>另一个是<code>QueryBuilders</code>，其中包含各种<strong>叶子查询</strong>、<strong>复合查询</strong></p><p><img src="/inori/65068962/ElasticSearch%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%BA%8C)%5Cquerybuilders.png" alt="querybuilders"></p><h3 id="解析响应结果"><a href="#解析响应结果" class="headerlink" title="解析响应结果"></a>解析响应结果</h3><p>在发送请求以后，得到了响应结果<code>SearchResponse</code>，这个类的结构与kibana中看到的响应结果JSON结构完全一致</p><p>解析<code>SearchResponse</code>的代码就是在解析这个JSON结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.遍历结果数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 3.得到_source，也就是原始json文档</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 4.反序列化并打印</span></span><br><span class="line">        <span class="type">ItemDoc</span> <span class="variable">item</span> <span class="operator">=</span> JSONUtil.toBean(source, ItemDoc.class);</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过<code>response.getHits()</code>获取，就是JSON中的最外层的<code>hits</code>，代表命中的结果 <ul><li><code>SearchHits.getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits.getHits()</code>：获取<code>SearchHit</code>数组，也就是文档数组 <ul><li><code>SearchHit.getSourceAsString()</code>：获取文档结果中的<code>_source</code>，也就是原始的<code>json</code>文档数据</li></ul></li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>文档搜索的基本步骤是：</p><ol><li>创建<code>SearchRequest</code>对象</li><li>准备<code>request.source()</code>，也就是DSL<ol><li><code>QueryBuilders</code>来构建查询条件</li><li>传入<code>request.source()</code> 的<code>query()</code>方法</li></ol></li><li>发送请求，得到结果</li><li>解析结果</li></ol><h2 id="叶子查询-1"><a href="#叶子查询-1" class="headerlink" title="叶子查询"></a>叶子查询</h2><p>所有的查询条件都是由QueryBuilders来构建的，叶子查询也不例外</p><p>例如<code>match</code>查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRange</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">10000</span>).lte(<span class="number">30000</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>term</code>查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testTerm</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;华为&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合查询-1"><a href="#复合查询-1" class="headerlink" title="复合查询"></a>复合查询</h2><p>复合查询也是由<code>QueryBuilders</code>来构建，我们以<code>bool</code>查询为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.准备bool查询</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">bool</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.关键字搜索</span></span><br><span class="line">    bool.must(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.3.品牌过滤</span></span><br><span class="line">    bool.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;德亚&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.4.价格过滤</span></span><br><span class="line">    bool.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">300</span>));</span><br><span class="line">    request.source().query(bool);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.搜索条件参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.排序参数</span></span><br><span class="line">    request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页参数</span></span><br><span class="line">    request.source().from((pageNo - <span class="number">1</span>) * pageSize).size(pageSize);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高亮-1"><a href="#高亮-1" class="headerlink" title="高亮"></a>高亮</h2><ul><li>条件同样是在<code>request.source()</code>中指定，高亮条件要基于<code>HighlightBuilder</code>来构造</li><li>高亮响应结果与搜索的文档结果不在一起，需要单独解析</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.query条件</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮条件</span></span><br><span class="line">    request.source().highlighter(</span><br><span class="line">            SearchSourceBuilder.highlight()</span><br><span class="line">                    .field(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                    .preTags(<span class="string">&quot;&lt;em&gt;&quot;</span>)</span><br><span class="line">                    .postTags(<span class="string">&quot;&lt;/em&gt;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果解析部分，文档解析不变，主要是高亮内容需要单独解析出来:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.遍历结果数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 3.得到_source，也就是原始json文档</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 4.反序列化</span></span><br><span class="line">        <span class="type">ItemDoc</span> <span class="variable">item</span> <span class="operator">=</span> JSONUtil.toBean(source, ItemDoc.class);</span><br><span class="line">        <span class="comment">// 5.获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; hfs = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isNotEmpty(hfs)) &#123;</span><br><span class="line">            <span class="comment">// 5.1.有高亮结果，获取name的高亮结果</span></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">hf</span> <span class="operator">=</span> hfs.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (hf != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 5.2.获取第一个高亮结果片段，就是商品名称的高亮值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">hfName</span> <span class="operator">=</span> hf.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                item.setName(hfName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第<code>3、4</code>步：从结果中获取<code>_source</code>。<code>hit.getSourceAsString()</code>，这部分是非高亮结果，json字符串。还需要反序列为<code>ItemDoc</code>对象</li><li>第<code>5</code>步：获取高亮结果。<code>hit.getHighlightFields()</code>，返回值是一个<code>Map</code>，key是高亮字段名称，值是<code>HighlightField</code>对象，代表高亮值</li><li>第<code>5.1</code>步：从<code>Map</code>中根据高亮字段名称，获取高亮字段值对象<code>HighlightField</code></li><li>第<code>5.2</code>步：从<code>HighlightField</code>中获取<code>Fragments</code>，并且转为字符串。这部分就是真正的高亮字符串了</li><li>最后：用高亮的结果替换<code>ItemDoc</code>中的非高亮结果</li></ul><h1 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h1><p>聚合（<code>aggregations</code>）可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><p>聚合常见的有三类：</p><ul><li>桶（<code>Bucket</code>）聚合：用来对文档做分组 <ul><li><code>TermAggregation</code>：按照文档字段值分组，例如按照品牌值分组</li><li><code>Date Histogram</code>：按照日期阶梯分组，例如一周为一组</li></ul></li><li>度量（<code>Metric</code>）聚合：用以计算一些值<ul><li><code>Avg</code>：求平均值</li><li><code>Max</code>：求最大值</li><li><code>Min</code>：求最小值</li><li><code>Stats</code>：同时求<code>max</code>、<code>min</code>、<code>avg</code>、<code>sum</code>等</li></ul></li><li>管道（<code>pipeline</code>）聚合：其它聚合的结果为基础做进一步运算</li></ul><p><strong>参加聚合的字段必须是keyword、日期、数值、布尔类型</strong></p><h2 id="DSL实现聚合"><a href="#DSL实现聚合" class="headerlink" title="DSL实现聚合"></a>DSL实现聚合</h2><h3 id="Bucket聚合"><a href="#Bucket聚合" class="headerlink" title="Bucket聚合"></a>Bucket聚合</h3><p>例如我们要统计所有商品中共有哪些商品分类，其实就是以分类（category）字段对数据分组。category值一样的放在同一组，属于<code>Bucket</code>聚合中的<code>Term</code>聚合。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;category_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;category&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>语法说明：</p><ul><li><code>size</code>：设置<code>size</code>为0，就是每页查0条，则结果中就不包含文档，只包含聚合</li><li><code>aggs</code>：定义聚合<ul><li><code>category_agg</code>：聚合名称，自定义，不能重复<ul><li><code>terms</code>：聚合的类型，按分类聚合，所以用<code>term</code><ul><li><code>field</code>：参与聚合的字段名称</li><li><code>size</code>：希望返回的聚合结果的最大数量</li></ul></li></ul></li></ul></li></ul><h3 id="带条件聚合"><a href="#带条件聚合" class="headerlink" title="带条件聚合"></a>带条件聚合</h3><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>例如，我想知道价格高于3000元的手机品牌有哪些，该怎么统计呢？</p><p>我们需要从需求中分析出搜索查询的条件和聚合的目标：</p><ul><li>搜索查询条件：<ul><li>价格高于3000</li><li>必须是手机</li></ul></li><li>聚合目标：统计的是品牌，肯定是对brand字段做term聚合</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">300000</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brand_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Metric聚合"><a href="#Metric聚合" class="headerlink" title="Metric聚合"></a>Metric聚合</h3><p>上节课，我们统计了价格高于3000的手机品牌，形成了一个个桶。现在我们需要对桶内的商品做运算，获取每个品牌价格的最小值、最大值、平均值。</p><p>这就要用到<code>Metric</code>聚合了，例如<code>stat</code>聚合，就可以同时获取<code>min</code>、<code>max</code>、<code>avg</code>等结果</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">300000</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brand_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;stats_meric&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到我们在<code>brand_agg</code>聚合的内部，我们新加了一个<code>aggs</code>参数。这个聚合就是<code>brand_agg</code>的子聚合，会对<code>brand_agg</code>形成的每个桶中的文档分别统计。</p><ul><li><code>stats_meric</code>：聚合名称<ul><li><code>stats</code>：聚合类型，stats是<code>metric</code>聚合的一种<ul><li><code>field</code>：聚合字段，这里选择<code>price</code>，统计价格</li></ul></li></ul></li></ul><p>由于stats是对brand_agg形成的每个品牌桶内文档分别做统计，因此每个品牌都会统计出自己的价格最小、最大、平均值。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>aggs代表聚合，与query同级，此时query的作用是？</p><ul><li>限定聚合的的文档范围</li></ul><p>聚合必须的三要素：</p><ul><li>聚合名称</li><li>聚合类型</li><li>聚合字段</li></ul><p>聚合可配置属性有：</p><ul><li>size：指定聚合结果数量</li><li>order：指定聚合结果排序方式</li><li>field：指定聚合字段</li></ul><h2 id="RestClient实现聚合"><a href="#RestClient实现聚合" class="headerlink" title="RestClient实现聚合"></a>RestClient实现聚合</h2><p>在DSL中，<code>aggs</code>聚合条件与<code>query</code>条件是同一级别，都属于查询JSON参数，因此依然是利用<code>request.source()</code>方法来设置。</p><p>聚合条件的要利用<code>AggregationBuilders</code>这个工具类来构造，聚合结果与搜索文档同一级别，需要单独获取和解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAgg</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">bool</span> <span class="operator">=</span> QueryBuilders.boolQuery()</span><br><span class="line">            .filter(QueryBuilders.termQuery(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;手机&quot;</span>))</span><br><span class="line">            .filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">3000</span>));</span><br><span class="line">    request.source().query(bool).size(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3.聚合参数</span></span><br><span class="line">    request.source().aggregation(</span><br><span class="line">            AggregationBuilders.terms(<span class="string">&quot;brand_agg&quot;</span>).field(<span class="string">&quot;brand&quot;</span>).size(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 4.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 5.解析聚合结果</span></span><br><span class="line">    <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">    <span class="comment">// 5.1.获取品牌聚合</span></span><br><span class="line">    <span class="type">Terms</span> <span class="variable">brandTerms</span> <span class="operator">=</span> aggregations.get(<span class="string">&quot;brand_agg&quot;</span>);</span><br><span class="line">    <span class="comment">// 5.2.获取聚合中的桶</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();</span><br><span class="line">    <span class="comment">// 5.3.遍历桶内数据</span></span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 5.4.获取桶内key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">brand</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">        System.out.print(<span class="string">&quot;brand = &quot;</span> + brand);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> bucket.getDocCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;; count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务入门(二)</title>
      <link href="/inori/98835b85.html"/>
      <url>/inori/98835b85.html</url>
      
        <content type="html"><![CDATA[<p>在微服务远程调用的过程中，还存在几个问题需要解决。</p><p>首先是<strong>业务健壮性</strong>问题：</p><p>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服 务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息。</p><p>还有级联失败问题：</p><p>还是查询购物车的业务，假如商品服务业务并发较高，占用过多Tomcat连接。可能会导致商品服务的所有接口响应时间增加，延迟变高，甚至是长时间阻塞直至查询失败。</p><p>此时查询购物车业务需要查询并等待商品查询结果，从而导致查询购物车列表业务的响应时间也变长，甚至也阻塞直至无法访问。而此时如果查询购物车的请求较多，可能导致购物车服务的Tomcat连接占用较多，所有接口的响应时间都会增加，整个服务性能很差， 甚至不可用。</p><p>暂时无法在飞书文档外展示此内容</p><p>依次类推，整个微服务群中与购物车服务、商品服务等有调用关系的服务可能都会出现问题，最终导致整个集群不可用。</p><p>暂时无法在飞书文档外展示此内容</p><p>这就是级联失败问题，或者叫雪崩问题。</p><h1 id="微服务保护"><a href="#微服务保护" class="headerlink" title="微服务保护"></a>微服务保护</h1><p>保证服务运行的健壮性，避免级联失败导致的雪崩问题（整个微服务群中有调用关系的服务出现问题，最终导致整个集群不可用），就属于微服务保护</p><h2 id="服务保护方案"><a href="#服务保护方案" class="headerlink" title="服务保护方案"></a>服务保护方案</h2><p>微服务保护的方案有很多，比如：</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul><p>这些方案或多或少都会导致服务的体验上略有下降，比如请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。因此这些方案都属于服务<strong>降级</strong>的方案。但通过这些方案，服务的健壮性得到了提升，</p><h3 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h3><p>服务故障最重要原因，就是并发太高。解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是<strong>限制或控制</strong>接口访问的并发流量，避免服务因流量激增而出现故障。</p><p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。</p><h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以必须把这种影响降低，或者缩减影响的范围，线程隔离正是解决这个问题的好办法。</p><p>其原理就是为了避免某个接口故障或压力过大导致整个服务不可用，限定每个接口可以使用的资源范围，也就是将其“隔离”起来。</p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>线程隔离虽然避免了雪崩问题，但故障服务依然会拖慢服务调用方的接口响应速度，而且其故障可能会导致接下来要调用的其他服务也变得不可用。</p><p>所以要做两件事情：</p><ul><li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li><li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li></ul><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><a href="https://sentinelguard.io/zh-cn/">Sentinel</a>是阿里巴巴开源的一款服务保护框架，目前已经加入SpringCloudAlibaba中</p><p>Sentinel的使用可以分为两个部分:</p><ul><li><strong>核心库</strong>（Jar包）：不依赖任何框架&#x2F;库，能够运行于 ava8及以上的版本的运行时环境，同时对Dubbo&#x2F;Spring Cloud等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</li><li><strong>控制台</strong>（Dashboard）：Dashboard主要负责管理推送规则、监控、管理机器信息等。</li></ul><p>为了方便监控微服务，需要先把Sentinel的控制台搭建出来。</p><p>1）<a href="https://github.com/alibaba/Sentinel/releases">下载jar包</a></p><p>2）运行</p><p>将jar包放在任意非中文、不包含特殊字符的目录下,运行如下命令启动控制台：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</span><br></pre></td></tr></table></figure><p>其它启动时可配置参数可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9">官方文档</a></p><p>3）访问</p><p>访问<a href="http://localhost:8080/">http://localhost:8090</a>页面，就可以看到sentinel的控制台了，需要输入账号和密码，默认都是：sentinel，登录后，即可看到控制台，默认会监控sentinel-dashboard服务本身</p><h3 id="微服务整合"><a href="#微服务整合" class="headerlink" title="微服务整合"></a>微服务整合</h3><p>想要在微服务连接<code>sentinel-dashboard</code>控制台，步骤如下： </p><p>1）引入sentinel依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置控制台</p><p>修改application.yaml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br></pre></td></tr></table></figure><p>3）访问微服务任意端点</p><p>重启微服务，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到<code>sentinel-dashboard</code>控制台。并展示出统计信息</p><p>点击簇点链路菜单，会看到下面的页面：</p><p><img src="/inori/98835b85/sentinel_service_control.png" alt="sentinel_service_control"></p><p>簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被Sentinel监控的资源。默认情况下，<code>Sentinel</code>会监控<code>SpringMVC</code>的每一个<code>Endpoint</code>（接口）</p><p><code>/carts</code>这个接口路径就是其中一个簇点，我们可以对其进行限流、熔断、隔离等保护措施。</p><p>默认情况下Sentinel会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。</p><p>所以可以选择打开Sentinel的请求方式前缀，把<code>请求方式 + 请求路径</code>作为簇点资源名：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><h3 id="请求限流-1"><a href="#请求限流-1" class="headerlink" title="请求限流"></a>请求限流</h3><p>在簇点链路后面点击流控按钮，即可对其做限流配置</p><h3 id="线程隔离-1"><a href="#线程隔离-1" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。所以要对查询商品的FeignClient接口做线程隔离。</p><h4 id="OpenFeign整合Sentinel"><a href="#OpenFeign整合Sentinel" class="headerlink" title="OpenFeign整合Sentinel"></a>OpenFeign整合Sentinel</h4><p>开启Feign的sentinel功能：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure><p>然后重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源</p><h4 id="配置线程隔离"><a href="#配置线程隔离" class="headerlink" title="配置线程隔离"></a>配置线程隔离</h4><p>点击查询商品的FeignClient对应的簇点资源后面的流控按钮：</p><p><img src="/inori/98835b85/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cthread_division.png" alt="thread_division"></p><p>这里勾选的是并发线程数限制，也就是说这个查询功能最多使用5个线程，而不是5QPS。如果查询商品的接口每秒处理2个请求，则5个线程的实际QPS在10左右，而超出的请求自然会被拒绝。</p><h3 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>通常来说，业务不能只配置线程隔离，还需要搭配服务熔断一起，因为：</p><ul><li>超出的QPS上限的请求就只能抛出异常，会损失用户体验。需要给查询失败设置一个<strong>降级处理</strong>逻辑</li><li>由于查询商品的延迟较高，从而导致其他相关联的业务响应时间也变的很长。对于这种不太健康的接口，应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。</li></ul><h4 id="编写降级逻辑"><a href="#编写降级逻辑" class="headerlink" title="编写降级逻辑"></a>编写降级逻辑</h4><p>触发限流或熔断后的请求不一定要直接报错，也可以返回一些默认数据或者友好提示，用户体验会更好。</p><p>给FeignClient编写失败后的降级逻辑有两种方式：</p><ul><li>FallbackClass，无法对远程调用的异常做处理</li><li>FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式。</li></ul><p>定义降级处理类，实现<code>FallbackFactory</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(Collection&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;远程调用queryItemByIds方法出现异常，参数：&#123;&#125;&quot;</span>, ids, cause);</span><br><span class="line">                <span class="comment">// 查询购物车允许失败，查询失败，返回空集合</span></span><br><span class="line">                <span class="keyword">return</span> CollUtils.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;</span><br><span class="line">                <span class="comment">// 库存扣减业务需要触发事务回滚，查询失败，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>ItemClientFallback</code>注册为一个<code>Bean</code></p><p>在接口中使用<code>ItemClientFallbackFactory</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class,fallbackFactory = ItemClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; items)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/stock/add&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetail&gt; items)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务熔断-2"><a href="#服务熔断-2" class="headerlink" title="服务熔断"></a>服务熔断</h4><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</p><p>断路器的工作状态切换有一个状态机来控制：</p><p><img src="/inori/98835b85/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Csentinel_stop.png" alt="sentinel_stop"></p><p>状态机包括三个状态：</p><ul><li><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 <ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p>我们可以在控制台通过点击簇点后的<strong>熔断</strong>按钮来配置熔断策略，这种是按照慢调用比例来做熔断，上述配置的含义是：</p><ul><li>RT超过200毫秒的请求调用就是慢调用</li><li>统计最近1000ms内的最少5次请求，如果慢调用比例不低于0.5，则触发熔断</li><li>熔断持续时长20s</li></ul><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为<strong>分支事务</strong>。多个有关联的分支事务一起就组成了<strong>全局事务</strong>。必须保证整个全局事务同时成功或失败。</p><p>我们知道每一个分支事务就是传统的<strong>单体事务</strong>，都可以满足ACID(原子性，一致性，隔离性，持久性)，但全局事务跨越多个服务、多个数据库，如何满足ACID呢？</p><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此一般会使用开源的框架来解决分布式事务问题。</p><p>在众多的开源分布式事务框架中，功能最完善、使用最多的是<a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">Seata</a>。</p><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。</p><p>因此解决分布式事务的思想为：就是找一个统一的<strong>事务协调者</strong>，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。</p><p>在Seata的事务管理中有三个重要的角色：</p><ul><li>TC (Transaction Coordinator) - <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚</li><li>TM (Transaction Manager) - <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务</li><li>RM (Resource Manager) - <strong>资源管理器：</strong>管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚</li></ul><p>Seata的工作架构为：</p><p><img src="/inori/98835b85/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cseata_frame.png" alt="seata_frame"></p><p>其中，<strong>TM</strong>和<strong>RM</strong>可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来<strong>TM</strong>和<strong>RM</strong>就会协助微服务，实现本地分支事务与<strong>TC</strong>之间交互，实现事务的提交或回滚。</p><p>而<strong>TC</strong>服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p><h3 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h3><p>需要准备数据库表、导入配置文件、使用Docker命令部署，详见<a href="https://blog.csdn.net/studio_1/article/details/135650319">这篇博客</a></p><h4 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h4><p>需要注意，要确保nacos、mysql都在同一网络中。如果某个容器不在同一网络，可以参考下面的命令将某容器加入指定网络：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network connect [网络名] [容器名]</span><br></pre></td></tr></table></figure><h3 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata</h3><p>参与分布式事务的每一个微服务都需要集成Seata，我们以<code>trade-service</code>为例。</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>为了方便各个微服务集成seata，我们需要把seata配置共享到nacos，因此不仅仅要引入seata依赖，还要引入nacos依赖:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">hmall</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与tc集群的映射关系</span></span><br><span class="line">      <span class="attr">hmall:</span> <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure><h4 id="添加数据库表"><a href="#添加数据库表" class="headerlink" title="添加数据库表"></a>添加数据库表</h4><p>seata的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。加入到需要分布式事务的微服务的数据库中：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `undo_log`</span><br><span class="line">(</span><br><span class="line">    `branch_id`     <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    `xid`           <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    `context`       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    `rollback_info` LONGBLOB     <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    `log_status`    <span class="type">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    `log_created`   DATETIME(<span class="number">6</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    `log_modified`  DATETIME(<span class="number">6</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4 COMMENT <span class="operator">=</span><span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure><p>至此为止，微服务整合的工作就完成了</p><p>那么，Seata是如何解决分布式事务的呢？</p><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><p>Seata支持四种不同的分布式事务解决方案：</p><ul><li><strong>XA</strong></li><li><strong>TCC</strong></li><li><strong>AT</strong></li><li><strong>SAGA</strong></li></ul><p><code>XA</code> 规范是<code> X/Open</code> 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA规范描述了全局的<code>TM</code>与局部的<code>RM</code>之间的接口，几乎所有主流的数据库都对XA规范提供了支持。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>正常情况：</p><p><img src="/inori/98835b85/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cxa_normal.png" alt="xa_normal"></p><p>异常情况：</p><p><img src="/inori/98835b85/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cxa_nonomal.png" alt="xa_nonomal"></p><p>一阶段：</p><ul><li>事务协调者通知每个事务参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作</li><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul><h4 id="Seata的XA模型"><a href="#Seata的XA模型" class="headerlink" title="Seata的XA模型"></a>Seata的XA模型</h4><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><p><img src="/inori/98835b85/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cxa_model.png" alt="xa_model"></p><p><code>RM</code>一阶段的工作：</p><ol><li>注册分支事务到<code>TC</code></li><li>执行分支业务sql但不提交</li><li>报告执行状态到<code>TC</code></li></ol><p><code>TC</code>二阶段的工作：</p><ol><li><code>TC</code>检测各分支事务执行状态</li><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ol><p><code>RM</code>二阶段的工作：</p><ul><li>接收<code>TC</code>指令，提交或回滚事务</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><code>XA</code>模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p><code>XA</code>模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>首先，在配置文件中设置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure><p>其次，我们要利用<code>@GlobalTransactional</code>标记分布式事务的入口方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">createOrder</span><span class="params">(OrderFormDTO orderFormDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p><code>AT</code>模式同样是分阶段提交的事务模型，不过缺弥补了<code>XA</code>模型中资源锁定周期过长的缺陷。</p><h4 id="Seata的AT模型"><a href="#Seata的AT模型" class="headerlink" title="Seata的AT模型"></a>Seata的AT模型</h4><p><img src="/inori/98835b85/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cat_model.png" alt="at_model"></p><p>阶段一<code>RM</code>的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时<code>RM</code>的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时<code>RM</code>的工作：</p><ul><li>根据undo-log恢复数据到更新前</li></ul><h4 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h4><p>我们用一个真实的业务来梳理下AT模式的原理。</p><p>比如，现在有一个数据库表，记录用户余额：</p><table><thead><tr><th align="left"><strong>id</strong></th><th align="left"><strong>money</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">100</td></tr></tbody></table><p>其中一个分支业务要执行的SQL为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>AT模式下，当前分支事务执行流程如下：</p><p><strong>一阶段</strong>：</p><ol><li><code>TM</code>发起并注册全局事务到<code>TC</code></li><li><code>TM</code>调用分支事务</li><li>分支事务准备执行业务SQL</li><li><code>RM</code>拦截业务SQL，根据where条件查询原始数据，形成快照。</li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;money&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol><li><code>RM</code>执行业务SQL，提交本地事务，释放数据库锁。此时 money &#x3D; 90</li><li><code>RM</code>报告本地事务状态给<code>TC</code></li></ol><p><strong>二阶段</strong>：</p><ol><li><code>TM</code>通知<code>TC</code>事务结束</li><li><code>TC</code>检查分支事务状态<ol><li>如果都成功，则删除快照</li><li>如果有分支事务失败，需要回滚。读取快照数据（{“id”: 1, “money”: 100}），将快照恢复到数据库。此时数据库再次恢复为100</li></ol></li></ol><h4 id="AT模式的脏写问题"><a href="#AT模式的脏写问题" class="headerlink" title="AT模式的脏写问题"></a>AT模式的脏写问题</h4><p>在极端情况下，特别是多线程并发访问AT模式的分布式事务时，有可能出现脏写问题，比如一个事物A获取DB锁，保存快照，执行<code>set money = 90</code>然后提交事务，释放DB锁，但是这是有另一个事务B接着获取DB锁，保存快照后执行<code>set money = 80</code>然后提交事务，释放DB锁。但是这时事务A需要回滚，事务A的快照保存的<code>money=100</code>，这就造成了脏写。</p><p>解决思路就是引入了全局锁的概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p><h3 id="AT与XA的区别"><a href="#AT与XA的区别" class="headerlink" title="AT与XA的区别"></a>AT与XA的区别</h3><p>简述<code>AT</code>模式与<code>XA</code>模式最大的区别是什么？</p><ul><li><code>XA</code>模式一阶段不提交事务，锁定资源；<code>AT</code>模式一阶段直接提交，不锁定资源。</li><li><code>XA</code>模式依赖数据库机制实现回滚；<code>AT</code>模式利用数据快照实现数据回滚。</li><li><code>XA</code>模式强一致；<code>AT</code>模式最终一致</li></ul><p>可见，AT模式使用起来更加简单，无业务侵入，性能更好。</p><h3 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h3><p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p><ul><li><code>try</code>：资源的检测和预留</li><li><code>confirm</code>：完成资源操作业务；要求 <code>try</code> 成功 <code>confirm</code> 一定要能成功 </li><li><code>cancel</code>：预留资源释放，可以理解为try的反向操作</li></ul><p>举例，一个扣减用户余额的业务。假设账户A原来余额是100，需要余额扣减30元。</p><p><strong>阶段一（ Try ）</strong>：检查余额是否充足，如果充足则冻结金额增加30元，可用余额扣除30，此时，<code>总金额 = 冻结金额 + 可用金额</code>，数量依然是100不变。事务直接提交无需等待其它事务</p><p>**阶段二（Confirm)**：假如要提交（Confirm），之前可用金额已经扣减，并转移到冻结金额。因此可用金额不变，直接冻结金额扣减30即可。此时，<code>总金额 = 冻结金额 + 可用金额 = 0 + 70  = 70元</code></p><p>**阶段三(Canncel)**：<u>如果</u>要回滚（Cancel），则释放之前冻结的金额，也就是冻结金额扣减30，可用余额增加30</p><p>假如一个分布式事务中包含两个分支事务，try阶段，一个分支成功执行，另一个分支事务阻塞</p><h4 id="事务悬挂和空回滚"><a href="#事务悬挂和空回滚" class="headerlink" title="事务悬挂和空回滚"></a>事务悬挂和空回滚</h4><p>假如一个分布式事务中包含两个分支事务，try阶段，一个分支成功执行，另一个分支事务阻塞</p><p><img src="/inori/98835b85/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Ctcc_1.png" alt="tcc_1"></p><p>如果阻塞时间太长，可能导致全局事务超时而触发二阶段的<code>cancel</code>操作。两个分支事务都会执行cancel操作</p><p><img src="/inori/98835b85/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Ctcc_2.png" alt="tcc_2"></p><p>要知道，其中一个分支是未执行<code>try</code>操作的，直接执行了<code>cancel</code>操作，反而会导致数据错误。因此，这种情况下，尽管<code>cancel</code>方法要执行，但其中不能做任何回滚操作，这就是<strong>空回滚</strong></p><p>对于整个空回滚的分支事务，将来try方法阻塞结束依然会执行。但是整个全局事务其实已经结束了，因此永远不会再有confirm或cancel，也就是说这个事务执行了一半，处于<strong>悬挂状态</strong>，这就是业务悬挂问题</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>TCC模式的每个阶段</p><ul><li>Try：资源检查和预留</li><li>Confirm：业务执行和提交</li><li>Cancel：预留资源的释放</li></ul><p>TCC的优点</p><ul><li>一阶段完成直接提交事务，释放数据库资源，性能好</li><li>相比AT模型，无需生成快照，无需使用全局锁，性能最强</li><li>不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</li></ul><p>TCC的缺点</p><ul><li>有代码侵入，需要人为编写try、Confirm和Cancel接口</li><li>软状态，事务是最终一致</li><li>需要考虑Confirm和Cancel的失败情况，做好幂等处理、事务悬挂和空回滚处理</li></ul><h2 id="CAP与BASE理论"><a href="#CAP与BASE理论" class="headerlink" title="CAP与BASE理论"></a>CAP与BASE理论</h2><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导，首先就是CAP定理</p><ul><li>Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致</li><li><strong>A</strong>vailability（可用性）：用户访问分布式系统时，读或写操作总能成功</li><li><strong>P</strong>artition tolerance （分区容错性）：即便是系统出现网络分区，整个系统也要持续对外提供服务</li></ul><p>它们的第一个字母分别是 <code>C</code>、<code>A</code>、<code>P</code>。开发者认为任何分布式系统架构方案都不可能同时满足这3个目标，这个结论就叫做CAP定理</p><p>在分布式系统中，网络不能100%保证畅通，也就是说网络分区的情况一定会存在。而我们的系统必须要持续运行，对外提供服务。所以分区容错性（<code>P</code>）是硬性指标，所有分布式系统都要满足。而在设计分布式系统时要取舍的就是一致性（<code>C</code>）和可用性（<code>A</code>）了。</p><p>假设有三个node节点，由于网络故障，当我们把数据写入node01时，可以与node02完成数据同步，但是无法同步给node03。现在有两种选择：</p><ul><li>允许用户任意读写，保证可用性。但由于node03无法完成同步，就会出现数据不一致的情况。满足AP</li><li>不允许用户写，可以读，直到网络恢复，分区消失。这样就确保了一致性，但牺牲了可用性。满足CP</li></ul><p>可见，在分布式系统中，<code>A</code>和<code>C</code>之间只能满足一个</p><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><p>既然分布式系统要遵循CAP定理，那么问题来了，我到底是该牺牲一致性还是可用性呢？如果牺牲了一致性，出现数据不一致该怎么处理？</p><p>人们在总结系统设计经验时，最终得到了一些心得：</p><ul><li><strong>B</strong>asically <strong>A</strong>vailable（基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用</li><li><strong>S</strong>oft State<strong>（</strong>软状态<strong>）：</strong>在一定时间内，允许出现中间状态，比如临时的不一致状态</li><li><strong>Ev</strong>entually Consistent<strong>（</strong>最终一致性<strong>）</strong>：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致</li></ul><p>简单来说，BASE理论就是一种取舍的方案，不再追求完美，而是最终达成目标。因此解决分布式事务的思想也是这样，有两个方向：</p><ul><li>AP思想：各个子事务分别执行和提交，无需锁定数据。允许出现结果不一致，然后采用弥补措施恢复，实现最终一致即可。例如<code>AT</code>模式就是如此</li><li>CP思想：各个子事务执行后不要提交，而是等待彼此结果，然后同时提交或回滚。在这个过程中锁定资源，不允许其它人访问，数据处于不可用状态，但能保证一致性。例如<code>XA</code>模式</li></ul><h2 id="服务保护"><a href="#服务保护" class="headerlink" title="服务保护"></a>服务保护</h2><p>在SpringCloud的早期版本中采用的服务保护技术叫做<code>Hystix</code>，不过后来被淘汰，替换为<code>Spring Cloud Circuit Breaker</code>，其底层实现可以是<code>Spring Retry</code>和<code>Resilience4J</code></p><p>不过在国内使用较多还是<code>SpringCloudAlibaba</code>中的<code>Sentinel</code>组件</p><h3 id="线程隔离-2"><a href="#线程隔离-2" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>首先我们来看下线程隔离功能，无论是Hystix还是Sentinel都支持线程隔离。不过其实现方式不同。</p><p>线程隔离有两种方式实现：</p><ul><li>线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果，优点是支持主动超时和异步调用，缺点是线程额外开销大</li><li>信号量隔离：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求，优点是无额外开销，缺点是不支持主动超时和异步调用</li></ul><p>Sentinel的线程隔离就是基于信号量隔离实现的，而Hystix两种都支持，但默认是基于线程池隔离</p><h3 id="滑动窗口算法"><a href="#滑动窗口算法" class="headerlink" title="滑动窗口算法"></a>滑动窗口算法</h3><p>在熔断功能中，需要统计异常请求或慢请求比例，也就是计数。在限流的时候，要统计每秒钟的QPS，同样是计数。可见计数算法在熔断限流中的应用非常多。sentinel中采用的计数器算法就是滑动窗口计数算法</p><h4 id="固定窗口计数"><a href="#固定窗口计数" class="headerlink" title="固定窗口计数"></a>固定窗口计数</h4><p>固定窗口计数法基本原理是：</p><ul><li>将时间划分为多个窗口，窗口时间跨度称为<code>Interval</code></li><li>每个窗口维护1个计数器，每有1次请求就将计数器<code>+1</code>。限流就是设置计数器阈值</li><li>如果计数器超过了限流阈值，则超出阈值的请求都被丢弃</li></ul><p>但是有一种特殊场景，假设<code>Interval</code>为1s：</p><ul><li>假如在第5、6秒，请求数量都为3，没有超过阈值，全部放行</li><li>但是，如果第5秒的三次请求都是在4.5<del>5秒之间进来；第6秒的请求是在5</del>5.5之间进来。那么从第4.5~5.5之间就有6次请求！也就是说每秒的QPS达到了6，远超阈值</li></ul><h4 id="滑动窗口计数"><a href="#滑动窗口计数" class="headerlink" title="滑动窗口计数"></a>滑动窗口计数</h4><p>固定时间窗口算法中窗口有很多，其跨度和位置是与时间区间绑定，因此是很多固定不动的窗口。而滑动时间窗口算法中只包含1个固定跨度的窗口，但窗口是可移动的，与时间区间无关</p><ul><li>窗口时间跨度<code>Interval</code>大小固定，例如1秒</li><li>时间区间跨度为<code>Interval / n</code> ，例如n&#x3D;2，则时间区间跨度为500ms</li><li>窗口会随着当前请求所在时间<code>currentTime</code>移动，窗口范围从<code>currentTime-Interval</code>时刻之后的第一个时区开始，到<code>currentTime</code>所在时区结束</li></ul><p>滑动窗口内划分的时区越多，这种统计就越准确。</p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>漏桶算法可以解释为请求到达后不是直接处理，而是先放入一个队列。而后以固定的速率从队列中取出并处理请求。之所以叫漏桶算法，就是把请求看做水，队列看做是一个漏了的桶，设计上更适合应对并发波动较大的场景</p><ul><li>将每个请求视作”水滴”放入”漏桶”进行存储</li><li>“漏桶”以固定速率向外”漏”出请求来执行，如果”漏桶”空了则停止”漏水”</li><li>如果”漏桶”满了则多余的”水滴”会被直接丢弃</li></ul><p>漏桶的优势就是<strong>流量整型</strong>，桶就像是一个大坝，请求就是水。并发量不断波动，就如图水流时大时小，但都会被大坝拦住。而后大坝按照固定的速度放水，避免下游被洪水淹没。</p><p>因此，不管并发量如何波动，经过漏桶处理后的请求一定是相对平滑的曲线</p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>限流的另一种常见算法是令牌桶算法。Sentinel中的<strong>热点参数限流</strong>正是基于令牌桶算法实现的。</p><p>说明：</p><ul><li>以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，多余令牌丢弃</li><li>请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理</li><li>如果令牌桶中没有令牌，则请求等待或丢弃</li></ul><p>基于令牌桶算法，每秒产生的令牌数量基本就是QPS上限</p><p>当然也有例外情况，例如：</p><ul><li>某一秒令牌桶中产生了很多令牌，达到令牌桶上限N，缓存在令牌桶中，但是这一秒没有请求进入。</li><li>下一秒的前半秒涌入了超过2N个请求，之前缓存的令牌桶的令牌耗尽，同时这一秒又生成了N个令牌，于是总共放行了2N个请求。超出了我们设定的QPS阈值。</li></ul><p>因此，在使用令牌桶算法时，尽量不要将令牌上限设定到服务能承受的QPS上限。而是预留一定的波动空间，这样我们才能应对突发流量。</p><p>什么是热点参数限流？</p><ul><li><p>商品ID为参数，统计一段时间内最常购买的商品ID并进行限制</p></li><li><p>用户ID为参数，针对一段时间内频繁访问的用户ID进行限制</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch基础入门</title>
      <link href="/inori/d672aa30.html"/>
      <url>/inori/d672aa30.html</url>
      
        <content type="html"><![CDATA[<p>在某些数据量非常大的项目中，一定会提供搜索功能。如果搜索功能仅仅使用数据库模糊查询实现，就会带来很多问题：</p><ol><li>效率低。由于数据库模糊查询不走索引，在数据量较大的时候，查询性能很差。数据库模糊查询随着表数据量的增多，查询性能的下降会非常明显，</li><li>功能单一。数据库的模糊搜索功能单一，匹配条件非常苛刻，必须恰好包含用户搜索的关键字。</li></ol><p>而使用搜索引擎就没有上述问题。</p><h1 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h1><p><a href="https://www.elastic.co/cn/elasticsearch/">ElasticSearch</a>是一款非常强大的开源搜索引擎，支持的功能非常多</p><h2 id="认识和安装"><a href="#认识和安装" class="headerlink" title="认识和安装"></a>认识和安装</h2><p>Elasticsearch是elastic技术栈中的一部分。完整的技术栈包括：</p><ul><li>Elasticsearch：用于数据存储、计算和搜索</li><li>Logstash&#x2F;Beats：用于数据收集</li><li>Kibana：用于数据可视化</li></ul><p>整套技术栈被称为ELK，经常用来做日志收集、系统监控和状态分析等等，其核心就是用来<strong>存储</strong>、<strong>搜索</strong>、<strong>计算</strong>的Elasticsearch</p><p>需要安装的内容有：</p><ul><li>Elasticsearch：提供核心的数据存储、搜索、分析功能。</li><li>Kibana：Elasticsearch对外提供的是Restful风格的API，任何操作都可以通过发送http请求来完成。不过http请求的方式、路径、还有请求参数的格式都有严格的规范。要借助于Kibana服务</li></ul><p>而且，Kibana的功能非常强大，包括：</p><ul><li>对Elasticsearch数据的搜索、展示</li><li>对Elasticsearch数据的统计、聚合，并形成图形化报表、图形</li><li>对Elasticsearch的集群状态监控</li><li>它还提供了一个开发控制台（DevTools），在其中对Elasticsearch的Restful的API接口提供了<strong>语法提示</strong></li></ul><h3 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h3><p>通过Docker命令安装单机版本的elasticsearch，这里采用的是elasticsearch7版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name es \</span><br><span class="line">  -e <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">  -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">  -v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">  --privileged \</span><br><span class="line">  --network test-net \</span><br><span class="line">  -p 9200:9200 \</span><br><span class="line">  -p 9300:9300 \</span><br><span class="line">  elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><p>安装完成后，访问9200端口，即可看到响应的Elasticsearch服务的基本信息。</p><h3 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h3><p>通过Docker命令部署Kibana：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=test-net \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure><p>安装完成后，直接访问5601端口，即可看到控制台页面，选择<code>Explore on my own</code>之后，进入主页面，然后选中<code>Dev tools</code>，进入开发工具页面，之后主要在这里预先输入ES查询语句。</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>ES之所以有如此高性能的搜索表现，正是得益于底层的倒排索引技术。倒排索引的概念是基于MySQL这样的正向索引而言的。</p><h3 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h3><p>例如有一张名为<code>tb_goods</code>的表：</p><table><thead><tr><th align="left"><strong>id</strong></th><th align="left"><strong>title</strong></th><th align="left"><strong>price</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">小米手机</td><td align="left">3499</td></tr><tr><td align="left">2</td><td align="left">华为手机</td><td align="left">4999</td></tr><tr><td align="left">3</td><td align="left">华为小米充电器</td><td align="left">49</td></tr><tr><td align="left">4</td><td align="left">小米手环</td><td align="left">49</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>其中的<code>id</code>字段已经创建了索引，由于索引底层采用了B+树结构，因此我们根据id搜索的速度会非常快。但是其他字段例如<code>title</code>，只在叶子节点上存在。</p><p>因此要根据<code>title</code>搜索的时候只能遍历树中的每一个叶子节点，判断title数据是否符合要求。</p><p>比如用户的SQL语句为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_goods <span class="keyword">where</span> title <span class="keyword">like</span> <span class="string">&#x27;%手机%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>那搜索的大概流程为：</p><p><img src="/inori/d672aa30/sql_search.png" alt="img"></p><ul><li>1）检查到搜索条件为<code>like &#39;%手机%&#39;</code>，需要找到<code>title</code>中包含<code>手机</code>的数据</li><li>2）逐条遍历每行数据（每个叶子节点），比如第1次拿到<code>id</code>为1的数据</li><li>3）判断数据中的<code>title</code>字段值是否符合条件</li><li>4）如果符合则放入结果集，不符合则丢弃</li><li>5）回到步骤1</li></ul><p>当搜索条件为模糊匹配时，由于索引无法生效，导致从索引查询退化为全表扫描，效率很差。因此，正向索引适合于根据索引字段的精确搜索，不适合基于部分词条的模糊匹配。而倒排索引恰好解决的就是根据部分词条模糊匹配的问题。</p><h3 id="倒排索引-1"><a href="#倒排索引-1" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引中有两个概念：</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条</li></ul><p>创建倒排索引是对正向索引的一种特殊处理和应用，流程为：</p><ul><li>将每一个文档的数据利用<strong>分词算法</strong>根据语义拆分，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建<strong>正向</strong>索引</li></ul><p>此时形成的这张以词条为索引的表，就是倒排索引表，两者对比如下：</p><p><strong>正向索引</strong></p><table><thead><tr><th align="left"><strong>id（索引）</strong></th><th align="left"><strong>title</strong></th><th align="left"><strong>price</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">小米手机</td><td align="left">3499</td></tr><tr><td align="left">2</td><td align="left">华为手机</td><td align="left">4999</td></tr><tr><td align="left">3</td><td align="left">华为小米充电器</td><td align="left">49</td></tr><tr><td align="left">4</td><td align="left">小米手环</td><td align="left">49</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p><strong>倒排索引</strong></p><table><thead><tr><th align="left"><strong>词条（索引）</strong></th><th align="left"><strong>文档id</strong></th></tr></thead><tbody><tr><td align="left">小米</td><td align="left">1，3，4</td></tr><tr><td align="left">手机</td><td align="left">1，2</td></tr><tr><td align="left">华为</td><td align="left">2，3</td></tr><tr><td align="left">充电器</td><td align="left">3</td></tr><tr><td align="left">手环</td><td align="left">4</td></tr></tbody></table><p>倒排索引的<strong>搜索流程</strong>如下为：</p><p><img src="/inori/d672aa30/es_search.png" alt="img"></p><p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p><p>2）对用户输入条件分词，得到词条：<code>华为</code>、<code>手机</code></p><p>3）拿着词条在倒排索引中查找（由于词条有索引，查询效率很高），即可得到包含词条的文档id：<code>1、2、3</code></p><p>4）拿着文档<code>id</code>到正向索引中查找具体文档即可（由于<code>id</code>也有索引，查询效率也很高）</p><h3 id="正向和倒排的优缺点"><a href="#正向和倒排的优缺点" class="headerlink" title="正向和倒排的优缺点"></a>正向和倒排的优缺点</h3><p><strong>正向索引</strong>：</p><ul><li>优点： <ul><li>可以给多个字段创建索引</li><li>根据索引字段搜索、排序速度非常快</li></ul></li><li>缺点： <ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul></li></ul><p><strong>倒排索引</strong>：</p><ul><li>优点： <ul><li>根据词条搜索、模糊搜索时，速度非常快</li></ul></li><li>缺点： <ul><li>只能给词条创建索引，而不是字段</li><li>无法根据字段做排序</li></ul></li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p><h3 id="文档和字段"><a href="#文档和字段" class="headerlink" title="文档和字段"></a>文档和字段</h3><p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为<code>json</code>格式后存储在<code>elasticsearch</code>中：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小米手机&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">3499</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华为手机&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华为小米充电器&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">49</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小米手环&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">299</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>因此，原本数据库中的一行数据就是ES中的一个JSON文档；而数据库中每行数据都包含很多列，这些列就转换为JSON文档中的<strong>字段（Field）</strong>。</p><h3 id="索引和映射"><a href="#索引和映射" class="headerlink" title="索引和映射"></a>索引和映射</h3><p>随着业务发展，需要在es中存储的文档也会越来越多，比如有商品的文档、用户的文档、订单文档等等，后期将类型相同的文档集中在一起管理，称为<strong>索引（Index）</strong>。</p><p>例如：</p><ul><li>所有用户文档，就可以组织在一起，称为用户的索引</li><li>所有商品的文档，可以组织在一起，称为商品的索引</li><li>所有订单的文档，可以组织在一起，称为订单的索引</li></ul><p>可以把索引当做是数据库中的表。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p><h3 id="mysql与elasticsearch"><a href="#mysql与elasticsearch" class="headerlink" title="mysql与elasticsearch"></a>mysql与elasticsearch</h3><table><thead><tr><th align="left"><strong>MySQL</strong></th><th align="left"><strong>Elasticsearch</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Table</td><td align="left">Index</td><td align="left">索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td align="left">Row</td><td align="left">Document</td><td align="left">文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td align="left">Column</td><td align="left">Field</td><td align="left">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td align="left">Schema</td><td align="left">Mapping</td><td align="left">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td align="left">SQL</td><td align="left">DSL</td><td align="left">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><ul><li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性 </li><li>Elasticsearch：擅长海量数据的搜索、分析、计算</li></ul><p>项目中往往两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><p>Elasticsearch的关键就是倒排索引，而倒排索引依赖于对文档内容的分词，而分词则需要高效、精准的分词算法，IK分词器就是这样的中文分词算法。</p><h3 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h3><p>运行命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it es ./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span><br></pre></td></tr></table></figure><p>重启es容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><h3 id="使用IK分词器"><a href="#使用IK分词器" class="headerlink" title="使用IK分词器"></a>使用IK分词器</h3><p>IK分词器包含两种模式：</p><ul><li><code>ik_smart</code>——智能语义切分：可以在词典库中识别词语，将句子分成一个个词语</li><li><code>ik_max_word</code>——最细粒度切分：除了将句子分成一个个词语之外，还分出一个个字，便于精确查找</li></ul><h3 id="拓展词典"><a href="#拓展词典" class="headerlink" title="拓展词典"></a>拓展词典</h3><p>互联网发展伴随着越来越多的新词语，而这些新词语在ik分词器的原始词典中并不存在，所以要想正确分词，词库也需要不断的更新，所以分词器提供了扩展词汇的功能。</p><p>1）打开IK分词器config目录</p><p>注意：如果ik插件下没有config目录，要么自己手动创建<code>config目录</code>和<code>IKAnalyzer.cfg.xml</code>文件，要么<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">需要下载复制到服务器中</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-v7.12.1.zip</span><br></pre></td></tr></table></figure><p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）在IK分词器的config目录新建一个 <code>ext.dic</code>，在其中写入想要扩展的词汇</p><p>4）重启elasticsearch</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart es</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure><h1 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h1><p>Index就类似数据库表，Mapping映射就类似表的结构。我们要向es中存储数据，必须先创建Index和Mapping</p><h2 id="Mapping映射属性"><a href="#Mapping映射属性" class="headerlink" title="Mapping映射属性"></a>Mapping映射属性</h2><p>Mapping是对索引库中文档的约束，常见的Mapping属性包括：</p><ul><li><code>type</code>：字段数据类型，常见的简单类型有： <ul><li>字符串：<code>text</code>（可分词的文本）、<code>keyword</code>（精确值，例如：品牌、国家、ip地址）</li><li>数值：<code>long</code>、<code>integer</code>、<code>short</code>、<code>byte</code>、<code>double</code>、<code>float</code>、</li><li>布尔：<code>boolean</code></li><li>日期：<code>date</code></li><li>对象：<code>object</code></li></ul></li><li><code>index</code>：是否创建索引，默认为<code>true</code></li><li><code>analyzer</code>：使用哪种分词器</li><li><code>properties</code>：该字段的子字段</li></ul><p>例如下面的json文档：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">52.1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isMarried&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;某某高校某某年级学生&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxx111@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">99.1</span><span class="punctuation">,</span> <span class="number">99.5</span><span class="punctuation">,</span> <span class="number">98.9</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;祈&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;楪&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对应的每个字段映射（Mapping）：</p><table><thead><tr><th align="left">字段名</th><th align="left">字段类型</th><th align="left">类型说明</th><th align="left">是否参与搜索</th><th align="left">是否参与分词</th><th align="left">分词器</th></tr></thead><tbody><tr><td align="left">age</td><td align="left"><code>integer</code></td><td align="left">整数</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">weight</td><td align="left"><code>float</code></td><td align="left">浮点数</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">isMarried</td><td align="left"><code>boolean</code></td><td align="left">布尔</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">info</td><td align="left"><code>text</code></td><td align="left">字符串，需要分词</td><td align="left">是</td><td align="left">是</td><td align="left">IK</td></tr><tr><td align="left">email</td><td align="left"><code>keyword</code></td><td align="left">字符串，但是不分词</td><td align="left">否</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">score</td><td align="left"><code>float</code></td><td align="left">只看数组中元素类型</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">firstName</td><td align="left"><code>keyword</code></td><td align="left">字符串，但是不分词</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">lastName</td><td align="left"><code>keyword</code></td><td align="left">字符串，但是不分词</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr></tbody></table><h2 id="索引库的CRUD"><a href="#索引库的CRUD" class="headerlink" title="索引库的CRUD"></a>索引库的CRUD</h2><p>由于Elasticsearch采用的是Restful风格的API，因此其请求方式和路径相对都比较规范，而且请求参数也都采用JSON风格。</p><h3 id="创建索引库和映射"><a href="#创建索引库和映射" class="headerlink" title="创建索引库和映射"></a>创建索引库和映射</h3><p><strong>基本语法</strong>：</p><ul><li>请求方式：<code>PUT</code></li><li>请求路径：<code>/索引库名</code>，可以自定义</li><li>请求参数：<code>mapping</code>映射</li></ul><p><strong>格式</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;子字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><p><strong>基本语法</strong>：</p><ul><li>请求方式：GET </li><li>请求路径：&#x2F;索引库名 </li><li>请求参数：无</li></ul><p><strong>格式</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p><p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。因此修改索引库能做的就是向索引库中添加新字段，或者更新索引库的基础属性。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><p><strong>语法：</strong></p><ul><li>请求方式：DELETE </li><li>请求路径：&#x2F;索引库名 </li><li>请求参数：无</li></ul><p><strong>格式：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure><h1 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h1><h2 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h2><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p>根据rest风格，新增是post，查询是get，需在后面加上文档id。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_doc/id</span><br></pre></td></tr></table></figure><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><p><strong>语法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DELETE</span> /索引库名/_doc/id</span><br></pre></td></tr></table></figure><h2 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h2><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>局部修改：修改文档中的部分字段</li></ul><h3 id="全量修改"><a href="#全量修改" class="headerlink" title="全量修改"></a>全量修改</h3><p>语法与新增文档相同，全量修改是覆盖原来的文档，其本质是两步操作：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="局部修改"><a href="#局部修改" class="headerlink" title="局部修改"></a>局部修改</h3><p>局部修改是只修改指定id匹配的文档中的部分字段。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;新的值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>批处理采用POST请求，基本语法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; <span class="string">&quot;index&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value1&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;delete&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;create&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value3&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;update&quot;</span> : &#123;<span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>, <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>&#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;doc&quot;</span> : &#123;<span class="string">&quot;field2&quot;</span> : <span class="string">&quot;value2&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>index</code>代表新增操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li><li><code>&#123; &quot;field1&quot; : &quot;value1&quot; &#125;</code>：则是要新增的文档内容</li></ul></li><li><code>delete</code>代表删除操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li></ul></li><li><code>update</code>代表更新操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li><li><code>&#123; &quot;doc&quot; : &#123;&quot;field2&quot; : &quot;value2&quot;&#125; &#125;</code>：要更新的文档字段</li></ul></li></ul><h1 id="RestAPI"><a href="#RestAPI" class="headerlink" title="RestAPI"></a>RestAPI</h1><p><a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">ES官方</a>提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES</p><h2 id="初始化RestClient"><a href="#初始化RestClient" class="headerlink" title="初始化RestClient"></a>初始化RestClient</h2><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为<code>RestHighLevelClient</code>的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接</p><p>1）引入<code>es</code>的<code>RestHighLevelClient</code>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）因为SpringBoot默认的ES版本是<code>7.17.10</code>，需要覆盖默认的ES版本：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）初始化RestHighLevelClient：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://ip地址:9200&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>这里为了单元测试方便，我们创建一个测试类<code>IndexTest</code>，然后将初始化的代码编写在<code>@BeforeEach</code>方法中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.145.128:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h2><p>由于要实现对商品搜索，所以需要将商品添加到Elasticsearch中，不过需要根据搜索业务的需求来设定索引库结构，而不是一股脑的把MySQL数据写入Elasticsearch</p><h3 id="Mapping映射"><a href="#Mapping映射" class="headerlink" title="Mapping映射"></a>Mapping映射</h3><p>实现搜索功能需要的字段包括三大部分：</p><ul><li>搜索过滤字段<ul><li>分类</li><li>品牌</li><li>价格</li></ul></li><li>排序字段<ul><li>默认：按照更新时间降序排序</li><li>销量</li><li>价格</li></ul></li><li>展示字段<ul><li>商品id：用于点击后跳转</li><li>图片地址</li><li>是否是广告推广商品</li><li>名称</li><li>价格</li><li>评价数量</li><li>销量</li></ul></li></ul><p>结合数据库表结构，以上字段对应的mapping映射属性如下：</p><table><thead><tr><th>字段名</th><th>字段类型</th><th>类型说明</th><th>是否参与搜索</th><th>是否参与分词</th><th>分词器</th></tr></thead><tbody><tr><td>id</td><td><code>long</code></td><td>长整数</td><td>是</td><td>否</td><td>——</td></tr><tr><td>name</td><td><code>text</code></td><td>字符串，参与分词搜索</td><td>是</td><td>是</td><td>IK</td></tr><tr><td>price</td><td><code>integer</code></td><td>以分为单位，所以是整数</td><td>是</td><td>否</td><td>——</td></tr><tr><td>stock</td><td><code>integer</code></td><td>字符串，但需要分词</td><td>是</td><td>否</td><td>——</td></tr><tr><td>image</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>否</td><td>否</td><td>——</td></tr><tr><td>category</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>是</td><td>否</td><td>——</td></tr><tr><td>brand</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>是</td><td>否</td><td>——</td></tr><tr><td>sold</td><td><code>integer</code></td><td>销量，整数</td><td>是</td><td>否</td><td>——</td></tr><tr><td>commentCount</td><td><code>integer</code></td><td>评价，整数</td><td>否</td><td>否</td><td>——</td></tr><tr><td>isAD</td><td><code>boolean</code></td><td>布尔类型</td><td>是</td><td>否</td><td>——</td></tr><tr><td>updateTime</td><td><code>Date</code></td><td>更新时间</td><td>是</td><td>否</td><td>——</td></tr></tbody></table><p>最终索引库文档结构应该是这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /items</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sold&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;commentCount&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isAD&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;boolean&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>分为三步：</p><p>1）创建Request对象。因为是创建索引库的操作，因此Request是<code>CreateIndexRequest</code></p><p>2）添加请求参数。Json格式的Mapping映射参数</p><p>3）发送请求。<code>client.indices()</code>方法的返回值是<code>IndicesClient</code>类型，封装了所有与索引库操作有关的方法。例如创建索引、删除索引、判断索引是否存在等</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPING_TEMPLATE</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;stock\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;image\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;category\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;sold\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;commentCount\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;isAD\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;boolean\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;updateTime\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;date\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h2><p>与创建索引库相比：</p><ul><li>请求方式从PUT变为DELTE</li><li>请求路径不变</li><li>无请求参数</li></ul><p>所以代码的差异，注意体现在Request对象上。流程如下：</p><p>1）创建Request对象。DeleteIndexRequest对象</p><p>2）准备参数。省略</p><p>3）发送请求。delete方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断索引库是否存在"><a href="#判断索引库是否存在" class="headerlink" title="判断索引库是否存在"></a>判断索引库是否存在</h2><p>判断索引库是否存在，本质就是查询，对应的请求语句是：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel</span><br></pre></td></tr></table></figure><p>因此与删除的Java代码流程是类似的，流程如下：</p><p>1）创建Request对象。GetIndexRequest对象</p><p>2）准备参数。省略</p><p>3）发送请求。exists方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistsIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    System.err.println(exists ? <span class="string">&quot;索引库已经存在！&quot;</span> : <span class="string">&quot;索引库不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaRestClient操作elasticsearch的流程基本类似。核心是<code>client.indices()</code>方法来获取索引库的操作对象。</p><p>索引库操作的基本步骤：</p><ul><li>初始化<code>RestHighLevelClient</code></li><li>创建XxxIndexRequest。XXX是<code>Create</code>、<code>Get</code>、<code>Delete</code></li><li>准备请求参数（<code>Create</code>时需要，其它是无参，可以省略）</li><li>发送请求。调用<code>RestHighLevelClient#indices().xxx()</code>方法，xxx是<code>create</code>、<code>exists</code>、<code>delete</code></li></ul><h1 id="RestClient操作文档"><a href="#RestClient操作文档" class="headerlink" title="RestClient操作文档"></a>RestClient操作文档</h1><h2 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h2><p>新增文档的请求语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>1）创建Request对象，这里是<code>IndexRequest</code>，因为添加文档就是创建倒排索引的过程</p><p>2）准备请求参数，本例中就是Json文档</p><p>3）发送请求</p><p>这里直接使用<code>client.xxx()</code>的API</p><p>整体步骤为：</p><ul><li>1）根据id查询商品数据<code>Item</code></li><li>2）将<code>Item</code>封装为<code>ItemDoc</code></li><li>3）将<code>ItemDoc</code>序列化为JSON</li><li>4）创建IndexRequest，指定索引库名和id</li><li>5）准备请求参数，也就是JSON文档</li><li>6）发送请求</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.根据id查询商品数据</span></span><br><span class="line">    <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getById(<span class="number">100002644680L</span>);</span><br><span class="line">    <span class="comment">// 2.转换为文档类型</span></span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class);</span><br><span class="line">    <span class="comment">// 3.将ItemDTO转json</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">doc</span> <span class="operator">=</span> JSONUtil.toJsonStr(itemDoc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(itemDoc.getId());</span><br><span class="line">    <span class="comment">// 2.准备Json文档</span></span><br><span class="line">    request.source(doc, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h2><p>查询的请求语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_doc/id</span><br></pre></td></tr></table></figure><ul><li>创建Request对象</li><li>发送请求</li></ul><p>流程如下：</p><p>1）准备Request对象。这次是查询，所以是<code>GetRequest</code></p><p>2）发送请求，得到结果。因为是查询，这里调用<code>client.get()</code>方法</p><p>3）解析结果，对JSON做反序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.获取响应结果中的source</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.getSourceAsString();</span><br><span class="line">    </span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> JSONUtil.toBean(json, ItemDoc.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;itemDoc= &quot;</span> + ItemDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h2><p>删除的请求语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /hotel/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与查询相比，仅仅是请求方式从<code>DELETE</code>变成<code>GET</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request，两个参数，第一个是索引库名，第二个是文档id</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;item&quot;</span>, <span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h2><p>有两种方式：</p><ul><li>全量修改：本质是先根据id删除，再新增</li><li>局部修改：修改文档中的指定字段值</li></ul><p>在RestClient的API中，全量修改与新增的API完全一致。</p><p>局部修改的请求语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_update/id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;字段值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;字段值&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>1）准备<code>Request</code>对象。这次是修改，所以是<code>UpdateRequest</code></p><p>2）准备参数。也就是JSON文档，里面包含要修改的字段</p><p>3）更新文档。这里调用<code>client.update()</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;items&quot;</span>, <span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">            <span class="string">&quot;price&quot;</span>, <span class="number">58800</span>,</span><br><span class="line">            <span class="string">&quot;commentCount&quot;</span>, <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批量导入文档"><a href="#批量导入文档" class="headerlink" title="批量导入文档"></a>批量导入文档</h2><p>如果要将大量数据导入索引库，肯定不能逐条导入，而是采用批处理方案。常见的方案有：</p><ul><li>利用Logstash批量导入<ul><li>需要安装Logstash</li><li>对数据的再加工能力较弱</li><li>无需编码</li></ul></li><li>利用JavaAPI批量导入<ul><li>需要编码，但基于JavaAPI，学习成本低</li><li>更加灵活，可以任意对数据做再加工处理后写入索引库</li></ul></li></ul><p>在这里使用JavaAPI导入。</p><h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><p>批处理与前面讲的文档的CRUD步骤基本一致：</p><ul><li>创建Request，这次用的是<code>BulkRequest</code></li><li>准备请求参数</li><li>发送请求，用到<code>client.bulk()</code>方法</li></ul><p><code>BulkRequest</code>本身其实并没有请求参数，其本质就是将多个普通的CRUD请求组合在一起发送。例如：</p><ul><li>批量新增文档，就是给每个文档创建一个<code>IndexRequest</code>请求，然后封装到<code>BulkRequest</code>中，一起发出。</li><li>批量删除，就是创建N个<code>DeleteRequest</code>请求，然后封装到<code>BulkRequest</code>，一起发出</li></ul><p>因此<code>BulkRequest</code>中提供了<code>add</code>方法，用以添加其它CRUD的请求：</p><p><img src="/inori/d672aa30/ElasticSearch%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8(%E4%B8%80)%5Ces_bulk.png" alt="es_bulk"></p><p>能添加的请求有：</p><ul><li><code>IndexRequest</code></li><li><code>UpdateRequest</code></li><li><code>DeleteRequest</code></li></ul><p>因此Bulk中添加了多个<code>IndexRequest</code>，就是批量新增功能了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulk</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;1&quot;</span>).source(<span class="string">&quot;json doc1&quot;</span>, XContentType.JSON));</span><br><span class="line">    request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;2&quot;</span>).source(<span class="string">&quot;json doc2&quot;</span>, XContentType.JSON));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>文档操作的基本步骤：</p><ul><li>初始化<code>RestHighLevelClient</code></li><li>创建XxxRequest。<ul><li>XXX是<code>Index</code>、<code>Get</code>、<code>Update</code>、<code>Delete</code>、<code>Bulk</code></li></ul></li><li>准备参数（<code>Index</code>、<code>Update</code>、<code>Bulk</code>时需要）</li><li>发送请求。<ul><li>调用<code>RestHighLevelClient#.xxx()</code>方法，xxx是<code>index</code>、<code>get</code>、<code>update</code>、<code>delete</code>、<code>bulk</code></li></ul></li><li>解析结果（<code>Get</code>时需要）</li></ul>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务入门(一)</title>
      <link href="/inori/37b2c0e7.html"/>
      <url>/inori/37b2c0e7.html</url>
      
        <content type="html"><![CDATA[<h1 id="微服务基础知识"><a href="#微服务基础知识" class="headerlink" title="微服务基础知识"></a>微服务基础知识</h1><h2 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h2><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>单体架构（monolithic structure）即整个项目中所有功能模块都在一个工程中开发。项目部署时需要对所有模块一起编译、打包。项目的架构设计、开发模式都相对简单。</p><p>当项目规模较小时，这种模式上手快，部署、运维也都很方便，因此早期很多小型项目都采用这种模式。</p><p>但随着项目的业务规模越来越大，团队开发人员也不断增加，单体架构就呈现出越来越多的问题：</p><ul><li><strong>团队协作成本高</strong>：团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊。</li><li><strong>系统发布效率低</strong>：任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时。</li><li><strong>系统可用性差</strong>：单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用。</li></ul><p>要想解决这些问题，就需要使用微服务架构。</p><h3 id="从单体架构到微服务"><a href="#从单体架构到微服务" class="headerlink" title="从单体架构到微服务"></a>从单体架构到微服务</h3><p>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。同时要满足下面的一些特点：</p><ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模较小</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li></ul><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud框架是目前Java领域最全面的微服务组件的集合。它依托于SpringBoot的自动装配能力，降低了其项目搭建、组件使用的成本。</p><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>不同的微服务虽然功能不同，但因为还是同一个项目，或多或少会出现互相调用的情况。但不同的微服务都是不同的项目，不能使用Spring的自动装配，这时就需要服务之间发送Http请求去获取数据。</p><h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><p>Spring提供了一个RestTemplate的API，可以方便的实现Http请求的发送。其中提供了大量的方法，方便发送Http请求</p><p><img src="/inori/37b2c0e7/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cresttemplate.png" alt="resttemplate"></p><p>常见的Get、Post、Put、Delete请求都支持，如果请求参数比较复杂，还可以使用exchange方法来构造请求。</p><h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>先将RestTemplate注册为一个Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用RestTemplate发送请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取商品id</span></span><br><span class="line">    Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">// 2.查询商品</span></span><br><span class="line">    <span class="comment">// 利用RestTemplate发起http请求，得到http的响应</span></span><br><span class="line">    ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">            <span class="string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>,<span class="comment">// 请求路径</span></span><br><span class="line">            HttpMethod.GET,<span class="comment">// 请求方式</span></span><br><span class="line">            <span class="literal">null</span>, <span class="comment">// 请求实体</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;,<span class="comment">// 返回值类型</span></span><br><span class="line">            Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))<span class="comment">// 请求参数</span></span><br><span class="line">    );</span><br><span class="line">    List&lt;ItemDTO&gt; items = response.getBody();<span class="comment">// 获取返回值</span></span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，利用RestTemplate发送http请求与前端ajax发送请求非常相似，都包含四部分信息：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>在这个过程中，<code>item-service</code>提供了查询接口，<code>cart-service</code>利用Http请求调用该接口。因此<code>item-service</code>可以称为服务的提供者，而<code>cart-service</code>则称为服务的消费者或服务调用者。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>服务拆分之后，不可避免的会出现跨微服务的业务，此时微服务之间就需要进行远程调用。微服务之间的远程调用被称为RPC，即远程过程调用。RPC的实现方式有很多，比如：</p><ul><li>基于Http协议</li><li>基于Dubbo协议</li></ul><p>这里使用的是Http方式，这种方式不关心服务提供者的具体技术实现，只要对外暴露Http接口即可。</p><p>Java发送http请求可以使用Spring提供的RestTemplate，使用的基本步骤如下：</p><ul><li>注册RestTemplate到Spring容器</li><li>调用RestTemplate的API发送请求，常见方法有：<ul><li>getForObject：发送Get请求并返回指定类型对象</li><li>PostForObject：发送Post请求并返回指定类型对象</li><li>put：发送PUT请求</li><li>delete：发送Delete请求</li><li>exchange：发送任意类型请求，返回ResponseEntity</li></ul></li></ul><h2 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h2><p>上面通过Http请求实现了跨微服务的远程调用，不过这种手动发送Http请求的方式存在一些问题。</p><p>试想一下，假如商品微服务被调用较多，为了应对更高的并发，进行了多实例部署，一个微服务对应多个ip地址或端口</p><p>此时，每个service的实例其IP或端口不同，问题来了：</p><ul><li>service这么多实例，其他服务如何知道每一个实例的地址？</li><li>http请求要写url地址，其他服务到底该调用哪个实例？</li><li>如果在运行过程中，该服务实例宕机，其他服务依然在调用该怎么办？</li><li>如果并发太高，该服务临时多部署了N台实例，其他服务如何知道新实例的地址？</li></ul><p>为了解决上述问题，就必须引入注册中心的概念。</p><p>为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。</p><h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><p>在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问</li><li>服务消费者：调用其它微服务提供的接口</li></ul><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><p><img src="/inori/37b2c0e7/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Clog_center.jpg" alt="log_center"></p><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h3 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h3><p>目前开源的注册中心框架有很多，比较常见的有：</p><ul><li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</li><li>Consul：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</li></ul><p>以上几种注册中心都遵循SpringCloud中的API规范，因此在业务开发使用上没有太大差异，这里学习<a href="https://nacos.io/">Nacos</a></p><h4 id="安装nacos"><a href="#安装nacos" class="headerlink" title="安装nacos"></a>安装nacos</h4><p>首先要准备MySQL数据库表，用来存储Nacos的数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导出 nacos 的数据库结构</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `nacos`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `nacos` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */</span> <span class="comment">/*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */</span>;</span><br><span class="line">USE `nacos`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_aggr 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_aggr`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_aggr 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_aggr`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_beta 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_beta`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_beta 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_beta`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_tag 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_tag`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_tag 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_tag`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_tags_relation 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_tags_relation`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_tags_relation 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_tags_relation`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.group_capacity 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `group_capacity`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.group_capacity 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `group_capacity`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.his_config_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `his_config_info`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.his_config_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `his_config_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.permissions 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `permissions`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `permissions` (</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.permissions 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `permissions`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.roles 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `roles`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `roles` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_user_role` (`username`,`role`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.roles 的数据：~1 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `roles`;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `roles` (`username`, `role`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.tenant_capacity 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tenant_capacity`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.tenant_capacity 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `tenant_capacity`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.tenant_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tenant_info`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.tenant_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `tenant_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.users 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `users`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `enabled` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.users 的数据：~1 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `users`;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `users` (`username`, `password`, `enabled`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>然后需要配置环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PREFER_HOST_MODE=hostname</span><br><span class="line">MODE=standalone</span><br><span class="line">SPRING_DATASOURCE_PLATFORM=mysql</span><br><span class="line">MYSQL_SERVICE_HOST=192.168.145.128# 改成自己的IP地址</span><br><span class="line">MYSQL_SERVICE_DB_NAME=nacos</span><br><span class="line">MYSQL_SERVICE_PORT=3306</span><br><span class="line">MYSQL_SERVICE_USER=root</span><br><span class="line">MYSQL_SERVICE_PASSWORD=123</span><br><span class="line">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><p>进入root目录，执行docker命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line"><span class="literal">--name</span> nacos \</span><br><span class="line"><span class="literal">--env-file</span> ./nacos/custom.env \</span><br><span class="line"><span class="literal">-p</span> <span class="number">8848</span>:<span class="number">8848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9848</span>:<span class="number">9848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9849</span>:<span class="number">9849</span> \</span><br><span class="line"><span class="literal">--restart</span>=always \</span><br><span class="line">nacos/nacos<span class="literal">-server</span>:v2.<span class="number">1.0</span><span class="literal">-slim</span></span><br></pre></td></tr></table></figure><p>启动完成后，访问下面地址：<code>http://ip地址/nacos/</code></p><p>首次访问会跳转到登录页，账号密码都是nacos</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>接下来，把service注册到Nacos</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在<code>pom.xml</code>中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置Nacos"><a href="#配置Nacos" class="headerlink" title="配置Nacos"></a>配置Nacos</h4><p>在<code>application.yml</code>中添加nacos地址配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><p>启动服务实例后访问nacos控制台，可以发现服务注册成功</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。</p><p>在<code>pom.xml</code>中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现，这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</p><h4 id="配置Nacos地址"><a href="#配置Nacos地址" class="headerlink" title="配置Nacos地址"></a>配置Nacos地址</h4><p>在<code>application.yml</code>中添加nacos地址配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><p>####发现并调用服务</p><p>接下来，服务调用者就可以去订阅已经在Nacos注册过的服务了。不过因为服务可能有多个实例，而真正发起调用时只需要知道一个实例的地址。</p><p>因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：</p><ul><li>随机</li><li>轮询</li><li>IPHash</li><li>最近最少访问</li><li>…</li></ul><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p>Eureka是Netflix公司开源的一个服务注册中心组件，早期版本的SpringCloud都是使用Eureka作为注册中心。由于Eureka和Nacos的starter中提供的功能都是基于SpringCloudCommon规范，因此两者使用起来差别不大。</p><h4 id="Eureka和Nacos对比"><a href="#Eureka和Nacos对比" class="headerlink" title="Eureka和Nacos对比"></a>Eureka和Nacos对比</h4><p>Eureka和Nacos都能起到注册中心的作用，用法基本类似。但还是有一些区别的，例如：</p><ul><li>Nacos支持配置管理，而Eureka则不支持</li></ul><p>服务注册发现上也有区别，在Eureka中，健康检测的原理如下：</p><ul><li>微服务启动时注册信息到Eureka，这点与Nacos一致</li><li>微服务每隔30秒向Eureka发送心跳请求，报告自己的健康状态。Nacos中默认是5秒一次</li><li>Eureka如果90秒未收到心跳，则认为服务疑似故障，可能被剔除。Nacos中则是15秒超时，30秒剔除</li><li>Eureka如果发现超过85%比例的服务都心跳异常，会认为是自己的网络异常，暂停剔除服务的功能</li><li>Eureka每隔60秒执行一次服务检测和清理任务；Nacos是每隔5秒执行一次</li></ul><p>综上，你会发现Eureka是尽量不剔除服务，这就导致当服务真的出现故障时，迟迟不会被剔除，给服务的调用者带来困扰</p><p>不仅如此，当Eureka发现服务宕机并从服务列表中剔除以后，并不会将服务列表的变更消息推送给所有微服务。而是等待微服务自己来拉取时发现服务列表的变化。而微服务每隔30秒才会去Eureka更新一次服务列表，进一步推迟了服务宕机时被发现的时间。</p><p>而Nacos中微服务除了自己定时去Nacos中拉取服务列表以外，Nacos还会在服务列表变更时主动推送最新的服务列表给所有的订阅者</p><p>综上，Eureka和Nacos的相似点有：</p><ul><li>都支持服务注册发现功能</li><li>都有基于心跳的健康监测功能</li><li>都支持集群，集群间数据同步默认是AP模式，即最全高可用性</li></ul><p>Eureka和Nacos的区别有：</p><ul><li>Eureka的心跳是30秒一次，Nacos则是5秒一次</li><li>Eureka如果90秒未收到心跳，则认为服务疑似故障，可能被剔除。Nacos中则是15秒超时，30秒剔除。</li><li>Eureka每隔60秒执行一次服务检测和清理任务；Nacos是每隔5秒执行一次。</li><li>Eureka只能等微服务自己每隔30秒更新一次服务列表；Nacos即有定时更新，也有在服务变更时的广播推送</li><li>Eureka仅有注册中心功能，而Nacos同时支持注册中心、配置管理</li><li>Eureka和Nacos都支持集群，而且默认都是AP模式</li></ul><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><p>上面利用Nacos实现了服务的治理，利用RestTemplate实现了服务的远程调用。但是远程调用的代码太复杂了。</p><p>而且这种调用方式，与原本的本地方法调用差异太大，编程时的体验也不统一，一会儿远程调用，一会儿本地调用。</p><p>因此，必须想办法改变远程调用的开发模式，让<strong>远程调用像本地方法调用一样简单</strong>。而这就要用到OpenFeign组件了。</p><p>其实远程调用的关键点就在于四个：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>所以，OpenFeign就利用SpringMVC的相关注解来声明上述4个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在服务调用者的<code>pom.xml</code>中引入<code>OpenFeign</code>的依赖和<code>loadBalancer</code>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="启用OpenFeign"><a href="#启用OpenFeign" class="headerlink" title="启用OpenFeign"></a>启用OpenFeign</h4><p>在启动类上添加注解，启动OpenFeign功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span><span class="comment">// 启动OpenFeign</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;...&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        SpringApplication.run(CartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写OpenFeign客户端"><a href="#编写OpenFeign客户端" class="headerlink" title="编写OpenFeign客户端"></a>编写OpenFeign客户端</h4><p>定义一个新的接口，编写Feign客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要声明接口，无需实现方法。接口中的几个关键信息：</p><ul><li><code>@FeignClient(&quot;&quot;)</code> ：声明服务名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping(&quot;&quot;)</code> ：声明请求路径</li><li><code>@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul><p>有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向<code>http://item-service/items</code>发送一个<code>GET</code>请求，携带ids为请求参数，并自动将返回值处理为<code>List&lt;ItemDTO&gt;</code>。</p><p>我们只需要直接调用这个方法，即可实现远程调用了。</p><h4 id="使用FeignClient"><a href="#使用FeignClient" class="headerlink" title="使用FeignClient"></a>使用FeignClient</h4><p>最后在服务调用者的调用<code>ItemClient</code>的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;CartMapper, Cart&gt; <span class="keyword">implements</span> <span class="title class_">ICartService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ItemClient itemClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取商品id</span></span><br><span class="line">        Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());</span><br><span class="line">        <span class="comment">// 2.查询商品: 使用feign远程调用</span></span><br><span class="line">        List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>feign完成了服务拉取、负载均衡、发送http请求的所有工作，不再需要RestTemplate了，还省去了RestTemplate的注册</p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</p><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，使用OKHttp</p><h4 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开启连接池"><a href="#开启连接池" class="headerlink" title="开启连接池"></a>开启连接池</h4><p>在<code>application.yml</code>中开启Feign的连接池功能：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure><p>重启服务，连接池就生效了。</p><h3 id="负载均衡原理"><a href="#负载均衡原理" class="headerlink" title="负载均衡原理"></a>负载均衡原理</h3><p>在SpringCloud的早期版本中，负载均衡都是有Netflix公司开源的Ribbon组件来实现的，甚至Ribbon被直接集成到了Eureka-client和Nacos-Discovery中。</p><p>但是自SpringCloud2020版本开始，已经弃用Ribbon，改用Spring自己开源的Spring Cloud LoadBalancer了，我们使用的OpenFeign的也已经与其整合。</p><p>Spring在整合OpenFeign的时候，实现了<code>org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient</code>类，其中定义了OpenFeign发起远程调用的核心流程。也就是四步：</p><ul><li>获取请求中的<code>serviceId</code></li><li>根据<code>serviceId</code>负载均衡，找出一个可用的服务实例</li><li>利用服务实例的<code>ip</code>和<code>port</code>信息重构url</li><li>向真正的url发起请求</li></ul><p>而具体的负载均衡则是不是由<code>OpenFeign</code>组件负责。而是分成了<strong>负载均衡的接口规范</strong>，以及<strong>负载均衡的具体实现</strong>两部分。</p><p>负载均衡的接口规范是定义在<code>Spring-Cloud-Common</code>模块中，包含下面的接口：</p><ul><li><code>LoadBalancerClient</code>：负载均衡客户端，职责是根据serviceId最终负载均衡，选出一个服务实例</li><li><code>ReactiveLoadBalancer</code>：负载均衡器，负责具体的负载均衡算法</li></ul><p>OpenFeign的负载均衡是基于<code>Spring-Cloud-Common</code>模块中的负载均衡规则接口，并没有写死具体实现。这就意味着以后还可以拓展其它各种负载均衡的实现。</p><p>不过目前<code>SpringCloud</code>中只有<code>Spring-Cloud-Loadbalancer</code>这一种实现。</p><p><code>Spring-Cloud-Loadbalancer</code>模块中，实现了<code>Spring-Cloud-Common</code>模块的相关接口，具体如下：</p><ul><li><code>BlockingLoadBalancerClient</code>：实现了<code>LoadBalancerClient</code>，会根据serviceId选出负载均衡器并调用其算法实现负载均衡。</li><li><code>RoundRobinLoadBalancer</code>：基于轮询算法实现了<code>ReactiveLoadBalancer</code></li><li><code>RandomLoadBalancer</code>：基于随机算法实现了<code>ReactiveLoadBalancer</code></li><li><code>NacosLoadBalancer</code>：基于集群优先+实例权重+随机的方式实现<code>ReactiveLoadBalancer</code></li></ul><p><img src="/inori/37b2c0e7/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5COpenFeign.png" alt="OpenFeign"></p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>单体架构时只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，这就存在一些问题：</p><ul><li>每个微服务都需要编写登录校验、用户信息获取的功能吗？</li><li>当微服务之间调用时，该如何传递用户信息？</li></ul><p>这些问题都可以通过<strong>网关</strong>技术解决。</p><h2 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h2><p>网关就是网络的关口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的路由和转发以及数据安全的校验。微服务网关起到同样的作用。前端请求不能直接访问微服务，而是要请求网关：</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFiODMyMWU3MTdmZjczN2Y1MmZjYzg1ZTE1ZDc4YTdfNHhLNkZzcWZoaEN0T0JFNEhSYWNuRmRxR3pLTUJRYXdfVG9rZW46WFdmaWJuMUpKb0loM0x4V21SdGNneHVsbm9lXzE3MTU0OTI0MTc6MTcxNTQ5NjAxN19WNA" alt="img"></p><p>在SpringCloud当中，提供了两种网关实现方案：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li></ul><p>这里学习SpringCloudGateway</p><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：</p><ul><li>创建网关微服务</li><li>引入SpringCloudGateway、NacosDiscovery依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><h4 id="引入依赖-3"><a href="#引入依赖-3" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>创建微服务后，在<code>pom.xml</code>文件中引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><p>在<code>application.yaml</code>文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br></pre></td></tr></table></figure><h3 id="路由过滤"><a href="#路由过滤" class="headerlink" title="路由过滤"></a>路由过滤</h3><p>路由规则的定义语法如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><p>其中routes对应的类型为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="meta">@Valid</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RouteDefinition&gt; routes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>是一个集合，也就是说可以定义很多路由规则。集合中的<code>RouteDefinition</code>就是具体的路由规则定义，其中常见的属性如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteDefinition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@NotEmpty</span> <span class="meta">@Valid</span> List&lt;PredicateDefinition&gt; predicates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Valid</span> List&lt;FilterDefinition&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@NotNull</span> URI uri;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>id</code>：路由的唯一标示</li><li><code>predicates</code>：路由断言，其实就是匹配条件</li><li><code>filters</code>：路由过滤条件，后面讲</li><li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li></ul><p>这里重点关注<code>predicates</code>，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">- Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method&#x3D;GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query&#x3D;name, Jack或者- Query&#x3D;name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td align="left">weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table><h2 id="网关登录校验"><a href="#网关登录校验" class="headerlink" title="网关登录校验"></a>网关登录校验</h2><p>单体架构时只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取。</p><h3 id="网关过滤器"><a href="#网关过滤器" class="headerlink" title="网关过滤器"></a>网关过滤器</h3><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理。</p><p><img src="/inori/37b2c0e7/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cgateway_filter.png" alt="gateway_filter"></p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理。</li><li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）。</li><li><code>Filter</code>被分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</li><li>最终把响应结果返回。</li></ol><p>最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。如果能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<code>NettyRoutingFilter</code>之前，这就符合需求了</p><p>网关过滤器链中的过滤器有两种：</p><ul><li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code>.</li><li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由，不可配置</li></ul><p><code>FilteringWebHandler</code>在处理请求时，会将<code>GlobalFilter</code>装饰为<code>GatewayFilter</code>，然后放到同一个过滤器链中，排序以后依次执行。</p><p><code>Gateway</code>中内置了很多的<code>GatewayFilter</code>，详情可以参考<a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories">官方文档</a></p><p><code>Gateway</code>内置的<code>GatewayFilter</code>过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个<code>Route</code>下，就作用于哪个<code>Route</code></p><p>例如，有一个过滤器叫做<code>AddRequestHeaderGatewayFilterFacotry</code>，即添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。只需要在application.yaml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://test-service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="string">-Path=/test/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">AddRequestHeader=key,</span> <span class="string">value</span> <span class="comment"># 逗号之前是请求头的key，逗号之后是value</span></span><br></pre></td></tr></table></figure><p>如果想要让过滤器作用于所有的路由，则可以这样配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># default-filters下的过滤器可以作用于所有路由</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=key,</span> <span class="string">value</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://test-service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="string">-Path=/test/**</span></span><br></pre></td></tr></table></figure><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p><code>GatewayFilter</code>和<code>GlobalFilter</code>都支持自定义，只不过<strong>编码</strong>方式、<strong>使用</strong>方式略有差别</p><h4 id="自定义GatewayFilter"><a href="#自定义GatewayFilter" class="headerlink" title="自定义GatewayFilter"></a>自定义GatewayFilter</h4><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求</span></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;过滤器执行&quot;</span>);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：该类的名称一定要以<code>GatewayFilterFactory</code>为后缀</p><p>然后在yaml配置中这样使用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny</span> <span class="comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></span><br></pre></td></tr></table></figure><p>另外，这种过滤器还可以支持动态配置参数，不过实现起来比较复杂：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="comment">// 父类泛型是内部类的Config类型</span></span><br><span class="line">                <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;PrintAnyGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span></span><br><span class="line">        <span class="comment">// - GatewayFilter：过滤器</span></span><br><span class="line">        <span class="comment">// - int order值：值越小，过滤器执行优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取config值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> config.getA();</span><br><span class="line">                <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> config.getB();</span><br><span class="line">                <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> config.getC();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">                System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">                System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义配置属性，成员变量名称很重要，下面会用到</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 返回当前配置类的类型，也就是内部的Config</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;Config&gt; <span class="title function_">getConfigClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Config.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在yaml文件中使用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny=1,2,3</span> <span class="comment"># 注意，这里多个参数以&quot;,&quot;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span></span><br></pre></td></tr></table></figure><p>上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。</p><p>还有一种用法，无需按照这个顺序，就是手动指定参数名：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PrintAny</span></span><br><span class="line">              <span class="attr">args:</span> <span class="comment"># 手动指定参数名，无需按照参数顺序</span></span><br><span class="line">                <span class="attr">a:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">b:</span> <span class="number">2</span></span><br><span class="line">                <span class="attr">c:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="自定义GlobalFilter"><a href="#自定义GlobalFilter" class="headerlink" title="自定义GlobalFilter"></a>自定义GlobalFilter</h4><p>自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，无法设置动态参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;未登录，无法访问&quot;</span>);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="comment">// return chain.filter(exchange);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤器执行顺序，值越小，优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="微服务获取用户"><a href="#微服务获取用户" class="headerlink" title="微服务获取用户"></a>微服务获取用户</h2><p>当网关将请求转发到微服务时，微服务又该如何获取用户身份呢？</p><p>由于网关发送请求到微服务依然采用的是<code>Http</code>请求，因此可以将用户信息以请求头的方式传递到微服务。然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先，我们修改登录校验拦截器的处理逻辑，保存用户信息到请求头中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> userId.toString();</span><br><span class="line"><span class="type">ServerWebExchange</span> <span class="variable">ex</span> <span class="operator">=</span> exchange.mutate().request(b -&gt; b.header(<span class="string">&quot;user-info&quot;</span>, userInfo)).build();</span><br></pre></td></tr></table></figure><h4 id="拦截器获取用户"><a href="#拦截器获取用户" class="headerlink" title="拦截器获取用户"></a>拦截器获取用户</h4><p>定义拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(userInfo)) &#123;</span><br><span class="line">            <span class="comment">// 不为空，保存到ThreadLocal</span></span><br><span class="line">                UserContext.setUser(Long.valueOf(userInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置登录拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInfoInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OpenFeign传递用户"><a href="#OpenFeign传递用户" class="headerlink" title="OpenFeign传递用户"></a>OpenFeign传递用户</h2><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p><p>但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，购物车服务无法知道当前用户是谁</p><p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong>。</p><p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？</p><p>这里要借助Feign中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called for every request. </span></span><br><span class="line"><span class="comment">   * Add data using methods on the supplied &#123;<span class="doctag">@link</span> RequestTemplate&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要实现这个接口，然后实现apply方法，利用<code>RequestTemplate</code>类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoRequestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取登录用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">            <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果为空则直接跳过</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不为空则放入请求头中，传递给下游微服务</span></span><br><span class="line">            template.header(<span class="string">&quot;user-info&quot;</span>, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>现在依然还有几个问题需要解决：</p><ul><li>网关路由在配置文件中写死了，如果变更必须重启微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要重启服务</li><li>每个微服务都有很多重复的配置，维护成本高</li></ul><p>这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src="/inori/37b2c0e7/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cgateway_set_control.jpg" alt="gateway_set_control"></p><p>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。</p><p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p><h3 id="共享配置"><a href="#共享配置" class="headerlink" title="共享配置"></a>共享配置</h3><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li>在Nacos中添加共享配置</li><li>微服务拉取配置</li></ul><h4 id="添加共享配置"><a href="#添加共享配置" class="headerlink" title="添加共享配置"></a>添加共享配置</h4><p>在nacos控制台分别添加这些配置。</p><p>首先是jdbc相关配置，在<code>配置管理</code>-&gt;<code>配置列表</code>中点击<code>+</code>新建一个配置：</p><p><img src="/inori/37b2c0e7/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cnacos_add_set_1.png" alt="nacos_add_set_1"></p><p>在弹出的表单中填写信息：</p><p><img src="/inori/37b2c0e7/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cnacos_add_set_2.png" alt="nacos_add_set_2"></p><p>jdbc的相关参数并没有写死，例如：</p><ul><li><code>数据库ip</code>：通过<code>$&#123;hm.db.host:192.168.145.128&#125;</code>配置了默认值为，同时允许通过<code>$&#123;hm.db.host&#125;</code>来覆盖默认值</li><li><code>数据库端口</code>：通过<code>$&#123;hm.db.port:3306&#125;</code>配置了默认值为<code>3306</code>，同时允许通过<code>$&#123;hm.db.port&#125;</code>来覆盖默认值</li><li><code>数据库database</code>：可以通过<code>$&#123;hm.db.database&#125;</code>来设定</li></ul><h4 id="拉取共享配置"><a href="#拉取共享配置" class="headerlink" title="拉取共享配置"></a>拉取共享配置</h4><p>接下来要在微服务拉取共享配置。将拉取到的共享配置与本地的<code>application.yaml</code>配置合并，完成项目上下文的初始化。</p><p>不过，需要注意的是，读取Nacos配置是SpringCloud上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取<code>application.yaml</code>。</p><p>也就是说引导阶段，<code>application.yaml</code>文件尚未读取，根本不知道nacos地址，该如何去加载nacos中的配置文件呢？</p><p>SpringCloud在初始化上下文的时候会先读取一个名为<code>bootstrap.yaml</code>(或者<code>bootstrap.properties</code>)的文件，如果我们将nacos地址配置到<code>bootstrap.yaml</code>中，那么在项目引导阶段就可以读取nacos中的配置了</p><p><img src="/inori/37b2c0e7/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8%5Cbootstrap.jpg" alt="bootstrap"></p><p>因此，微服务整合Nacos配置管理的步骤如下：</p><p>1）引入依赖：</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）新建bootstrap.yaml</p><p>在的resources目录新建一个bootstrap.yaml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure><p>3）修改application.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp连接池支持</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">swagger:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">购物车服务接口文档</span></span><br><span class="line">    <span class="attr">package:</span> <span class="string">com.hmall.cart.controller</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">hm-cart</span></span><br></pre></td></tr></table></figure><p>重启服务，使配置生效</p><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><p>目前的项目修改了配置需要重新打包、重启服务才能生效。能不能不用重启，直接生效呢？</p><p>这就要用到Nacos的配置热更新能力了，分为两步：</p><ul><li>在Nacos中添加配置</li><li>在微服务读取配置</li></ul><h4 id="添加配置到Nacos"><a href="#添加配置到Nacos" class="headerlink" title="添加配置到Nacos"></a>添加配置到Nacos</h4><p>首先在nacos中添加一个配置文件，注意文件的dataId格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[服务名]-[spring.active.profile].[后缀名]</span><br></pre></td></tr></table></figure><p>文件名称由三部分组成：</p><ul><li><strong><code>服务名</code></strong></li><li>**<code>spring.active.profile</code>**：就是spring boot中的<code>spring.active.profile</code>，可以省略，则所有profile共享该配置</li><li><strong><code>后缀名</code></strong></li></ul><h4 id="配置热更新-1"><a href="#配置热更新-1" class="headerlink" title="配置热更新"></a>配置热更新</h4><p>接着，我们在微服务中读取配置，实现配置热更新。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;test.cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer maxAmount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>网关的路由配置全部是在项目启动时由<code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code>在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更</p><p>因此，我们必须监听Nacos的配置变更，然后手动把最新的路由更新到路由表中。这里有两个难点：</p><ul><li>如何监听Nacos配置变更？</li><li>如何把路由信息更新到路由表？</li></ul><h3 id="监听Nacos配置变更"><a href="#监听Nacos配置变更" class="headerlink" title="监听Nacos配置变更"></a>监听Nacos配置变更</h3><p>在Nacos官网中给出了<a href="https://nacos.io/zh-cn/docs/sdk.html">手动监听Nacos配置变更的SDK</a></p><p>如果希望Nacos推送配置变更，可以使用Nacos动态监听配置接口来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(String dataId, String group, Listener listener)</span></span><br></pre></td></tr></table></figure><p>请求参数说明：</p><table><thead><tr><th align="left"><strong>参数名</strong></th><th align="left"><strong>参数类型</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">dataId</td><td align="left">string</td><td align="left">配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（”.”、”:”、”-“、”_”）。不超过 256 字节</td></tr><tr><td align="left">group</td><td align="left">string</td><td align="left">配置分组，一般是默认的DEFAULT_GROUP</td></tr><tr><td align="left">listener</td><td align="left">Listener</td><td align="left">监听器，配置变更进入监听器的回调函数</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;&#123;serverAddr&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;&#123;dataId&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;&#123;group&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// 1.创建ConfigService，连接Nacos</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;serverAddr&quot;</span>, serverAddr);</span><br><span class="line"><span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> NacosFactory.createConfigService(properties);</span><br><span class="line"><span class="comment">// 2.读取配置</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> configService.getConfig(dataId, group, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 3.添加配置监听器</span></span><br><span class="line">configService.addListener(dataId, group, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置变更的通知处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;recieve1:&quot;</span> + configInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里核心的步骤有2步：</p><ul><li>创建ConfigService，目的是连接到Nacos</li><li>添加配置监听器，编写配置变更的通知处理逻辑</li></ul><p>这里采用了<code>spring-cloud-starter-alibaba-nacos-config</code>自动装配，因此<code>ConfigService</code>已经在<code>com.alibaba.cloud.nacos.NacosConfigAutoConfiguration</code>中自动创建好了</p><p>因此只要拿到<code>NacosConfigManager</code>就等于拿到了<code>ConfigService</code>，第一步就实现了。</p><p>第二步，编写监听器。虽然官方提供的SDK是ConfigService中的addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的API是这个：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getConfigAndSignListener</span><span class="params">(</span></span><br><span class="line"><span class="params">    String dataId, // 配置文件id</span></span><br><span class="line"><span class="params">    String group, // 配置组，走默认</span></span><br><span class="line"><span class="params">    <span class="type">long</span> timeoutMs, // 读取配置的超时时间</span></span><br><span class="line"><span class="params">    Listener listener // 监听器</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> NacosException;</span><br></pre></td></tr></table></figure><p>既可以配置监听器，并且会根据dataId和group读取配置并返回。我们就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新。</p><h3 id="更新路由"><a href="#更新路由" class="headerlink" title="更新路由"></a>更新路由</h3><p>更新路由要用到<code>org.springframework.cloud.gateway.route.RouteDefinitionWriter</code>接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RouteDefinitionWriter</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">save</span><span class="params">(Mono&lt;RouteDefinition&gt; route)</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据路由id删除某个路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">delete</span><span class="params">(Mono&lt;String&gt; routeId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新的路由，也就是RouteDefinition，包含下列常见字段：</p><ul><li>id：路由id</li><li>predicates：路由匹配规则</li><li>filters：路由过滤器</li><li>uri：路由目的地</li></ul><p>将来我们保存到Nacos的配置也要符合这个对象结构，将来我们以JSON来保存，格式如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以上JSON配置就等同于：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><h3 id="实现动态路由"><a href="#实现动态路由" class="headerlink" title="实现动态路由"></a>实现动态路由</h3><p>在网关gateway引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加载bootstrap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在网关<code>gateway</code>的<code>resources</code>目录创建<code>bootstrap.yaml</code>文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure><p>接着，修改<code>gateway</code>的<code>resources</code>目录下的<code>application.yml</code>，把之前的路由移除，最终内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">location:</span>  <span class="comment"># 秘钥地址</span></span><br><span class="line">    <span class="attr">alias:</span>  <span class="comment"># 秘钥别名</span></span><br><span class="line">    <span class="attr">password:</span>  <span class="comment"># 秘钥文件密码</span></span><br><span class="line">    <span class="attr">tokenTTL:</span> <span class="string">30m</span> <span class="comment"># 登录有效期</span></span><br><span class="line">  <span class="attr">auth:</span></span><br><span class="line">    <span class="attr">excludePaths:</span> <span class="comment"># 无需登录校验的路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/search/**</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/users/login</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/items/**</span></span><br></pre></td></tr></table></figure><p>然后，在<code>gateway</code>中定义配置监听器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRouteLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteDefinitionWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NacosConfigManager nacosConfigManager;</span><br><span class="line">    <span class="comment">// 路由配置文件的id和分组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;gateway-routes.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">    <span class="comment">// 保存更新过的路由id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; routeIds = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRouteConfigListener</span><span class="params">()</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 1.注册监听器并首次拉取配置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configInfo</span> <span class="operator">=</span> nacosConfigManager.getConfigService()</span><br><span class="line">                .getConfigAndSignListener(dataId, group, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">                        updateConfigInfo(configInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 2.首次启动时，更新一次配置</span></span><br><span class="line">        updateConfigInfo(configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;监听到路由配置变更，&#123;&#125;&quot;</span>, configInfo);</span><br><span class="line">        <span class="comment">// 1.反序列化</span></span><br><span class="line">        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);</span><br><span class="line">        <span class="comment">// 2.更新前先清空旧路由</span></span><br><span class="line">        <span class="comment">// 2.1.清除旧路由</span></span><br><span class="line">        <span class="keyword">for</span> (String routeId : routeIds) &#123;</span><br><span class="line">            writer.delete(Mono.just(routeId)).subscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        routeIds.clear();</span><br><span class="line">        <span class="comment">// 2.2.判断是否有新的路由要更新</span></span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(routeDefinitions)) &#123;</span><br><span class="line">            <span class="comment">// 无新路由配置，直接结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.更新路由</span></span><br><span class="line">        routeDefinitions.forEach(routeDefinition -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3.1.更新路由</span></span><br><span class="line">            writer.save(Mono.just(routeDefinition)).subscribe();</span><br><span class="line">            <span class="comment">// 3.2.记录路由id，方便将来删除</span></span><br><span class="line">            routeIds.add(routeDefinition.getId());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在Nacos控制台添加路由，即可实现动态配置路由。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ基础入门</title>
      <link href="/inori/1567c610.html"/>
      <url>/inori/1567c610.html</url>
      
        <content type="html"><![CDATA[<p>在微服务中，必然会涉及到服务之间的调用，基于OpenFeign的调用需要调用者发起请求后等待服务提供者执行业务返回结果后，才能执行后续的操作，即调用者在调用过程中处于阻塞状态，这种调用方式为<strong>同步调用</strong>。但在很多场景下，我们可能需要采用<strong>异步调用</strong>的方式，将与业务关系不大的微服务与主干业务剥离开，以提升整体效率。目前常见的实现方案就是基于MQ实现。</p><h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p>MQ即消息队列(MessageQueue)，目前比较常见的MQ有：</p><ul><li><p>ActiveMQ</p></li><li><p>RabbitMQ</p></li><li><p>RocketMQ</p></li><li><p>Kafka</p></li></ul><table><thead><tr><th></th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><p>综合考虑，<a href="https://www.rabbitmq.com/">RabbitMQ</a>更加均衡，这里对RabbitMQ进行学习。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用docker命令进行安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -e RABBITMQ_DEFAULT_USER=inori -e RABBITMQ_DEFAULT_PASS=123456 -v mq-plugins:/plugins --name mq --hostname mq -p 15672:15672 -p 5672:5672 --network test-net -d rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问<u>服务器地址:15672</u>即可看到管理控制台。在控制台中，可以进行创建和查看交换机、队列中的已有信息，发送消息等步骤，不过开发业务时，一般不会在控制台收发消息，而是基于编程的方式。</p><h3 id="RabbitMQ架构"><a href="#RabbitMQ架构" class="headerlink" title="RabbitMQ架构"></a>RabbitMQ架构</h3><p><img src="/inori/1567c610/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%5Crabbitmq_frame.png" alt="rabbitmq_frame"></p><ul><li>**<code>publisher</code>**：生产者，发送消息的一方</li><li>**<code>consumer</code>**：消费者，获取消息的一方</li><li>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列，没有存储功能</li><li>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue，不同的虚拟主机内的交换机和队列可以重名</li></ul><h2 id="WorkQueues模型"><a href="#WorkQueues模型" class="headerlink" title="WorkQueues模型"></a>WorkQueues模型</h2><p>WorkQueues模型就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong></p><p>适用场景：当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用此模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>WorkQueue默认的处理方式是消息平均分配给每个消费者，并没有考虑到消费者的处理能力，即没有充分利用每一个消费者的能力，这样显然是有问题的。</p><h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><p>在spring中进行配置，可以解决这个问题。添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>添加这个配置后，处理速度较快的消费者就可以处理更多的数据。</p><h2 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h2><p>在之前的测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：</p><p><img src="/inori/1567c610/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%5Cadd_exchange.png" alt="add_exchange"></p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p>交换机只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失</p><p>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><h3 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h3><p>可以理解为广播交换机。即当该交换机收到消息后，会转发给所有绑定到该交换机上的队列</p><p>1）可以有多个队列</p><p>2）每个队列都要绑定到Exchange</p><p>3）生产者发送的消息，只能发送到交换机</p><p>4）交换机把消息发送给绑定过的所有队列</p><p>5）订阅队列的消费者都能拿到消息</p><h3 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h3><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="/inori/1567c610/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%5Cdirect_exchange.png" alt="direct_exchange"></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code></li><li>消息的发送方在向Exchange发送消息时，也必须指定消息的<code>RoutingKey</code></li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的<code>Routing key</code>相同才会接收到消息</li></ul><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);<span class="comment">// 需要在参数中指定RoutingKey</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h3><p><code>Topic</code>类型与<code>Direct</code>类似，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。</p><p>只不过<code>Topic</code>类型可以让队列在绑定<code>BindingKey</code> 的时候使用通配符</p><p><code>BindingKey</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如：item.insert</p><p>通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.cpu.insert</code> 或者 <code>item.cpu</code></li><li><code>item.*</code>：只能匹配<code>item.cpu</code></li></ul><h2 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span> <span class="comment"># 虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/test</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><h3 id="简单消息的发送和接收"><a href="#简单消息的发送和接收" class="headerlink" title="简单消息的发送和接收"></a>简单消息的发送和接收</h3><p>消息发送：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用RabbitListener来声明要监听的队列信息，一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringAMQP声明队列和交换机"><a href="#SpringAMQP声明队列和交换机" class="headerlink" title="SpringAMQP声明队列和交换机"></a>SpringAMQP声明队列和交换机</h3><h4 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h4><p>SpringAMQP提供了一个Queue类，用来创建队列,还提供了一个Exchange接口，来表示所有不同类型的交换机，我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：</p><p><img src="/inori/1567c610/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%5CAMQPApi1.png" alt="AMQPApi1"></p><p>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：</p><p><img src="/inori/1567c610/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%5CAMQPApi2.png" alt="AMQPApi2"></p><h4 id="基于Bean声明Fanout示例"><a href="#基于Bean声明Fanout示例" class="headerlink" title="基于Bean声明Fanout示例"></a>基于Bean声明Fanout示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;test.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于注解声明"><a href="#基于注解声明" class="headerlink" title="基于注解声明"></a>基于注解声明</h4><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>例如声明Direct模式的交换机和队列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;test.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;test.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>Spring的消息发送代码接收的消息体是一个Object，而在数据传输时，它会把发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。而JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><h4 id="配置JSON转换器"><a href="#配置JSON转换器" class="headerlink" title="配置JSON转换器"></a>配置JSON转换器</h4><p>如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。如果没有则需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置消息转换器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转换器中添加的messageId可以便于将来做幂等性判断</p><h4 id="消费者接收Object"><a href="#消费者接收Object" class="headerlink" title="消费者接收Object"></a>消费者接收Object</h4><p>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Map&lt;String, Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到object.queue消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MQ消息的可靠性"><a href="#MQ消息的可靠性" class="headerlink" title="MQ消息的可靠性"></a>MQ消息的可靠性</h1><p>在大多数异步调用业务场景下，必须确保MQ消息的可靠性，即：消息应该至少被消费者处理1次</p><ul><li>我们该如何确保MQ消息的可靠性？</li><li>如果真的发送失败，有没有其它方案？</li></ul><h2 id="可靠性分析"><a href="#可靠性分析" class="headerlink" title="可靠性分析"></a>可靠性分析</h2><p>消息从发送者发送消息，到消费者处理消息，需要经过发送者发送消息到交换机，交换机转发消息到队列，队列发送到消费者，消费者消费数据。</p><p>其中每一步都可能导致消息丢失：</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：</p><ul><li>确保生产者一定把消息发送到MQ</li><li>确保MQ不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><h2 id="生产者的可靠性"><a href="#生产者的可靠性" class="headerlink" title="生产者的可靠性"></a>生产者的可靠性</h2><h3 id="生产者重试机制"><a href="#生产者重试机制" class="headerlink" title="生产者重试机制"></a>生产者重试机制</h3><p>SpringAMQP提供的消息发送时的重试机制。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。</p><p>修改<code>publisher</code>模块的<code>application.yaml</code>文件，添加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。</p><p>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h3 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h3><p>一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况。</p><p>不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：</p><ul><li>MQ内部处理消息的进程发生了异常</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code>，因此无法路由</li></ul><p>针对上述情况，RabbitMQ提供了生产者消息确认机制，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的<strong>回执</strong>。</p><p><img src="/inori/1567c610/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%5Cmq_publisher_return.png" alt="mq_publisher_return"></p><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回Ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>其中<code>ack</code>和<code>nack</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于<strong>Publisher Return</strong>机制。</p><p>默认两种机制都是关闭状态，需要通过配置文件来开启。</p><h4 id="实现生产者确认"><a href="#实现生产者确认" class="headerlink" title="实现生产者确认"></a>实现生产者确认</h4><p>在publisher模块的<code>application.yaml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><p>一般我们推荐使用<code>correlated</code>，回调机制。</p><h4 id="定义ReturnCallback"><a href="#定义ReturnCallback" class="headerlink" title="定义ReturnCallback"></a>定义ReturnCallback</h4><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在publisher模块定义一个配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h4><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数：CorrelationData</p><p>这里的CorrelationData中包含两个核心的东西：</p><ul><li><code>id</code>：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的Future对象</li></ul><p>将来MQ的回执就会通过这个<code>Future</code>来返回，可以提前给<code>CorrelationData</code>中的<code>Future</code>添加回调函数来处理消息回执</p><p>新建一个测试，向系统自带的交换机发送消息，并且添加<code>ConfirmCallback</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">&quot;send message fail&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123; <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>开启生产者确认比较消耗MQ性能，一般不建议开启。而且大家思考一下触发确认的几种情况：</p><ul><li>路由失败：一般是因为RoutingKey错误导致，往往是编程导致</li><li>交换机名称错误：同样是编程错误导致</li><li>MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了。</li></ul><h2 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h2><p>消息到达MQ以后，如果MQ不能及时保存，也会导致消息丢失，所以MQ的可靠性也非常重要。</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化：在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数：设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</li><li>队列持久化：在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数</li><li>消息持久化：在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code></li></ul><p><strong>说明</strong>：在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。</p><p>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。</p><h3 id="LazyQueue"><a href="#LazyQueue" class="headerlink" title="LazyQueue"></a>LazyQueue</h3><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为称为<code>PageOut</code>。</p><p><code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从RabbitMQ的3.6版本开始，就增加了LazyQueues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。</p><h4 id="代码配置Lazy模式"><a href="#代码配置Lazy模式" class="headerlink" title="代码配置Lazy模式"></a>代码配置Lazy模式</h4><p>在利用SpringAMQP声明队列的时候，添加<code>x-queue-mod=lazy</code>参数可以设置队列为Lazy模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以基于注解来声明队列并设置为Lazy模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新已有队列为lazy模式"><a href="#更新已有队列为lazy模式" class="headerlink" title="更新已有队列为lazy模式"></a>更新已有队列为lazy模式</h4><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。</p><p>可以基于命令行设置policy：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues  </span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置：</p><p><img src="/inori/1567c610/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%5Clazyqueue_set_in_window.png" alt="lazyqueue_set_in_window"></p><h2 id="消费者的可靠性"><a href="#消费者的可靠性" class="headerlink" title="消费者的可靠性"></a>消费者的可靠性</h2><p>当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li></ul><p>一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。</p><h3 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h3><p>为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）即：当消费者处理消息结束后，向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>一般reject方式用的较少，除非是消息格式有问题。因此大多数情况下我们需要将消息处理的代码通过<code>try catch</code>机制捕获，消息处理成功时返回ack，处理失败时返回nack.</p><p>由于消息回执的处理代码比较统一，SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li>**<code>none</code>**：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。不建议使用</li><li>**<code>manual</code>**：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵（在当前业务中插入与当前业务无关的其他逻辑），但更灵活</li><li>**<code>auto</code>**：自动模式。SpringAMQP利用AOP对消息处理逻辑做了环绕增强，当业务正常执行时则自动返回<code>ack</code>.当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是<strong>业务异常</strong>，会自动返回<code>nack</code></li><li>如果是<strong>消息处理或校验异常</strong>，自动返回<code>reject</code></li></ul></li></ul><p>通过下面的配置可以修改SpringAMQP的ACK处理方式：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动模式</span></span><br></pre></td></tr></table></figure><h3 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h3><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。</p><p>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力，为了应对该情况，Spring提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列</p><p>修改consumer服务的application.yml文件，添加内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态，false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><ul><li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是<code>reject</code></li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃</li></ul><h3 id="失败处理策略"><a href="#失败处理策略" class="headerlink" title="失败处理策略"></a>失败处理策略</h3><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适</p><p>因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。默认就是这种方式 </li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较推荐的是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续集中处理</p><p>1）定义处理失败消息的交换机和队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）定义RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h3><p><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。</p><p>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。</p><p>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><h4 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h4><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。</p><p>以Jackson的消息转换器为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h4><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样，大体思路为在获取到MQ的消息后，先判断当前数据库中的数据的某些状态是否与要修改之前的数据的状态保持一致，若一致则修改。</p><p>相比较而言，消息ID的方案需要改造原有的数据库，所以更推荐使用业务判断的方案。</p><h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><p>在某些业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p><p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易</p><p>通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。</p><p>像这种在一段时间以后才执行的任务称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案是利用MQ的延迟消息。</p><p>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><h3 id="死信交换机和延迟消息"><a href="#死信交换机和延迟消息" class="headerlink" title="死信交换机和延迟消息"></a>死信交换机和延迟消息</h3><h4 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h4><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或<code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过**<code>dead-letter-exchange</code><strong>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为</strong>死信交换机**（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试的<code>RepublishMessageRecoverer</code>作用类似。</p><p>而最后一种场景，可以作为延迟消息的实现方式</p><h3 id="延迟消息-1"><a href="#延迟消息-1" class="headerlink" title="延迟消息"></a>延迟消息</h3><p>假设有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是<code>ttl.queue</code>没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>，而队列<code>direct.queue1</code>则与死信交换机绑定，RoutingKey是blue</p><p><img src="/inori/1567c610/RabbitMQ%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%5Cmq_delayMessage.png" alt="mq_delayMessage"></p><ol><li>假如我们现在发送一条消息到<code>ttl.fanout</code>，RoutingKey为blue，并设置消息的有效期。尽管这里的<code>ttl.fanout</code>不需要RoutingKey，但是当消息变为死信并投递到死信交换机时，会沿用之前的RoutingKey，这样<code>hmall.direct</code>才能正确路由消息，消息肯定会被投递到<code>ttl.queue</code>之后，由于没有消费者，消息无人消费</li><li>5秒之后，消息的有效期到期，成为死信</li><li>死信被再次投递到死信交换机<code>hmall.direct</code>，并沿用之前的RoutingKey，也就是<code>blue</code></li><li>由于<code>direct.queue1</code>与<code>hmall.direct</code>绑定的key是blue，因此最终消息被成功路由到<code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code>绑定， 也就能成功消费消息了。但此时已经是5秒钟以后了</li></ol><p>也就是说，publisher发送了一条消息，但最终consumer在5秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><p><strong>注意：</strong></p><p>RabbitMQ的消息过期是基于追溯方式来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。</p><p>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此设置的TTL时间不一定准确。</p><h3 id="DelayExchange插件"><a href="#DelayExchange插件" class="headerlink" title="DelayExchange插件"></a>DelayExchange插件</h3><p>基于死信队列虽然可以实现延迟消息，但是太麻烦。因此RabbitMQ社区提供了一个<a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">延迟消息插件</a>来实现相同的效果。</p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">插件下载</a>后，因为mq是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p>插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，我们上传插件到该目录下。</p><p>接下来执行命令，安装插件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><h4 id="声明延迟交换机"><a href="#声明延迟交换机" class="headerlink" title="声明延迟交换机"></a>声明延迟交换机</h4><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于<code>@Bean</code>的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送延迟消息"><a href="#发送延迟消息" class="headerlink" title="发送延迟消息"></a>发送延迟消息</h4><p>必须通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。</p><p>因此不建议设置延迟时间过长的延迟消息</p>]]></content>
      
      
      <categories>
          
          <category> rabbitMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（五）</title>
      <link href="/inori/4a863c41.html"/>
      <url>/inori/4a863c41.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java新特性介绍（9-17）"><a href="#Java新特性介绍（9-17）" class="headerlink" title="Java新特性介绍（9~17）"></a>Java新特性介绍（9~17）</h1><h2 id="Java-9新特性"><a href="#Java-9新特性" class="headerlink" title="Java 9新特性"></a>Java 9新特性</h2><p>Java9的主要特性有JShell、接口的private方法等。</p><h3 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h3><p>Java 9为提供一种交互式编程工具JShell，类似于Python的Shell，安装java并完成环境配置后，只需要输入<code>jshell</code>命令即可开启交互式编程</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\71947&gt;jshell</span><br><span class="line">|  欢迎使用 JShell -- 版本 17.0.9</span><br><span class="line">|  要大致了解该版本, 请键入: /help intro</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int a = 10</span></span><br><span class="line">a ==&gt; 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int b = 15</span></span><br><span class="line">b ==&gt; 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int c = a + b</span></span><br><span class="line">c ==&gt; 25</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">public int max(int a, int b)&#123;</span></span><br><span class="line">   ...&gt;     return a &gt;= b ? a : b;</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  已创建 方法 max(int,int)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int d = max(a, b)</span></span><br><span class="line">d ==&gt; 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">/vars</span></span><br><span class="line">|    int a = 10</span><br><span class="line">|    int b = 15</span><br><span class="line">|    int c = 25</span><br><span class="line">|    int d = 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">/exit</span></span><br><span class="line">|  再见</span><br></pre></td></tr></table></figure><p>更多口令可以通过输入<code>/help</code>了解</p><h3 id="在接口内定义private方法"><a href="#在接口内定义private方法" class="headerlink" title="在接口内定义private方法"></a>在接口内定义private方法</h3><p>在Jdk8中，接口中方法支持添加<code>default</code>关键字来默认实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java9中，接口中可以存在私有方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;默认实现&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.inner();   <span class="comment">//接口中方法的默认实现可以直接调用接口中的私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span>&#123;   <span class="comment">//声明一个私有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;私有方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有方法和默认方法一样，要提供方法体，并且此方法只能被接口中的其他私有方法或是默认实现调用</p><h3 id="集合类新增工厂方法"><a href="#集合类新增工厂方法" class="headerlink" title="集合类新增工厂方法"></a>集合类新增工厂方法</h3><p>如果我们想要快速创建一个Map：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;AAA&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&quot;BBB&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java 9之后，可以通过<code>of</code>方法快速创建：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;AAA&quot;</span>, <span class="number">1</span>, <span class="string">&quot;BBB&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>通过这种方式创建的Map和通过Arrays创建的List类似，无法进行修改。</u></p><p>除了Map之外，其他的集合类都有相应的<code>of</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = Set.of(<span class="string">&quot;A&quot;</span>， <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进的Stream"><a href="#改进的Stream" class="headerlink" title="改进的Stream"></a>改进的Stream</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)   <span class="comment">//将一些元素封装到Stream中</span></span><br><span class="line">        .filter(s -&gt; s.equals(<span class="string">&quot;B&quot;</span>))   <span class="comment">//通过过滤器过滤</span></span><br><span class="line">        .distinct()   <span class="comment">//去重</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stream在Java9得到了进一步的增强：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.of(<span class="literal">null</span>)   <span class="comment">//如果传入null会报错</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Stream.ofNullable(<span class="literal">null</span>) <span class="comment">//使用新增的ofNullable方法，不会报错</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过迭代快速生成一组数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, i -&gt; i &lt; <span class="number">20</span>, i -&gt; i + <span class="number">1</span>)  <span class="comment">//快速生成一组0~19的int数据，中间可以添加一个断言，表示什么时候结束生成</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stream还新增了对数据的截断操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .takeWhile(i -&gt; i &lt; <span class="number">10</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dropWhile和takeWhile相反，满足条件的才会通过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .dropWhile(i -&gt; i &lt; <span class="number">10</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-10新特性"><a href="#Java-10新特性" class="headerlink" title="Java 10新特性"></a>Java 10新特性</h2><p>Java 10的改变不是很多，比较突出的是局部变量类型推断</p><h3 id="局部变量类型推断var"><a href="#局部变量类型推断var" class="headerlink" title="局部变量类型推断var"></a>局部变量类型推断var</h3><p>在Java10中，可以使用自动类型推断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// String a = &quot;Hello World!&quot;;   //之前定义变量必须指定类型</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;   <span class="comment">//现在使用var关键字来自动进行类型推断，因为完全可以从后面的值来判断是什么类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>var</code>关键字必须位于有初始值设定的变量上,且仅适用于局部变量，没办法在其他地方使用</p><h2 id="Java-11新特性"><a href="#Java-11新特性" class="headerlink" title="Java 11新特性"></a>Java 11新特性</h2><p>Java 11中比较关键的是用于Lambda的形参局部变量语法。</p><h3 id="用于Lambda的形参局部变量语法"><a href="#用于Lambda的形参局部变量语法" class="headerlink" title="用于Lambda的形参局部变量语法"></a>用于Lambda的形参局部变量语法</h3><p>在Java 11中支持了在Lambda中使用<code>var</code>关键字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; consumer = (<span class="keyword">var</span> str) -&gt; &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对于String类的方法增强"><a href="#针对于String类的方法增强" class="headerlink" title="针对于String类的方法增强"></a>针对于String类的方法增强</h3><p>在Java 11为String新增一些更加方便的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;A\nB\nD&quot;</span>;</span><br><span class="line">    System.out.println(str.isBlank());    <span class="comment">//isBlank方法用于判断是否字符串为空或者是仅包含空格</span></span><br><span class="line">    str.lines()   <span class="comment">//根据字符串中的\n换行符进行切割，分为多个字符串，并转换为Stream进行操作</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以快速地进行空格去除操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot; A B C D &quot;</span>;</span><br><span class="line">    System.out.println(str.strip());   <span class="comment">//去除首尾空格</span></span><br><span class="line">    System.out.println(str.stripLeading());  <span class="comment">//去除首部空格</span></span><br><span class="line">    System.out.println(str.stripTrailing());   <span class="comment">//去除尾部空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-12-16-新特性"><a href="#Java-12-16-新特性" class="headerlink" title="Java 12~16 新特性"></a>Java 12~16 新特性</h2><p>Java12-16并非长期支持版本，很多特性都是实验性的功能。</p><h3 id="改进的switch语法"><a href="#改进的switch语法" class="headerlink" title="改进的switch语法"></a>改进的switch语法</h3><p>Java 12中引入改进的switch语法，之前的switch写法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">grade</span><span class="params">(<span class="type">int</span> score)</span>&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            res =  <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            res = <span class="string">&quot;良好&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            res = <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            res = <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用新特性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">grade</span><span class="params">(<span class="type">int</span> score)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (score) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>, <span class="number">9</span> -&gt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>, <span class="number">7</span> -&gt; <span class="string">&quot;良好&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种全新的switch语法称为<code>switch表达式</code>，具体语法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> ...</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>case后添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -&gt; 来返回如果匹配此case语句的结果</li><li>根据不同的分支，可以存在多个case</li></ul><p>那么如果我们并不是能够马上返回，而是需要做点什么其他的工作才能返回结果呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;   <span class="comment">//使用花括号来将整套逻辑括起来</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">yield</span>  <span class="string">&quot;不及格&quot;</span>;  <span class="comment">//注意处理完成后使用yield关键字返回最终结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>Java 13引入文本块，通过三引号将字符串括起来，在其中不需要使用转义字符</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                weriodfghhj</span></span><br><span class="line"><span class="string">                fgghjkkkkwjdjwid</span></span><br><span class="line"><span class="string">                &lt;h1&gt;</span></span><br><span class="line"><span class="string">                &lt;div class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">             &quot;&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新instanceof语法"><a href="#新instanceof语法" class="headerlink" title="新instanceof语法"></a>新instanceof语法</h3><p>我们之前要重写一个类的equals方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但instanceof加强之后，可以直接将student替换为模式变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student student) &#123;</span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-17新特性"><a href="#Java-17新特性" class="headerlink" title="Java 17新特性"></a>Java 17新特性</h2><h3 id="密封类型"><a href="#密封类型" class="headerlink" title="密封类型"></a>密封类型</h3><p>在Java中，可以通过继承（extends关键字）来实现类的能力复用、扩展与增强。但有的时候，可能并不是所有的类我们都希望能够被继承。所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是<strong>限制类的继承</strong>。</p><p>实际上在之前我们如果不希望别人继承我们的类，可以直接添加<code>final</code>关键字：<code>public final class A&#123;&#125;</code></p><p>这样有一个缺点，如果添加了<code>final</code>关键字，那么无论是谁，包括我们自己也是没办法实现继承的，但是现在我们有一个需求，只允许我们自己写的类继承A，但是不允许别人写的类继承A，就可以使用密封类型来实现这个功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">permits</span> B&#123;&#125;   <span class="comment">//在class关键字前添加sealed关键字，表示此类为密封类型，permits后面跟上允许继承的类型，多个子类使用逗号隔开</span></span><br></pre></td></tr></table></figure><p>密封类型有以下要求：</p><ul><li>可以基于普通类、抽象类、接口，也可以是继承自其他接抽象类的子类或是实现其他接口的类等。</li><li>必须有子类继承，且不能是匿名内部类或是lambda的形式。</li><li><code>sealed</code>写在原来<code>final</code>的位置，但是不能和<code>final</code>、<code>non-sealed</code>关键字同时出现，只能选择其一。</li><li>继承的子类必须显式标记为<code>final</code>、<code>sealed</code>或是<code>non-sealed</code>类型。</li></ul><p>标准的声明格式为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> [<span class="keyword">abstract</span>] [class/interface] 类名 [extends 父类] [implements 接口, ...] <span class="keyword">permits</span> [子类, ...]&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类格式为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> [<span class="keyword">final</span>/<span class="keyword">sealed</span>/<span class="keyword">non-sealed</span>] class 子类 extends 父类 &#123;   <span class="comment">//必须继承自父类</span></span><br><span class="line"><span class="comment">//final类型：任何类不能再继承当前类</span></span><br><span class="line">  <span class="comment">//sealed类型：同父类，需要指定由哪些类继承</span></span><br><span class="line">  <span class="comment">//non-sealed类型：解封，重新开放为普通类，任何类都可以继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过反射来获取类是否为密封类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;A&gt; a = A.class;</span><br><span class="line">    System.out.println(a.isSealed());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（四）</title>
      <link href="/inori/2518f906.html"/>
      <url>/inori/2518f906.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><p>Java8中经常使用的有Lambda表达式、Stream流、日期与时间API</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ol><li>无参数和返回值的Lambda</li></ol><p>需要启动一个线程去完成某些任务时，通常会通过Runnable接口来定义任务内容，使用Thread类启动线程。</p><p>传统写法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() (</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(<span class="string">&quot;新线程任务执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda是一个<strong>匿名函数</strong>，可以理解为一段可以传递的代码。使用Java8的写法，上述写法可以重写为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;新线程任务执行&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lambda表达式可以简化匿名内部类的使用，使语法更加简洁。</p><ol start="2"><li>有参数和返回值的Lambda</li></ol><p>当需要对一个对象集合进行排序时，传统写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Person&gt; persons;<span class="comment">// 假设里面已经有很多数据</span></span><br><span class="line">        Collections.sort(persons, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lambda后的写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Person&gt; persons;<span class="comment">// 假设里面已经有很多数据</span></span><br><span class="line">        Collections.sort(persons, (o1, o2) -&gt; &#123;o1.getAge() - o2.getAge()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h4><p>Lambda由3部分组成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123;</span><br><span class="line">代码体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h4><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li><p>小括号内参数的类型可以省略</p></li><li><p>如果小括号内<strong>有且仅有一个参数</strong>，则小括号可以省略</p></li><li><p>如果大括号内<strong>有且仅有一个语句</strong>，可以同时省略大括号、return关键字及语句分号</p></li></ol><h4 id="使用Lambda的前提"><a href="#使用Lambda的前提" class="headerlink" title="使用Lambda的前提"></a>使用Lambda的前提</h4><p>Lambda表达式不是随便使用的，使用时有几个条件要特别注意：</p><ol><li><p>方法的参数或局部变量类型必须为接口才能使用Lambda</p></li><li><p>接口中有且仅有一个抽象方法</p></li></ol><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong>。</p><p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p><h5 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="FunctionalInterface注解"></a>FunctionalInterface注解</h5><p>与<code>@Override</code>注解的作用类似，Java8中专门为函数式接口引入了一个新的注解：<code>@FunctionalInterface</code>。该注解可用于一个接口的定义上：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。不过，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><h5 id="常用的函数式接口"><a href="#常用的函数式接口" class="headerlink" title="常用的函数式接口"></a>常用的函数式接口</h5><p>Lambda表达式的前提是需要有函数式接口。而Lambda使用时不关心接口名，抽象方法名，只关心抽象方法的参数列表和返回值类型。因此为了让我们使用Lambda方便，JDK提供了大量常用的函数式接口。</p><ol><li>Supplier接口</li></ol><p>java.util.function.Supplier<T>接口，它意味着”供给”,对应的Lambda表达式需要“<strong>对外提供</strong>”一个符合泛型类型的对象数据。</T></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Consumer接口</li></ol><p><strong>消费</strong>一个数据，其数据类型由泛型参数决定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Function接口</li></ol><p>java.util.function.Function&lt;T,R&gt;接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。有参数有返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Predicate接口</li></ol><p>java.util.function.Predicate<T> 接口用于做判断,返回boolean类型的值，有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。</T></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>如果在Lambda中所指定的功能，已经有其他方法存在相同方案，则没有必要再写重复逻辑，可以直接“引用”过去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n: arr) &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printMax(Test::getMax);<span class="comment">// 方法引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(Consumer&lt;<span class="type">int</span>[]&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        consumer.accept(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法引用的格式"><a href="#方法引用的格式" class="headerlink" title="方法引用的格式"></a>方法引用的格式</h5><p><strong>符号表示</strong>：<code>::</code></p><p><strong>符号说明</strong>: 双冒号为方法引用运算符，而它所在的表达式被称为<strong>方法引用</strong></p><p><strong>应用场景</strong>: 如果Lambda所要实现的方案, 已经有其他方法存在相同方案，那么则可以使用方法引用</p><h5 id="常用引用方式"><a href="#常用引用方式" class="headerlink" title="常用引用方式"></a>常用引用方式</h5><p>方法引用在JDK8中使用方式相当灵活，有以下几种形式：</p><ol><li><p><code>instanceName::methodName</code> 对象::方法名</p></li><li><p><code>ClassName::staticMethodName</code> 类名::静态方法</p></li><li><p><code>ClassName::methodName</code> 类名::普通方法</p></li><li><p><code>ClassName::new</code> 类名::new 调用的构造器</p></li><li><p><code>TypeName[]::new String[]::new</code> 调用数组的构造器</p></li></ol><h5 id="常用格式解析"><a href="#常用格式解析" class="headerlink" title="常用格式解析"></a>常用格式解析</h5><ol><li>对象::方法名</li></ol><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法，则可以通过对象名引用成员方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    Supplier&lt;Long&gt; supp = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> now.getTime();</span><br><span class="line">&#125;;</span><br><span class="line">    System.out.println(supp.get());</span><br><span class="line">    </span><br><span class="line">    Supplier&lt;Long&gt; supp2 = now::getTime;</span><br><span class="line">    System.out.println(supp2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法引用的注意事项</p><ul><li><p>被引用的方法，参数要和接口中抽象方法的参数一样</p></li><li><p>当接口抽象方法有返回值时，被引用的方法也必须有返回值</p></li></ul><ol start="2"><li>类名::静态方法</li></ol><p>由于在<code>java.lang.System</code>类中已经存在了静态方法<code>currentTimeMillis</code>，要通过Lambda来调用该方法时,可以使用方法引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Supplier&lt;Long&gt; supp = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">&#125;;</span><br><span class="line">    System.out.println(supp.get());</span><br><span class="line">    </span><br><span class="line">    Supplier&lt;Long&gt; supp2 = System::currentTimeMillis;</span><br><span class="line">    System.out.println(supp2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>类名::普通方法</li></ol><p>由于构造器的名称与类名完全一样。所以构造器引用使用类名称::new的格式表示。</p><p>首先是一个Person类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用这个函数式接口，可以通过方法引用传递：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Supplier&lt;Person&gt; sup = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line">    </span><br><span class="line">    Supplier&lt;Person&gt; sup2 = Person::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">    </span><br><span class="line">    BiFunction&lt;String, Integer, Person&gt; fun2 = Person::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(fun2.apply(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>类名::new调用的构造器</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Function&lt;Integer, String[]&gt; fun = (len) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[len];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    String[] arr1 = fun.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(arr1 + <span class="string">&quot;, &quot;</span> + arr1.length);</span><br><span class="line">    </span><br><span class="line">    Function&lt;Integer, String[]&gt; fun2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    String[] arr2 = fun.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(arr2 + <span class="string">&quot;, &quot;</span> + arr2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>Stream流式思想类似于工厂车间的“<strong>生产流水线</strong>”，Stream流不是一种数据结构，不保存数据，而是对数据进行加工处理。Stream可以看作是流水线上的一个工序。在流水线上，通过多个工序让一个原材料加工成一个商品。</p><p>Stream API能让我们快速完成许多复杂的操作，如筛选、切片、映射、查找、去除重复，统计，匹配和归约。</p><h3 id="获取Stream流"><a href="#获取Stream流" class="headerlink" title="获取Stream流"></a>获取Stream流</h3><h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><p><code>java.util.Collection</code>接口中加入了default stream方法用来获取流，所以其所有实现类均可获取流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 集合获取流</span></span><br><span class="line">        <span class="comment">// Collection接口中的方法: default Stream&lt;E&gt; stream() 获取流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream3 = vector.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map不是 Collection的子接口，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Map获取流</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">        Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream中的静态方法of获取流"><a href="#Stream中的静态方法of获取流" class="headerlink" title="Stream中的静态方法of获取流"></a>Stream中的静态方法of获取流</h4><p>由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Stream中的静态方法: static Stream of(T... values)</span></span><br><span class="line">        Stream&lt;String&gt; stream6 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream7 = Stream.of(arr);</span><br><span class="line">        Integer[] arr2 = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream8 = Stream.of(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream常用方法"><a href="#Stream常用方法" class="headerlink" title="Stream常用方法"></a>Stream常用方法</h3><ul><li><p><strong>终结方法</strong>：返回值类型不再是 Stream 类型的方法，不再支持链式调用。</p></li><li><p><strong>非终结方法</strong>：返回值类型仍然是 Stream 类型的方法，支持链式调用。</p></li></ul><table><thead><tr><th><strong>方法名</strong></th><th><strong>方法作用</strong></th><th><strong>返回值类型</strong></th><th><strong>方法种类</strong></th></tr></thead><tbody><tr><td>count</td><td>统计个数</td><td>long</td><td>终结</td></tr><tr><td>forEach</td><td>逐一处理</td><td>void</td><td>终结</td></tr><tr><td>filter</td><td>过滤</td><td>Stream</td><td>函数拼接</td></tr><tr><td>limit</td><td>取用前几个</td><td>Stream</td><td>函数拼接</td></tr><tr><td>skip</td><td>跳过前几个</td><td>Stream</td><td>函数拼接</td></tr><tr><td>map</td><td>映射</td><td>Stream</td><td>函数拼接</td></tr><tr><td>concat</td><td>组合</td><td>Stream</td><td>函数拼接</td></tr></tbody></table><p>注意：</p><ol><li><p>Stream只能操作一次</p></li><li><p>Stream方法返回的是新的流</p></li><li><p>Stream不调用终结方法，中间的操作不会执行</p></li></ol><h4 id="count方法"><a href="#count方法" class="headerlink" title="count方法"></a>count方法</h4><p>count方法可以统计其中的元素个数，该方法返回一个long值代表元素个数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCount</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    System.out.println(one.stream().count());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h4><p>forEach用来遍历流中的数据，该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForEach</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Filter方法"><a href="#Filter方法" class="headerlink" title="Filter方法"></a>Filter方法</h4><p>filter用于过滤数据，返回符合过滤条件的数据，可以将一个流转换成另一个子集流。需要接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().filter(s -&gt; s.length() == <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="limit方法"><a href="#limit方法" class="headerlink" title="limit方法"></a>limit方法</h4><p>limit方法可以对流进行截取，只取用前n个。参数是一个long型，如果集合当前长度大于参数则进行截取。否则不进行操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLimit</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="skip方法"><a href="#skip方法" class="headerlink" title="skip方法"></a>skip方法</h4><p>如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流。如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSkip</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h4><p>map方法可以将流中的元素映射到另一个流中，该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;33&quot;</span>);</span><br><span class="line">    Stream&lt;Integer&gt; result = original.map(Integer::parseInt);</span><br><span class="line">    result.forEach(s -&gt; System.out.println(s + <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="distinct方法"><a href="#distinct方法" class="headerlink" title="distinct方法"></a>distinct方法</h4><p>distinct方法可以去除重复数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDistinct</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream.of(<span class="number">22</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">33</span>)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h4><p>如果需要判断数据是否匹配指定的条件，可以使用 Match 相关方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Stream.of(<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// .allMatch(e -&gt; e &gt; 0); // allMatch: 元素是否全部满足条件</span></span><br><span class="line">    <span class="comment">// .anyMatch(e -&gt; e &gt; 5); // anyMatch: 元素是否任意有一个满足条件</span></span><br><span class="line">    .noneMatch(e -&gt; e &lt; <span class="number">0</span>); <span class="comment">// noneMatch: 元素是否全部不满足条件</span></span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="concat方法"><a href="#concat方法" class="headerlink" title="concat方法"></a>concat方法</h4><p>有两个流需要合并成为一个流，可以使用 Stream 接口的静态方法 concat</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testContact</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">    result.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream流中的结果到集合中"><a href="#Stream流中的结果到集合中" class="headerlink" title="Stream流中的结果到集合中"></a>Stream流中的结果到集合中</h4><p>Stream流提供collect方法，其参数需要一个java.util.stream.Collector&lt;T, A, R&gt;接口对象来指定收集到哪种集合中。java.util.stream.Collectors类提供一些方法，可以作为Collector接口的实例：</p><p><code>public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</code>：转换为 List 集合。</p><p><code>public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</code>：转换为 Set 集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStreamToCollection</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    <span class="comment">// List&lt;String&gt; list = stream.collect(Collectors.toList());</span></span><br><span class="line">    <span class="comment">// Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span></span><br><span class="line">    ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">    HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream流中的结果到数组中"><a href="#Stream流中的结果到数组中" class="headerlink" title="Stream流中的结果到数组中"></a>Stream流中的结果到数组中</h4><p>Stream提供toArray方法来将结果放到一个数组中，返回值类型为Object[]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStreamToArray</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    String[] strings = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : strings) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对流中数据进行拼接"><a href="#对流中数据进行拼接" class="headerlink" title="对流中数据进行拼接"></a>对流中数据进行拼接</h4><p>Collectors.joining会根据指定的连接符，将所有元素连接成一个字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJoining</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;Student&gt; studentStream = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a&quot;</span>, <span class="number">52</span>, <span class="number">95</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;b&quot;</span>, <span class="number">56</span>, <span class="number">88</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;c&quot;</span>, <span class="number">56</span>, <span class="number">99</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d&quot;</span>, <span class="number">52</span>, <span class="number">77</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> studentStream</span><br><span class="line">        .map(Student::getName)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;&gt;_&lt;&quot;</span>, <span class="string">&quot;^_^&quot;</span>, <span class="string">&quot;^v^&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行的Stream流"><a href="#并行的Stream流" class="headerlink" title="并行的Stream流"></a>并行的Stream流</h3><p>parallelStream是一个并行执行的流。它通过默认的ForkJoinPool，可能提高多线程任务的速度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testgetParallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 直接获取并行的流</span></span><br><span class="line">    Stream&lt;Integer&gt; stream1 = list.parallelStream();</span><br><span class="line">    <span class="comment">// 将串行流转成并行流</span></span><br><span class="line">    Stream&lt;Integer&gt; stream2 = list.stream().parallel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行操作代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test0Parallel</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line">        .parallel() <span class="comment">// 将流转成并发流,Stream处理的时候将才去</span></span><br><span class="line">        .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;, s = &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">    .count();</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p>Optional是一个没有子类的工具类，是一个可以为null的容器对象。它的作用主要就是为了解决避免Null检查，防止NullPointerException。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>创建方式：</p><p><code>Optional.of(T t)</code>: 创建一个Optional实例</p><p><code>Optional.empty()</code>: 创建一个空的Optional实例</p><p><code>Optional.ofNullable(T t)</code>:若t不为null,创建Optional实例,否则创建空实例</p><p>常用方法：</p><p><code>isPresent()</code>: 判断是否包含值,包含值返回true，不包含值返回false</p><p><code>get()</code>: 如果Optional有值则将其返回，否则抛出NoSuchElementException</p><p><code>orElse(T t)</code>: 如果调用对象包含值，返回该值，否则返回参数t</p><p><code>orElseGet(Supplier s)</code>:如果调用对象包含值，返回该值，否则返回s获取的值</p><p><code>map(Function f)</code>: 如果有值对其处理，并返回处理后的Optional，否则返回Optional.empty()</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Optional&lt;String&gt; userName = Optional.empty();</span><br><span class="line">    <span class="keyword">if</span> (userNameO.isPresent()) &#123;</span><br><span class="line">        <span class="comment">// get() : 如果Optional有值则将其返回，否则抛出NoSuchElementException。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> userName.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名为:&quot;</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日期和时间API"><a href="#日期和时间API" class="headerlink" title="日期和时间API"></a>日期和时间API</h2><p>JDK 8中增加了一套全新的日期时间API，这套API设计合理，是线程安全的。新的日期及时间API位于<code>java.time</code>包中，下面是一些关键类。</p><p><code>LocalDate</code>：表示日期，包含年月日，格式为 2019-10-16</p><p><code>LocalTime</code>：表示时间，包含时分秒，格式为 16:38:54.158549300</p><p><code>LocalDateTime</code>：表示日期时间，包含年月日，时分秒，格式为 2018-09-06T15:33:56.750</p><p><code>DateTimeFormatter</code>：日期时间格式化类。</p><p><code>Instant</code>：时间戳，表示一个特定的时间瞬间。</p><p><code>Duration</code>：用于计算2个时间(LocalTime，时分秒)的距离</p><p><code>Period</code>：用于计算2个日期(LocalDate，年月日)的距离</p><p><code>ZonedDateTime</code>：包含时区的时间</p><p>LocalDate、LocalTime、LocalDateTime类的实例是不可变的对象，分别表示使用 ISO-8601 日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建指定日期</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">fj</span> <span class="operator">=</span> LocalDate.of(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;fj = &quot;</span> + fj); <span class="comment">// 1985-09-23</span></span><br><span class="line">    <span class="comment">// 得到当前日期</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nowDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;nowDate = &quot;</span> + nowDate);</span><br><span class="line">    <span class="comment">// 获取日期信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;年: &quot;</span> + nowDate.getYear());</span><br><span class="line">    System.out.println(<span class="string">&quot;月: &quot;</span> + nowDate.getMonthValue());</span><br><span class="line">    System.out.println(<span class="string">&quot;日: &quot;</span> + nowDate.getDayOfMonth());</span><br><span class="line">    System.out.println(<span class="string">&quot;星期: &quot;</span> + nowDate.getDayOfWeek());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 得到指定的时间</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>,<span class="number">15</span>, <span class="number">28</span>, <span class="number">129_900_000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + time);</span><br><span class="line">    <span class="comment">// 得到当前时间</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">nowTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;nowTime = &quot;</span> + nowTime);</span><br><span class="line">    <span class="comment">// 获取时间信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;小时: &quot;</span> + nowTime.getHour());</span><br><span class="line">    System.out.println(<span class="string">&quot;分钟: &quot;</span> + nowTime.getMinute());</span><br><span class="line">    System.out.println(<span class="string">&quot;秒: &quot;</span> + nowTime.getSecond());</span><br><span class="line">    System.out.println(<span class="string">&quot;纳秒: &quot;</span> + nowTime.getNano());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">fj</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;fj = &quot;</span> + fj);</span><br><span class="line">    <span class="comment">// 得到当前日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;now = &quot;</span> + now);</span><br><span class="line">    System.out.println(now.getYear());</span><br><span class="line">    System.out.println(now.getMonthValue());</span><br><span class="line">    System.out.println(now.getDayOfMonth());</span><br><span class="line">    System.out.println(now.getHour());</span><br><span class="line">System.out.println(now.getMinute());</span><br><span class="line">System.out.println(now.getSecond());</span><br><span class="line">System.out.println(now.getNano());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对日期时间的修改，对已存在的LocalDate对象，创建它的修改版，最简单的方式是使用withAttribute方法。withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。以下所有的方法都返回了一个修改属性的对象，他们不会影响原来的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LocalDateTime类: 对日期时间的修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;now = &quot;</span> + now);</span><br><span class="line">    <span class="comment">// 修改日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">setYear</span> <span class="operator">=</span> now.withYear(<span class="number">2077</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改年份: &quot;</span> + setYear);</span><br><span class="line">    System.out.println(<span class="string">&quot;now == setYear: &quot;</span> + (now == setYear));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改月份: &quot;</span> + now.withMonth(<span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改小时: &quot;</span> + now.withHour(<span class="number">9</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改分钟: &quot;</span> + now.withMinute(<span class="number">11</span>));</span><br><span class="line">    <span class="comment">// 再当前对象的基础上加上或减去指定的时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> now.plusDays(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;5天后: &quot;</span> + localDateTime);</span><br><span class="line">    System.out.println(<span class="string">&quot;now == localDateTime: &quot;</span> + (now == localDateTime));</span><br><span class="line">    System.out.println(<span class="string">&quot;10年后: &quot;</span> + now.plusYears(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;20月后: &quot;</span> + now.plusMonths(<span class="number">20</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;20年前: &quot;</span> + now.minusYears(<span class="number">20</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;5月前: &quot;</span> + now.minusMonths(<span class="number">5</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;100天前: &quot;</span> + now.minusDays(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日期的比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在JDK8中，LocalDate类中使用isBefore()、isAfter()、equals()方法来比较两个日期，可直接进行比较。</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">    System.out.println(now.isBefore(date)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(now.isAfter(date)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间格式化与解析"><a href="#时间格式化与解析" class="headerlink" title="时间格式化与解析"></a>时间格式化与解析</h3><p>通过<code>java.time.format.DateTimeFormatter</code>类可以进行日期时间解析与格式化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 得到当前日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="comment">// 将日期时间格式化为字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> now.format(formatter);</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);</span><br><span class="line">    <span class="comment">// 将字符串解析为日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;1970-01-01 12:12:12&quot;</span>, formatter);</span><br><span class="line">    System.out.println(<span class="string">&quot;parse = &quot;</span> + parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB基础入门</title>
      <link href="/inori/623bd2ca.html"/>
      <url>/inori/623bd2ca.html</url>
      
        <content type="html"><![CDATA[<p>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB是介于<strong>关系数据库</strong>和<strong>非关系数据库</strong>之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p><p>Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>MongoDB相较于传统的关系型数据库，可应对“三高“需求</p><ul><li>High performance：对数据库高并发读写的需求</li><li>Huge Storage：对海量数据的高效率存储和访问的需求</li><li>High Scalability &amp;&amp; High Availability：对数据库的高可扩展性和高可用性的需求</li></ul><h3 id="什么时候选择MongoDB"><a href="#什么时候选择MongoDB" class="headerlink" title="什么时候选择MongoDB"></a>什么时候选择MongoDB</h3><ul><li>新应用，需求会变，数据模型无法确定，想快速迭代开发</li><li>应用需要2000-3000以上的读写QPS（更高也可以）</li><li>应用需要TB甚至PB级别数据存储</li><li>应用要求存储的数据不丢失</li><li>应用需要99.999%高可用</li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><table><thead><tr><th>SQL术语&#x2F;概念</th><th>MongoDB术语&#x2F;概念</th><th>说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表&#x2F;集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行&#x2F;文档</td></tr><tr><td>column</td><td>field</td><td>数据字段&#x2F;域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>primary key</td><td>primary key</td><td>主键</td></tr></tbody></table><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>MongoDB的最小存储单位是文档(document)对象。数据在MongoDB中以BSON（Binary-JSON）文档的格式存储在磁盘上。</p><p>BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON。BSON和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。</p><p>BSON采用了类似于C语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p>Bson中，除了基本的JSON类型：string,integer,boolean,double,null,array和object，mongo还使用了特殊的数据类型。这些类型包括date,object id,binary data,regular expression和code。</p><h2 id="MongoDB优点"><a href="#MongoDB优点" class="headerlink" title="MongoDB优点"></a>MongoDB优点</h2><ol><li>高性能</li></ol><p>​MongoDB提供高性能的数据持久性。特别是对嵌入式数据模型的支持减少了数据库系统上I&#x2F;O活动。索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。</p><ol start="2"><li><p>高可用性<br>MongoDB的复制工具称为副本集（replica set），它可提供自动故障转移和数据冗余</p></li><li><p>高扩展性<br>MongoDB提供了水平可扩展性作为其核心功能的一部分。分片将数据分布在一组集群的机器上。（海量数据存储，服务能力水平扩展）</p><p>从3.4开始，MoηgoDB支持基于片键创建数据区域。在一个平衡的集群中， MongoDB将一个区域所覆盖的读写只定向到该区域内的那些片。</p></li><li><p>丰富的查询支持<br>MongoDB支持丰富的査询语言，支持读和写操作（CRUD），比如数据聚合、文本搜索和地理空间查询等</p></li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>需要用到的时候可以查阅<a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/create-index/">MongoDB官方文档</a>，在此列举常用命令</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p><code>mongosh</code>:打开一个连接到本地实例的MongoShell。所有其他命令都需要在mongosh中执行</p><p><code>show databases\show dbs</code>:显示当前MongoDB实例中的所有数据库</p><p><code>use &lt;dbname&gt;</code>:切换到dbname数据库</p><p><code>cls</code>: 清屏</p><p><code>show collections</code>: 显示数据库中的所有集合</p><p><code>db.dropDatabase()</code>:删除当前数据库</p><p><code>exit</code>: 退出</p><h3 id="创建、插入"><a href="#创建、插入" class="headerlink" title="创建、插入"></a>创建、插入</h3><p><code>insertOne</code>:在集合中插入一个新的文档，如果集合存在，那么直接插入数据。如果集合不存在，那么会隐式创建。</p><ul><li><code>db.test.insertOne(&#123;name: &quot;Jack&quot;, age: 18&#125;)</code>:向test数据库中插入一条数据</li></ul><p><code>insertMany</code>:批量插入文档</p><h4 id="快速插入"><a href="#快速插入" class="headerlink" title="快速插入"></a>快速插入</h4><p>由于<code>mongodb</code>底层使用<code>JS</code>引擎实现的，所以支持部分<code>Js</code>语法。因此可以写<code>for</code>循环</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (var i=1; i&lt;=10; i++) &#123; db.c2.insertOne(&#123;uanme: &quot;a&quot;+i, age: i&#125;) &#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>delectOne</code>:删除满足条件的第一个文档</p><p><code>delectMany</code>:删除满足条件的所有文档</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><code>updateOne</code>:更新满足条件的第一个文档</p><p><code>updateMany</code>:更新满足条件的所有文档</p><p><code>replaceone</code>:替换满足条件的第一个文档</p><p><code>save</code>:通过传入的文档替换已有文档或插入一个新的文档</p><p><code>$set</code>:只更新文档中$set指定的字段</p><ul><li><code>db.test.update(&#123;name:&quot;Jack&quot;&#125;,&#123;$set:&#123;uname:&quot;Candy&quot;&#125;&#125;)</code>:把jack改成Candy</li></ul><p><code>$inc</code>:用于递增&#x2F;递减文档中指定字段值的操作符</p><p><code>$rename</code>:更新某个字段的名称</p><p><code>$unset</code>:删除一个字段</p><p><code>$push</code>:将值加入一个数组中，不会判断是否有重复的值</p><p><code>$pull</code>:将值从一个数组中移除</p><p><code>$addToSet</code>:将值加入一个数组中，如果数组中有重复的值则不会加入</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><code>find</code>:查询所有文档</p><p><code>find(&lt;filterObject&gt;)</code>:查询所有满足参数对象<code>&lt;filterObject&gt;</code>中指定过滤条件的数据</p><ul><li><code>db.test.find(&#123;age: 18&#125;)</code>:查询所有年龄为18岁的文档</li></ul><p><code>db.find(&lt;filterObject&gt;, &lt;selectObject&gt;)</code>:查询所有满足参数对象<code>&lt;filterObject&gt;</code>中指定过滤条件的数据，并且只返回或者不返回<code>&lt;selectObject&gt;</code>中指定的字段</p><ul><li><code>db.test.find(&#123;&#125;, &#123;name:1&#125;)</code>:只看name列</li><li><code>db.test.find(&#123;&#125;, &#123;name:0&#125;)</code>:除了name列都看</li></ul><p><code>findOne</code>:与find用法相同，但是只返回1条</p><p><code>countDocuments</code>:返回满足条件的记录的数量</p><p><code>sort</code>:使用给定的字段按照升序或降序排序</p><ul><li><code>db.test.find().sort(&#123;age:1&#125;)</code>:按照年龄升序排序（传入-1是降序排序）</li></ul><p><code>limit</code>:限定只返回给定数量的文档</p><ul><li><code>db.test.find().limit(1)</code>:只返回一条数据</li></ul><p><code>skip</code>:从头开始跳过给定数值的文档</p><ul><li><code>db.test.find().limit(x).skip(y*x)</code>:实现翻页效果，一页x个内容，翻y页</li></ul><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><code>$sum</code>:计算总和</p><p><code>$avg</code>:计算平均值</p><p><code>$min</code>:计算最小值</p><p><code>$max</code>:计算最大值</p><p><code>$first</code>:获取第一个文档数据</p><p><code>$last</code>:获取最后一个文档数据</p><h3 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h3><p><code>$eq</code>:等于</p><p><code>$ne</code>:不等于</p><p><code>$gt\$get</code>:大于\大于等于</p><ul><li><code>db.c1.find(&#123;age:&#123;$gt:5&#125;&#125;)</code>:查询age大于5的数据</li></ul><p><code>$lt\$lte</code>:小于\小于等于</p><p><code>$in</code>:值在指定列表中就返回文档</p><ul><li><code>db.c2.find(&#123;age:&#123;$in:[5,8,10]&#125;&#125;)</code>:查询年龄是5,8,10的数据</li></ul><p><code>$nin</code>:值不在指定列表中就返回文档</p><p><code>$and</code>:检查复数条件是否均为真，可以理解为“并且”</p><ul><li><code>db.test.find(&#123;$and:[&#123;age:&#123;$gte:10&#125;&#125;, &#123;age:&#123;$lte:20&#125;&#125;&#125;]&#125;)</code>:返回年龄在10-20岁之间的文档</li></ul><p><code>$or</code>:检查复试条件是否有一个为真，可以理解为“或者”</p><p><code>$not</code>:逻辑区取反</p><p><code>$exists</code>:检查一个字段是否存在</p><p><code>$expr</code>:在不同的字段中作比较</p><h2 id="Java中操作MongoDB"><a href="#Java中操作MongoDB" class="headerlink" title="Java中操作MongoDB"></a>Java中操作MongoDB</h2><p>首先需要导入mongodb驱动包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mongodb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-java-driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建链接对象"><a href="#创建链接对象" class="headerlink" title="创建链接对象"></a>创建链接对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MongoClient mongoclient= <span class="keyword">new</span> <span class="title class_">MongoClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>);</span><br></pre></td></tr></table></figure><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取库对象，参数为库名</span></span><br><span class="line"><span class="type">MongoDatabase</span> <span class="variable">db</span> <span class="operator">=</span> mongoclient.getDatabase(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//获取当前库对象的所有集合名的迭代器</span></span><br><span class="line">MongoIterable&lt;String&gt; list = db.getlistCollectionNames();</span><br><span class="line"><span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">    System.out.println(str);<span class="comment">//获取所有表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取集合对象，参数为集合名</span></span><br><span class="line">MongoCollention&lt;Document&gt; collection = db.getCollection(<span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="对数据库进行增删改查"><a href="#对数据库进行增删改查" class="headerlink" title="对数据库进行增删改查"></a>对数据库进行增删改查</h3><h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取集合对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = db.getCollection(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//新增时创建一个Docuement对象，以键值对的形式传入内容</span></span><br><span class="line"><span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">document.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">document.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">document.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="comment">//添加一条数据，没有返回值</span></span><br><span class="line">collection.insertOne(document);</span><br><span class="line"><span class="comment">//新增多条数据,传入一个document集合</span></span><br><span class="line">collection.insertMany(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><p>删除，修改，查询时传入的筛选条件，比如<code>Bson eq = Filters.eq(&quot;name&quot;,&quot;张三&quot;);</code></p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Filters.eq()</td><td>等值</td></tr><tr><td>Filters.gt()</td><td>大于指定值(gte大于等于)</td></tr><tr><td>Filters.lt()</td><td>小于指定值(lte小于等于)</td></tr><tr><td>Filters.ne()</td><td>不等于指定</td></tr><tr><td>Filters.nin()</td><td>不等于数组中的值</td></tr><tr><td>Filters.and()</td><td>传入多个Bson对象，and连接</td></tr><tr><td>Filters.regex()</td><td>模糊查询</td></tr><tr><td>Filters.exists()</td><td>存在改字段</td></tr></tbody></table><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件</span></span><br><span class="line"><span class="type">Bson</span> <span class="variable">eq</span> <span class="operator">=</span> Filters.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//删除一条符合的</span></span><br><span class="line"><span class="type">DeleteResult</span> <span class="variable">deleteOne</span> <span class="operator">=</span> collection.deleteOne(eq);</span><br><span class="line"><span class="comment">//删除 所有符合条件的</span></span><br><span class="line"><span class="type">DeleteResult</span> <span class="variable">deleteMany</span> <span class="operator">=</span> collection.deleteMany(eq);</span><br></pre></td></tr></table></figure><p>修改的返回值内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AcknowledgedDeleteResult&#123;deletedCount=<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p><code>deletedCount</code>:被删除的文档数</p><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改条件</span></span><br><span class="line"><span class="type">Bson</span> <span class="variable">eq</span> <span class="operator">=</span> Filters.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//修改匹配到的第一条</span></span><br><span class="line"><span class="type">UpdateResult</span> <span class="variable">updateOne</span> <span class="operator">=</span> collection.updateOne(</span><br><span class="line">    eq, <span class="keyword">new</span> <span class="title class_">Document</span>(<span class="string">&quot;$set&quot;</span>,<span class="keyword">new</span> <span class="title class_">Document</span>(<span class="string">&quot;age&quot;</span>,<span class="number">50</span>)));</span><br><span class="line"><span class="comment">//修改匹配的多条</span></span><br><span class="line">collection.updateMany(eq, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>修改的返回值内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AcknowledgedUpdateResult&#123;matchedCount=<span class="number">0</span>, modifiedCount=<span class="number">0</span>, upsertedId=<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><p><code>matchedCount</code>:代表匹配到的文档数</p><p><code>modifiedCount</code>:代表被修改的文档数</p><p><code>upsertedId</code>:代表修改的文档id(主键)</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无条件全查</span></span><br><span class="line">FindIterable&lt;Document&gt; find = collection.find();</span><br><span class="line"><span class="comment">//带条件查询</span></span><br><span class="line"><span class="type">Bson</span> <span class="variable">eq</span> <span class="operator">=</span> Filters.regex(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张&quot;</span>);</span><br><span class="line">FindIterable&lt;Document&gt; find = collection.find(eq);</span><br></pre></td></tr></table></figure><p>查询的结果集映射,这种解析方式我们必须知道文档中的各个字段名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询</span></span><br><span class="line">FindIterable&lt;Document&gt; find = collection.find();</span><br><span class="line"><span class="comment">//创建一个实体类集合准备接收结果</span></span><br><span class="line">List&lt;Student&gt; slist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"><span class="comment">//获取结果集迭代器对象</span></span><br><span class="line">MongoCursor&lt;Document&gt; iterator = find.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Document</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">s.setSname(next.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">s.setSex(next.getString(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">s.setAge(next.getInteger(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">    <span class="comment">//将结果添加至实体类集合</span></span><br><span class="line">slist.add(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mongoclient.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mongodb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mongodb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker的基本使用</title>
      <link href="/inori/ca4a993b.html"/>
      <url>/inori/ca4a993b.html</url>
      
        <content type="html"><![CDATA[<p>Docker使用Google推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><p>Docker在容器的基础上进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得Docker技术比虚拟机技术更为轻便、快捷。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像：一个特殊的文件系统"><a href="#镜像：一个特殊的文件系统" class="headerlink" title="镜像：一个特殊的文件系统"></a><strong>镜像：一个特殊的文件系统</strong></h3><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。</p><p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker设计时，就将其设计为分层存储的架构，镜像实际是由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p><p>在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><p>因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h3 id="容器：镜像运行时的实体"><a href="#容器：镜像运行时的实体" class="headerlink" title="容器：镜像运行时的实体"></a><strong>容器：镜像运行时的实体</strong></h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。</p><p>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新start，数据不会丢失。</p><h3 id="仓库：集中存放镜像文件的地方"><a href="#仓库：集中存放镜像文件的地方" class="headerlink" title="仓库：集中存放镜像文件的地方"></a><strong>仓库：集中存放镜像文件的地方</strong></h3><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</p><p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。</p><p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><p>这里补充一下 Docker Registry 公开服务和私有 Docker Registry 的概念：</p><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。</p><p>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的<a href="https://hub.docker.com/">Docker Hub</a>，这也是默认的Registry，并拥有大量的高质量的镜像。</p><p>在国内访问可能会比较慢，国内也有一些云服务商提供类似于Docker Hub的公开服务。</p><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 Docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><p><img src="/inori/ca4a993b/Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%5Cimg_con.png" alt="img_con"></p><h2 id="初步配置Docker"><a href="#初步配置Docker" class="headerlink" title="初步配置Docker"></a>初步配置Docker</h2><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker容器开机自启</span></span><br><span class="line">docker update <span class="literal">--restart</span>=always [容器名/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p>给常用Docker命令起别名，方便访问：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br></pre></td></tr></table></figure><p>执行命令使修改生效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p><img src="/inori/ca4a993b/Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%5Cdocker_control.png" alt="docker_control"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    <span class="number">605</span>c77e624dd   <span class="number">16</span> months ago   <span class="number">141</span>MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步，创建并允许Nginx容器</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第5步，查看运行中容器</span></span><br><span class="line">docker <span class="built_in">ps</span></span><br><span class="line"><span class="comment"># 也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第8步，查看所有容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第9步，再次启动nginx容器</span></span><br><span class="line">docker <span class="built_in">start</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第10步，再次查看容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br><span class="line"><span class="comment"># 或者，可以进入MySQL</span></span><br><span class="line">docker exec <span class="literal">-it</span> mysql mysql <span class="literal">-uroot</span> <span class="literal">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第13步，删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br><span class="line"><span class="comment"># 发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> nginx</span><br></pre></td></tr></table></figure><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷（volume）是一个虚拟目录，是<strong>容器内</strong>目录与<strong>宿主机</strong>目录之间映射的桥梁。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     <span class="number">29524</span>ff09715htrhfhthfhta2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-04-24T09:50:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html</span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br></pre></td></tr></table></figure><h3 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h3><p>数据卷的目录结构较深，去操作数据卷目录会不太方便。在很多情况下会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><p>本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>如果想要部署我们自己的项目，需要将其打包为一个镜像。</p><p>打包镜像分成如下步骤：</p><ul><li>准备Linux运行环境</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。记录镜像结构的文件就称为<a href="https://docs.docker.com/engine/reference/builder/"><strong>Dockerfile</strong></a></p><h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>通常在其他人提供好的基础镜像之上制作镜像</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像</p><p>首先将本地打包好的jar包和Dockerfile传入linux服务器，然后执行命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/image</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><p><code>docker build </code>: 构建一个docker镜像</p></li><li><p><code>-t demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</p></li><li><p><code>.</code> : 指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接指定Dockerfile目录</span></span><br><span class="line">docker build -t docker-demo:1.0 /root/image</span><br></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>项目往往需要访问其它各种中间件，例如MySQL、Redis等。但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p><p>所以，我们必须借助于<a href="https://docs.docker.com/engine/reference/commandline/network/">docker的网络功能</a>来解决这个问题</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   demo      bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了demo以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect demo mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect demo <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>只是部署一个简单的java项目，会包含以下3个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了</p><p>DockerCompose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的docker-compose.yml模板文件（YAML格式）来定义一组相关联的应用容器。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">docker-compose.yml文件的基本语法</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数很相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network demo</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th align="left"><strong>docker run 参数</strong></th><th align="left"><strong>docker compose 指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">–name</td><td align="left">container_name</td><td align="left">容器名称</td></tr><tr><td align="left">-p</td><td align="left">ports</td><td align="left">端口映射</td></tr><tr><td align="left">-e</td><td align="left">environment</td><td align="left">环境变量</td></tr><tr><td align="left">-v</td><td align="left">volumes</td><td align="left">数据卷配置</td></tr><tr><td align="left">–network</td><td align="left">networks</td><td align="left">网络</td></tr></tbody></table><h3 id="项目部署示例"><a href="#项目部署示例" class="headerlink" title="项目部署示例"></a>项目部署示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">project:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">demo:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">net</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以<a href="https://docs.docker.com/compose/reference/">部署项目</a>了</p><p>基本语法：<code>docker compose [OPTIONS] [COMMAND]</code></p><p>OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td><td align="left"></td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left">down</td><td align="left">停止并移除所有容器、网络</td><td align="left"></td></tr><tr><td align="left">ps</td><td align="left">列出所有启动的容器</td><td align="left"></td></tr><tr><td align="left">logs</td><td align="left">查看指定容器的日志</td><td align="left"></td></tr><tr><td align="left">stop</td><td align="left">停止容器</td><td align="left"></td></tr><tr><td align="left">start</td><td align="left">启动容器</td><td align="left"></td></tr><tr><td align="left">restart</td><td align="left">重启容器</td><td align="left"></td></tr><tr><td align="left">top</td><td align="left">查看运行的进程</td><td align="left"></td></tr><tr><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td><td align="left"></td></tr></tbody></table><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除镜像</span></span><br><span class="line">docker rmi demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY demo-service.jar /app.jar                                         0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root                                                 0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network net      Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container demo   Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis进阶篇</title>
      <link href="/inori/a9e82450.html"/>
      <url>/inori/a9e82450.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便继续使用缓存</p><p><strong>主动更新：</strong>手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="/inori/a9e82450/redis%E8%BF%9B%E9%98%B6%E7%AF%87%5Credis_cacheUpdate.png" alt="redis_cacheUpdate"></p><h3 id="数据库缓存不一致解决方案"><a href="#数据库缓存不一致解决方案" class="headerlink" title="数据库缓存不一致解决方案"></a>数据库缓存不一致解决方案</h3><p>由于缓存的数据源来自于数据库,而数据库的数据是会发生变化的,因此,如果当数据库中数据发生变化,而缓存却没有同步,此时就会有一致性问题存在,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern: 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><h3 id="缓存穿透问题的解决思路"><a href="#缓存穿透问题的解决思路" class="headerlink" title="缓存穿透问题的解决思路"></a>缓存穿透问题的解决思路</h3><p><strong>缓存穿透</strong>：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器使用的是哈希思想，而哈希思想可能存在哈希冲突</p><h3 id="缓存雪崩问题及解决思路"><a href="#缓存雪崩问题及解决思路" class="headerlink" title="缓存雪崩问题及解决思路"></a>缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性（哨兵模式、集群模式）</li><li>给缓存业务添加降级限流策略（nginx或SpringCloud Gateway）</li><li>给业务添加多级缓存（Guava或Caffeine）</li></ul><h3 id="缓存击穿问题及解决思路"><a href="#缓存击穿问题及解决思路" class="headerlink" title="缓存击穿问题及解决思路"></a>缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个新线程去进行以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁，而线程1直接进行返回旧数据，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="/inori/a9e82450/redis%E8%BF%9B%E9%98%B6%E7%AF%87%5CredisThrough.png" alt="redisThrough"></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><h3 id="分布式锁应该满足的条件"><a href="#分布式锁应该满足的条件" class="headerlink" title="分布式锁应该满足的条件"></a>分布式锁应该满足的条件</h3><ul><li>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li><li>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</li><li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li><li>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全也是程序中必不可少的一环</li></ul><h3 id="常见的分布式锁"><a href="#常见的分布式锁" class="headerlink" title="常见的分布式锁"></a>常见的分布式锁</h3><p><img src="/inori/a9e82450/redis%E8%BF%9B%E9%98%B6%E7%AF%87%5Ccommon_lock.png" alt="common_lock"></p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><ul><li>如何合理的控制锁的有效时长？<ul><li>根据业务执行时间预估</li><li>给锁续期</li></ul></li></ul><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><h4 id="Redisson简介"><a href="#Redisson简介" class="headerlink" title="Redisson简介"></a>Redisson简介</h4><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="/inori/a9e82450/redis%E8%BF%9B%E9%98%B6%E7%AF%87%5Credisson_type.png" alt="redisson_type"></p><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://IP地址:端口号&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Redission的分布式锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间（可选，如有会取消看门狗机制），时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redission可重入锁原理"><a href="#redission可重入锁原理" class="headerlink" title="redission可重入锁原理"></a>redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0时，表示当前这把锁没有被人持有。</p><p>在redission中也支持支持可重入锁</p><p>在分布式锁中，采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，小key表示当前这把锁被哪个线程持有，分析一下当前的这个lua表达式:</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure><p>此处一共有3个参数：</p><p><strong>KEYS[1]：锁名称</strong></p><p><strong>ARGV[1]：锁失效时间</strong></p><p><strong>ARGV[2]：id + “:” + threadId；锁的小key</strong></p><p>exists: 判断数据是否存在</p><p>name：是lock是否存在,如果&#x3D;&#x3D;0，就表示当前这把锁不存在</p><p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p><p>Lock{</p><p>​    id + <strong>“:”</strong> + threadId :  1</p><p>}</p><p>如果当前这把锁存在，则第一个条件不满足，再判断</p><p>redis.call(‘hexists’, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1</p><p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p><p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p><p>将当前这个锁的value进行+1</p><p>redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p><p>他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p><p><img src="/inori/a9e82450/redis%E8%BF%9B%E9%98%B6%E7%AF%87%5CgetLock.png" alt="getLock"></p><h3 id="锁重试和WatchDog机制"><a href="#锁重试和WatchDog机制" class="headerlink" title="锁重试和WatchDog机制"></a>锁重试和WatchDog机制</h3><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前该线程已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，存在一个while(true) 进行tryAcquire抢锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br></pre></td></tr></table></figure><p>如果是没有传入时间，则此时也会进行抢锁，而且抢锁时间是默认看门狗时间<code>commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</code></p><p><code>ttlRemainingFuture.onComplete((ttlRemaining, e)</code>相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure><p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（）方法Method(<strong>new</strong> TimerTask(){}, 参数2, 参数3)</p><p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MutiLock原理"><a href="#MutiLock原理" class="headerlink" title="MutiLock原理"></a>MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="/inori/a9e82450/redis%E8%BF%9B%E9%98%B6%E7%AF%87%5Cmutilock_1.png" alt="mutilock_1"></p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功，那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试</p><p><img src="/inori/a9e82450/redis%E8%BF%9B%E9%98%B6%E7%AF%87%5Cmutilock_2.png" alt="mutilock_2"></p><h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><p>消息队列的字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>使用队列的好处在于 <strong>解耦：</strong>生产者不必等待消费者，生产出来的东西可以直接放到队列中，消费者也不必等待生产者，直接从队列中获得所需的消息，二者异步执行，增加效率。</p><h3 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a>基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h3 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream是Redis 5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="/inori/a9e82450/redis%E8%BF%9B%E9%98%B6%E7%AF%87%5Cstream_1.png" alt="stream_1"></p><p>例如：</p><p><code>XADD user * name jack age 18</code>:创建名为users的队列，并向其中发送一个消息，内容为{name&#x3D;jack,age&#x3D;18},使用Redis自动生成ID</p><p>读取消息的方式之一：XREAD</p><p><img src="/inori/a9e82450/redis%E8%BF%9B%E9%98%B6%E7%AF%87%5Cstream_xread.png" alt="stream_xread"></p><p>例如，使用XREAD读取第一个消息：<code>XREAD COUNT 1 STREAMS users 0</code></p><p>XREAD阻塞方式，读取最新的消息：<code>XREAD COUNT 1 BLOCK 1000 STREAMS user $</code></p><p>可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 尝试读取队列中的消息，最多阻塞2秒</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.execute(<span class="string">&quot;XREAD COUNT 1 BLOCK 2000 STREAMS user $&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    handleMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p><img src="/inori/a9e82450/redis%E8%BF%9B%E9%98%B6%E7%AF%87%5Cuser_group.png" alt="user_group"></p><p>创建消费者组：<code>XGROUP CREATE key gruopName ID [MKSTREAM]</code><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><h2 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，根据经纬度来检索数据。</p><p>常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li></ul><p><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></p><ul><li>GEODIST：计算指定的两个点之间的距离并返回</li></ul><p><code>GEODIST key member1 member2 [m|km|ft|mi]</code></p><ul><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li></ul><p><code>GEOHASH key member [member ...]</code></p><ul><li>GEOPOS：返回指定member的坐标</li></ul><p><code>GEOPOS key member [member ...]</code></p><ul><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。(已废弃)</li></ul><p><code>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></p><ul><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。</li></ul><p><code>GEOSEARCH key [FROMMEMBER member] [FROMCOORD longitude latitude] [BYRADIUS radius unit] [BYBOX width height unit] [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count] [STORE key] [STOREDIST key]</code></p><p>其中，<code>key</code>是指定的键，可选的查询参数包括：</p><p>​<code>FROMMEMBER member</code>：从指定的位置成员开始搜索。</p><p>​<code>FROMCOORD longitude latitude</code>：从指定的经度和纬度开始搜索。</p><p>​<code>BYRADIUS radius unit</code>：根据半径进行搜索。</p><p>​<code>BYBOX width height unit</code>：根据矩形区域进行搜索。</p><p>​<code>WITHCOORD</code>：返回位置的经度和纬度。</p><p>​<code>WITHDIST</code>：返回位置与查询点的距离。</p><p>​<code>ASC|DESC</code>：按距离升序或降序排序。</p><p>​<code>COUNT count</code>：返回最多指定数量的结果。</p><p>​<code>STORE key</code>：将结果存储到指定的键中。</p><p>​<code>STOREDIST key</code>：将结果存储到指定的键中，并同时存储位置与查询点的距离。</p><ul><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个新的key中。</li></ul><p><code>GEOSEARCHSTORE destkey key [FROMMEMBER member] [FROMCOORD longitude latitude] [BYRADIUS radius unit] [BYBOX width height unit] [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count] [STOREDIST key]</code></p><h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>Bitmap并不是实际的数据类型，而是定义在String类型上的一个面向字节操作的集合。因为字符串是二进制安全的块，他们的最大长度是512M，最适合设置成2^32个不同字节。Bitmap的最大优势之一在存储信息时极其节约空间。</p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT：获取指定位置（offset）的bit值</li><li>BITCOUNT：统计BitMap中值为1的bit位的数量</li><li>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git入门</title>
      <link href="/inori/8e7db504.html"/>
      <url>/inori/8e7db504.html</url>
      
        <content type="html"><![CDATA[<p>Git是一个分布式的版本控制系统，可以管理应用开发版本，同样可以作为部署工具使用。</p><p>常用的git平台：<a href="https://github.com/">GitHub</a>、<a href="https://gitee.com/">Gitee</a>、<a href="https://gitlab.com/">GitLab</a>等</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>工作区：仓库的目录。工作区是独立于各个分支的。</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本。</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在<del>&#x2F;.gitconfig文件中<br><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在</del>&#x2F;.gitconfig文件中<br><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中<br><code>git add XX</code>：将XX文件添加到暂存区</p><ul><li><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</li></ul><p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉<br><code>git commit -m &quot;备注信息&quot;</code>：将暂存区的内容提交到当前分支<br><code>git status</code>：查看仓库状态<br><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容<br><code>git log</code>：查看当前分支的所有版本<br><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）<br><code>git reset --hard HEAD^ 或 git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><ul><li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li><li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li><li><code>git reset --hard 版本号</code>：回滚到某一特定版本</li></ul><p><code>git checkout — XX或git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销<br><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库<br><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库</p><ul><li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li></ul><p><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下<br><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支<br><code>git branch</code>：查看所有分支和当前所处分支<br><code>git checkout branch_name</code>：切换到branch_name这个分支<br><code>git merge branch_name</code>：将分支branch_name合并到当前分支上<br><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支<br><code>git branch branch_name</code>：创建新分支<br><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支<br><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支<br><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p><ul><li><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</li></ul><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应<br><code>git checkout -t origin/branch_name</code>: 将远程的branch_name分支拉取到本地<br><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中<br><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素<br><code>git stash drop</code>：删除栈顶存储的修改<br><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素<br><code>git stash list</code>：查看栈中所有元素</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础</title>
      <link href="/inori/a4a81253.html"/>
      <url>/inori/a4a81253.html</url>
      
        <content type="html"><![CDATA[<p>转载自<a href="https://www.acwing.com/activity/content/57/">AcWing——Linux基础课</a></p><h2 id="文件操作常用命令"><a href="#文件操作常用命令" class="headerlink" title="文件操作常用命令"></a>文件操作常用命令</h2><ul><li><p>ctrl c: 取消命令，并且换行</p></li><li><p>ctrl u: 清空本行命令</p></li><li><p>tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li><li><p>ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p></li><li><p>pwd: 显示当前路径</p></li><li><p>cd XXX: 进入XXX目录下, cd .. 返回上层目录</p></li><li><p>cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如..&#x2F;dir_c&#x2F;a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p></li><li><p>mkdir XXX: 创建目录XXX</p></li><li><p>rm XXX: 删除普通文件</p><ul><li>rm XXX -r: 删除文件夹</li></ul></li><li><p>mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令</p></li><li><p>touch XXX: 创建一个文件</p></li><li><p>cat XXX: 展示文件XXX中的内容</p></li><li><p>复制文本</p><ul><li><p>windows&#x2F;Linux下：Ctrl + insert</p></li><li><p>Mac下：command + c</p></li></ul></li><li><p>粘贴文本</p><ul><li><p>windows&#x2F;Linux下：Shift + insert</p></li><li><p>Mac下：command + v</p></li></ul></li></ul><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><ul><li><p>功能</p><ul><li><p>分屏</p></li><li><p>允许断开Terminal连接后，继续运行进程</p></li></ul></li><li><p>结构：</p><ul><li>一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane</li><li>操作（魔改后）：<ul><li>tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</li><li>按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。</li><li>按下Ctrl + a后手指松开，然后按”（注意是双引号”）：将当前pane上下平分成两个pane。</li><li>Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</li><li>鼠标点击可以选pane。</li><li>按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。</li><li>鼠标拖动pane之间的分割线，可以调整分割线的位置。</li><li>按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。</li><li>按下ctrl + a后手指松开，然后按z：将当前pane全屏&#x2F;取消全屏。</li><li>按下ctrl + a后手指松开，然后按d：挂起当前session。</li><li>tmux a：打开之前挂起的session。</li><li>按下ctrl + a后手指松开，然后按s：选择其它session。<br>方向键 —— 上：选择上一项 session&#x2F;window&#x2F;pane<br>方向键 —— 下：选择下一项 session&#x2F;window&#x2F;pane<br>方向键 —— 右：展开当前项 session&#x2F;window<br>方向键 —— 左：闭合当前项 session&#x2F;window</li><li>按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。</li><li>按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。</li><li>按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。</li><li>鼠标滚轮：翻阅当前pane内的内容。</li><li>在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</li><li>tmux中复制&#x2F;粘贴文本的通用方式：<br> 1. 按下Ctrl + a后松开手指，然后按[<br>      2. 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板<br>      3. 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</li></ul></li></ul></li></ul><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><ul><li>功能：<ul><li>命令行模式下的文本编辑器。</li><li>根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</li><li>使用方式：vim filename<ul><li>如果已有该文件，则打开它。</li><li>如果没有该文件，则打开个一个新的文件，并命名为filename</li></ul></li></ul></li><li>模式：<ul><li>一般命令模式<ul><li>默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</li><li>编辑模式<br>   在一般命令模式里按下i，会进入编辑模式。<br>   按下ESC会退出编辑模式，返回到一般命令模式。</li><li>命令行模式<br>   在一般命令模式里按下:&#x2F;?三个字母中的任意一个，会进入命令行模式。命令行在最下面。<br>   可以查找、替换、保存、退出、配置编辑器等。</li></ul></li></ul></li><li>操作：<ul><li>i和a：进入编辑模式</li><li>ESC：进入一般命令模式<ul><li>h 或 左箭头键：光标向左移动一个字符</li><li>j 或 向下箭头：光标向下移动一个字符</li><li>k 或 向上箭头：光标向上移动一个字符</li><li>l 或 向右箭头：光标向右移动一个字符</li><li>n<Space>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</Space></li><li>0 或 功能键[Home]：光标移动到本行开头</li><li><code>$ 或 功能键[End]</code>：光标移动到本行末尾</li><li>G：光标移动到最后一行</li><li>:n 或 nG：n为数字，光标移动到第n行</li><li>gg：光标移动到第一行，相当于1G</li><li>n<Enter>：n为数字，光标向下移动n行</Enter></li><li>&#x2F;word：向光标之下寻找第一个值为word的字符串。</li><li>?word：向光标之上寻找第一个值为word的字符串。</li><li>n：重复前一个查找操作</li><li>N：反向重复前一个查找操作</li><li>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</li><li>:1,$s&#x2F;word1&#x2F;word2&#x2F;g：将全文的word1替换为word2<br>        (20) :1,$s&#x2F;word1&#x2F;word2&#x2F;gc：将全文的word1替换为word2，且在替换前要求用户确认。</li><li>v：选中文本</li><li>d：删除选中的文本</li><li>dd: 删除当前行</li><li>y：复制选中的文本</li><li>yy: 复制当前行</li><li>p: 将复制的数据在光标的下一行&#x2F;下一个位置粘贴</li><li>u：撤销</li><li>Ctrl + r：取消撤销</li><li>大于号 &gt;：将选中的文本整体向右缩进一次</li><li>小于号 &lt;：将选中的文本整体向左缩进一次</li><li>:w 保存</li><li>:w! 强制保存</li><li>:q 退出</li><li>:q! 强制退出</li><li>:wq 保存并退出</li><li>:set paste 设置成粘贴模式，取消代码自动缩进</li><li>:set nopaste 取消粘贴模式，开启代码自动缩进</li><li>:set nu 显示行号</li><li>:set nonu 隐藏行号</li><li>gg&#x3D;G：将全文代码格式化</li><li>:noh 关闭查找关键词高亮</li><li>Ctrl + q：当vim卡死时，可以取消当前正在执行的命令</li></ul></li></ul></li><li>异常处理：<ul><li>每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。</li><li>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<ol><li>找到正在打开该文件的程序，并退出</li><li>直接删掉该swp文件</li></ol></li></ul></li></ul><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>远程登录服务器：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname</span><br></pre></td></tr></table></figure><p>user: 用户名<br>hostname: IP地址或域名</p><ul><li>第一次登录时会提示：</li></ul><blockquote><p> The authenticity of host ‘123.57.47.211 (123.57.47.211)’ can’t be established.<br>ECDSA key fingerprint is SHA256:iy237yysfCe013&#x2F;l+kpDGfEG9xxHxm0dnxnAbJTPpG8.<br>Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])?</p></blockquote><p>输入yes，然后回车即可。<br>这样会将该服务器的信息记录在~&#x2F;.ssh&#x2F;known_hosts文件中。</p><p>然后输入密码即可登录到远程服务器中。</p><p>默认登录端口号为22。如果想登录某一特定端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname -p 22</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>创建文件 ~&#x2F;.ssh&#x2F;config。</p><p>然后在文件中输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host myserver1</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br><span class="line"></span><br><span class="line">Host myserver2</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure><p>之后再使用服务器时，可以直接使用别名myserver1、myserver2。</p><h3 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h3><p>创建密钥：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>执行结束后，~&#x2F;.ssh&#x2F;目录下会多两个文件：</p><ol><li>id_rsa：私钥</li><li>id_rsa.pub：公钥</li></ol><p>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</p><p>例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~&#x2F;.ssh&#x2F;authorized_keys文件里即可。</p><p>也可以使用如下命令一键添加公钥：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id myserver</span><br></pre></td></tr></table></figure><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>命令格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh user@hostname command</span><br></pre></td></tr></table></figure><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道类似于文件重定向，可以将前一个命令的stdout重定向到下一个命令的stdin。</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li><p>管道命令仅处理<code>stdout</code>，会忽略<code>stderr</code></p></li><li><p>管道右边的命令必须能接受<code>stdin</code></p></li><li><p>多个管道命令可以串联</p></li><li><p>与文件重定向的区别</p></li><li><p>文件重定向左边为命令，右边为文件。</p></li><li><p>管道左右两边均为命令，左边有stdout，右边有stdin。</p></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>统计当前目录下所有python文件的总行数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &#x27;*.py&#x27; | xargs cat | wc -l</span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Linux系统中会用很多环境变量来记录配置信息。<br>环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>列出当前环境下的所有环境变量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env  # 显示当前用户的变量</span><br><span class="line">set  # 显示当前shell的变量，包括当前用户的变量;</span><br><span class="line">export  # 显示当前导出成用户变量的shell变量</span><br></pre></td></tr></table></figure><p>输出某个环境变量的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>为了将对环境变量的修改应用到未来所有环境下，可以将修改命令放到<del>&#x2F;.bashrc文件中。<br>修改完</del>&#x2F;.bashrc文件后，记得执行source ~&#x2F;.bashrc，来将修改应用到当前的bash环境下。</p><p>为何将修改命令放到~&#x2F;.bashrc，就可以确保修改会影响未来所有的环境呢？</p><ul><li>每次启动bash，都会先执行~&#x2F;.bashrc。</li><li>每次ssh登陆远程服务器，都会启动一个bash命令行给我们。</li><li>每次tmux新开一个pane，都会启动一个bash命令行给我们。</li><li>所以未来所有新开的环境都会加载我们修改的内容。</li></ul><h3 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h3><ol><li>HOME：用户的家目录。</li><li>PATH：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。</li><li>LD_LIBRARY_PATH：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。</li><li>C_INCLUDE_PATH：C语言的头文件路径，内容是以冒号分隔的路径列表。</li><li>CPLUS_INCLUDE_PATH：CPP的头文件路径，内容是以冒号分隔的路径列表。</li><li>PYTHONPATH：Python导入包的路径，内容是以冒号分隔的路径列表。</li><li>JAVA_HOME：jdk的安装目录。</li><li>CLASSPATH：存放Java导入类的路径，内容是以冒号分隔的路径列表。</li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="系统状况"><a href="#系统状况" class="headerlink" title="系统状况"></a>系统状况</h3><ol><li><p>top：查看所有进程的信息（Linux的任务管理器）</p><ul><li>打开后，输入M：按使用内存排序</li><li>打开后，输入P：按使用CPU排序</li><li>打开后，输入q：退出</li></ul></li><li><p>df -h：查看硬盘使用情况</p></li><li><p>free -h：查看内存使用情况</p></li><li><p>du -sh：查看当前目录占用的硬盘空间</p></li><li><p>ps aux：查看所有进程</p></li><li><p>kill -9 pid：杀死编号为pid的进程</p><ul><li>传递某个具体的信号：<code>kill -s SIGTERM pid</code></li></ul></li><li><p>netstat -nt：查看所有网络连接</p></li><li><p>w：列出当前登陆的用户</p></li><li><p>ping <code>某url</code>：检查是否连网</p></li></ol><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li>chmod：修改文件权限<ul><li>chmod +x xxx：给xxx添加可执行权限</li><li>chmod -x xxx：去掉xxx的可执行权限</li><li>chmod 777 xxx：将xxx的权限改成777</li><li>chmod 777 xxx -R：递归修改整个文件夹的权限</li></ul></li></ul><h3 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h3><ol><li><p>find &#x2F;path&#x2F;to&#x2F;directory&#x2F; -name ‘<em>.py’：搜索某个文件路径下的所有</em>.py文件</p></li><li><p>grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。</p></li><li><p>wc：统计行数、单词数、字节数</p><ul><li>既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；</li><li>wc -l：统计行数</li><li>wc -w：统计单词数</li><li>wc -c：统计字节数</li></ul></li><li><p>tree：展示当前目录的文件结构</p><ul><li>tree &#x2F;path&#x2F;to&#x2F;directory&#x2F;：展示某个目录的文件结构</li><li>tree -a：展示隐藏文件</li></ul></li><li><p>ag xxx：搜索当前目录下的所有文件，检索xxx字符串</p></li><li><p>cut：分割一行内容</p><ul><li>从stdin中读入多行数据</li><li><code>echo $PATH | cut -d &#39;:&#39; -f 3,5</code>：输出PATH用:分割后第3、5列数据</li><li><code>echo $PATH | cut -d &#39;:&#39; -f 3-5</code>：输出PATH用:分割后第3-5列数据</li><li><code>echo $PATH | cut -c 3,5</code>：输出PATH的第3、5个字符</li><li><code>echo $PATH | cut -c 3-5</code>：输出PATH的第3-5个字符</li></ul></li><li><p>sort：将每行内容按字典序排序</p><ul><li><p>可以从stdin中读取多行数据</p></li><li><p>可以从命令行参数中读取文件名列表</p></li></ul></li><li><p>xargs：将stdin中的数据用空格或回车分割成命令行参数</p><ul><li>find . -name ‘*.py’ | xargs cat | wc -l：统计当前目录下所有python文件的总行数</li></ul></li></ol><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><ol><li><p>more：浏览文件内容</p><ul><li><p>回车：下一行</p></li><li><p>空格：下一页</p></li><li><p>b：上一页</p></li><li><p>q：退出</p></li></ul></li><li><p>less：与more类似，功能更全</p><ul><li>回车：下一行</li><li>y：上一行</li><li>Page Down：下一页</li><li>Page Up：上一页</li><li>q：退出</li></ul></li><li><p>head -3 xxx：展示xxx的前3行内容，同时支持从stdin读入内容</p></li><li><p>ail -3 xxx：展示xxx末尾3行内容，同时支持从stdin读入内容</p></li></ol><h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3><p><code>history</code>：展示当前用户的历史操作。内容存放在~&#x2F;.bash_history中</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol><li>md5sum：计算md5哈希值<ul><li>可以从stdin读入内容</li><li>可以在命令行参数中传入文件名列表</li></ul></li><li>time command：统计command命令的执行时间</li><li>ipython3：交互式python3环境。可以当做计算器，或者批量管理文件<ul><li><code>! echo &quot;Hello World&quot;</code>：!表示执行shell脚本</li></ul></li><li>watch -n 0.1 command：每0.1秒执行一次command命令</li><li>tar：压缩文件<ul><li>tar -zcvf xxx.tar.gz &#x2F;path&#x2F;to&#x2F;file&#x2F;*：压缩</li><li>tar -zxvf xxx.tar.gz：解压缩</li></ul></li><li>diff xxx yyy：查找文件xxx与yyy的不同点</li></ol><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><ul><li>sudo command：以root身份执行command命令</li><li>apt-get install xxx：安装软件</li><li>pip install xxx –user –upgrade：安装python包</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis入门篇</title>
      <link href="/inori/8660e5c0.html"/>
      <url>/inori/8660e5c0.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.redis.net.cn/">Redis</a>是一个基于<strong>内存</strong>的<u>key-value</u>结构NoSql数据库。相比于常规的数据库，Redis</p><ul><li>基于内存存储，读写性能高</li><li>适合存储热点数据（热点商品、资讯、新闻）和在短时间内有大量访问的数据</li><li>应用广泛</li></ul><h2 id="Redis启动"><a href="#Redis启动" class="headerlink" title="Redis启动"></a>Redis启动</h2><p>安装好Redis并配置好环境变量之后，在cmd中使用<code>redis-server</code>启动redis，Redis服务默认端口号为6379。</p><p>使用命令<code>redis-cli</code>连接客户端，默认连接的是本地的redis服务，并且使用默认6379端口。也可以通过指定如下参数连接：-h ip地址-p 端口号 -a 密码（如果有）</p><p>也可以使用<a href="https://github.com/qishibo/AnotherRedisDesktopManager">Another-Redis-Desktop-Manager</a>图形化工具连接和管理Redis</p><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串(string)：普通字符串，Redis中最简单的数据类型</li><li>哈希(hash)：类似于Java中的HashMap结构</li><li>列表(list)：按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList</li><li>集合(set)：无序集合，没有重复元素，类似于Java中的HashSet</li><li>有序集合(zset)：集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素</li></ul><h2 id="Redis操作命令"><a href="#Redis操作命令" class="headerlink" title="Redis操作命令"></a>Redis操作命令</h2><h3 id="字符串操作命令"><a href="#字符串操作命令" class="headerlink" title="字符串操作命令"></a>字符串操作命令</h3><ul><li><code>SET key value</code>：设置指定key的值</li><li><code>GET key</code>：获取指定key的值</li><li><code>SETEX key seconds value</code>：设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><code>SETNX key value</code>：只有在 key 不存在时设置 key 的值</li></ul><h3 id="哈希操作命令"><a href="#哈希操作命令" class="headerlink" title="哈希操作命令"></a>哈希操作命令</h3><ul><li><code>HSET key field value</code>：将哈希表 key 中的字段 field 的值设为 value</li><li><code>HGET key field</code>：获取存储在哈希表中指定字段的值</li><li><code>HDEL key field</code>：删除存储在哈希表中的指定字段</li><li><code>HKEYS key</code>：获取哈希表中所有字段</li><li><code>HVALS key</code>：获取哈希表中所有值</li></ul><h3 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h3><ul><li><code>LPUSH key value1 [value2]</code>：将一个或多个值插入到列表头部(左边)</li><li><code>LRANGE key start stop</code>：获取列表指定范围内的元素</li><li><code>RPOP key</code>：移除并获取列表最后一个元素(右边)</li><li><code>LLEN key</code>：获取列表长度</li></ul><h3 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h3><ul><li><code>SADD key member1 [member2]</code>：向集合添加一个或多个成员</li><li><code>SMEMBERS key</code>：返回集合中的所有成员</li><li><code>SCARD key</code>：获取集合的成员数</li><li><code>SINTER key1 [key2]</code>：返回给定所有集合的交集</li><li><code>SUNION key1 [key2]</code>：返回所有给定集合的并集</li><li><code>SREM key member1 [member2]</code>：删除集合中一个或多个成员</li></ul><h3 id="有序集合操作命令"><a href="#有序集合操作命令" class="headerlink" title="有序集合操作命令"></a>有序集合操作命令</h3><ul><li><code>ZADD key score1 member1 [score2 member2]</code>：向有序集合添加一个或多个成员</li><li><code>ZRANGE key start stop [WITHSCORES]</code>：通过索引区间返回有序集合中指定区间内的成员</li><li><code>ZINCRBY key increment member</code>：有序集合中对指定成员的分数加上增量increment</li><li><code>ZREM key member [member ...]</code>：移除有序集合中的一个或多个成员</li></ul><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li><code>KEYS pattern</code>：查找所有符合给定模式(pattern)的key </li><li><code>EXISTS key</code>：检查给定key是否存在</li><li><code>TYPE key</code>：返回key所储存的值的类型</li><li><code>DEL key</code>：该命令用于在key存在时删除 key</li></ul><h2 id="在Java中操作Redis"><a href="#在Java中操作Redis" class="headerlink" title="在Java中操作Redis"></a>在Java中操作Redis</h2><p>Redis的Java客户端很多，常用的有：<u>Jedis</u>、<u>Lettuce</u>、<u><strong>Spring Data Redis</strong></u></p><p>其中Spring Data Redis是Spring的一部分，对Redis底层开发包进行了高度封装。在Spring项目中，可以使用Spring Data Redis来简化操作。</p><h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><ol><li>导入Spring Data Redis的maven坐标</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置Redis数据源</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;lty.redis.host&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;lty.redis.port&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;lty.redis.database&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>编写配置类，创建RedisTemplate对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer将key序列化，避免乱码</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>通过RedisTemplate对象操作Redis</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishService dishService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;DishVO&gt;&gt; <span class="title function_">test</span><span class="params">(Long categoryId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + categoryId;</span><br><span class="line">        List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(list != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// redis中存在数据，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> Result.success(list);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 否则从数据库中查数据</span></span><br><span class="line">        <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dish</span>();</span><br><span class="line">        dish.setCategoryId(categoryId);</span><br><span class="line">        dish.setStatus(StatusConstant.ENABLE);</span><br><span class="line">        list = dishService.listWithFlavor(dish);</span><br><span class="line">        <span class="comment">// 查出来的数据加入到redis中</span></span><br><span class="line">        redisTemplate.opsForValue().set(key, list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Data-Redis使用方式"><a href="#Spring-Data-Redis使用方式" class="headerlink" title="Spring Data Redis使用方式"></a>Spring Data Redis使用方式</h2><p>RedisTemplate针对大量api进行了归类封装,将同一数据类型的操作封装为对应的Operation接口，具体分类如下：</p><ul><li>ValueOperations：string类型数据操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：hash类型的数据操作</li><li>ListOperations：list类型的数据操作</li></ul><h3 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h3><p><code>set void set(K key, V value)</code>：添加获取数据</p><p><code>set void set(K key, V value, long timeout, TimeUnit unit)</code>：设置数据有效期</p><blockquote><p>TimeUnit.DAYS          &#x2F;&#x2F;天<br>TimeUnit.HOURS         &#x2F;&#x2F;小时<br>TimeUnit.MINUTES       &#x2F;&#x2F;分钟<br>TimeUnit.SECONDS       &#x2F;&#x2F;秒<br>TimeUnit.MILLISECONDS  &#x2F;&#x2F;毫秒</p></blockquote><p><code>set void set(K key, V value, long offset)</code>:根据key设置value指定下标字符</p><p><code>get V get(Object key)</code>:Get操作</p><p><code>getAndSet V getAndSet(K key, V value)</code>:设置键的字符串值并返回其旧值</p><p><code>append Integer append(K key, String value)</code>:根据key拼接value的值，如果被拼接的key没值则为空字符串</p><p><code>size Long size(K key)</code>:根据key获取value的长度</p><h3 id="List操作"><a href="#List操作" class="headerlink" title="List操作"></a>List操作</h3><p><code>Long size(K key)</code>:返回存储在键中的列表的长度。如果键不存在，则将其解释为空列表，并返回0。当key存储的值不是列表时返回错误。</p><p><code>Long leftPush(K key, V value)</code>:（从左边插入）将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。</p><p><code>Long leftPushAll(K key, V... values)</code>:（从左边插入）批量把一个数组插入到列表中</p><p><code>Long rightPush(K key, V value)</code>:（从右边插入）将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。（从右边插入）</p><p><code>Long rightPushAll(K key, V... values)</code>:（从右边插入）批量把一个数组插入到列表中</p><p><code>void set(K key, long index, V value)</code>:在列表中index的位置设置value值</p><p><code>Long remove(K key, long count, Object value)</code>:从存储在键中的列表中删除等于值的元素的第一个计数事件。</p><blockquote><p>计数参数以下列方式影响操作：<br>count&gt; 0：删除等于从头到尾移动的值的元素。<br>count &lt;0：删除等于从尾到头移动的值的元素。<br>count &#x3D; 0：删除等于value的所有元素。 </p></blockquote><p><code>V index(K key, long index)</code>:根据下标获取列表中的值，下标是从0开始的，-1为获取全部</p><p><code>V leftPop(K key)</code>:弹出最左边的元素</p><p><code>V rightPop(K key)</code>:弹出最右边的元素</p><h3 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h3><p><code>Long delete(H key, Object... hashKeys)</code>:删除给定的哈希hashKeys</p><p><code>Boolean hasKey(H key, Object hashKey)</code>:判断哈希hashKey是否存在</p><p><code>HV get(H key, Object hashKey)</code>:从键中的哈希获取给定hashKey的值</p><p><code>Set keys(H key)</code>:获取key所对应的散列表的key</p><p><code>Long size(H key)</code>:获取key所对应的散列表的大小个数</p><p><code>void putAll(H key, Map&lt;? extends HK, ? extends HV&gt; m)</code>:使用m中提供的多个散列字段设置到key对应的散列表中</p><p><code>void put(H key, HK hashKey, HV value)</code>:设置散列hashKey的值</p><p><code>List values(H key)</code>:获取整个哈希存储的值根据密钥</p><p><code>Map&lt;HK, HV&gt; entries(H key)</code>:获取整个哈希存储根据密钥</p><p><code>Cursor&lt;Map.Entry&lt;HK, HV&gt;&gt; scan(H key, ScanOptions options)</code>:使用Cursor在key的hash中迭代，相当于迭代器。</p><h3 id="Set操作"><a href="#Set操作" class="headerlink" title="Set操作"></a>Set操作</h3><p><code>Long add(K key, V... values)</code>:无序集合中添加元素，返回添加个数也可以直接在add里面添加多个值 如：template.opsForSet().add(“setTest”,”aaa”,”bbb”)</p><p><code>Long remove(K key, Object... values)</code>:移除集合中一个或多个成员</p><p><code>V pop(K key)</code>:移除并返回集合中的一个随机元素</p><p><code>Boolean move(K key, V value, K destKey)</code>:将 member 元素从 source 集合移动到 destination 集合</p><p><code>Long size(K key)</code>:无序集合的大小长度</p><p><code>et members(K key)</code>:返回集合中的所有成员</p><p><code>Cursor scan(K key, ScanOptions options)</code>:遍历set</p><h3 id="ZSet操作"><a href="#ZSet操作" class="headerlink" title="ZSet操作"></a>ZSet操作</h3><p><code>Boolean add(K key, V value, double score)</code>:新增一个有序集合，存在的话为false，不存在的话为true</p><p><code>Long add(K key, Set&lt;TypedTuple&gt; tuples)</code>:新增一个有序集合</p><p><code>Long remove(K key, Object... values)</code>:从有序集合中移除一个或者多个元素</p><p><code>Long rank(K key, Object o)</code>:返回有序集中指定成员的排名，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Set range(K key, long start, long end)</code>:通过索引区间返回有序集合成指定区间内的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Long count(K key, double min, double max)</code>:通过分数返回有序集合指定区间内的成员个数</p><p><code>Long size(K key)</code>:获取有序集合的成员数，内部调用的就是zCard方法</p><p><code>Double score(K key, Object o)</code>:获取指定成员的score值</p><p><code>Long removeRange(K key, long start, long end)</code>:移除指定索引位置的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Cursor&lt;TypedTuple&gt; scan(K key, ScanOptions options)</code>:遍历zset</p><h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>Spring Cache 是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。</p><p>它提供了一层抽象，底层可以切换不同的缓存实现，例如：</p><ul><li>EHCache</li><li>Caffeine</li><li>Redis</li></ul><p>需要引入Maven坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@EnableCaching</td><td align="center">开启缓存注解功能，通常加在启动类上</td></tr><tr><td align="center">@Cacheable(cacheNames&#x3D;”数据库名”,key&#x3D;”存储的键”)</td><td align="center">在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td align="center">@CachePut</td><td align="center">将方法的返回值放到缓存中</td></tr><tr><td align="center">@CacheEvict(cacheNames &#x3D; “数据库名”,[allEntries(是否全部删除) &#x3D; true],key &#x3D; “要删除的键”)</td><td align="center">将一条或多条数据从缓存中删除</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-Plus</title>
      <link href="/inori/1276cc28.html"/>
      <url>/inori/1276cc28.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://baomidou.com/">MyBatis-Plus</a>是<a href="https://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生</p><p>特性：</p><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><p>支持数据库：</p><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库，优炫数据库</li></ul><h2 id="MyBatis-Plus核心功能"><a href="#MyBatis-Plus核心功能" class="headerlink" title="MyBatis-Plus核心功能"></a>MyBatis-Plus核心功能</h2><h3 id="基于Mapper接口CRUD"><a href="#基于Mapper接口CRUD" class="headerlink" title="基于Mapper接口CRUD"></a>基于Mapper接口CRUD</h3><blockquote><p>通用 CRUD 封装BaseMapper接口，<code>Mybatis-Plus</code>启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器! 内部包含常见的单表操作！</p></blockquote><h4 id="Insert方法"><a href="#Insert方法" class="headerlink" title="Insert方法"></a>Insert方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="comment">// T 就是要插入的实体对象</span></span><br><span class="line"><span class="comment">// 默认主键生成策略为雪花算法（后面讲解）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>T</td><td>entity</td><td>实体对象</td></tr></tbody></table><h4 id="Delete方法"><a href="#Delete方法" class="headerlink" title="Delete方法"></a>Delete方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>Wrapper<T></T></td><td>wrapper</td><td>实体对象封装操作类（可以为 null）</td></tr><tr><td>Collection&lt;? extends Serializable&gt;</td><td>idList</td><td>主键 ID 列表(不能为 null 以及 empty)</td></tr><tr><td>Serializable</td><td>id</td><td>主键 ID</td></tr><tr><td>Map&lt;String, Object&gt;</td><td>columnMap</td><td>表字段 map 对象</td></tr></tbody></table><h4 id="Update方法"><a href="#Update方法" class="headerlink" title="Update方法"></a>Update方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, </span></span><br><span class="line"><span class="params"><span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 修改  主键属性必须值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>T</td><td>entity</td><td>实体对象 (set 条件值,可为 null)</td></tr><tr><td>Wrapper<T></T></td><td>updateWrapper</td><td>实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</td></tr></tbody></table><h4 id="Select方法"><a href="#Select方法" class="headerlink" title="Select方法"></a>Select方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><p>参数说明</p><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>Serializable</td><td>id</td><td>主键 ID</td></tr><tr><td>Wrapper<T></T></td><td>queryWrapper</td><td>实体对象封装操作类（可以为 null）</td></tr><tr><td>Collection&lt;? extends Serializable&gt;</td><td>idList</td><td>主键 ID 列表(不能为 null 以及 empty)</td></tr><tr><td>Map&lt;String, Object&gt;</td><td>columnMap</td><td>表字段 map 对象</td></tr><tr><td>IPage<T></T></td><td>page</td><td>分页查询条件（可以为 RowBounds.DEFAULT）</td></tr></tbody></table><h4 id="自定义和多表映射"><a href="#自定义和多表映射" class="headerlink" title="自定义和多表映射"></a>自定义和多表映射</h4><p>mybatis-plus的默认mapperxml位置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> <span class="comment"># mybatis-plus的配置</span></span><br><span class="line"><span class="comment"># 默认位置 private String[] mapperLocations = new String[]&#123;&quot;classpath*:/mapper/**/*.xml&quot;&#125;;    </span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>自定义mapper方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常自定义方法！</span></span><br><span class="line"><span class="comment">//可以使用注解@Select或者mapper.xml实现</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于mapper.xml实现：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace = 接口的全限定符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于Service接口CRUD"><a href="#基于Service接口CRUD" class="headerlink" title="基于Service接口CRUD"></a>基于Service接口CRUD</h3><p>通用 Service CRUD 封装<a href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java">IService (opens new window)</a>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</p><h4 id="对比Mapper接口CRUD区别："><a href="#对比Mapper接口CRUD区别：" class="headerlink" title="对比Mapper接口CRUD区别："></a>对比Mapper接口CRUD区别：</h4><ul><li>service添加了批量方法</li><li>service层的方法自动添加事务</li></ul><h4 id="使用Iservice接口方式"><a href="#使用Iservice接口方式" class="headerlink" title="使用Iservice接口方式"></a>使用Iservice接口方式</h4><p>接口继承IService接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类继承ServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CRUD方法介绍"><a href="#CRUD方法介绍" class="headerlink" title="CRUD方法介绍"></a>CRUD方法介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">保存：</span><br><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">修改或者保存：</span><br><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">移除：</span><br><span class="line"><span class="comment">// 根据 queryWrapper 设置的条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">更新：</span><br><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">数量： </span><br><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">查询：</span><br><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line">集合：</span><br><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分页查询实现"><a href="#分页查询实现" class="headerlink" title="分页查询实现"></a>分页查询实现</h3><ol><li>导入分页插件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用分页查询</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置分页参数</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//获取分页数据</span></span><br><span class="line">    List&lt;User&gt; list = page.getRecords();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页：&quot;</span>+page.getCurrent());</span><br><span class="line">    System.out.println(<span class="string">&quot;每页显示的条数：&quot;</span>+page.getSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span>+page.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span>+page.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有上一页：&quot;</span>+page.hasPrevious());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有下一页：&quot;</span>+page.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义的mapper方法使用分页</li></ol><p>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数携带Ipage接口</span></span><br><span class="line"><span class="comment">//返回结果为IPage</span></span><br><span class="line">IPage&lt;User&gt; <span class="title function_">selectPageVo</span><span class="params">(IPage&lt;?&gt; page, Integer id)</span>;</span><br></pre></td></tr></table></figure><p>接口实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectPageVo&quot;</span> resultType=<span class="string">&quot;xxx.xxx.xxx.User&quot;</span>&gt;</span><br><span class="line">SELECT * FROM user WHERE id &gt; #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    userMapper.selectPageVo(page,<span class="number">2</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> page.getCurrent();</span><br><span class="line">    System.out.println(<span class="string">&quot;current = &quot;</span> + current);</span><br><span class="line">    <span class="type">long</span> <span class="variable">pages</span> <span class="operator">=</span> page.getPages();</span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + pages);</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();</span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + total);</span><br><span class="line">    <span class="type">List</span> <span class="variable">records</span> <span class="operator">=</span> page.getRecords();</span><br><span class="line">    System.out.println(<span class="string">&quot;records = &quot;</span> + records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件构造器使用"><a href="#条件构造器使用" class="headerlink" title="条件构造器使用"></a>条件构造器使用</h3><h4 id="条件构造器作用"><a href="#条件构造器作用" class="headerlink" title="条件构造器作用"></a>条件构造器作用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>); <span class="comment">// 添加等于条件</span></span><br><span class="line">queryWrapper.ne(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>); <span class="comment">// 添加不等于条件</span></span><br><span class="line">queryWrapper.like(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;@gmail.com&quot;</span>); <span class="comment">// 添加模糊匹配条件</span></span><br><span class="line">等同于： </span><br><span class="line">delete from user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;John&quot;</span> and age != <span class="number">30</span></span><br><span class="line">and email like <span class="string">&quot;%@gmail.com%&quot;</span></span><br><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure><p>使用MyBatis-Plus的条件构造器，你可以构建灵活、高效的查询条件，而不需要手动编写复杂的 SQL 语句。它提供了许多方法来支持各种条件操作符，并且可以通过链式调用来组合多个条件。这样可以简化查询的编写过程，并提高开发效率。</p><h4 id="条件构造器继承结构"><a href="#条件构造器继承结构" class="headerlink" title="条件构造器继承结构"></a>条件构造器继承结构</h4><p>Wrapper：条件构造抽象类，最顶端父类</p><ul><li>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件</li><li>QueryWrapper ： 查询&#x2F;删除条件封装</li><li>UpdateWrapper ： 修改条件封装</li><li>AbstractLambdaWrapper ： 使用Lambda 语法</li><li>LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper</li><li>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</li></ul><h4 id="基于QueryWrapper-组装条件"><a href="#基于QueryWrapper-组装条件" class="headerlink" title="基于QueryWrapper 组装条件"></a>基于QueryWrapper 组装条件</h4><p>组装查询条件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息</span></span><br><span class="line"><span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    .between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">    .isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装排序条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//按年龄降序查询用户，如果年龄相同则按id升序排列</span></span><br><span class="line"><span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">    .orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    .orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装删除条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//删除email为空的用户</span></span><br><span class="line"><span class="comment">//DELETE FROM t_user WHERE (email IS NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="comment">//条件构造器也可以构建删除语句的条件</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and和or关键字使用(修改)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改</span></span><br><span class="line"><span class="comment">//UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL)</span></span><br><span class="line">    queryWrapper</span><br><span class="line">    .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    .gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    .or()</span><br><span class="line">    .isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定列映射查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//查询用户信息的username和age字段</span></span><br><span class="line"><span class="comment">//SELECT username,age FROM t_user</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="comment">//selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>condition判断组织条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//判断条件拼接</span></span><br><span class="line">    <span class="comment">//当name不为null拼接等于, age &gt; 1 拼接等于判断</span></span><br><span class="line">    <span class="comment">//方案1: 手动判断</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(name))&#123;</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方案2: 拼接condition判断</span></span><br><span class="line">    <span class="comment">//每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!</span></span><br><span class="line">    <span class="comment">//eq(condition,列名,值)</span></span><br><span class="line">    queryWrapper.eq(!StringUtils.isEmpty(name),<span class="string">&quot;name&quot;</span>,name)</span><br><span class="line">    .eq(age&gt;<span class="number">1</span>,<span class="string">&quot;age&quot;</span>,age);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于UpdateWrapper组装条件"><a href="#基于UpdateWrapper组装条件" class="headerlink" title="基于UpdateWrapper组装条件"></a>基于UpdateWrapper组装条件</h4><p>使用queryWrapper + 实体类形式可以实现修改，但是无法将列值修改为null值！</p><p>使用updateWrapper:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将id = 3 的email设置为null, age = 18</span></span><br><span class="line">updateWrapper.eq(<span class="string">&quot;id&quot;</span>,<span class="number">3</span>)</span><br><span class="line">.set(<span class="string">&quot;email&quot;</span>,<span class="literal">null</span>)  <span class="comment">// set 指定列和结果</span></span><br><span class="line">.set(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="comment">//如果使用updateWrapper 实体对象写null即可!</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用updateWrapper可以随意设置列的值！！</p><h4 id="基于LambdaQueryWrapper组装条件"><a href="#基于LambdaQueryWrapper组装条件" class="headerlink" title="基于LambdaQueryWrapper组装条件"></a>基于LambdaQueryWrapper组装条件</h4><ol><li><strong>LambdaQueryWrapper对比QueryWrapper优势</strong></li></ol><p>QueryWrapper 示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>)</span><br><span class="line">.ge(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">.orderByDesc(<span class="string">&quot;create_time&quot;</span>)</span><br><span class="line">.last(<span class="string">&quot;limit 10&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure><p>LambdaQueryWrapper 示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">lambdaQueryWrapper.eq(User::getName, <span class="string">&quot;John&quot;</span>)</span><br><span class="line">.ge(User::getAge, <span class="number">18</span>)</span><br><span class="line">.orderByDesc(User::getCreateTime)</span><br><span class="line">.last(<span class="string">&quot;limit 10&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(lambdaQueryWrapper);</span><br></pre></td></tr></table></figure><p>从上面的代码对比可以看出，相比于 QueryWrapper，LambdaQueryWrapper 使用了实体类的属性引用（例如 <code>User::getName</code>、<code>User::getAge</code>），而不是字符串来表示字段名，这提高了代码的可读性和可维护性。</p><ol start="2"><li><strong>lambda表达式</strong></li></ol><p>Lambda 表达式是 Java 8 引入的一种函数式编程特性，它提供了一种更简洁、更直观的方式来表示匿名函数或函数式接口的实现。Lambda 表达式可以用于简化代码，提高代码的可读性和可维护性。</p><p>Lambda 表达式的语法可以分为以下几个部分：</p><ul><li><strong>参数列表：</strong> 参数列表用小括号 <code>()</code> 括起来，可以指定零个或多个参数。如果没有参数，可以省略小括号；如果只有一个参数，可以省略小括号。</li></ul><p>示例：<code>(a, b)</code>, <code>x -&gt;</code>, <code>() -&gt;</code></p><ul><li><strong>箭头符号：</strong> 箭头符号 <code>-&gt;</code> 分割参数列表和 Lambda 表达式的主体部分。</li></ul><p>示例：<code>-&gt;</code></p><ul><li><strong>Lambda 表达式的主体：</strong> Lambda 表达式的主体部分可以是一个表达式或一个代码块。如果是一个表达式，可以省略 return 关键字；如果是多条语句的代码块，需要使用大括号 <code>&#123;&#125;</code> 括起来，并且需要明确指定 return 关键字。</li></ul><p>示例：</p><ul><li>单个表达式：<code>x -&gt; x * x</code></li><li>代码块：<code>(x, y) -&gt; &#123; int sum = x + y; return sum; &#125;</code></li></ul><p>Lambda 表达式的语法可以更具体地描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式实现一个接口的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始匿名内部类方式</span></span><br><span class="line"><span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a-&gt;System.out.println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lambda 表达式实现接口的方法</span></span><br><span class="line">greeting = () -&gt; System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out::println;</span><br><span class="line">() -&gt;  类.XXX(); -&gt; 类：：方法名</span><br><span class="line"><span class="comment">// 调用接口的方法</span></span><br><span class="line">greeting.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 方法引用:</strong></p><p>方法引用是 Java 8 中引入的一种语法特性，它提供了一种简洁的方式来直接引用已有的方法或构造函数。方法引用可以替代 Lambda 表达式，使代码更简洁、更易读。</p><p>Java 8 支持以下几种方法引用的形式：</p><ul><li><p><strong>静态方法引用：</strong> 引用静态方法，语法为 <code>类名::静态方法名</code>。</p></li><li><p><strong>实例方法引用：</strong> 引用实例方法，语法为 <code>实例对象::实例方法名</code>。</p></li><li><p><strong>对象方法引用：</strong> 引用特定对象的实例方法，语法为 <code>类名::实例方法名</code>。</p></li><li><p><strong>构造函数引用：</strong> 引用构造函数，语法为 <code>类名::new</code>。</p></li></ul><p>演示代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReferenceExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">        names.forEach(name -&gt; System.out.println(name));</span><br><span class="line">        <span class="comment">// 使用方法引用</span></span><br><span class="line">        names.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. lambdaQueryWrapper使用案例:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">int</span>    <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!</span></span><br><span class="line">    <span class="comment">//eq(condition,列名,值)</span></span><br><span class="line">    queryWrapper.eq(!StringUtils.isEmpty(name),<span class="string">&quot;name&quot;</span>,name)</span><br><span class="line">    .eq(age&gt;<span class="number">1</span>,<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 使用lambdaQueryWrapper</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//注意: 需要使用方法引用</span></span><br><span class="line">    <span class="comment">//技巧: 类名::方法名</span></span><br><span class="line">    lambdaQueryWrapper.eq(!StringUtils.isEmpty(name), User::getName,name);</span><br><span class="line">    List&lt;User&gt; users= userMapper.selectList(lambdaQueryWrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于LambdaUpdateWrapper组装条件"><a href="#基于LambdaUpdateWrapper组装条件" class="headerlink" title="基于LambdaUpdateWrapper组装条件"></a>基于LambdaUpdateWrapper组装条件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将id = 3 的email设置为null, age = 18</span></span><br><span class="line">updateWrapper.eq(<span class="string">&quot;id&quot;</span>,<span class="number">3</span>)</span><br><span class="line">.set(<span class="string">&quot;email&quot;</span>,<span class="literal">null</span>)  <span class="comment">// set 指定列和结果</span></span><br><span class="line">.set(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambdaUpdateWrapper</span></span><br><span class="line">LambdaUpdateWrapper&lt;User&gt; updateWrapper1 = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">updateWrapper1.eq(User::getId,<span class="number">3</span>)</span><br><span class="line">.set(User::getEmail,<span class="literal">null</span>)</span><br><span class="line">.set(User::getAge,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用updateWrapper 实体对象写null即可!</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心注解使用"><a href="#核心注解使用" class="headerlink" title="核心注解使用"></a>核心注解使用</h3><ol><li>理解和介绍</li></ol><p>MyBatis-Plus是一个基于MyBatis框架的增强工具，提供了一系列简化和增强的功能，用于加快开发人员在使用MyBatis进行数据库访问时的效率。</p><p>MyBatis-Plus提供了一种基于注解的方式来定义和映射数据库操作，其中的注解起到了重要作用。</p><p>理解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口对应的方法为什么会自动触发 user表的crud呢？</p><p>默认情况下， 根据指定的&lt;实体类&gt;的名称对应数据库表名，属性名对应数据库的列名！</p><p>但是不是所有数据库的信息和实体类都完全映射！</p><p>例如： 表名 t_user  → 实体类 User 这时候就不对应了！</p><p>自定义映射关系就可以使用mybatis-plus提供的注解即可！<br>2. @TableName注解</p><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span> <span class="comment">//对应数据库表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊情况：如果表名和实体类名相同（忽略大小写）可以省略该注解！</p><p>其他解决方案：<a href="https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">全局设置前缀</a></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> <span class="comment"># mybatis-plus的配置</span></span><br><span class="line"><span class="attr">global-config:</span></span><br><span class="line"><span class="attr">db-config:</span></span><br><span class="line"><span class="attr">table-prefix:</span> <span class="string">sys_</span> <span class="comment"># 表名前缀字符串</span></span><br></pre></td></tr></table></figure><ol start="3"><li>@TableId 注解</li></ol><ul><li>描述：主键注解</li><li>使用位置：实体类主键字段</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@TableId(value=&quot;主键列名&quot;,type=主键策略)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>类型</th><th>必须指定</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>主键字段名</td></tr><tr><td>type</td><td>Enum</td><td>否</td><td>IdType.NONE</td><td>指定主键类型</td></tr></tbody></table><p><a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/IdType.java">IdType</a>属性可选值：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>AUTO</td><td>数据库 ID 自增 (mysql配置主键自增长)</td></tr><tr><td>ASSIGN_ID（默认）</td><td>分配 ID(主键类型为 Number(Long )或 String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td></tr></tbody></table><p>全局配置修改主键策略:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">configuration:</span><br><span class="line"># 配置MyBatis日志</span><br><span class="line">log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">global-config:</span><br><span class="line">db-config:</span><br><span class="line"># 配置MyBatis-Plus操作表的默认前缀</span><br><span class="line">table-prefix: t_</span><br><span class="line"># 配置MyBatis-Plus的主键策略</span><br><span class="line">id-type: auto</span><br></pre></td></tr></table></figure><p>在以下场景下，添加<code>@TableId</code>注解是必要的：</p><ol><li>实体类的字段与数据库表的主键字段不同名：如果实体类中的字段与数据库表的主键字段不一致，需要使用<code>@TableId</code>注解来指定实体类中表示主键的字段。</li><li>主键生成策略不是默认策略：如果需要使用除了默认主键生成策略以外的策略，也需要添加<code>@TableId</code>注解，并通过<code>value</code>属性指定生成策略。</li><li>雪花算法使用场景</li></ol><p>雪花算法（Snowflake Algorithm）是一种用于生成唯一ID的算法。它由Twitter公司提出，用于解决分布式系统中生成全局唯一ID的需求。</p><p>在传统的自增ID生成方式中，使用单点数据库生成ID会成为系统的瓶颈，而雪花算法通过在分布式系统中生成唯一ID，避免了单点故障和性能瓶颈的问题。</p><p>雪花算法生成的ID是一个64位的整数，由以下几个部分组成：</p><ol><li>时间戳：41位，精确到毫秒级，可以使用69年。</li><li>节点ID：10位，用于标识分布式系统中的不同节点。</li><li>序列号：12位，表示在同一毫秒内生成的不同ID的序号。</li></ol><p>通过将这三个部分组合在一起，雪花算法可以在分布式系统中生成全局唯一的ID，并保证ID的生成顺序性。</p><p>雪花算法的工作方式如下：</p><ol><li>当前时间戳从某一固定的起始时间开始计算，可以用于计算ID的时间部分。</li><li>节点ID是分布式系统中每个节点的唯一标识，可以通过配置或自动分配的方式获得。</li><li>序列号用于记录在同一毫秒内生成的不同ID的序号，从0开始自增，最多支持4096个ID生成。</li></ol><p>需要注意的是，雪花算法依赖于系统的时钟，需要确保系统时钟的准确性和单调性，否则可能会导致生成的ID不唯一或不符合预期的顺序。</p><p>雪花算法是一种简单但有效的生成唯一ID的算法，广泛应用于分布式系统中，如微服务架构、分布式数据库、分布式锁等场景，以满足全局唯一标识的需求。</p><p>雪花算法生成的数字,需要使用Long 或者 String类型主键<br>5. @TableField</p><p>描述：字段注解（非主键）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@TableId</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="meta">@TableField(&quot;nickname&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MyBatis-Plus会自动开启驼峰命名风格映射</strong></p><h2 id="MyBatis-Plus高级扩展"><a href="#MyBatis-Plus高级扩展" class="headerlink" title="MyBatis-Plus高级扩展"></a>MyBatis-Plus高级扩展</h2><h3 id="逻辑删除实现"><a href="#逻辑删除实现" class="headerlink" title="逻辑删除实现"></a>逻辑删除实现</h3><p><strong>概念:</strong></p><p>逻辑删除，可以方便地实现对数据库记录的逻辑删除而不是物理删除。逻辑删除是指通过更改记录的状态或添加标记字段来模拟删除操作，从而保留了删除前的数据，便于后续的数据分析和恢复。</p><ul><li>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</li><li>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</li></ul><p><strong>逻辑删除实现:</strong></p><ol><li>数据库和实体类添加逻辑删除字段</li><li>表添加逻辑删除字段</li></ol><p>可以是一个布尔类型、整数类型或枚举类型。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> deleted <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> ;  # <span class="type">int</span> 类型 <span class="number">1</span> 逻辑删除 <span class="number">0</span> 未逻辑删除</span><br></pre></td></tr></table></figure><ol start="2"><li>实体类添加逻辑删除属性</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line">public class <span class="keyword">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="variable">@TableId</span></span><br><span class="line">private <span class="type">Integer</span> id;</span><br><span class="line">private String name;</span><br><span class="line">private <span class="type">Integer</span> age;</span><br><span class="line">private String email;</span><br><span class="line"></span><br><span class="line"><span class="variable">@TableLogic</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>逻辑删除字段 <span class="type">int</span> mybatis<span class="operator">-</span>plus下,默认 逻辑删除值为<span class="number">1</span> 未逻辑删除 <span class="number">1</span> </span><br><span class="line">private <span class="type">Integer</span> deleted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>指定逻辑删除字段和属性值</li><li>单一指定</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line">public class <span class="keyword">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="variable">@TableId</span></span><br><span class="line">private <span class="type">Integer</span> id;</span><br><span class="line">private String name;</span><br><span class="line">private <span class="type">Integer</span> age;</span><br><span class="line">private String email;</span><br><span class="line"><span class="variable">@TableLogic</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>逻辑删除字段 <span class="type">int</span> mybatis<span class="operator">-</span>plus下,默认 逻辑删除值为<span class="number">1</span> 未逻辑删除 <span class="number">1</span> </span><br><span class="line">private <span class="type">Integer</span> deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>全局指定</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"><span class="attr">global-config:</span></span><br><span class="line"><span class="attr">db-config:</span></span><br><span class="line"><span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line"><span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line"><span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><h4 id="悲观锁和乐观锁场景和介绍"><a href="#悲观锁和乐观锁场景和介绍" class="headerlink" title="悲观锁和乐观锁场景和介绍"></a>悲观锁和乐观锁场景和介绍</h4><p><strong>并发问题场景演示:</strong></p><p><img src="https://secure2.wostatic.cn/static/nWoVTstK7jnH8ida2Urujn/image.png?auth_key=1711513165-swYv5xUT1t4HAcN64ZBD7D-0-aa35481fb137c5a1fb50a1488ffff7bf"></p><p>​    </p><p>**解决思路: **</p><p>乐观锁和悲观锁是在并发编程中用于处理并发访问和资源竞争的两种不同的锁机制!!</p><p>悲观锁:<br>悲观锁的基本思想是，在整个数据访问过程中，将共享资源锁定，以确保其他线程或进程不能同时访问和修改该资源。悲观锁的核心思想是”先保护，再修改”。在悲观锁的应用中，线程在访问共享资源之前会获取到锁，并在整个操作过程中保持锁的状态，阻塞其他线程的访问。只有当前线程完成操作后，才会释放锁，让其他线程继续操作资源。这种锁机制可以确保资源独占性和数据的一致性，但是在高并发环境下，悲观锁的效率相对较低。</p><p>乐观锁:<br>乐观锁的基本思想是，认为并发冲突的概率较低，因此不需要提前加锁，而是在数据更新阶段进行冲突检测和处理。乐观锁的核心思想是”先修改，后校验”。在乐观锁的应用中，线程在读取共享资源时不会加锁，而是记录特定的版本信息。当线程准备更新资源时，会先检查该资源的版本信息是否与之前读取的版本信息一致，如果一致则执行更新操作，否则说明有其他线程修改了该资源，需要进行相应的冲突处理。乐观锁通过避免加锁操作，提高了系统的并发性能和吞吐量，但是在并发冲突较为频繁的情况下，乐观锁会导致较多的冲突处理和重试操作。</p><p>理解点: 悲观锁和乐观锁是两种解决并发数据问题的思路</p><p><strong>具体技术和方案:</strong></p><ol><li>乐观锁实现方案和技术：</li></ol><ul><li>版本号&#x2F;时间戳：为数据添加一个版本号或时间戳字段，每次更新数据时，比较当前版本号或时间戳与期望值是否一致，若一致则更新成功，否则表示数据已被修改，需要进行冲突处理。</li><li>CAS（Compare-and-Swap）：使用原子操作比较当前值与旧值是否一致，若一致则进行更新操作，否则重新尝试。</li><li>无锁数据结构：采用无锁数据结构，如无锁队列、无锁哈希表等，通过使用原子操作实现并发安全。</li></ul><ol start="2"><li>悲观锁实现方案和技术：</li></ol><ul><li>锁机制：使用传统的锁机制，如互斥锁（Mutex Lock）或读写锁（Read-Write Lock）来保证对共享资源的独占访问。</li><li>数据库锁：在数据库层面使用行级锁或表级锁来控制并发访问。</li><li>信号量（Semaphore）：使用信号量来限制对资源的并发访问。</li></ul><p><strong>介绍版本号乐观锁技术的实现流程:</strong></p><ul><li>每条数据添加一个版本号字段version</li><li>取出记录时，获取当前 version</li><li>更新时，检查获取版本号是不是数据库当前最新版本号</li><li>如果是[证明没有人修改数据], 执行更新, set 数据更新 , version &#x3D; version+ 1 </li><li>如果 version 不对[证明有人已经修改了]，我们现在的其他记录就是失效数据!就更新失败</li></ul><h4 id="使用mybatis-plus数据使用乐观锁"><a href="#使用mybatis-plus数据使用乐观锁" class="headerlink" title="使用mybatis-plus数据使用乐观锁"></a>使用mybatis-plus数据使用乐观锁</h4><ol><li>添加版本号更新插件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乐观锁字段添加@Version注解</p><p>注意: 数据库也需要添加version字段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER ADD VERSION INT DEFAULT <span class="number">1</span> ;  # <span class="type">int</span> 类型 乐观锁字段</span><br></pre></td></tr></table></figure><ul><li>支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime</li><li>仅支持 <code>updateById(id)</code> 与 <code>update(entity, wrapper)</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure><ol start="2"><li>正常更新使用即可</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示乐观锁生效场景</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//步骤1: 先查询,在更新 获取version数据</span></span><br><span class="line">    <span class="comment">//同时查询两条,但是version唯一,最后更新的失败</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span>  <span class="operator">=</span> userMapper.selectById(<span class="number">5</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span>  <span class="operator">=</span> userMapper.selectById(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user1.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">    <span class="comment">//乐观锁生效,失败!</span></span><br><span class="line">    userMapper.updateById(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防全表更新和删除实现"><a href="#防全表更新和删除实现" class="headerlink" title="防全表更新和删除实现"></a>防全表更新和删除实现</h3><p>针对 update 和 delete 语句 作用: 阻止恶意的全表更新删除</p><p>添加防止全表更新和删除拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试全部更新或者删除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick8</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;custom_name&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;xxx@mail.com&quot;</span>);</span><br><span class="line">    <span class="comment">//Caused by: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: Prohibition of table update operation</span></span><br><span class="line">    <span class="comment">//全局更新,报错</span></span><br><span class="line">    userService.saveOrUpdate(user,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向工程和MybatisX插件"><a href="#逆向工程和MybatisX插件" class="headerlink" title="逆向工程和MybatisX插件"></a>逆向工程和MybatisX插件</h2><h3 id="ORM思维介绍"><a href="#ORM思维介绍" class="headerlink" title="ORM思维介绍"></a>ORM思维介绍</h3><p>ORM（Object-Relational Mapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作!!</p><p>最终<strong>可以使用面向对象思维进行数据库操作</strong></p><p><strong>ORM 框架通常有半自动和全自动两种方式</strong></p><ul><li>半自动 ORM 通常需要程序员手动编写 SQL 语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。</li><li>全自动 ORM 则是将实体类和数据表进行自动映射，使用 API 进行数据库操作时，ORM 框架会自动执行 SQL 语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL 语句和转换代码。</li></ul><p><strong>半自动和全自动 ORM 框架的区别：</strong></p><ol><li>映射方式：半自动 ORM 框架需要程序员手动指定实体类和数据表之间的映射关系，通常使用 XML 文件或注解方式来指定；全自动 ORM 框架则可以自动进行实体类和数据表的映射，无需手动干预。</li><li>查询方式：半自动 ORM 框架通常需要程序员手动编写 SQL 语句并将查询结果集转换成实体对象；全自动 ORM 框架可以自动组装 SQL 语句、执行查询操作，并将查询结果转换成实体对象。</li><li>性能：由于半自动 ORM 框架需要手动编写 SQL 语句，因此程序员必须对 SQL 语句和数据库的底层知识有一定的了解，才能编写高效的 SQL 语句；而全自动 ORM 框架通过自动优化生成的 SQL 语句来提高性能，程序员无需进行优化。</li><li>学习成本：半自动 ORM 框架需要程序员手动编写 SQL 语句和映射配置，要求程序员具备较高的数据库和 SQL 知识；全自动 ORM 框架可以自动生成 SQL 语句和映射配置，程序员无需了解过多的数据库和 SQL 知识。</li></ol><p>常见的半自动 ORM 框架包括 MyBatis 等；常见的全自动 ORM 框架包括 Hibernate、Spring Data JPA、MyBatis-Plus 等。</p><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>MyBatis 的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml 文件、Mapper 接口等代码文件，简化了开发者手动生成的过程。逆向工程使开发者可以快速地构建起 DAO 层，并快速上手进行业务开发。<br>MyBatis 的逆向工程有两种方式：通过 MyBatis Generator 插件实现和通过 Maven 插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接 URL、用户名、密码、要生成的表名、生成的文件路径等等。<br>总的来说，逆向工程为程序员提供了一种方便快捷的方式，能够快速地生成持久层代码和映射文件，是半自动 ORM 思维像全自动发展的过程，提高程序员的开发效率。</p><p>逆向工程只能生成单表crud的操作，多表查询依然需要自己编写！</p><h3 id="逆向工程插件MyBatisX使用"><a href="#逆向工程插件MyBatisX使用" class="headerlink" title="逆向工程插件MyBatisX使用"></a>逆向工程插件MyBatisX使用</h3><p>MyBatisX 是一个 MyBatis 的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo 类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤：</p><ol><li>安装插件：</li></ol><p>在 IntelliJ IDEA 中打开插件市场，搜索 MyBatisX 并安装。<br>2. 使用 IntelliJ IDEA连接数据库</p><ul><li><p>连接数据库</p></li><li><p>逆向工程使用</p></li></ul><p><img src="https://secure2.wostatic.cn/static/s6LMYQtxCLAQ86ScJS5Kam/image.png?auth_key=1711513456-irs5D2suoMaDcbvLMLPAvw-0-6770defa442ddcfaf7713d246a720652"></p><p>逆向工程案例使用,自动生成单表的crud方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> 针对表【user】的数据库操作Mapper</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertSelective</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">User <span class="title function_">selectByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateByPrimaryKeySelective</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot3框架入门</title>
      <link href="/inori/21ae6bf2.html"/>
      <url>/inori/21ae6bf2.html</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot3介绍"><a href="#SpringBoot3介绍" class="headerlink" title="SpringBoot3介绍"></a>SpringBoot3介绍</h2><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.introducing-spring-boot">SpringBoot</a>帮我们简单、快速地创建一个独立的、生产级别的 <strong>Spring应用（说明：SpringBoot底层是Spring）</strong>，大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术</p><p>SpringBoot的主要目标是：</p><ul><li>为所有 Spring 开发提供更快速、可广泛访问的入门体验。</li><li>开箱即用，设置合理的默认值，但是也可以根据需求进行适当的调整。</li><li>提供一系列大型项目通用的非功能性程序（如嵌入式服务器、安全性、指标、运行检查等）。</li><li>约定大于配置，基本不需要主动编写配置类、也不需要 XML 配置文件。</li></ul><p><strong>总结：简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。</strong></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><blockquote><p>场景：浏览器发送**&#x2F;hello**请求，返回”<strong>Hello,Spring Boot 3!</strong>“</p></blockquote><ol><li><p>开发步骤</p><ol><li><strong>创建Maven工程</strong></li><li><strong>添加依赖(springboot父工程依赖 , web启动器依赖)</strong></li><li><strong>编写启动引导类(springboot项目运行的入口)</strong></li><li><strong>编写处理器Controller</strong></li><li><strong>启动项目</strong></li></ol></li><li><p>创建项目</p></li><li><p>添加依赖</p></li></ol><ul><li>添加父工程坐标</li></ul><p>SpringBoot可以帮我们方便的管理项目依赖 , 在Spring Boot提供了一个名为<strong>spring-boot-starter-parent</strong>的工程，里面已经对各种常用依赖的版本进行了管理，需要以这个项目为父工程，这样就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标(不需要添加版本)即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--所有springboot项目都必须继承自 spring-boot-starter-parent--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加web启动器</li></ul><p>为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的<strong>自动配置依赖</strong>，我们称为<strong>启动器</strong>。因为是web项目，这里引入web启动器，在pom.xml文件中加入如下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--web开发的场景启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>创建package和启动类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@SpringBootApplication</span>是一个特殊的注解，用于标识一个Spring Boot应用程序的入口类。它的主要作用是将三个常用注解组合在一起，简化了配置的过程。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 具体而言，<span class="doctag">@SpringBootApplication</span>注解包含以下三个注解的功能：</span></span><br><span class="line"><span class="comment">*     <span class="doctag">@Configuration</span>：将该类标识为应用程序的配置类。它允许使用Java代码定义和配置Bean。</span></span><br><span class="line"><span class="comment">*     <span class="doctag">@EnableAutoConfiguration</span>：启用Spring Boot的自动配置机制。它根据项目的依赖项自动配置Spring应用程序的行为。自动配置根据类路径、注解和配置属性等条件来决定要使用的功能和配置。</span></span><br><span class="line"><span class="comment">*     <span class="doctag">@ComponentScan</span>：自动扫描并加载应用程序中的组件，如控制器、服务、存储库等。它默认扫描<span class="doctag">@SpringBootApplication</span>注解所在类的包及其子包中的组件。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用<span class="doctag">@SpringBootApplication</span>注解，可以将上述三个注解的功能集中在一个注解上，简化了配置文件的编写和组件的加载和扫描过程。它是Spring Boot应用程序的入口点，标识了应用程序的主类，</span></span><br><span class="line"><span class="comment">* 并告诉Spring Boot在启动时应如何配置和加载应用程序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SpringApplication.run() 方法是启动 Spring Boot 应用程序的关键步骤。它创建应用程序上下文、</span></span><br><span class="line"><span class="comment">// 自动配置应用程序、启动应用程序，并处理命令行参数，使应用程序能够运行和提供所需的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(MainApplication.class,args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>编写处理器Controller</p><p>IoC和DI注解需要在启动类的同包或者子包下方可生效，无需指定，约束俗称。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot 3!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>为什么依赖不需要写版本？</li></ol><ul><li>每个boot项目都有一个父项目<code>spring-boot-starter-parent</code></li><li>parent的父项目是<code>spring-boot-dependencies</code></li><li>父项目 <strong>版本仲裁中心</strong>，把所有常见的jar的依赖版本都声明好了。</li></ul><ol start="2"><li>启动器(Starter)</li></ol><p>Spring Boot提供了一种叫做Starter的概念，它是一组预定义的依赖项集合，旨在简化Spring应用程序的配置和构建过程。Starter包含了一组相关的依赖项，以便在启动应用程序时自动引入所需的库、配置和功能。</p><p>主要作用如下：</p><ol><li>简化依赖管理：Spring Boot Starter通过捆绑和管理一组相关的依赖项，减少了手动解析和配置依赖项的工作。只需引入一个相关的Starter依赖，即可获取应用程序所需的全部依赖。</li><li>自动配置：Spring Boot Starter在应用程序启动时自动配置所需的组件和功能。通过根据类路径和其他设置的自动检测，Starter可以自动配置Spring Bean、数据源、消息传递等常见组件，从而使应用程序的配置变得简单和维护成本降低。</li><li>提供约定优于配置：Spring Boot Starter遵循“约定优于配置”的原则，通过提供一组默认设置和约定，减少了手动配置的需要。它定义了标准的配置文件命名约定、默认属性值、日志配置等，使得开发者可以更专注于业务逻辑而不是繁琐的配置细节。</li><li>快速启动和开发应用程序：Spring Boot Starter使得从零开始构建一个完整的Spring Boot应用程序变得容易。它提供了主要领域（如Web开发、数据访问、安全性、消息传递等）的Starter，帮助开发者快速搭建一个具备特定功能的应用程序原型。</li><li>模块化和可扩展性：Spring Boot Starter的组织结构使得应用程序的不同模块可以进行分离和解耦。每个模块可以有自己的Starter和依赖项，使得应用程序的不同部分可以按需进行开发和扩展。</li></ol><p>Spring Boot提供了许多预定义的Starter，例如spring-boot-starter-web用于构建Web应用程序，spring-boot-starter-data-jpa用于使用JPA进行数据库访问，spring-boot-starter-security用于安全认证和授权等等。</p><p>使用Starter非常简单，只需要在项目的构建文件（例如Maven的pom.xml）中添加所需的Starter依赖，Spring Boot会自动处理依赖管理和配置。</p><p>通过使用Starter，开发人员可以方便地引入和配置应用程序所需的功能，避免了手动添加大量的依赖项和编写冗长的配置文件的繁琐过程。同时，Starter也提供了一致的依赖项版本管理，确保依赖项之间的兼容性和稳定性。</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">spring boot提供的全部启动器</a></p><p>命名规范：</p><ul><li>官方提供的场景：命名为：<code>spring-boot-starter-*</code></li><li>第三方提供场景：命名为：<code>*-spring-boot-starter</code></li></ul><ol start="3"><li>@SpringBootApplication注解的功效？</li></ol><p>@SpringBootApplication添加到启动类上，是一个组合注解，他的功效有具体的子注解实现！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br></pre></td></tr></table></figure><p>@SpringBootApplication注解是Spring Boot框架中的核心注解，它的主要作用是简化和加速Spring Boot应用程序的配置和启动过程。</p><p>具体而言，@SpringBootApplication注解起到以下几个主要作用：</p><ol><li>自动配置：@SpringBootApplication注解包含了@EnableAutoConfiguration注解，用于启用Spring Boot的自动配置机制。自动配置会根据应用程序的依赖项和类路径，自动配置各种常见的Spring配置和功能，减少开发者的手动配置工作。它通过智能地分析类路径、加载配置和条件判断，为应用程序提供适当的默认配置。</li><li>组件扫描：@SpringBootApplication注解包含了@ComponentScan注解，用于自动扫描并加载应用程序中的组件，例如控制器（Controllers）、服务（Services）、存储库（Repositories）等。它默认会扫描@SpringBootApplication注解所在类的包及其子包中的组件，并将它们纳入Spring Boot应用程序的上下文中，使它们可被自动注入和使用。</li><li>声明配置类：@SpringBootApplication注解本身就是一个组合注解，它包含了@Configuration注解，将被标注的类声明为配置类。配置类可以包含Spring框架相关的配置、Bean定义，以及其他的自定义配置。通过@SpringBootApplication注解，开发者可以将配置类与启动类合并在一起，使得配置和启动可以同时发生。</li></ol><p>总的来说，@SpringBootApplication注解的主要作用是简化Spring Boot应用程序的配置和启动过程。它自动配置应用程序、扫描并加载组件，并将配置和启动类合二为一，简化了开发者的工作量，提高了开发效率。</p><h2 id="SpringBoot3配置文件"><a href="#SpringBoot3配置文件" class="headerlink" title="SpringBoot3配置文件"></a>SpringBoot3配置文件</h2><h3 id="统一配置管理概述"><a href="#统一配置管理概述" class="headerlink" title="统一配置管理概述"></a>统一配置管理概述</h3><p>SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（<code>application.properties</code>或<code>application.yml</code>）中！</p><p>配置文件应该放置在Spring Boot工程的<code>src/main/resources</code>目录下。这是因为<code>src/main/resources</code>目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">功能配置参数说明</a></p><p>细节总结：</p><ul><li>集中式管理配置。统一在一个文件完成程序功能参数设置和自定义参数声明 。</li><li>位置：resources文件夹下，必须命名application  后缀 .properties &#x2F; .yaml &#x2F;  .yml 。</li><li>如果同时存在application.properties | application.yml(.yaml) , properties的优先级更高。</li><li>配置基本都有默认值。</li></ul><h3 id="属性配置文件使用"><a href="#属性配置文件使用" class="headerlink" title="属性配置文件使用"></a>属性配置文件使用</h3><ol><li>配置文件</li></ol><p>在 resource 文件夹下面新建 application.properties 配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># application.properties 为统一配置文件</span><br><span class="line"># 内部包含: 固定功能的key,自定义的key</span><br><span class="line"># 此处的配置信息,我们都可以在程序中@Value等注解读取</span><br><span class="line"></span><br><span class="line"># 固定的key</span><br><span class="line"># 启动端口号</span><br><span class="line">server.port=80 </span><br><span class="line"></span><br><span class="line"># 自定义</span><br><span class="line">spring.jdbc.datasource.driverClassName=com.mysql.cj.jdbc.driver</span><br><span class="line">spring.jdbc.datasource.url=jdbc:mysql:///springboot</span><br><span class="line">spring.jdbc.datasource.username=root</span><br><span class="line">spring.jdbc.datasource.password=root</span><br></pre></td></tr></table></figure><ol start="2"><li>读取配置文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.driverClassName&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.url&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.password&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试效果</li></ol><p>在controller注入，输出进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSourceProperties dataSourceProperties ;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(dataSourceProperties);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello Spring Boot ! &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="YAML配置文件使用"><a href="#YAML配置文件使用" class="headerlink" title="YAML配置文件使用"></a>YAML配置文件使用</h3><ol><li>yaml格式介绍</li></ol><p>YAML（YAML Ain’t Markup Language）是一种基于层次结构的数据序列化格式，旨在提供一种易读、人类友好的数据表示方式。</p><p>与<code>.properties</code>文件相比，YAML格式有以下优势：</p><ul><li>层次结构：YAML文件使用缩进和冒号来表示层次结构，使得数据之间的关系更加清晰和直观。这样可以更容易理解和维护复杂的配置，特别适用于深层次嵌套的配置情况。</li><li>自我描述性：YAML文件具有自我描述性，字段和值之间使用冒号分隔，并使用缩进表示层级关系。这使得配置文件更易于阅读和理解，并且可以减少冗余的标点符号和引号。</li><li>注释支持：YAML格式支持注释，可以在配置文件中添加说明性的注释，使配置更具可读性和可维护性。相比之下，<code>.properties</code>文件不支持注释，无法提供类似的解释和说明。</li><li>多行文本：YAML格式支持多行文本的表示，可以更方便地表示长文本或数据块。相比之下，<code>.properties</code>文件需要使用转义符或将长文本拆分为多行。</li><li>类型支持：YAML格式天然支持复杂的数据类型，如列表、映射等。这使得在配置文件中表示嵌套结构或数据集合更加容易，而不需要进行额外的解析或转换。</li><li>更好的可读性：由于YAML格式的特点，它更容易被人类读懂和解释。它减少了配置文件中需要的特殊字符和语法，让配置更加清晰明了，从而减少了错误和歧义。</li></ul><p>综上所述，YAML格式相对于<code>.properties</code>文件具有更好的层次结构表示、自我描述性、注释支持、多行文本表示、复杂数据类型支持和更好的可读性。这些特点使YAML成为一种有力的配置文件格式，尤其适用于复杂的配置需求和人类可读的场景。然而，选择使用YAML还是<code>.properties</code>取决于实际需求和团队的偏好，简单的配置可以使用<code>.properties</code>，而复杂的配置可以选择YAML以获得更多的灵活性和可读性<br>2. yaml语法说明</p><ol><li>数据结构用树形结构呈现，通过缩进来表示层级，</li><li>连续的项目（集合）通过减号 ” - ” 来表示</li><li>键值结构里面的key&#x2F;value对用冒号 ” : ” 来分隔。</li><li>YAML配置文件的扩展名是yaml 或 yml</li><li>例如：</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># YAML配置文件示例</span></span><br><span class="line"><span class="attr">app_name:</span> <span class="string">我的应用程序</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">张三</span></span><br><span class="line"></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5432</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">password123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">features:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">登录</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">注册</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">仪表盘</span></span><br><span class="line"></span><br><span class="line"><span class="attr">settings:</span></span><br><span class="line">    <span class="attr">analytics:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">theme:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">jdbc:</span></span><br><span class="line">        <span class="attr">datasource:</span></span><br><span class="line">            <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">            <span class="attr">url:</span> <span class="string">jdbc:mysql:///springboot_02</span></span><br><span class="line">            <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">            <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><ol start="4"><li>读取配置文件</li></ol><p>读取方式和properties一致</p><h3 id="批量配置文件注入"><a href="#批量配置文件注入" class="headerlink" title="批量配置文件注入"></a>批量配置文件注入</h3><blockquote><p> <strong>@ConfigurationProperties</strong>是SpringBoot提供的重要注解, 他可以将一些配置属性批量注入到bean对象。</p></blockquote><ol><li>创建类，添加属性和注解</li></ol><p>在类上通过@ConfigurationProperties注解声明该类要读取属性配置</p><p>prefix&#x3D;”spring.jdbc.datasource” 读取属性文件中前缀为spring.jdbc.datasource的值。前缀和属性名称和配置文件中的key必须要保持一致才可以注入成功</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.jdbc.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfigurationProperties</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><ol start="2"><li>测试效果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceProperties dataSourceProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceConfigurationProperties dataSourceConfigurationProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dataSourceProperties = &quot;</span> + dataSourceProperties);</span><br><span class="line">        System.out.println(<span class="string">&quot;dataSourceConfigurationProperties = &quot;</span> + dataSourceConfigurationProperties);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot 3!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多环境配置和使用"><a href="#多环境配置和使用" class="headerlink" title="多环境配置和使用"></a>多环境配置和使用</h3><ol><li>需求</li></ol><p>在Spring Boot中，可以使用多环境配置来根据不同的运行环境（如开发、测试、生产）加载不同的配置。SpringBoot支持多环境配置让应用程序在不同的环境中使用不同的配置参数，例如数据库连接信息、日志级别、缓存配置等。</p><p>以下是实现Spring Boot多环境配置的常见方法：</p><ol><li>属性文件分离：将应用程序的配置参数分离到不同的属性文件中，每个环境对应一个属性文件。例如，可以创建<code>application-dev.properties</code>、<code>application-prod.properties</code>和<code>application-test.properties</code>等文件。在这些文件中，可以定义各自环境的配置参数，如数据库连接信息、端口号等。然后，在<code>application.properties</code>中通过<code>spring.profiles.active</code>属性指定当前使用的环境。Spring Boot会根据该属性来加载对应环境的属性文件，覆盖默认的配置。</li><li>YAML配置文件：与属性文件类似，可以将配置参数分离到不同的YAML文件中，每个环境对应一个文件。例如，可以创建<code>application-dev.yml</code>、<code>application-prod.yml</code>和<code>application-test.yml</code>等文件。在这些文件中，可以使用YAML语法定义各自环境的配置参数。同样，通过<code>spring.profiles.active</code>属性指定当前的环境，Spring Boot会加载相应的YAML文件。</li><li>命令行参数(动态)：可以通过命令行参数来指定当前的环境。例如，可以使用<code>--spring.profiles.active=dev</code>来指定使用开发环境的配置。</li></ol><p>通过上述方法，Spring Boot会根据当前指定的环境来加载相应的配置文件或参数，从而实现多环境配置。这样可以简化在不同环境之间的配置切换，并且确保应用程序在不同环境中具有正确的配置。<br>2. 多环境配置（基于方式b实践）</p><blockquote><p>创建开发、测试、生产三个环境的配置文件</p></blockquote><p>application-dev.yml（开发）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///dev</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p>application-test.yml（测试）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///test</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p>application-prod.yml（生产）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///prod</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><ol start="3"><li>环境激活</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line"><span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><p><strong>注意 :</strong></p><p>如果设置了spring.profiles.active，并且和application有重叠属性，以active设置优先。</p><p>如果设置了spring.profiles.active，和application无重叠属性，application设置依然生效！</p><h2 id="SpringBoot3整合SpringMVC"><a href="#SpringBoot3整合SpringMVC" class="headerlink" title="SpringBoot3整合SpringMVC"></a>SpringBoot3整合SpringMVC</h2><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ol><li>创建程序</li><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-starter-springmvc-03<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        web开发的场景启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建启动类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建实体类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username ;</span><br><span class="line">    <span class="keyword">private</span> String password ;</span><br><span class="line">    <span class="keyword">private</span> Integer age ;</span><br><span class="line">    <span class="keyword">private</span> String sex ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>编写Controller</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;杨过&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        user.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="web相关配置"><a href="#web相关配置" class="headerlink" title="web相关配置"></a>web相关配置</h3><p>位置：application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># web相关的配置</span></span><br><span class="line"><span class="comment"># https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment"># 端口号设置</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># 项目根路径</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/boot</span></span><br></pre></td></tr></table></figure><p>当涉及Spring Boot的Web应用程序配置时，以下是五个重要的配置参数：</p><ol><li><code>server.port</code>: 指定应用程序的HTTP服务器端口号。默认情况下，Spring Boot使用8080作为默认端口。您可以通过在配置文件中设置<code>server.port</code>来更改端口号。</li><li><code>server.servlet.context-path</code>: 设置应用程序的上下文路径。这是应用程序在URL中的基本路径。默认情况下，上下文路径为空。您可以通过在配置文件中设置<code>server.servlet.context-path</code>属性来指定自定义的上下文路径。</li><li><code>spring.mvc.view.prefix</code>和<code>spring.mvc.view.suffix</code>: 这两个属性用于配置视图解析器的前缀和后缀。视图解析器用于解析控制器返回的视图名称，并将其映射到实际的视图页面。<code>spring.mvc.view.prefix</code>定义视图的前缀，<code>spring.mvc.view.suffix</code>定义视图的后缀。</li><li><code>spring.resources.static-locations</code>: 配置静态资源的位置。静态资源可以是CSS、JavaScript、图像等。默认情况下，Spring Boot会将静态资源放在<code>classpath:/static</code>目录下。您可以通过在配置文件中设置<code>spring.resources.static-locations</code>属性来自定义静态资源的位置。</li><li><code>spring.http.encoding.charset</code>和<code>spring.http.encoding.enabled</code>: 这两个属性用于配置HTTP请求和响应的字符编码。<code>spring.http.encoding.charset</code>定义字符编码的名称（例如UTF-8），<code>spring.http.encoding.enabled</code>用于启用或禁用字符编码的自动配置。</li></ol><p>这些是在Spring Boot的配置文件中与Web应用程序相关的一些重要配置参数。根据您的需求，您可以在配置文件中设置这些参数来定制和配置您的Web应用程序</p><h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><blockquote><p>在WEB开发中我们需要引入一些静态资源 , 例如 : HTML , CSS , JS , 图片等 , 如果是普通的项目静态资源可以放在项目的webapp目录下。现在使用Spring Boot做开发 , 项目中没有webapp目录 , 我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？</p></blockquote><ol><li>默认路径</li></ol><p>在springboot中就定义了静态资源的默认查找路径：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web;</span><br><span class="line"><span class="comment">//..................</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> String[] staticLocations;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> addMappings;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> customized;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Chain chain;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Resources</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line"><span class="built_in">this</span>.addMappings = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.customized = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">this</span>.chain = <span class="keyword">new</span> <span class="title class_">Chain</span>();</span><br><span class="line"><span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="title class_">Cache</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...........        </span></span><br></pre></td></tr></table></figure><p><strong>默认的静态资源路径为：</strong></p><p><strong>· classpath:&#x2F;META-INF&#x2F;resources&#x2F;</strong></p><p><strong>· classpath:&#x2F;resources&#x2F;</strong></p><p><strong>· classpath:&#x2F;static&#x2F;</strong></p><p><strong>· classpath:&#x2F;public&#x2F;</strong></p><p>我们只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:&#x2F;static&#x2F; 目录下。在resources目录下创建index.html文件</p><ol start="2"><li>覆盖路径</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># web相关的配置</span></span><br><span class="line"><span class="comment"># https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment"># 端口号设置</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># 项目根路径</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/boot</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="comment"># 配置静态资源地址,如果设置,会覆盖默认值</span></span><br><span class="line"><span class="attr">static-locations:</span> <span class="string">classpath:/webapp</span></span><br></pre></td></tr></table></figure><h3 id="自定义拦截器-SpringMVC配置"><a href="#自定义拦截器-SpringMVC配置" class="headerlink" title="自定义拦截器(SpringMVC配置)"></a>自定义拦截器(SpringMVC配置)</h3><ol><li>拦截器声明</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor拦截器的preHandle方法执行....&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor拦截器的postHandle方法执行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor拦截器的afterCompletion方法执行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>拦截器配置</li></ol><p>正常使用配置类，只要保证，<strong>配置类要在启动类的同包或者子包方可生效！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyInterceptor myInterceptor ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* /**  拦截当前目录及子目录下的所有路径 /user/**   /user/findAll  /user/order/findAll</span></span><br><span class="line"><span class="comment">* /*   拦截当前目录下的以及子路径   /user/*     /user/findAll</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">registry.addInterceptor(myInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot3整合Druid数据源"><a href="#SpringBoot3整合Druid数据源" class="headerlink" title="SpringBoot3整合Druid数据源"></a>SpringBoot3整合Druid数据源</h2><ol><li>创建程序</li><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-starter-druid-04<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  web开发的场景启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid启动器的依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 驱动类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>配置文件编写</li></ol><blockquote><p>添加druid连接池的基本配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="comment"># 连接池类型 </span></span><br><span class="line"><span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Druid的其他属性配置 springboot3整合情况下,数据库连接信息必须在Druid属性下!</span></span><br><span class="line"><span class="attr">druid:</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/day01</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># 初始化时建立物理连接的个数</span></span><br><span class="line"><span class="attr">initial-size:</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># 连接池的最小空闲数量</span></span><br><span class="line"><span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># 连接池最大连接数量</span></span><br><span class="line"><span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line"><span class="comment"># 获取连接时最大等待时间，单位毫秒</span></span><br><span class="line"><span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line"><span class="comment"># 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</span></span><br><span class="line"><span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 既作为检测的间隔时间又作为testWhileIdel执行的依据</span></span><br><span class="line"><span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line"><span class="comment"># 销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接(配置连接在池中的最小生存时间)</span></span><br><span class="line"><span class="attr">min-evictable-idle-time-millis:</span> <span class="number">30000</span></span><br><span class="line"><span class="comment"># 用来检测数据库连接是否有效的sql 必须是一个查询语句(oracle中为 select 1 from dual)</span></span><br><span class="line"><span class="attr">validation-query:</span> <span class="string">select</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line"><span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line"><span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否缓存preparedStatement, 也就是PSCache,PSCache对支持游标的数据库性能提升巨大，比如说oracle,在mysql下建议关闭。</span></span><br><span class="line"><span class="attr">pool-prepared-statements:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</span></span><br><span class="line"><span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">-1</span></span><br><span class="line"><span class="comment"># 合并多个DruidDataSource的监控数据</span></span><br><span class="line"><span class="attr">use-global-data-source-stat:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">level:</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><ol start="5"><li>编写Controller</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users where id = ? ; &quot;</span>;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), <span class="number">1</span>);</span><br><span class="line">log.info(<span class="string">&quot;查询的user数据为:&#123;&#125;&quot;</span>,user.toString());</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>启动测试</li></ol><h2 id="SpringBoot3整合Mybatis"><a href="#SpringBoot3整合Mybatis" class="headerlink" title="SpringBoot3整合Mybatis"></a>SpringBoot3整合Mybatis</h2><h3 id="MyBatis整合步骤"><a href="#MyBatis整合步骤" class="headerlink" title="MyBatis整合步骤"></a>MyBatis整合步骤</h3><ol><li>导入依赖：在Spring Boot项目的构建文件（如pom.xml）中添加MyBatis和数据库驱动的相关依赖。例如，如果使用MySQL数据库，您需要添加MyBatis和MySQL驱动的依赖。</li><li>配置数据源：在<code>application.properties</code>或<code>application.yml</code>中配置数据库连接信息，包括数据库URL、用户名、密码、mybatis的功能配置等。</li><li>创建实体类：创建与数据库表对应的实体类。</li><li>创建Mapper接口：创建与数据库表交互的Mapper接口。</li><li>创建Mapper接口SQL实现:可以使用mapperxml文件或者注解方式</li><li>创建程序启动类</li><li>注解扫描：在Spring Boot的主应用类上添加<code>@MapperScan</code>注解，用于扫描和注册Mapper接口。</li><li>使用Mapper接口：在需要使用数据库操作的地方，通过依赖注入或直接实例化Mapper接口，并调用其中的方法进行数据库操作。</li></ol><h3 id="Mybatis整合实践"><a href="#Mybatis整合实践" class="headerlink" title="Mybatis整合实践"></a>Mybatis整合实践</h3><ol><li>创建项目</li><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid启动器的依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 驱动类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">druid:</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///day01</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">configuration:</span>  <span class="comment"># setting配置</span></span><br><span class="line"><span class="attr">auto-mapping-behavior:</span> <span class="string">full</span></span><br><span class="line"><span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.slf4j.Slf4jImpl</span></span><br><span class="line"><span class="attr">type-aliases-package:</span> <span class="string">pojo</span> <span class="comment"># 配置别名</span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span> <span class="comment"># mapperxml位置</span></span><br></pre></td></tr></table></figure><ol start="4"><li>实体类准备</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String account ;</span><br><span class="line">    <span class="keyword">private</span> String password ;</span><br><span class="line">    <span class="keyword">private</span> Integer id ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>Mapper接口准备</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>Mapper接口实现（XML）</li></ol><p>位置：resources&#x2F;mapper&#x2F;UserMapper.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line"><span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;!-- namespace = 接口的全限定符 --&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;queryAll&quot;</span> resultType=<span class="string">&quot;user&quot;</span>&gt;</span><br><span class="line">select * from users</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>编写三层架构代码</li></ol><p>controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">List&lt;User&gt; userList = userService.findList();</span><br><span class="line">log.info(<span class="string">&quot;查询的user数据为:&#123;&#125;&quot;</span>,userList);</span><br><span class="line"><span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findList</span><span class="params">()</span>&#123;</span><br><span class="line">List&lt;User&gt; users = userMapper.queryAll();</span><br><span class="line">log.info(<span class="string">&quot;查询全部数据:&#123;&#125;&quot;</span>,users);</span><br><span class="line"><span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>启动类和接口扫描</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;mapper&quot;)</span> <span class="comment">//mapper接口扫描配置</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="9"><li>启动测试</li></ol><h3 id="声明式事务整合配置"><a href="#声明式事务整合配置" class="headerlink" title="声明式事务整合配置"></a>声明式事务整合配置</h3><p>依赖导入:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：SpringBoot项目会自动配置一个 DataSourceTransactionManager，所以我们只需在方法（或者类）加上 @Transactional 注解，就自动纳入 Spring 的事务管理了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">1</span>);</span><br><span class="line">user.setPassword(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">user.setAccount(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">userMapper.update(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOP整合配置"><a href="#AOP整合配置" class="headerlink" title="AOP整合配置"></a>AOP整合配置</h3><p>依赖导入:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接使用aop注解即可: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com..service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LogAdvice.before&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;joinPoint = &quot;</span> + joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot3项目打包和运行"><a href="#SpringBoot3项目打包和运行" class="headerlink" title="SpringBoot3项目打包和运行"></a>SpringBoot3项目打包和运行</h2><h3 id="添加打包插件"><a href="#添加打包插件" class="headerlink" title="添加打包插件"></a>添加打包插件</h3><blockquote><p>在Spring Boot项目中添加<code>spring-boot-maven-plugin</code>插件是为了支持将项目打包成可执行的可运行jar包。如果不添加<code>spring-boot-maven-plugin</code>插件配置，使用常规的<code>java -jar</code>命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行打包"><a href="#执行打包" class="headerlink" title="执行打包"></a>执行打包</h3><p>在idea点击package进行打包,可以在编译的target文件中查看jar包</p><h3 id="命令启动和参数说明"><a href="#命令启动和参数说明" class="headerlink" title="命令启动和参数说明"></a>命令启动和参数说明</h3><p><code>java -jar</code>命令用于在Java环境中执行可执行的JAR文件。下面是关于<code>java -jar</code>命令的说明：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">命令格式：java -jar  [选项] [参数] <span class="tag">&lt;<span class="name">jar文件名</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性，可以通过<code>System.getProperty()</code>方法在应用程序中获取该属性值。例如：<code>java -jar -Dserver.port=8080 myapp.jar</code>。</li><li><code>-X</code>：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括：</li></ol><ul><li><code>-Xmx&lt;size&gt;</code>：设置JVM的最大堆内存大小，例如 <code>-Xmx512m</code> 表示设置最大堆内存为512MB。</li><li><code>-Xms&lt;size&gt;</code>：设置JVM的初始堆内存大小，例如 <code>-Xms256m</code> 表示设置初始堆内存为256MB。</li></ul><ol start="3"><li><code>-Dspring.profiles.active=&lt;profile&gt;</code>：指定Spring Boot的激活配置文件，可以通过<code>application-&lt;profile&gt;.properties</code>或<code>application-&lt;profile&gt;.yml</code>文件来加载相应的配置。例如：<code>java -jar -Dspring.profiles.active=dev myapp.jar</code>。</li></ol><p>注意：-D 参数必须要在jar之前！否者不生效！</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC框架入门</title>
      <link href="/inori/faa8450.html"/>
      <url>/inori/faa8450.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">Spring Web MVC</a>是基于Servlet API构建的原始Web框架,SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化</p><p><img src="https://secure2.wostatic.cn/static/bnm9zUQo34z7FgXA9vAmfm/image.png?auth_key=1711510047-qBsPAaHR88tC2aDLqhpekV-0-b3cb1c35742a1e107a3a8c3877ea1ebe"></p><p>SpringMVC的作用主要覆盖的是表述层，例如：</p><ul><li>请求映射</li><li>数据输入</li><li>视图界面</li><li>请求分发</li><li>表单回显</li><li>会话控制</li><li>过滤拦截</li><li>异步交互</li><li>文件上传</li><li>文件下载</li><li>数据校验</li><li>类型转换</li></ul><p><strong>总结：</strong></p><ol><li>简化前端参数接收( 形参列表 )</li><li>简化后端数据响应(返回值)</li><li>以及其他……</li></ol><h2 id="SpringMVC核心组件和调用流程"><a href="#SpringMVC核心组件和调用流程" class="headerlink" title="SpringMVC核心组件和调用流程"></a>SpringMVC核心组件和调用流程</h2><p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code> <code>DispatcherServlet</code> 做整体请求处理调度！</p><p>除了<code>DispatcherServlet</code>SpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。</p><p><strong>SpringMVC处理请求流程：</strong></p><p><img src="https://secure2.wostatic.cn/static/no1PDXU3JX5K4cecSAx5oL/image.png?auth_key=1711510176-53NMzAsNwUn8BfjGcoEv4M-0-fd69e4a59e527b36adecb53b624ec5d2"></p><p><strong>SpringMVC涉及组件理解：</strong></p><ol><li>DispatcherServlet:SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发</li><li>HandlerMapping:SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler</li><li>HandlerAdapter:SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器</li><li>Handler:handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果</li><li>ViewResovler:SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的</li></ol><h2 id="SpringMVC接收数据"><a href="#SpringMVC接收数据" class="headerlink" title="SpringMVC接收数据"></a>SpringMVC接收数据</h2><h3 id="访问路径设置"><a href="#访问路径设置" class="headerlink" title="访问路径设置"></a>访问路径设置</h3><p>@RequestMapping注解的作用就是将请求的URL地址和处理请求的方式（handler方法）关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。</p><ol><li><strong>精准路径匹配</strong></li></ol><p>在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>模糊路径匹配</strong></li></ol><p>在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  路径设置为 /product/*  </span></span><br><span class="line"><span class="comment">*    /* 为单层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">*    /product/a/a 不可以</span></span><br><span class="line"><span class="comment">*  路径设置为 /product/** </span></span><br><span class="line"><span class="comment">*   /** 为任意层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">*   /product/a/a 也可以访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/product/*&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductController.show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;product show!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单层匹配和多层匹配：<br><code>/*</code>：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“&#x2F;*&#x2F;*”以此类推。<br><code>/**</code>：可以匹配URL地址中的多层。<br>其中所谓的一层或多层是指一个URL地址字符串被“&#x2F;”划分出来的各个层次<br>这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。</p><ol start="3"><li><strong>类和方法级别区别</strong></li></ol><p><code>@RequestMapping</code> 注解可以用于类级别和方法级别，它们之间的区别如下：</p><ol><li>设置到类级别：<code>@RequestMapping</code> 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。</li><li>设置到方法级别：<code>@RequestMapping</code> 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 <code>@RequestMapping</code> 注解进行更精细的映射。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.标记到handler方法</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/logout&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.优化标记类+handler方法</span></span><br><span class="line"><span class="comment">//类上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//handler方法上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>附带请求方式限制</strong></li></ol><p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问</p><p>如果需要特定指定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">* method = RequestMethod.POST 可以指定单个或者多个请求方式!</span></span><br><span class="line"><span class="comment">* 注意:违背请求方式会出现405异常!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>进阶注解</strong></li></ol><p>还有 <code>@RequestMapping</code> 的 HTTP 方法特定快捷方式变体：</p><ul><li><code>@GetMapping</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code></li><li><code>@DeleteMapping</code></li><li><code>@PatchMapping</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)</span></span><br><span class="line">||</span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/login&quot;)</span></span><br></pre></td></tr></table></figure><p>注意：进阶注解只能添加到handler方法上，无法添加到类上！</p><h3 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h3><h4 id="param和json参数比较"><a href="#param和json参数比较" class="headerlink" title="param和json参数比较"></a>param和json参数比较</h4><p>在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比：</p><ol><li>参数编码：</li></ol><p>param 类型的参数会被编码为 ASCII 码。例如，假设 <code>name=john doe</code>，则会被编码为 <code>name=john%20doe</code>。而 JSON 类型的参数会被编码为 UTF-8。<br>2. 参数顺序：  </p><p>param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。<br>3. 数据类型：  </p><p>param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。<br>4. 嵌套性：  </p><p>param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。<br>5. 可读性：  </p><p>param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。</p><p>总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p><h4 id="param参数接收"><a href="#param参数接收" class="headerlink" title="param参数接收"></a>param参数接收</h4><ol><li><strong>直接接值</strong></li></ol><p>handler接收参数</p><p>只要形参数名和类型与传递参数相同，即可自动接收!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 可以利用形参列表,直接接收前端传递的param参数!</span></span><br><span class="line"><span class="comment">*    要求: 参数名 = 形参名</span></span><br><span class="line"><span class="comment">*          类型相同</span></span><br><span class="line"><span class="comment">* 出现乱码正常，json接收具体解决！！</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回前端数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@GetMapping(value=&quot;/value&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setupForm</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> name + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>@RequestParam注解</strong></li></ol><p>可以使用 <code>@RequestParam</code> 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p><p><code>@RequestParam</code>使用场景：</p><ul><li>指定绑定的请求参数名</li><li>要求请求参数必须传递</li><li>为请求参数提供默认值</li></ul><p>基本用法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*  使用<span class="doctag">@RequestParam</span>注解标记handler方法的形参</span></span><br><span class="line"><span class="comment">*  指定形参对应的请求参数<span class="doctag">@RequestParam</span>(请求参数名称)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(&quot;stuAge&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，使用此批注的方法参数是必需的，但您可以通过将 <code>@RequestParam</code> 批注的 <code>required</code> 标志设置为 <code>false</code>！</p><p>将参数设置非必须，并且设置默认值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params"><span class="meta">@RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line"><span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>特殊场景接值</strong></li></ol><p>一名多值:多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  一名多值,可以使用集合接收即可!但是需要使用<span class="doctag">@RequestParam</span>注解指定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/mul&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">mulForm</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hbs)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hbs = &quot;</span> + hbs);</span><br><span class="line"><span class="keyword">return</span> hbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体接收:Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。</p><p>定义一个用于接收参数的实体类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制器中，使用实体对象接收，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line"><span class="comment">// 在这里可以使用 user 对象的属性来接收请求参数</span></span><br><span class="line">System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！</p><h4 id="路径参数接收"><a href="#路径参数接收" class="headerlink" title="路径参数接收"></a>路径参数接收</h4><p>路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 <code>@PathVariable</code> 注解来处理路径传递参数。</p><p><code>@PathVariable</code> 注解允许将 URL 中的占位符映射到控制器方法中的参数。</p><p>例如，如果我们想将 <code>/user/&#123;id&#125;</code> 路径下的 <code>&#123;id&#125;</code> 映射到控制器方法的一个参数中，则可以使用 <code>@PathVariable</code> 注解来实现。</p><p>下面是一个使用 <code>@PathVariable</code> 注解处理路径传递参数的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!</span></span><br><span class="line"><span class="comment">* 形参列表取值: <span class="doctag">@PathVariable</span> Long id  如果形参名 = &#123;动态标识&#125; 自动赋值!</span></span><br><span class="line"><span class="comment">*              <span class="doctag">@PathVariable</span>(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, </span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;name&quot;)</span> String uname)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id + <span class="string">&quot;, uname = &quot;</span> + uname);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user_detail&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="json参数接收"><a href="#json参数接收" class="headerlink" title="json参数接收"></a>json参数接收</h4><p>前端传递 JSON 数据时，Spring MVC 框架可以使用 <code>@RequestBody</code> 注解来将 JSON 数据转换为 Java 对象。<code>@RequestBody</code> 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下：</p><ol><li>前端发送 JSON 数据的示例：</li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义一个用于接收 JSON 数据的 Java 类，例如：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在控制器中，使用 <code>@RequestBody</code> 注解来接收 JSON 数据，并将其转换为 Java 对象，例如：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里可以使用 person 对象来操作 JSON 数据中包含的属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>@RequestBody</code> 注解将请求体中的 JSON 数据映射到 <code>Person</code> 类型的 <code>person</code> 参数上，并将其作为一个对象来传递给 <code>addPerson()</code> 方法进行处理。<br>4. 完善配置</p><p>springmvc handlerAdpater配置json转化器,配置类需要明确：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"><span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"><span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"><span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pom.xml 加入jackson依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>@EnableWebMvc注解说明</li></ol><p>@EnableWebMvc注解效果等同于在 XML 配置中，可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 元素</p><h3 id="接收Cookie数据"><a href="#接收Cookie数据" class="headerlink" title="接收Cookie数据"></a>接收Cookie数据</h3><p>可以使用 <code>@CookieValue</code> 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。</p><p>考虑使用以下 cookie 的请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收请求头数据"><a href="#接收请求头数据" class="headerlink" title="接收请求头数据"></a>接收请求头数据</h3><p>可以使用 <code>@RequestHeader</code> 批注将请求标头绑定到控制器中的方法参数。</p><p>请考虑以下带有标头的请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Host                    localhost:<span class="number">8080</span></span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span></span><br><span class="line">Accept-Language         fr,en-gb;q=<span class="number">0.7</span>,en;q=<span class="number">0.3</span></span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line">Keep-Alive              <span class="number">300</span></span><br></pre></td></tr></table></figure><p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span><br><span class="line"><span class="params"><span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="type">long</span> keepAlive)</span> &#123; </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原生Api对象操作"><a href="#原生Api对象操作" class="headerlink" title="原生Api对象操作"></a>原生Api对象操作</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html">https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html</a></p><p>下表描述了支持的控制器方法参数</p><table><thead><tr><th>Controller method argument 控制器方法参数</th><th>Description</th></tr></thead><tbody><tr><td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td><td>请求&#x2F;响应对象</td></tr><tr><td><code>jakarta.servlet.http.HttpSession</code></td><td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td></tr><tr><td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td>用于访问由 Servlet API 公开的原始请求正文。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问由 Servlet API 公开的原始响应正文。</td></tr><tr><td><code>@PathVariable</code></td><td>接收路径参数注解</td></tr><tr><td><code>@RequestParam</code></td><td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestHeader</code></td><td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td></tr><tr><td><code>@CookieValue</code></td><td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestBody</code></td><td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>共享域对象，并在视图呈现过程中向模板公开。</td></tr><tr><td><code>Errors</code>, <code>BindingResult</code></td><td>验证和数据绑定中的错误信息获取对象！</td></tr></tbody></table><p>获取原生对象示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!</span></span><br><span class="line"><span class="comment">* 注意: 接收原生对象,并不影响参数接收!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">api</span><span class="params">(HttpSession session , HttpServletRequest request,</span></span><br><span class="line"><span class="params">    HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;method = &quot;</span> + method);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享域对象操作"><a href="#共享域对象操作" class="headerlink" title="共享域对象操作"></a>共享域对象操作</h3><h4 id="属性（共享）域作用回顾"><a href="#属性（共享）域作用回顾" class="headerlink" title="属性（共享）域作用回顾"></a>属性（共享）域作用回顾</h4><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p><ol><li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。</li><li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。</li><li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。</li><li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li></ol><p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p><h4 id="Request级别属性（共享）域"><a href="#Request级别属性（共享）域" class="headerlink" title="Request级别属性（共享）域"></a>Request级别属性（共享）域</h4><ol><li>使用 Model 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModel</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 在形参位置声明Model类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">Model model)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line"><span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">model.addAttribute(<span class="string">&quot;requestScopeMessageModel&quot;</span>,<span class="string">&quot;i am very happy[model]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 ModelMap 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModelMap</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 在形参位置声明ModelMap类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">ModelMap modelMap)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line"><span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">modelMap.addAttribute(<span class="string">&quot;requestScopeMessageModelMap&quot;</span>,<span class="string">&quot;i am very happy[model map]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 Map 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestMap</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 在形参位置声明Map类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line"><span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">map.put(<span class="string">&quot;requestScopeMessageMap&quot;</span>, <span class="string">&quot;i am very happy[map]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用原生 request 对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/original&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrOriginalRequest</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 拿到原生对象，就可以调用原生方法执行各种操作</span></span><br><span class="line"><span class="params">HttpServletRequest request)</span> &#123;</span><br><span class="line"></span><br><span class="line">request.setAttribute(<span class="string">&quot;requestScopeMessageOriginal&quot;</span>, <span class="string">&quot;i am very happy[original]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用 ModelAndView 对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/mav&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testAttrByModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建ModelAndView对象</span></span><br><span class="line"><span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line"><span class="comment">// 2.存入模型数据</span></span><br><span class="line">modelAndView.addObject(<span class="string">&quot;requestScopeMessageMAV&quot;</span>, <span class="string">&quot;i am very happy[mav]&quot;</span>);</span><br><span class="line"><span class="comment">// 3.设置视图名称</span></span><br><span class="line">modelAndView.setViewName(<span class="string">&quot;target&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Session级别属性（共享）域"><a href="#Session级别属性（共享）域" class="headerlink" title="Session级别属性（共享）域"></a>Session级别属性（共享）域</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/session&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line"><span class="comment">//直接对session对象操作,即对会话范围操作!</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Application级别属性（共享）域"><a href="#Application级别属性（共享）域" class="headerlink" title="Application级别属性（共享）域"></a>Application级别属性（共享）域</h4><p>springmvc会在初始化容器的时候，把servletContext对象存储到ioc容器中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/attr/application&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">attrApplication</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">servletContext.setAttribute(<span class="string">&quot;appScopeMsg&quot;</span>, <span class="string">&quot;i am hungry...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC响应数据"><a href="#SpringMVC响应数据" class="headerlink" title="SpringMVC响应数据"></a>SpringMVC响应数据</h2><h3 id="handler方法分析"><a href="#handler方法分析" class="headerlink" title="handler方法分析"></a>handler方法分析</h3><p>理解handler方法的作用和组成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> 一个controller的方法是控制层的一个处理器,我们称为handler</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> handler需要使用<span class="doctag">@RequestMapping</span>/<span class="doctag">@GetMapping</span>系列,声明路径,在HandlerMapping中注册,供DS查找!</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> handler作用总结:</span></span><br><span class="line"><span class="comment">*       1.接收请求参数(param,json,pathVariable,共享域等) </span></span><br><span class="line"><span class="comment">*       2.调用业务逻辑 </span></span><br><span class="line"><span class="comment">*       3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等)</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> handler如何处理呢</span></span><br><span class="line"><span class="comment">*       1.接收参数: handler(形参列表: 主要的作用就是用来接收参数)</span></span><br><span class="line"><span class="comment">*       2.调用业务: &#123; 方法体  可以向后调用业务方法 service.xx() &#125;</span></span><br><span class="line"><span class="comment">*       3.响应数据: return 返回结果,可以快速响应前端数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handler</span><span class="params">(简化请求参数接收)</span>&#123;</span><br><span class="line">    调用业务方法</span><br><span class="line">    返回的结果 （页面跳转，返回数据（json））</span><br><span class="line">    <span class="keyword">return</span> 简化响应前端数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求数据接收，我们都是通过handler的形参列表</p><p>前端数据响应，我们都是通过handler的return关键字快速处理</p><p>springmvc简化了参数接收和响应</p><h3 id="页面跳转控制"><a href="#页面跳转控制" class="headerlink" title="页面跳转控制"></a>页面跳转控制</h3><h4 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h4><p>在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 <code>redirect</code> 或者 <code>forward</code> 关键字来实现重定向。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirectDemo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 重定向到 /demo 路径 </span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/forward-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forwardDemo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 转发到 /demo 路径</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>将方法的返回值，设置String类型</li><li>转发使用forward关键字，重定向使用redirect关键字</li><li>关键字: &#x2F;路径</li><li>注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！</li></ul><h3 id="返回JSON数据"><a href="#返回JSON数据" class="headerlink" title="返回JSON数据"></a>返回JSON数据</h3><h4 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h4><p>导入jackson依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加json数据转化器</p><p>@EnableWebMvc </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"><span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"><span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"><span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><ol><li>方法上使用@ResponseBody</li></ol><p>可以在方法上使用 <code>@ResponseBody</code>注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，<code>@ResponseBody</code> 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestBody</span> User userParam)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;userParam = &quot;</span> + userParam);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setAge(<span class="number">18</span>);</span><br><span class="line">user.setName(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="comment">//返回的对象,会使用jackson的序列化工具,转成json返回给前端!</span></span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>类上使用@ResponseBody</li></ol><p>如果类中每个方法上都标记了@ResponseBody注解，那么这些注解就可以提取到类上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//responseBody可以添加到类上,代表默认类中的所有方法都生效!</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h4><p>类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解</p><p>RestController源码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">* to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 4.0.1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AliasFor(annotation = Controller.class)</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回静态资源处理"><a href="#返回静态资源处理" class="headerlink" title="返回静态资源处理"></a>返回静态资源处理</h3><ol><li><strong>静态资源概念</strong></li></ol><p>资源本身已经是可以直接拿到浏览器上使用的程度了，<strong>不需要在服务器端做任何运算、处理</strong>。典型的静态资源包括但不限于：</p><ul><li>HTML文件</li><li>图片</li><li>CSS文件</li><li>JavaScript文件</li></ul><ol start="2"><li><strong>静态资源访问问题解决</strong></li></ol><ul><li><p>web应用加入静态资源</p></li><li><p>手动构建确保编译</p></li><li><p>访问静态资源</p></li><li><p>此时访问不到，问题分析：</p><ul><li>DispatcherServlet 的 url-pattern 配置的是“&#x2F;”</li><li>url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理</li><li>对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法</li><li>现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404</li></ul></li></ul><p>在 SpringMVC 配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的问题：其他原本正常的handler请求访问不了了</p><p>解决方案：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器</span><br></pre></td></tr></table></figure><h2 id="RESTFul风格设计和实战"><a href="#RESTFul风格设计和实战" class="headerlink" title="RESTFul风格设计和实战"></a>RESTFul风格设计和实战</h2><p>RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发</p><p>通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件</p><p>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序</p><h3 id="RESTFul风格特点"><a href="#RESTFul风格特点" class="headerlink" title="RESTFul风格特点"></a>RESTFul风格特点</h3><ol><li>每一个URI代表1种资源（URI 是名词）；</li><li>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li><li>资源的表现形式是XML或者<strong>JSON</strong>；</li><li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li></ol><h3 id="RESTFul风格设计规范"><a href="#RESTFul风格设计规范" class="headerlink" title="RESTFul风格设计规范"></a>RESTFul风格设计规范</h3><ol><li><strong>HTTP协议请求方式要求</strong></li></ol><p>REST 风格主张在项目设计、开发过程中，具体的操作符合<strong>HTTP协议定义的请求方式的语义</strong>。</p><table><thead><tr><th>操作</th><th>请求方式</th></tr></thead><tbody><tr><td>查询操作</td><td>GET</td></tr><tr><td>保存操作</td><td>POST</td></tr><tr><td>删除操作</td><td>DELETE</td></tr><tr><td>更新操作</td><td>PUT</td></tr></tbody></table><ol start="2"><li><strong>URL路径风格要求</strong></li></ol><p>REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p><p>使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：GET</td></tr></tbody></table><ul><li>总结</li></ul><p>根据接口的具体动作，选择具体的HTTP协议请求方式</p><p>路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可</p><h2 id="SpringMVC其他扩展"><a href="#SpringMVC其他扩展" class="headerlink" title="SpringMVC其他扩展"></a>SpringMVC其他扩展</h2><h3 id="全局异常处理机制"><a href="#全局异常处理机制" class="headerlink" title="全局异常处理机制"></a>全局异常处理机制</h3><h4 id="异常处理两种方式"><a href="#异常处理两种方式" class="headerlink" title="异常处理两种方式"></a>异常处理两种方式</h4><p>开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。</p><p>对于异常的处理，一般分为两种方式：</p><ul><li>编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</li><li>声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 <code>@Throws</code> 或 <code>@ExceptionHandler</code>），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</li></ul><p>站在宏观角度来看待声明式事务处理：</p><p>整个项目从架构这个层面设计的异常处理的统一机制和规范。</p><p>一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。</p><p>使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！</p><h4 id="基于注解异常声明异常处理"><a href="#基于注解异常声明异常处理" class="headerlink" title="基于注解异常声明异常处理"></a>基于注解异常声明异常处理</h4><ol><li>声明异常处理控制器类</li></ol><p>异常处理控制类，统一定义异常处理handler方法！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* description: 全局异常处理器,内部可以定义异常处理Handler!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@RestControllerAdvice</span> = <span class="doctag">@ControllerAdvice</span> + <span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明异常处理hander方法</li></ol><p>异常处理handler方法和普通的handler方法参数接收和响应都一致！</p><p>只不过异常处理handler方法要映射异常，发生对应的异常会调用！</p><p>普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 异常处理handler </span></span><br><span class="line"><span class="comment">* <span class="doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span></span><br><span class="line"><span class="comment">* 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e 获取异常对象!</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回handler处理结果!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerJsonDateException</span><span class="params">(HttpMessageNotReadableException e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当发生空指针异常会触发此方法!</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerNullException</span><span class="params">(NullPointerException e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 所有异常都会触发此方法!但是如果有具体的异常处理Handler! </span></span><br><span class="line"><span class="comment">* 具体异常处理Handler优先级更高!</span></span><br><span class="line"><span class="comment">* 例如: 发生NullPointerException异常!</span></span><br><span class="line"><span class="comment">*       会触发handlerNullException方法,不会触发handlerException方法!</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件扫描控制器类配置</li></ol><p>确保异常处理控制类被扫描</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;controller&quot;,</span></span><br><span class="line"><span class="meta">&quot;exceptionhandler&quot;&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="拦截器使用"><a href="#拦截器使用" class="headerlink" title="拦截器使用"></a>拦截器使用</h3><p>在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测</p><p><img src="https://secure2.wostatic.cn/static/eBwRN4iKLw9e9DHpVGP4WX/img009.png?auth_key=1711509897-q84g4d16Pi8edgQsgjFxX1-0-e1f8aae4836ccd17e30f941dfd3a90ff"></p><p>拦截器 Springmvc VS 过滤器 javaWeb：</p><ul><li><p>相似点</p><ul><li>拦截：必须先把请求拦住，才能执行后续操作</li><li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul></li><li><p>不同点</p><ul><li>工作平台不同</li><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li><p>拦截的范围</p><ul><li><p>过滤器：能够拦截到的最大范围是整个 Web 应用</p></li><li><p>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</p></li></ul></li><li><p>IOC 容器支持</p><ul><li><p>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</p></li><li><p>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</p></li></ul></li></ul><p>选择：</p><p>功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器</p><p><img src="https://secure-bigfile.wostatic.cn/static/prqG4dtu3rDWj7VwX4WgsW/image.png?auth_key=1711509897-HdeEsMAR2ZKmzeit5j184-0-290313fb34c39d5661341d38a3a72010"></p><h4 id="拦截器使用-1"><a href="#拦截器使用-1" class="headerlink" title="拦截器使用"></a>拦截器使用</h4><ol><li>创建拦截器类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Process01Interceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if( ! preHandler())&#123;return;&#125;</span></span><br><span class="line"><span class="comment">// 在处理请求的目标 handler 方法前执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler);</span><br><span class="line">    System.out.println(<span class="string">&quot;Process01Interceptor.preHandle&quot;</span>);</span><br><span class="line">    <span class="comment">// 返回true：放行</span></span><br><span class="line">    <span class="comment">// 返回false：不放行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在目标 handler 方法之后，handler报错不执行!</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, modelAndView = &quot;</span> + modelAndView);</span><br><span class="line">    System.out.println(<span class="string">&quot;Process01Interceptor.postHandle&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染视图之后执行(最后),一定执行!</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, ex = &quot;</span> + ex);</span><br><span class="line">    System.out.println(<span class="string">&quot;Process01Interceptor.afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器方法拦截位置：</p><p><img src="https://secure2.wostatic.cn/static/9W6TF7dUwqdv2qi4KHAkAr/image.png?auth_key=1711509897-vQhhyorhLrk5H8FZd39JZZ-0-4b9cc18640fe0235a5931bcc1d5a7699"><br>2. 修改配置类添加拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;controller&quot;,&quot;exceptionhandler&quot;&#125;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; </span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>配置详解</li><li>默认拦截全部</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>精准配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line"><span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line"><span class="comment">//也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>排除配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line"><span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//排除匹配,排除应该在匹配的范围内排除</span></span><br><span class="line"><span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line"><span class="comment">//excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>())</span><br><span class="line">.addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>)</span><br><span class="line">.excludePathPatterns(<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>多个拦截器执行顺序</li><li>preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。</li><li>postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。</li><li>afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。</li></ol><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><blockquote><p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p></blockquote><ol><li><strong>校验概述</strong></li></ol><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Null</td><td>标注值必须为 null</td></tr><tr><td>@NotNull</td><td>标注值不可为 null</td></tr><tr><td>@AssertTrue</td><td>标注值必须为 true</td></tr><tr><td>@AssertFalse</td><td>标注值必须为 false</td></tr><tr><td>@Min(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@Max(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@DecimalMin(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@DecimalMax(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@Size(max,min)</td><td>标注值大小必须在 max 和 min 限定的范围内</td></tr><tr><td>@Digits(integer,fratction)</td><td>标注值值必须是一个数字，且必须在可接受的范围内</td></tr><tr><td>@Past</td><td>标注值只能用于日期型，且必须是过去的日期</td></tr><tr><td>@Future</td><td>标注值只能用于日期型，且必须是将来的日期</td></tr><tr><td>@Pattern(value)</td><td>标注值必须符合指定的正则表达式</td></tr></tbody></table><p>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Email</td><td>标注值必须是格式正确的 Email 地址</td></tr><tr><td>@Length</td><td>标注值字符串大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>标注值字符串不能是空字符串</td></tr><tr><td>@Range</td><td>标注值必须在指定的范围内</td></tr></tbody></table><p>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</p><p>配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。<br>2. <strong>操作演示</strong></p><ul><li>导入依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 校验注解实现--&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>应用校验注解</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="comment">//age   1 &lt;=  age &lt; = 150</span></span><br><span class="line"><span class="meta">@Min(10)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//name 3 &lt;= name.length &lt;= 6</span></span><br><span class="line"><span class="meta">@Length(min = 3,max = 10)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//email 邮箱格式</span></span><br><span class="line"><span class="meta">@Email</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>handler标记和绑定错误收集</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Validated</span> 代表应用校验注解! 必须添加!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">save</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user,</span></span><br><span class="line"><span class="params">//在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!</span></span><br><span class="line"><span class="params">BindingResult result)</span>&#123;</span><br><span class="line"><span class="comment">//判断是否有信息绑定错误! 有可以自行处理!</span></span><br><span class="line"><span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> result.getFieldError().toString();</span><br><span class="line"><span class="keyword">return</span> errorMsg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有,正常处理业务即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>易混总结</strong></li></ol><p>@NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p><ol><li>@NotNull  (包装类型不为null)</li></ol><p>@NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。<br>2. @NotEmpty (集合类型长度大于0)</p><p>@NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。<br>3. @NotBlank （字符串，不为null，切不为”  “字符串）</p><p>@NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。</p><p>总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis框架入门</title>
      <link href="/inori/6f411126.html"/>
      <url>/inori/6f411126.html</url>
      
        <content type="html"><![CDATA[<p>​MyBatis是一款优秀的持久层框架，它支持自定义SQL、存储过程以及高级映射。MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作。MyBatis可以通过简单的XML或注解来配置和映射原始类型、接口和Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="向SQL语句传参"><a href="#向SQL语句传参" class="headerlink" title="向SQL语句传参"></a>向SQL语句传参</h3><h4 id="mybatis日志输出配置"><a href="#mybatis日志输出配置" class="headerlink" title="mybatis日志输出配置"></a><strong>mybatis日志输出配置</strong></h4><p>mybatis配置文件设计标签和顶层结构如下：</p><ul><li>configuration（配置）</li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#environments">environments（环境配置）</a></li><li>environment（环境变量）</li><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li></ul><p>我们可以在mybatis的配置文件使用<strong>settings标签</strong>设置，输出运行过程SQL日志，通过查看日志，我们可以判定#{}和${}的输出效果</p><h4 id="形式"><a href="#形式" class="headerlink" title="#{}形式"></a><strong>#{}形式</strong></h4><p>Mybatis会将SQL语句中的<code>#&#123;&#125;</code>转换为问号占位符</p><h4 id="形式-1"><a href="#形式-1" class="headerlink" title="${}形式"></a><strong>${}形式</strong></h4><p><code>$&#123;&#125;</code>形式传参，底层Mybatis做的是字符串拼接操作。通常不会采用<code>$&#123;&#125;</code>的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用<code>$&#123;&#125;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findByColumn</span><span class="params">(<span class="meta">@Param(&quot;column&quot;)</span> String column, </span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;value&quot;)</span> String value)</span>;</span><br></pre></td></tr></table></figure><h3 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h3><h4 id="Mybatis总体机制概括"><a href="#Mybatis总体机制概括" class="headerlink" title="Mybatis总体机制概括"></a><strong>Mybatis总体机制概括</strong></h4><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img005.ebd8c6a3.png"></p><h4 id="单个简单类型参数"><a href="#单个简单类型参数" class="headerlink" title="单个简单类型参数"></a><strong>单个简单类型参数</strong></h4><p>Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee <span class="title function_">selectEmployee</span><span class="params">(Integer empId)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单个简单类型参数，在#{}中可以随意命名，但是没有必要。通常还是使用和接口方法参数同名</p></blockquote><h4 id="实体类类型参数"><a href="#实体类类型参数" class="headerlink" title="实体类类型参数"></a><strong>实体类类型参数</strong></h4><p>Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertEmployee</span><span class="params">(Employee employee)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmployee&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应关系<br><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img006.f9958c52.png"><br>Mybatis会根据#{}中传入的数据，加工成getXxx()方法，通过反射在实体类对象中调用这个方法，从而获取到对应的数据。填充到#{}解析后的问号占位符这个位置</p><h4 id="零散的简单类型数据"><a href="#零散的简单类型数据" class="headerlink" title="零散的简单类型数据"></a><strong>零散的简单类型数据</strong></h4><p>零散的多个简单类型参数，如果没有特殊处理，那么Mybatis无法识别自定义名称,需要在Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">updateEmployee</span><span class="params">(<span class="meta">@Param(&quot;empId&quot;)</span> Integer empId,<span class="meta">@Param(&quot;empSalary&quot;)</span> Double empSalary)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployee&quot;</span>&gt;</span></span><br><span class="line">update t_emp set emp_salary=#&#123;empSalary&#125; where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应关系<br><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img007.976da128.png"></p><h4 id="Map类型参数"><a href="#Map类型参数" class="headerlink" title="Map类型参数"></a><strong>Map类型参数</strong></h4><p>Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">updateEmployeeByMap</span><span class="params">(Map&lt;String, Object&gt; paramMap)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeByMap&quot;</span>&gt;</span></span><br><span class="line">update t_emp set emp_salary=#&#123;empSalaryKey&#125; where emp_id=#&#123;empIdKey&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>junit测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession session;</span><br><span class="line"><span class="comment">//junit5会在每一个@Test方法前执行@BeforeEach方法</span></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">session = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>()</span><br><span class="line">.build(</span><br><span class="line">Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line">.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateEmpNameByMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(EmployeeMapper.class);</span><br><span class="line">Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">&quot;empSalaryKey&quot;</span>, <span class="number">999.99</span>);</span><br><span class="line">paramMap.put(<span class="string">&quot;empIdKey&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.updateEmployeeByMap(paramMap);</span><br><span class="line">log.info(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//junit5会在每一个@Test方法后执行@@AfterEach方法</span></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对应关系</strong>：#{}中写Map中的key<br><strong>使用场景</strong>：有很多零散的参数需要传递，但是没有对应的实体类类型可以使用。使用@Param注解一个一个传入又太麻烦了。所以都封装到Map中。</p><h3 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h3><p>数据输出总体上有两种形式：</p><ul><li>增删改操作返回的受影响行数：直接使用 int 或 long 类型接收即可</li><li>查询操作的查询结果</li></ul><p>我们需要做的是，指定查询的输出数据类型即可</p><h4 id="单个简单类型"><a href="#单个简单类型" class="headerlink" title="单个简单类型"></a>单个简单类型</h4><p>Mapper接口中的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">selectEmpCount</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">select count(*) from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Mybatis 内部给常用的数据类型设定了很多别名。 以 int 类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER 等等。</p></blockquote><p><strong>细节解释：</strong><br>select标签，通过resultType指定查询返回值类型<br>resultType &#x3D; 全限定符 ｜ 别名 ｜ 如果是返回集合类型，写范型类型即可<br>别名问题：<a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases</a><br>类型别名可为Java类型设置一个缩写名字。 它仅用于XML配置，意在降低冗余的全限定类名书写</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当这样配置时，<code>Blog</code>可以用在任何使用domain.blog.Blog的地方，也可以指定一个包名，MyBatis会在包名下面搜索需要的Java Bean，比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span> <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是Mybatis为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_char (since 3.5.10)</td><td>char</td></tr><tr><td>_character (since 3.5.10)</td><td>char</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>char (since 3.5.10)</td><td>Character</td></tr><tr><td>character (since 3.5.10)</td><td>Character</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>biginteger</td><td>BigInteger</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>object[]</td><td>Object[]</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr></tbody></table><h4 id="返回实体类对象Mapper"><a href="#返回实体类对象Mapper" class="headerlink" title="返回实体类对象Mapper"></a>返回实体类对象Mapper</h4><p>接口的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee <span class="title function_">selectEmployee</span><span class="params">(Integer empId)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;</span></span><br><span class="line">select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过给数据库表字段加别名，让查询结果的每一列都和Java实体类中属性对应起来<br>增加全局配置自动识别对应关系，Mybatis全局配置文件中，做了下面的配置，select语句中可以不给字段设置别名</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在全局范围内对Mybatis进行配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="返回主键值"><a href="#返回主键值" class="headerlink" title="返回主键值"></a>返回主键值</h4><ol><li><strong>自增长类型主键</strong></li></ol><p>Mapper接口中的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertEmployee</span><span class="params">(Employee employee)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int insertEmployee(Employee employee); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmployee&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;empId&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp(emp_name,emp_salary)</span><br><span class="line">values(#&#123;empName&#125;,#&#123;empSalary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>junit测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveEmp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">EmployeeMapper</span> <span class="variable">employeeMapper</span> <span class="operator">=</span> session.getMapper(EmployeeMapper.class);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    employee.setEmpName(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">    employee.setEmpSalary(<span class="number">666.66</span>);</span><br><span class="line">    employeeMapper.insertEmployee(employee);</span><br><span class="line">    log.info(<span class="string">&quot;employee.getEmpId() = &quot;</span> + employee.getEmpId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><p>Mybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。<br>2. <strong>非自增长类型主键</strong></p><p>而对于不支持自增型主键的数据库（例如 Oracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用！</p><p>使用 <code>selectKey</code> 帮助插入UUID作为字符串类型主键示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">SELECT UUID() as id</span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    INSERT INTO user (id, username, password) </span><br><span class="line">    VALUES (</span><br><span class="line">    #&#123;id&#125;,</span><br><span class="line">    #&#123;username&#125;,</span><br><span class="line">    #&#123;password&#125;</span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上例中定义了一个<code>insertUser</code>的插入语句来将 <code>User</code> 对象插入到 <code>user</code> 表中。我们使用<code>selectKey</code>来查询 UUID 并设置到 <code>id</code>字段中。</p><p>通过 <code>keyProperty</code> 属性来指定查询到的 UUID 赋值给对象中的 <code>id</code> 属性，而 <code>resultType</code> 属性指定了 UUID 的类型为 <code>java.lang.String</code></p><p>需要注意的是，我们将 <code>selectKey</code> 放在了插入语句的前面，这是因为 MySQL 在 <code>insert</code> 语句中只支持一个 <code>select</code> 子句，而 <code>selectKey</code> 中查询 UUID 的语句就是一个 <code>select</code> 子句，因此我们需要将其放在前面。</p><p>最后，在将<code>User</code>对象插入到 <code>user</code> 表中时，我们直接使用对象中的 <code>id</code> 属性来插入主键值。</p><p>使用这种方式，可以方便地插入 UUID 作为字符串类型主键。</p><h4 id="实体类属性和数据库字段对应关系"><a href="#实体类属性和数据库字段对应关系" class="headerlink" title="实体类属性和数据库字段对应关系"></a>实体类属性和数据库字段对应关系</h4><ol><li>别名对应</li></ol><p>将字段的别名设置成和实体类属性一致。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;</span></span><br><span class="line">select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>关于实体类属性的约定：</p></blockquote><p>getXxx()方法、setXxx()方法把方法名中的get或set去掉，首字母小写。<br>2. 全局配置自动识别驼峰式命名规则</p><p>在Mybatis全局配置文件加入如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SQL语句中可以不使用别名</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Employee selectEmployee(Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用resultMap</li></ol><p>使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empSalary&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRM&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mapperXML标签总结"><a href="#mapperXML标签总结" class="headerlink" title="mapperXML标签总结"></a>mapperXML标签总结</h3><p>MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。</p><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>insert</code> – 映射插入语句。</li><li><code>update</code> – 映射更新语句。</li><li><code>delete</code> – 映射删除语句。</li><li><code>select</code> – 映射查询语句。</li></ul><p><strong>select标签：</strong></p><p>MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPerson&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;自定义结构&quot;</span>&gt;</span> SELECT * FROM PERSON WHERE ID = #&#123;id&#125; <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：#{id}  ${key}</p><p>MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 近似的 JDBC 代码，非 MyBatis 代码...</span></span><br><span class="line"><span class="type">String</span> <span class="variable">selectPerson</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM PERSON WHERE ID=?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(selectPerson);</span><br><span class="line">ps.setInt(<span class="number">1</span>,id);</span><br></pre></td></tr></table></figure><p>select 元素允许你配置很多属性来配置每条语句的行为细节：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>resultType</code></td><td>期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td><code>resultMap</code></td><td>对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td><code>timeout</code></td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td><code>statementType</code></td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr></tbody></table><p><strong>insert, update 和 delete标签：</strong></p><p>数据变更语句 insert，update 和 delete 的实现非常接近：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">keyProperty</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">keyColumn</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">useGeneratedKeys</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;updateAuthor&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;deleteAuthor&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>timeout</code></td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td><code>statementType</code></td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td><code>useGeneratedKeys</code></td><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td><code>keyProperty</code></td><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td><code>keyColumn</code></td><td>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr></tbody></table><h2 id="MyBatis多表映射"><a href="#MyBatis多表映射" class="headerlink" title="MyBatis多表映射"></a>MyBatis多表映射</h2><h3 id="对一映射"><a href="#对一映射" class="headerlink" title="对一映射"></a>对一映射</h3><ol><li>需求说明</li></ol><p>根据ID查询订单，以及订单关联的用户的信息！<br>2. OrderMapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">Order <span class="title function_">selectOrderWithCustomer</span><span class="params">(Integer orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>OrderMapper.xml配置文件</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建resultMap实现“对一”关联关系映射 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id属性：通常设置为这个resultMap所服务的那条SQL语句的id加上“ResultMap” --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- type属性：要设置为这个resultMap所服务的那条SQL语句最终要返回的类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectOrderWithCustomerResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 先设置Order自身属性和字段的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;order_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用association标签配置“对一”关联关系 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- property属性：在Order类中对一的一端进行引用时使用的属性名 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- javaType属性：一的一端类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Customer类的属性和字段名之间的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Order selectOrderWithCustomer(Integer orderId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOrderWithCustomer&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectOrderWithCustomerResultMap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">SELECT order_id,order_name,c.customer_id,customer_name</span><br><span class="line">FROM t_order o</span><br><span class="line">LEFT JOIN t_customer c</span><br><span class="line">ON o.customer_id=c.customer_id</span><br><span class="line">WHERE o.order_id=#&#123;orderId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应关系可以参考下图：</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img018.6c3cfc17.png"><br>4. Mybatis全局注册Mapper文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/OrderMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>junit测试程序</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SqlSession session;</span><br><span class="line"><span class="comment">// junit会在每一个@Test方法前执行@BeforeEach方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">session = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>()</span><br><span class="line">.build(</span><br><span class="line">Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line">.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRelationshipToOne</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">OrderMapper</span> <span class="variable">orderMapper</span> <span class="operator">=</span> session.getMapper(OrderMapper.class);</span><br><span class="line"><span class="comment">// 查询Order对象，检查是否同时查询了关联的Customer对象</span></span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectOrderWithCustomer(<span class="number">2</span>);</span><br><span class="line">log.info(<span class="string">&quot;order = &quot;</span> + order);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// junit会在每一个@Test方法后执行@@AfterEach方法</span></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>关键词</li></ol><p>在“对一”关联关系中，我们的配置比较多，但是关键词就只有：<strong>association</strong>和<strong>javaType</strong></p><h3 id="对多映射"><a href="#对多映射" class="headerlink" title="对多映射"></a>对多映射</h3><ol><li>需求说明</li></ol><p>查询客户和客户关联的订单信息！<br>2. CustomerMapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">Customer <span class="title function_">selectCustomerWithOrderList</span><span class="params">(Integer customerId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>CustomerMapper.xml文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">&quot;selectCustomerWithOrderListResultMap&quot;</span></span><br><span class="line"></span><br><span class="line">type=<span class="string">&quot;customer&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 映射Customer本身的属性 --&gt;</span><br><span class="line">&lt;id column=<span class="string">&quot;customer_id&quot;</span> property=<span class="string">&quot;customerId&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;result column=<span class="string">&quot;customer_name&quot;</span> property=<span class="string">&quot;customerName&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- collection标签：映射“对多”的关联关系 --&gt;</span><br><span class="line">&lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt;</span><br><span class="line">&lt;!-- ofType属性：集合属性中元素的类型 --&gt;</span><br><span class="line">&lt;collection property=<span class="string">&quot;orderList&quot;</span> ofType=<span class="string">&quot;order&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 映射Order的属性 --&gt;</span><br><span class="line">&lt;id column=<span class="string">&quot;order_id&quot;</span> property=<span class="string">&quot;orderId&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;result column=<span class="string">&quot;order_name&quot;</span> property=<span class="string">&quot;orderName&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/collection&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Customer <span class="title function_">selectCustomerWithOrderList</span><span class="params">(Integer customerId)</span>; --&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectCustomerWithOrderList&quot;</span> resultMap=<span class="string">&quot;selectCustomerWithOrderListResultMap&quot;</span>&gt;</span><br><span class="line">SELECT c.customer_id,c.customer_name,o.order_id,o.order_name</span><br><span class="line">FROM t_customer c</span><br><span class="line">LEFT JOIN t_order o</span><br><span class="line">ON c.customer_id=o.customer_id</span><br><span class="line">WHERE c.customer_id=#&#123;customerId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>对应关系可以参考下图：</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img019.dba418c1.png"><br>4. Mybatis全局注册Mapper文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/OrderMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/CustomerMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>junit测试程序</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRelationshipToMulti</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">CustomerMapper</span> <span class="variable">customerMapper</span> <span class="operator">=</span> session.getMapper(CustomerMapper.class);</span><br><span class="line"><span class="comment">// 查询Customer对象同时将关联的Order集合查询出来</span></span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> customerMapper.selectCustomerWithOrderList(<span class="number">1</span>);</span><br><span class="line">log.info(<span class="string">&quot;customer.getCustomerId() = &quot;</span> + customer.getCustomerId());</span><br><span class="line">log.info(<span class="string">&quot;customer.getCustomerName() = &quot;</span> + customer.getCustomerName());</span><br><span class="line">List&lt;Order&gt; orderList = customer.getOrderList();</span><br><span class="line"><span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">log.info(<span class="string">&quot;order = &quot;</span> + order);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>关键词</li></ol><p>在“对多”关联关系中，同样有很多配置，但是提炼出来最关键的就是：“collection”和“ofType”</p><h3 id="多表映射优化"><a href="#多表映射优化" class="headerlink" title="多表映射优化"></a>多表映射优化</h3><table><thead><tr><th>setting属性</th><th>属性含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>autoMappingBehavior</td><td>指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。</td><td>NONE, PARTIAL, FULL</td><td>PARTIAL</td></tr></tbody></table><p>我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名&#x3D;属性名，或者开启驼峰映射也可以自定映射）的result标签！</p><p>修改mybati-sconfig.xml:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启resultMap自动映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FULL&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>修改teacherMapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;teacherMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;tId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;result property=&quot;tName&quot; column=&quot;t_name&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;student&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;sId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;s_id&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;result property=&quot;sName&quot; column=&quot;s_name&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多表映射总结"><a href="#多表映射总结" class="headerlink" title="多表映射总结"></a>多表映射总结</h3><table><thead><tr><th>关联关系</th><th>配置项关键词</th><th>所在配置文件和具体位置</th></tr></thead><tbody><tr><td>对一</td><td>association标签&#x2F;javaType属性&#x2F;property属性</td><td>Mapper配置文件中的resultMap标签内</td></tr><tr><td>对多</td><td>collection标签&#x2F;ofType属性&#x2F;property属性</td><td>Mapper配置文件中的resultMap标签内</td></tr></tbody></table><h2 id="MyBatis动态语句"><a href="#MyBatis动态语句" class="headerlink" title="MyBatis动态语句"></a>MyBatis动态语句</h2><h3 id="if和where标签"><a href="#if和where标签" class="headerlink" title="if和where标签"></a>if和where标签</h3><p>使用动态 SQL 最常见情景是根据条件包含 where  &#x2F; if 子句的一部分。比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp</span><br><span class="line"><span class="comment">&lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#&#123;&#125; --&gt;</span></span><br><span class="line">or emp_name=#&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;gt;</span> 2000&quot;</span>&gt;</span></span><br><span class="line">or emp_salary&gt;#&#123;empSalary&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;?</span></span><br><span class="line"><span class="comment">第二种情况：部分条件满足 WHERE emp_salary&gt;?</span></span><br><span class="line"><span class="comment">第三种情况：所有条件都不满足 没有where子句</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeDynamic&quot;</span>&gt;</span></span><br><span class="line">update t_emp</span><br><span class="line"><span class="comment">&lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">emp_name=#&#123;empName&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span></span><br><span class="line">emp_salary=#&#123;empSalary&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">第一种情况：所有条件都满足 SET emp_name=?, emp_salary=?</span></span><br><span class="line"><span class="comment">第二种情况：部分条件满足 SET emp_salary=?</span></span><br><span class="line"><span class="comment">第三种情况：所有条件都不满足 update t_emp where emp_id=?</span></span><br><span class="line"><span class="comment">没有set子句的update语句会导致SQL语法错误</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose-when-otherwise标签"><a href="#choose-when-otherwise标签" class="headerlink" title="choose&#x2F;when&#x2F;otherwise标签"></a>choose&#x2F;when&#x2F;otherwise标签</h3><p>在多个分支条件中，仅执行一个。</p><ul><li>从上到下依次执行条件判断</li><li>遇到的第一个满足条件的分支会被采纳</li><li>被采纳分支后面的分支都将不被考虑</li><li>如果所有的when分支都不满足，那么就执行otherwise分支</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByConditionByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp</span><br><span class="line">where</span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span>emp_name=#&#123;empName&#125;<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span>emp_salary <span class="symbol">&amp;lt;</span> 3000<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>1=1<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">第一种情况：第一个when满足条件 where emp_name=?</span></span><br><span class="line"><span class="comment">第二种情况：第二个when满足条件 where emp_salary &lt; 3000</span></span><br><span class="line"><span class="comment">第三种情况：两个when都不满足 where 1=1 执行了otherwise</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p><strong>基本用法</strong></p><p>用批量插入举例</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">collection属性：要遍历的集合</span></span><br><span class="line"><span class="comment">item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象</span></span><br><span class="line"><span class="comment">separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符</span></span><br><span class="line"><span class="comment">open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串</span></span><br><span class="line"><span class="comment">close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串</span></span><br><span class="line"><span class="comment">index属性：这里起一个名字，便于后面引用</span></span><br><span class="line"><span class="comment">遍历List集合，这里能够得到List集合的索引值</span></span><br><span class="line"><span class="comment">遍历Map集合，这里能够得到Map集合的key</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;values&quot;</span> <span class="attr">index</span>=<span class="string">&quot;myIndex&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 --&gt;</span></span><br><span class="line">(#&#123;emp.empName&#125;,#&#123;myIndex&#125;,#&#123;emp.empSalary&#125;,#&#123;emp.empGender&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>批量更新时需要注意</strong></p><p>上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true</span><br></pre></td></tr></table></figure><p>对应的foreach标签如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeBatch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span>&gt;</span></span><br><span class="line">update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>关于foreach标签的collection属性</strong></p><p>如果没有给接口中List类型的参数使用@Param注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。这一点可以通过异常信息看出来：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Parameter &#x27;empList&#x27; not found. Available parameters are [arg0, collection, list]</span><br></pre></td></tr></table></figure><p>在实际开发中，为了避免隐晦的表达造成一定的误会，建议使用@Param注解明确声明变量的名称，然后在foreach标签的collection属性中按照@Param注解指定的名称来引用传入的参数。</p><h3 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h3><p><strong>抽取重复的SQL片段</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;mySelectSql&quot;</span>&gt;</span></span><br><span class="line">select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用已抽取的SQL片段</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用include标签引用声明的SQL片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;mySelectSql&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Mapper批量映射优化"><a href="#Mapper批量映射优化" class="headerlink" title="Mapper批量映射优化"></a>Mapper批量映射优化</h2><ol><li>需求</li></ol><p>Mapper配置文件很多时，在全局配置文件中一个一个注册太麻烦，希望有一个办法能够一劳永逸。<br>2. 配置方式</p><p>Mybatis允许在指定 Mapper 映射文件时，只指定其所在的包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时这个包下的所有 Mapper 配置文件将被自动加载、注册，比较方便。<br>3. 资源创建要求</p><ul><li>Mapper 接口和 Mapper 配置文件名称一致</li><li>Mapper 接口：EmployeeMapper.java</li><li>Mapper 配置文件：EmployeeMapper.xml</li><li>Mapper 配置文件放在 Mapper 接口所在的包内</li><li>可以将mapperxml文件放在mapper接口所在的包！</li><li>可以在sources下创建mapper接口包一致的文件夹结构存放mapper.xml文件</li></ul><h2 id="MyBatis总结"><a href="#MyBatis总结" class="headerlink" title="MyBatis总结"></a>MyBatis总结</h2><table><thead><tr><th>核心点</th><th>掌握目标</th></tr></thead><tbody><tr><td>mybatis基础</td><td>使用流程, 参数输入,#{} ${},参数输出</td></tr><tr><td>mybatis多表</td><td>实体类设计,resultMap多表结果映射</td></tr><tr><td>mybatis动态语句</td><td>Mybatis动态语句概念, where , if , foreach标签</td></tr><tr><td>mybatis扩展</td><td>Mapper批量处理,分页插件,逆向工程</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架入门</title>
      <link href="/inori/6c8c2c4f.html"/>
      <url>/inori/6c8c2c4f.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring与SpringFramework"><a href="#Spring与SpringFramework" class="headerlink" title="Spring与SpringFramework"></a>Spring与SpringFramework</h2><p><strong>广义的 Spring：Spring 技术栈</strong>（全家桶）</p><p>广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。</p><p>经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p><p>这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。</p><p><strong>狭义的 Spring：Spring Framework</strong>（基础框架）</p><p>狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。</p><p>Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。</p><p>Spring全家桶的其他框架都是以SpringFramework框架为基础</p><h2 id="SpringFramework主要功能"><a href="#SpringFramework主要功能" class="headerlink" title="SpringFramework主要功能"></a>SpringFramework主要功能</h2><table><thead><tr><th>功能模块</th><th>功能介绍</th></tr></thead><tbody><tr><td>Core Container</td><td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。</td></tr><tr><td>AOP&amp;Aspects</td><td>面向切面编程</td></tr><tr><td>TX</td><td>声明式事务管理。</td></tr><tr><td>Spring MVC</td><td>提供了面向Web应用程序的集成功能。</td></tr></tbody></table><h2 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h2><p>IoC(Inversion of Control)控制反转，对象创建责任的反转，在spring中BeanFacotory是IoC容器的核心接口，负责实例化，定位，配置应用程序中的对象及建立这些对象间的依赖。XmlBeanFacotory实现BeanFactory接口，通过获取xml配置文件数据，组成应用对象及对象间的依赖关系<br>spring中有三种注入方式，一种是set注入，一种是接口注入，另一种是构造方法注入</p><p>IOC，字面理解是控制反转，即对象的控制权被反转了(是什么)。之前一个对象中依赖另一个对象，需要自己new出来，当对象间的依赖关系非常复杂时，这个过程就变得很繁琐，并且代码间的耦合会很高。现在可以通过Ioc容器来管理控制对象的生成，可以把对象的实例化过程简单化，代码间解耦(为什么)。具体可以从DI(Dependency Injection) DL(Dependency Lookup)两个角度理解Ioc。DI中注入的方式包括属性，构造器，setter注入，DL含义是通过容器的API来查找所依赖的资源和协作对象，从Ioc容器维护的bean map中取出来(怎么做)</p><h3 id="组件和组件管理"><a href="#组件和组件管理" class="headerlink" title="组件和组件管理"></a>组件和组件管理</h3><p>整个项目就是由各种组件搭建而成的，原本使用组件需要先new出来并赋值才能使用，现在有了Spring之后组件可以完全交给Spring框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等</p><p>Spring具体的组件管理动作包含：</p><ul><li>组件对象实例化</li><li>组件属性属性赋值</li><li>组件对象之间引用</li><li>组件对象存活周期管理</li></ul><p>我们只需要编写元数据（配置文件）告知Spring管理哪些类组件和他们的关系即可！</p><p>注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！</p><ul><li>组件一定是对象</li><li>对象不一定是组件</li></ul><p>综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！</p><h3 id="Spring-IoC容器和容器实现"><a href="#Spring-IoC容器和容器实现" class="headerlink" title="Spring IoC容器和容器实现"></a>Spring IoC容器和容器实现</h3><h4 id="普通和复杂容器"><a href="#普通和复杂容器" class="headerlink" title="普通和复杂容器"></a>普通和复杂容器</h4><blockquote><p>普通容器只能用来存储，没有更多功能。</p></blockquote><ul><li>数组</li><li>集合：List</li><li>集合：Set</li></ul><blockquote><p>复杂容器可以持续管理组件，从产生到销毁</p></blockquote><p>  如：Servlet容器能够管理Servlet(init,service,destroy)、Filter、Listener这样的组件的一生，所以它是一个复杂容器。</p><table><thead><tr><th>名称</th><th>时机</th><th>次数</th></tr></thead><tbody><tr><td>创建对象</td><td>默认情况：接收到第一次请求  修改启动顺序后：Web应用启动过程中</td><td>一次</td></tr><tr><td>初始化操作</td><td>创建对象之后</td><td>一次</td></tr><tr><td>处理请求</td><td>接收到请求</td><td>多次</td></tr><tr><td>销毁操作</td><td>Web应用卸载之前</td><td>一次</td></tr></tbody></table><p>SpringIoC容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。<br>Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等</p><h4 id="IoC容器具体接口和实现类"><a href="#IoC容器具体接口和实现类" class="headerlink" title="IoC容器具体接口和实现类"></a>IoC容器具体接口和实现类</h4><p><strong>SpringIoc容器接口</strong><br><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！<br><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p><ul><li><p>更容易与 Spring 的 AOP 功能集成</p></li><li><p>消息资源处理（用于国际化）</p></li><li><p>特定于应用程序给予此接口实现，例如Web应用程序的 <code>WebApplicationContext</code></p><p>  简而言之，<code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能<code>ApplicationContext</code>是<code>BeanFactory</code>的完整超集！</p></li></ul><p><strong>ApplicationContext容器实现类</strong></p><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>AnnotationConfigApplicationContext</td><td>通过读取Java配置类创建 IOC 容器对象</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table><p><strong>SpringIoC容器管理配置方式</strong></p><p>Spring IoC容器使用多种形式的配置元数据。此配置元数据表示作为应用程序开发人员如何告诉Spring容器实例化、配置和组装应用程序中的对象。<br>Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式</p><ol><li>XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持</li><li>注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系</li><li>Java配置类方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置</li></ol><h4 id="SpringIoC-DI概念总结"><a href="#SpringIoC-DI概念总结" class="headerlink" title="SpringIoC&#x2F;DI概念总结"></a>SpringIoC&#x2F;DI概念总结</h4><ul><li><p><strong>IoC容器</strong></p><p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令</p></li><li><p><strong>IoC（Inversion of Control）控制反转</strong></p><p>IoC主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC容器来创建和管理，即控制权由应用程序转移到IoC容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即IoC容器维护着构成应用程序的对象，并负责创建这些对象</p></li><li><p><strong>DI (Dependency Injection) 依赖注入</strong></p><p>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在Spring中，DI是通过XML配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter方法注入和接口注入</p></li></ul><h2 id="Spring-IoC实践"><a href="#Spring-IoC实践" class="headerlink" title="Spring IoC实践"></a>Spring IoC实践</h2><h3 id="Spring-IoC-DI实现步骤"><a href="#Spring-IoC-DI实现步骤" class="headerlink" title="Spring IoC&#x2F;DI实现步骤"></a>Spring IoC&#x2F;DI实现步骤</h3><ol><li><strong>配置元数据（配置）</strong></li></ol><p>基于 XML 的配置元数据的基本结构：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">1</span>] <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">2</span>]&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">1</span>] <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">2</span>]&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring IoC容器管理一个或多个组件。这些组件是使用你提供给容器的配置元数据（例如，以 XML <code>&lt;bean/&gt;</code> 定义的形式）创建的。<br><code>&lt;bean/&gt;</code>标签等于组件信息声明</p><ul><li><code>id</code>属性是标识单个 Bean 定义的字符串</li><li><code>class</code>属性定义 Bean 的类型并使用完全限定的类名</li></ul><ol start="2"><li><strong>实例化IoC容器</strong></li></ol><p>提供给 <code>ApplicationContext</code> 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code> 等）加载配置元数据。<br>选择一个合适的容器实现类，进行IoC容器的实例化工作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>获取Bean（组件）</strong></li></ol><p><code>ApplicationContext</code>是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，可以检索 bean 的实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获取ioc容器的组件对象</span></span><br><span class="line"><span class="type">PetStoreService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"><span class="comment">//使用组件对象</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure><h3 id="基于配置类方式管理Bean"><a href="#基于配置类方式管理Bean" class="headerlink" title="基于配置类方式管理Bean"></a>基于配置类方式管理Bean</h3><h4 id="完全注解开发理解"><a href="#完全注解开发理解" class="headerlink" title="完全注解开发理解"></a>完全注解开发理解</h4><p>​Spring完全注解配置是指通过Java配置类代码来配置Spring应用程序，使用注解来替代原本在XML配置文件中的配置。相对于XML配置，完全注解配置具有更强的类型安全性和更好的可读性。</p><h4 id="配置类和扫描注解"><a href="#配置类和扫描注解" class="headerlink" title="配置类和扫描注解"></a>配置类和扫描注解</h4><p><strong>xml+注解方式</strong></p><p>配置application.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置自动扫描的包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.包要精准,提高性能!</span></span><br><span class="line"><span class="comment">         2.会扫描指定的包和子包内容</span></span><br><span class="line"><span class="comment">         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.components&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入外部配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;application.properties&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试创建IoC容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xml方式配置文件使用ClassPathXmlApplicationContext容器读取</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>配置类+注解方式（完全注解方式）</strong><br>使用<code>@Configuration</code>注解将一个普通的类标记为Spring的配置类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标注当前类是配置类，替代application.xml    </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//使用注解读取外部配置，替代 &lt;context:property-placeholder标签</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="comment">//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>测试创建IoC容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">iocContainerAnnotation</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfiguration.class);</span><br></pre></td></tr></table></figure><h4 id="Bean定义组件"><a href="#Bean定义组件" class="headerlink" title="@Bean定义组件"></a>@Bean定义组件</h4><p><strong>场景需求</strong>：将Druid连接池对象存储到IoC容器<br><strong>需求分析</strong>：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式<br>配置类方式实现：<br><code>@Bean</code>注释用于指示方法实例化、配置和初始化要由Spring IoC容器管理的新对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标注当前类是配置类，替代application.xml    </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//引入jdbc.properties文件</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:application.properties&quot;,&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//如果第三方类进行IoC管理,无法直接使用@Component相关注解</span></span><br><span class="line">    <span class="comment">//解决方案: xml方式可以使用&lt;bean标签</span></span><br><span class="line">    <span class="comment">//解决方案: 配置类方式,可以使用方法返回值+@Bean注解</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.user&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span>String password,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span>String url,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>String driverClassName)</span>&#123;</span><br><span class="line">        <span class="comment">//使用Java代码实例化</span></span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种配置方式对比"><a href="#三种配置方式对比" class="headerlink" title="三种配置方式对比"></a>三种配置方式对比</h3><h4 id="XML方式配置"><a href="#XML方式配置" class="headerlink" title="XML方式配置"></a>XML方式配置</h4><ol><li>所有内容写到xml格式配置文件中</li><li>声明bean通过&lt;bean标签</li><li>&lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value &#x2F; ref</li><li>引入外部的properties文件可以通过&lt;context:property-placeholder</li><li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li></ol><h4 id="XML-注解方式配置"><a href="#XML-注解方式配置" class="headerlink" title="XML+注解方式配置"></a>XML+注解方式配置</h4><ol><li>注解负责标记IoC的类和进行属性装配</li><li>xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围</li><li>标记IoC注解：@Component,@Service,@Controller,@Repository </li><li>标记DI注解：@Autowired @Qualifier @Resource @Value</li><li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li></ol><h4 id="完全注解方式配置"><a href="#完全注解方式配置" class="headerlink" title="完全注解方式配置"></a>完全注解方式配置</h4><ol><li>完全注解方式指的是去掉xml文件，使用配置类 + 注解实现</li><li>xml文件替换成使用@Configuration注解标记的类</li><li>标记IoC注解：@Component,@Service,@Controller,@Repository </li><li>标记DI注解：@Autowired @Qualifier @Resource @Value</li><li><code>&lt;context:component-scan&gt;</code>标签指定注解范围使用@ComponentScan(basePackages &#x3D; {“”})替代</li><li><code>&lt;context:property-placeholder&gt;</code>引入外部配置文件使用@PropertySource({“classpath:application.properties”,”classpath:jdbc.properties”})替代</li><li><code>&lt;bean&gt;</code>标签使用@Bean注解和方法实现</li><li>IoC具体容器实现选择AnnotationConfigApplicationContext对象</li></ol><h3 id="整合Spring5-Test5搭建测试环境"><a href="#整合Spring5-Test5搭建测试环境" class="headerlink" title="整合Spring5-Test5搭建测试环境"></a>整合Spring5-Test5搭建测试环境</h3><ol><li><p>整合测试环境作用</p><p> 好处1：不需要自己创建IOC容器对象了</p><p> 好处2：任何需要的bean都可以在测试类中直接享受自动装配</p></li><li><p>导入相关依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>整合测试注解使用</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@SpringJUnitConfig(locations = &#123;&quot;classpath:spring-context.xml&quot;&#125;)  //指定配置文件xml</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = &#123;BeanConfig.class&#125;)</span>  <span class="comment">//指定配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Junit5IntegrationTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJunit5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="为什么要有Spring-AOP"><a href="#为什么要有Spring-AOP" class="headerlink" title="为什么要有Spring AOP"></a>为什么要有Spring AOP</h3><p>业务代码已经被一些非核心的代码所混淆，并且占据了大量的空间，显然这种显示的调用过程成为了我们开发过程中的一个痛点，如何将类似这种的非核心的代码剥离出去成为一个迫切需要解决的问题。<br>诸如日志记录，登录权限控制，还有数据库事务的控制，数据库连接的创建和关闭等等，这些都充斥这大量重复性的模板代码</p><h3 id="解决技术代理模式"><a href="#解决技术代理模式" class="headerlink" title="解决技术代理模式"></a>解决技术代理模式</h3><p><strong>代理模式</strong></p><p>​二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p><p>相关术语：</p><ul><li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。</li><li>动词：指做代理这个动作，或这项工作</li><li>名词：扮演代理这个角色的类、对象、方法</li><li>目标：<strong>被代理</strong>“套用”了核心逻辑代码的类、对象、方法。<br>代理在开发中实现的方式具体有两种：静态代理，[动态代理技术]</li></ul><p><strong>动态代理</strong><br>动态代理技术分类</p><ul><li>JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须<strong>实现接口</strong>！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口</li><li>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口</li></ul><h3 id="面向切面编程思维（AOP）"><a href="#面向切面编程思维（AOP）" class="headerlink" title="面向切面编程思维（AOP）"></a>面向切面编程思维（AOP）</h3><ol><li><strong>面向切面编程思想AOP</strong></li></ol><p>AOP：Aspect Oriented Programming面向切面编程<br>AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。<br>使用AOP，可以在不修改原来代码的基础上添加新功能</p><ol start="2"><li><strong>AOP思想主要的应用场景</strong></li></ol><p>AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景：</p><ul><li><p>日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。</p></li><li><p>事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。</p></li><li><p>安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。</p></li><li><p>性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。</p></li><li><p>异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。</p></li><li><p>缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。</p></li><li><p>动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。</p></li></ul><ol start="3"><li><strong>AOP术语名词介绍</strong></li></ol><ul><li>横切关注点</li></ul><p>​从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。<br>​AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><ul><li><p>通知(增强)：每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p><ul><li>前置通知：在被代理的目标方法前执行</li><li>返回通知：在被代理的目标方法成功结束后执行</li><li>异常通知：在被代理的目标方法异常结束后执行</li><li>后置通知：在被代理的目标方法最终结束后执行</li><li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li></ul></li><li><p>连接点 joinpoint</p></li></ul><p>​这也是一个纯逻辑概念，不是语法定义的。指那些被拦截到的点。在Spring中，可以被动态代理拦截目标类的方法<br>​    <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img010.5af189f7.png"></p><ul><li>切入点 pointcut</li></ul><p>​定位连接点的方式，或者可以理解成被选中的连接点！</p><ul><li>切面 aspect</li></ul><p>​切入点和通知的结合。是一个类。</p><ul><li>目标 target</li></ul><p>​被代理的目标对象。</p><ul><li>代理 proxy</li></ul><p>​向目标对象应用通知之后创建的代理对象。</p><ul><li>织入 weave</li></ul><p>​指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。</p><h3 id="Spring-AOP框架介绍和关系梳理"><a href="#Spring-AOP框架介绍和关系梳理" class="headerlink" title="Spring AOP框架介绍和关系梳理"></a>Spring AOP框架介绍和关系梳理</h3><ol><li>AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！</li><li>代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！</li><li>Spring AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！</li></ol><h3 id="Spring-AOP基于注解方式实现和细节"><a href="#Spring-AOP基于注解方式实现和细节" class="headerlink" title="Spring AOP基于注解方式实现和细节"></a>Spring AOP基于注解方式实现和细节</h3><h4 id="Spring-AOP底层技术组成"><a href="#Spring-AOP底层技术组成" class="headerlink" title="Spring AOP底层技术组成"></a>Spring AOP底层技术组成</h4><ul><li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。</li><li>cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。</li><li>AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。</li></ul><h4 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h4><ol><li>加入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>准备接口</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>纯净实现类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorPureImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i - j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i / j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>声明切面类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Aspect表示这个类是一个切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">// @Component注解保证这个切面类能够放入IOC容器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// @Before注解：声明当前方法是前置通知方法</span></span><br><span class="line">    <span class="comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP前置通知] 方法开始了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterException</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogFinallyEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>开启aspectj注解支持<ol><li>xml方式</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 进行包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启aspectj框架注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​2. 配置类方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;&quot;)</span></span><br><span class="line"><span class="comment">//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>测试效果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = &#123;MyConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCalculator</span><span class="params">()</span>&#123;</span><br><span class="line">        calculator.add(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.atguigu.test.AopTest,testCalculator</span><br><span class="line">[AOP前置通知] 方法开始了</span><br><span class="line">[AOP返回通知] 方法成功返回了</span><br><span class="line">[AOP后置通知] 方法最终结束了</span><br></pre></td></tr></table></figure><h4 id="获取通知细节信息"><a href="#获取通知细节信息" class="headerlink" title="获取通知细节信息"></a>获取通知细节信息</h4><ol><li><strong>JointPoint接口</strong><br>需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。</li></ol><ul><li>要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息）</li><li>要点2：通过目标方法签名对象获取方法名</li><li>要点3：通过JoinPoint对象获取外界调用目标方法时传入的实参列表组成的数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Before注解标记前置通知方法</span></span><br><span class="line"><span class="comment">// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上</span></span><br><span class="line"><span class="comment">// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入</span></span><br><span class="line"><span class="comment">// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(public int aop.api.Calculator.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.通过JoinPoint对象获取目标方法签名对象</span></span><br><span class="line">    <span class="comment">// 方法的签名：一个方法的全部声明信息</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.通过方法的签名对象获取目标方法的详细信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;methodName = &quot;</span> + methodName);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> signature.getModifiers();</span><br><span class="line">    System.out.println(<span class="string">&quot;modifiers = &quot;</span> + modifiers);</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">declaringTypeName</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">    System.out.println(<span class="string">&quot;declaringTypeName = &quot;</span> + declaringTypeName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.由于数组直接打印看不到具体数据，所以转换为List集合</span></span><br><span class="line">    List&lt;Object&gt; argList = Arrays.asList(args);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP前置通知] &quot;</span> + methodName + <span class="string">&quot;方法开始了，参数列表：&quot;</span> + argList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>方法返回值</strong></li></ol><p>在返回通知中，通过**@AfterReturning**注解的returning属性获取目标方法的返回值！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @AfterReturning注解标记返回通知方法</span></span><br><span class="line"><span class="comment">// 在返回通知中获取目标方法返回值分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterReturning注解中通过returning属性设置一个名称</span></span><br><span class="line"><span class="comment">// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参</span></span><br><span class="line"><span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        returning = &quot;targetMethodReturnValue&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreSuccess</span><span class="params">(JoinPoint joinPoint, Object targetMethodReturnValue)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP返回通知] &quot;</span>+methodName+<span class="string">&quot;方法成功结束了，返回值是：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>异常对象捕捉</strong></li></ol><p>在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @AfterThrowing注解标记异常通知方法</span></span><br><span class="line"><span class="comment">// 在异常通知中获取目标方法抛出的异常分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称</span></span><br><span class="line"><span class="comment">// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们</span></span><br><span class="line"><span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        throwing = &quot;targetMethodException&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreException</span><span class="params">(JoinPoint joinPoint, Throwable targetMethodException)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP异常通知] &quot;</span>+methodName+<span class="string">&quot;方法抛异常了，异常类型是：&quot;</span> + targetMethodException.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切点表达式语法"><a href="#切点表达式语法" class="headerlink" title="切点表达式语法"></a>切点表达式语法</h4><ol><li><strong>切点表达式</strong></li></ol><p>AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。</p><ol start="2"><li><strong>切点表达式语法</strong></li></ol><p>语法细节</p><ul><li>第一位：execution( )固定开头</li><li>第二位：方法访问修饰符</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">private</span> 直接描述对应修饰符即可</span><br></pre></td></tr></table></figure><ul><li>第三位：方法返回值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> String <span class="keyword">void</span> 直接描述返回值类型</span><br></pre></td></tr></table></figure><ul><li>第四位：指定包的地址</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">固定的包: com.atguigu.api | service | dao</span><br><span class="line">单层的任意命名: com.atguigu.*  = api dao  * = 任意一层的任意命名</span><br><span class="line">任意层任意命名: com.. = api.erdaye com.a.a.a.a.a.a.a  ..任意层,任意命名 用在包上!</span><br><span class="line">注意: ..不能用作包开头   <span class="keyword">public</span> <span class="type">int</span> .. 错误语法  com..</span><br><span class="line">找到任何包下: *..</span><br></pre></td></tr></table></figure><ul><li>第五位：指定类名称</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">固定名称: UserService</span><br><span class="line">任意类名: *</span><br><span class="line">部分任意: com..service.impl.*Impl</span><br><span class="line">任意包任意类: *..*</span><br></pre></td></tr></table></figure><ul><li>第六位：指定方法名称<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">语法和类名一致</span><br><span class="line">任意访问修饰符,任意类的任意方法: * *..*.*</span><br></pre></td></tr></table></figure></li><li>第七位：方法参数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第七位: 方法的参数描述</span><br><span class="line">       具体值: (String,<span class="type">int</span>) != (<span class="type">int</span>,String) 没有参数 ()</span><br><span class="line">       模糊值: 任意参数 有 或者 没有 (..)  ..任意参数的意识</span><br><span class="line">       部分具体和模糊:</span><br><span class="line">         第一个参数是字符串的方法 (String..)</span><br><span class="line">         最后一个参数是字符串 (..String)</span><br><span class="line">         字符串开头,<span class="type">int</span>结尾 (String..<span class="type">int</span>)</span><br><span class="line">         包含<span class="type">int</span>类型(..<span class="type">int</span>..)</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>切点表达式案例</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>查询某包某类下，访问修饰符是公有，返回值是<span class="type">int</span>的全部方法</span><br><span class="line"><span class="number">2.</span>查询某包下类中第一个参数是String的方法</span><br><span class="line"><span class="number">3.</span>查询全部包下，无参数的方法！</span><br><span class="line"><span class="number">4.</span>查询com包下，以<span class="type">int</span>参数类型结尾的方法</span><br><span class="line"><span class="number">5.</span>查询指定包下，Service开头类的私有返回值<span class="type">int</span>的无参数方法</span><br></pre></td></tr></table></figure><h4 id="重用（提取）切点表达式"><a href="#重用（提取）切点表达式" class="headerlink" title="重用（提取）切点表达式"></a>重用（提取）切点表达式</h4><ol><li>重用切点表达式</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// @Before注解：声明当前方法是前置通知方法</span></span><br><span class="line"><span class="comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP前置通知] 方法开始了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterException</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogFinallyEnd</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同一类内部引用</li></ol><p>提取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切入点表达式重用</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(public int aop.api.Calculator.add(int,int)))</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">public void declarPointCut() &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>注意：提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！<br>引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;declarPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCoreOperation</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br></pre></td></tr></table></figure><ol start="3"><li>不同类中引用</li></ol><p>不同类在引用切点，只需要添加类的全限定符+方法名即可！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;aop.aspect.LogAspect.declarPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">roundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br></pre></td></tr></table></figure><ol start="4"><li>切点统一管理</li></ol><p>建议：将切点表达式统一存储到一个类中进行集中管理和维护！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtguiguPointCut</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(public int *..Calculator.sub(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atguiguGlobalPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(public int *..Calculator.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atguiguSecondPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* *..*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><p>环绕通知对应整个 try…catch…finally 结构，包括前面四种通知的所有功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用@Around注解标明环绕通知方法</span></span><br><span class="line"><span class="meta">@Around(value = &quot;aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">manageTransaction</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，</span></span><br><span class="line"><span class="params">        // Spring会将这个类型的对象传给我们</span></span><br><span class="line"><span class="params">        ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ProceedingJoinPoint对象获取目标方法的签名对象</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过签名对象获取目标方法的方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明变量用来存储目标方法的返回值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">targetMethodReturnValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在目标方法执行前：开启事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 开启事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，参数列表：&quot;</span> + Arrays.asList(args));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 过ProceedingJoinPoint对象调用目标方法</span></span><br><span class="line">        <span class="comment">// 目标方法的返回值一定要返回给外界调用者</span></span><br><span class="line">        targetMethodReturnValue = joinPoint.proceed(args);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法成功返回后：提交事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 提交事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，方法返回值：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">    </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">        <span class="comment">// 在目标方法抛异常后：回滚事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 回滚事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，异常：&quot;</span> + e.getClass().getName());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法最终结束后：释放数据库连接</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetMethodReturnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面优先级设置"><a href="#切面优先级设置" class="headerlink" title="切面优先级设置"></a>切面优先级设置</h4><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。</p><ul><li>优先级高的切面：外面</li><li>优先级低的切面：里面</li></ul><p>使用@Order注解可以控制切面的优先级： </p><ul><li>@Order(较小的数)：优先级高</li><li>@Order(较大的数)：优先级低</li></ul><p>此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。</p><h4 id="CGLib动态代理生效"><a href="#CGLib动态代理生效" class="headerlink" title="CGLib动态代理生效"></a>CGLib动态代理生效</h4><p>在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。</p><p>使用总结：</p><ul><li>如果目标类有接口,选择使用jdk动态代理</li><li>如果目标类没有接口,选择cglib动态代理</li><li>如果有接口,接口接值</li><li>如果没有接口,类进行接值</li></ul><h2 id="Spring-声明式事务"><a href="#Spring-声明式事务" class="headerlink" title="Spring 声明式事务"></a>Spring 声明式事务</h2><h3 id="声明式事务概念"><a href="#声明式事务概念" class="headerlink" title="声明式事务概念"></a>声明式事务概念</h3><p>声明式事务是指使用注解或XML配置的方式来控制事务的提交和回滚。<br>开发者只需要添加配置即可，具体事务的实现由第三方框架实现，避免我们直接进行事务操作！<br>使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。</p><h4 id="Spring事务管理器"><a href="#Spring事务管理器" class="headerlink" title="Spring事务管理器"></a>Spring事务管理器</h4><ol><li>Spring声明式事务对应依赖</li></ol><ul><li>spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）</li><li>spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager</li><li>spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等</li></ul><ol start="2"><li>Spring声明式事务对应事务管理器接口</li></ol><p>​使用的事务管理器是<code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code>，将来整合JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现</p><p>DataSourceTransactionManager类中的主要方法：</p><ul><li>doBegin()：开启事务</li><li>doSuspend()：挂起事务</li><li>doResume()：恢复挂起的事务</li><li>doCommit()：提交事务</li><li>doRollback()：回滚事务</li></ul><h3 id="基于注解的声明式事务"><a href="#基于注解的声明式事务" class="headerlink" title="基于注解的声明式事务"></a>基于注解的声明式事务</h3><ol><li>准备项目</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 数据库驱动 和 连接池--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- spring-jdbc --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 声明式事务依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>外部配置文件</li></ol><p>jdbc.properties</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://localhost:3306/studb</span><br><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><ol start="3"><li>spring配置文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//druid连接池</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//jdbcTemplate</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>准备dao&#x2F;service层</li></ol><p>dao</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateNameById</span><span class="params">(String name,Integer id)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update students set name = ? where id = ? ;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> jdbcTemplate.update(sql, name, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAgeById</span><span class="params">(Integer age,Integer id)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update students set age = ? where id = ? ;&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,age,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>测试环境搭建</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(JavaConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testTx</span><span class="params">()</span>&#123;</span><br><span class="line">        studentService.changeInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="基本事务控制"><a href="#基本事务控制" class="headerlink" title="基本事务控制"></a>基本事务控制</h4><ol><li>配置事务管理器</li></ol><p>数据库相关的配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description: 数据库和连接池配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponenScan(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化dataSource加入到ioc容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span>String url,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>String driver,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span>String username,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span>String password)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化JdbcTemplate对象,需要使用ioc中的DataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装配事务管理实现对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用声明事务注解@Transactional</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试事务效果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(classes = DataSourceConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testTx</span><span class="params">()</span>&#123;</span><br><span class="line">        studentService.changeInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="事务属性：只读"><a href="#事务属性：只读" class="headerlink" title="事务属性：只读"></a>事务属性：只读</h4><ol><li>只读介绍</li></ol><p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化</p><ol start="2"><li>设置方式</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readOnly = true把当前事务设置为只读 默认是false!</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>针对DML动作设置只读模式</li></ol><p>会抛出下面异常：</p><blockquote><p>Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed</p></blockquote><ol start="4"><li>@Transactional注解放在类上</li><li>生效原则</li></ol><p>​如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将 @Transactional 注解提取到类上。反过来说：@Transactional 注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional 注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了 @Transactional 注解。对一个方法来说，离它最近的 @Transactional 注解中的事务属性设置生效。</p><ol start="6"><li>用法举例</li></ol><p>​在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了便于核对数据库操作结果，不要修改同一条记录</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateTwice</span><span class="params">(……)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// readOnly = true把当前事务设置为只读</span></span><br><span class="line">    <span class="comment">// @Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmpName</span><span class="params">(Integer empId)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务属性：超时时间"><a href="#事务属性：超时时间" class="headerlink" title="事务属性：超时时间"></a>事务属性：超时时间</h4><ol><li>需求</li></ol><p>​事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。<br>​此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p><p>概括来说就是一句话：超时回滚，释放资源。</p><ol start="2"><li>设置超时时间</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,timeout = 3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//休眠4秒,等待方法超时!</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试超时效果</li></ol><p>执行抛出事务超时异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Wed May <span class="number">24</span> 09:<span class="number">10</span>:<span class="number">43</span> IRKT <span class="number">2023</span></span><br><span class="line"></span><br><span class="line">  at org.springframework.transaction.support.ResourceHolderSupport.checkTransactionTimeout(ResourceHolderSupport.java:<span class="number">155</span>)</span><br><span class="line">  at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInMillis(ResourceHolderSupport.java:<span class="number">144</span>)</span><br><span class="line">  at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInSeconds(ResourceHolderSupport.java:<span class="number">128</span>)</span><br><span class="line">  at org.springframework.jdbc.datasource.DataSourceUtils.applyTimeout(DataSourceUtils.java:<span class="number">341</span>)</span><br><span class="line">  at org.springframework.jdbc.core.JdbcTemplate.applyStatementSettings(JdbcTemplate.java:<span class="number">1467</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="事务属性：事务异常"><a href="#事务属性：事务异常" class="headerlink" title="事务属性：事务异常"></a>事务属性：事务异常</h4><ol><li>默认情况</li></ol><p>默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,timeout = 3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置回滚异常</li></ol><p>rollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and Error 异常方可回滚!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment"> * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment"> * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! </span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>设置不回滚的异常</li></ol><p>在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。</p><p>noRollbackFor属性：指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="事务属性：事务隔离级别"><a href="#事务属性：事务隔离级别" class="headerlink" title="事务属性：事务隔离级别"></a>事务属性：事务隔离级别</h4><ol><li>事务隔离级别</li></ol><p>数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：</p><ul><li><p>读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。</p></li><li><p>读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。</p></li><li><p>可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。</p></li><li><p>串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。</p></li></ul><p>不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。</p><ol start="2"><li>事务隔离级别设置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,</span></span><br><span class="line"><span class="meta">                   timeout = 3,</span></span><br><span class="line"><span class="meta">                   rollbackFor = Exception.class,</span></span><br><span class="line"><span class="meta">                   noRollbackFor = FileNotFoundException.class,</span></span><br><span class="line"><span class="meta">                   isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务属性：事务传播行为"><a href="#事务属性：事务传播行为" class="headerlink" title="事务属性：事务传播行为"></a>事务属性：事务传播行为</h4><ol><li>事务传播行为要研究的问题</li></ol><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img012.faac2cb7.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MethodA</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    MethodB();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MethodB</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>propagation属性</li></ol><p>@Transactional注解通过propagation属性设置事务的传播行为。它的默认值是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br></pre></td></tr></table></figure><p>propagation属性的可选值由org.springframework.transaction.annotation.Propagation枚举类提供：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>REQUIRED 默认值</td><td>如果父方法有事务，就加入，如果没有就新建自己独立</td></tr><tr><td>REQUIRES_NEW</td><td>不管父方法是否有事务，都新建事务，都是独立的</td></tr></tbody></table><ul><li>声明两个业务方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,</span></span><br><span class="line"><span class="meta">                   timeout = 3,</span></span><br><span class="line"><span class="meta">                   rollbackFor = Exception.class,</span></span><br><span class="line"><span class="meta">                   noRollbackFor = FileNotFoundException.class,</span></span><br><span class="line"><span class="meta">                   isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明两个独立修改数据库的事务业务方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeAge</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">99</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeName</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test2&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明一个整合业务方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">topService</span><span class="params">()</span>&#123;</span><br><span class="line">        studentService.changeAge();</span><br><span class="line">        studentService.changeName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加传播行为测试</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(classes = AppConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TopService topService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testTx</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        topService.topService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>    在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。</p><h5 id="其他传播行为值"><a href="#其他传播行为值" class="headerlink" title="其他传播行为值"></a>其他传播行为值</h5><ul><li>Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。</li><li>Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。</li><li>Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。</li><li>Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。</li><li>Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。</li><li>Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。</li><li>Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。</li></ul><h2 id="Spring核心点"><a href="#Spring核心点" class="headerlink" title="Spring核心点"></a>Spring核心点</h2><table><thead><tr><th>核心点</th><th>掌握目标</th></tr></thead><tbody><tr><td>spring框架理解</td><td>spring家族和spring framework框架</td></tr><tr><td>spring核心功能</td><td>ioc&#x2F;di , aop , tx</td></tr><tr><td>spring ioc &#x2F; di</td><td>组件管理、ioc容器、ioc&#x2F;di , 三种配置方式</td></tr><tr><td>spring aop</td><td>aop和aop框架和代理技术、基于注解的aop配置</td></tr><tr><td>spring tx</td><td>声明式和编程式事务、动态事务管理器、事务注解、属性</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven工具入门</title>
      <link href="/inori/aba8722c.html"/>
      <url>/inori/aba8722c.html</url>
      
        <content type="html"><![CDATA[<p>Maven 是一款为 Java 项目构建管理、依赖管理的工具（<strong>软件</strong>），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。</p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ol><li>场景概念</li></ol><p>​<strong>场景1：</strong>例如我们项目需要第三方库（依赖），如Druid连接池、MySQL数据库驱动和Jackson等。那么我们可以将需要的依赖项的信息编写到Maven工程的配置文件，Maven软件就会自动下载并复制这些依赖项到项目中，也会自动下载依赖需要的依赖！确保依赖版本正确无冲突和依赖完整</p><p>​<strong>场景2：</strong>项目开发完成后，想要将项目打成.war文件，并部署到服务器中运行，使用Maven软件，我们可以通过一行构建命令（mvn package）快速项目构建和打包<br>2. <strong>依赖管理：</strong></p><p>​Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，而我们仅仅需要编写配置即可<br>3. <strong>构建管理：</strong></p><p>​项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程</p><p>Maven可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可</p><p><img src="https://secure2.wostatic.cn/static/7crHSdhCetVYi4F1JxGLhz/image.png?auth_key=1711440213-eAgGzx2hYA5VgtcCYWA16G-0-6344489149ced524bf51fdb562e4623b"></p><h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>安装好Maven并配置环境变量后，使用<code>mvn -v</code>命令测试是否配置完成，如果输出版本信息则配置成功。、</p><ol><li>配置文件</li></ol><blockquote><p>需要修改<strong>maven&#x2F;conf&#x2F;settings.xml</strong>配置文件，来修改maven的一些默认配置。我们主要修改的有三个配置：<br>1.依赖本地缓存位置（本地仓库位置）<br>2.maven下载镜像<br>3.maven选用编译项目的jdk版本</p></blockquote><p>配置本地仓库</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>想要配置为仓库的绝对路径<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置国内阿里镜像</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置jdk17版本项目构建</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-17<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>17<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maven目录"><a href="#maven目录" class="headerlink" title="maven目录"></a>maven目录</h2><ul><li><strong>bin目录</strong>： 该目录包含了mvn运行的脚本，这些脚本用来配置java命令，准备好classpath和相关的Java系统属性，然后执行Java命令。</li><li><strong>boot目录</strong>: 该目录只包含一个文件，该文件为plexus-classworlds-2.5.2.jar。plexus-classworlds是一个类加载器框架，相对于默认的java类加载器，它提供了更加丰富的语法以方便配置，Maven使用该框架加载自己的类库。</li><li><strong>conf目录</strong>: 该目录包含了一个非常重要的文件settings.xml。直接修改该文件，就能在机器上全局地定制Maven的行为，一般情况下，我们更偏向于复制该文件至<del>&#x2F;.m2&#x2F;目录下（</del>表示用户目录），然后修改该文件，在用户范围定制Maven的行为。</li><li><strong>lib目录</strong>: 该目录包含了所有Maven运行时需要的Java类库，Maven本身是分模块开发的，因此用户能看到诸如maven-core-3.0.jar、maven-model-3.0.jar之类的文件，此外这里还包含一些Maven用到的第三方依赖如commons-cli-1.2.jar、commons-lang-2.6.jar等等。</li></ul><h2 id="Maven常用命令说明"><a href="#Maven常用命令说明" class="headerlink" title="Maven常用命令说明"></a>Maven常用命令说明</h2><ul><li><strong>mvn clean</strong>：表示运行清理操作（会默认把target文件夹中的数据清理）</li><li><strong>mvn clean compile</strong>：表示先运行清理之后运行编译，会将代码编译到target文件夹中</li><li><strong>mvn clean test</strong>：运行清理和测试</li><li><strong>mvn clean package</strong>：运行清理和打包</li><li><strong>mvn clean install</strong>：运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用</li><li><strong>mvn clean deploy</strong>：运行清理和发布（发布到私服上面）</li></ul><h2 id="设置http代理"><a href="#设置http代理" class="headerlink" title="设置http代理"></a>设置http代理</h2><p>编辑setting.xml文件，先检查一下代理服务器是否畅通。首先运行<code>telnet IP地址+端口</code>来检测该地址的该端口是否畅通。如果得到出错信息，需要先获取正确的代理服务信息</p><p>检查完毕之后，编辑~&#x2F;.m2&#x2F;settings.xml文件(如果没有该文件，则复制$M2_HOME&#x2F;conf&#x2F;settings.xml)。添加代理配置如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">proxies</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">proxy</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>my-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">protocol</span>&gt;</span>http<span class="tag">&lt;/<span class="name">protocol</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">host</span>&gt;</span>IP地址<span class="tag">&lt;/<span class="name">host</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>端口号<span class="tag">&lt;/<span class="name">port</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;username&gt;***&lt;/username&gt;  </span></span><br><span class="line"><span class="comment">        &lt;password&gt;***&lt;/password&gt;  </span></span><br><span class="line"><span class="comment">        &lt;nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">          repository.mycom.com|*.baidu.com  </span></span><br><span class="line"><span class="comment">        &lt;/nonProxyHosts&gt;</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">proxy</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">proxies</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>proxies下可以有多个proxy元素，如果声明了多个proxy元素，则默认情况下第一个被激活的proxy会生效。active的值为true表示激活该代理，protocol表示使用的代理协议，这里是http。最重要的是指定正确的主机名和端口。当代理服务需要认证时，就需要配置username和password。nonProxyHost元素用来指定哪些主机不需要代理，可以使用”|”符号来分隔多个主机名。</p><h2 id="依赖的配置"><a href="#依赖的配置" class="headerlink" title="依赖的配置"></a>依赖的配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>实际项目<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>模块<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">version</span>&gt;</span>版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">type</span>&gt;</span>依赖类型<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">scope</span>&gt;</span>依赖范围<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">optional</span>&gt;</span>依赖是否可选<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">　　　　 &lt;!—主要用于排除传递性依赖--&gt;</span><br><span class="line">　　　　 <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">　　　　     <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">　　　　　　　    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">　　　　　　　　　 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">　　　　　　　<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">　　　　 <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">　　<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>根元素project下的dependencies可以包含一个或者多个dependency元素，以声明一个或者多个项目依赖。每个依赖可以包含的元素有：</p><ul><li><strong>grounpId、artifactId和version</strong>:以来的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven根据坐标才能找到需要的依赖。</li><li><strong>type</strong>:依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar</li><li><strong>scope</strong>:依赖的范围</li><li><strong>optional</strong>:标记依赖是否可选</li><li><strong>exclusions</strong>:用来排除传递性依赖</li></ul><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系，Maven有如下几种依赖范围：</p><ul><li>**compile:**编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。</li><li><strong>test:</strong> 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。</li><li>**provided:**已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。</li><li>**runtime:**运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。</li><li>**system:**系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致，但是，使用system范围的依赖时必须通过systemPath元素显示地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.sql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdbc-stdext<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**import:**导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。 上述除import以外的各种依赖范围与三种classpath的关系如下:</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b27fceaaf09e1~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h2 id="依赖范围-1"><a href="#依赖范围-1" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>假设A依赖于B,B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。第一直接依赖和第二直接依赖的范围决定了传递性依赖的范围，如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间的交叉单元格则表示传递依赖范围。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b27fceba81e2b~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>从上图中，我们可以发现这样的规律：</p><ul><li>当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致；</li><li>当第二直接依赖的范围是test的时候，依赖不会得以传递；</li><li>当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，切传递依赖的范围同样为provided;</li><li>当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile列外，此时传递性依赖范围为runtime.</li></ul><h2 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h2><p>有时候，当传递性依赖造成为题的时候，就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。这就是依赖调解的作用，依赖调解有两大原则： </p><ol><li>路径最近者优先 比如项目有A有这样的依赖关系：A-&gt;B-&gt;C-&gt;X(1.0)、A-&gt;D-&gt;X(2.0),X是A的传递性依赖，但是两条依赖路径上有两个版本的X，所以根据第一原则，A-&gt;D-&gt;X(2.0)路径短，所以X(2.0)会被解析使用</li><li>第一声明者优先 如果路径都一样长的话，第一原则就不行了，比如 A-&gt;B-&gt;Y(1.0)、A-&gt;C-&gt;Y(2.0),Y(1.0)和Y(2.0)的路径一样，所以这时候根据第二原则，先声明的被解析。</li></ol><h2 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h2><p>有时候你引入的依赖中包含你不想要的依赖包，你想引入自己想要的，这时候就要用到排除依赖了，比如下图中spring-boot-starter-web自带了logback这个日志包，我想引入log4j2的，所以我先排除掉logback的依赖包，再引入想要的包就行了</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b27fd18cdd481~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>排除依赖代码结构：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure><p>声明exclustion的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId就能唯一定位依赖图中的某个依赖。</p><h2 id="归类依赖"><a href="#归类依赖" class="headerlink" title="归类依赖"></a>归类依赖</h2><p>有时候我们引入的很多依赖包，他们都来自同一个项目的不同模块，所以他们的版本号都一样，这时候我们可以用属性来统一管理版本号</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.juven.mvnbook.account<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>accout-email<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">springframework.version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">springframework.version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>   </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springframework.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span>  </span><br></pre></td></tr></table></figure><p>如图所示，先通过</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    这里定义你需要的版本</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>来定义，然后在下面依赖使用${}来引入你的属性。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>在Maven世界中，任何一个依赖、插件或者项目构建的输出，都可以称为构件。得益于坐标机制，任何Maven项目使用任何一个构件的方式都是完全相同的。在此基础上，Maven可以在某个位置统一存储所有Maven项目共享的构件，这个统一的位置就是仓库。</p><p>实际的Maven项目将不再各自存储其依赖文件，它们只需要声明这些依赖的坐标，在需要的时候（例如，编译项目的时候需要将依赖加入到classpath中），Maven会自动根据坐标找到仓库中的构件，并使用它们。</p><p>为了实现重用，项目构建完毕后可生成的构件也可以安装或者部署到仓库中，供其他项目使用。</p><h2 id="仓库的布局"><a href="#仓库的布局" class="headerlink" title="仓库的布局"></a>仓库的布局</h2><p>任何一个构件都有其唯一的坐标，根据这个坐标可以定义其在仓库中的唯一存储路径，这便是Maven的仓库布局方式。 该路经与坐标对应关系为groupId&#x2F;artifactId&#x2F;version&#x2F;artifactId-version.packaging</p><p>Maven仓库是基于简单文件系统存储的，我们也理解其存储方式、因此，当遇到一些与仓库相关的问题时，可以很方便的查找相关文件，方便定位问题</p><h2 id="仓库的分类"><a href="#仓库的分类" class="headerlink" title="仓库的分类"></a>仓库的分类</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/1/2/160b27fd1730a299~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><h3 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h3><p>一般来说，在Maven项目目录下，没有诸如lib&#x2F;这样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。</p><p>默认情况下，不管在Window还是Linux下，每个用户在自己用户目录下都有一个路径名为.m2&#x2F;repository&#x2F;的仓库目录。 如果你想自定义本地仓库目录地址。你可以编辑文件~&#x2F;.m2&#x2F;settings.xml，设置localRepository元素的值为想要的仓库地址，例如:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:\repository\<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，该用户的本地仓库地址就被设置成了 D:\repository\。 需要注意的是，默认情况下，~&#x2F;.m2&#x2F;settings.xml文件不存在，用户需要从Maven安装目录复制$M2_HOME&#x2F;conf&#x2F;settings.xml文件再进行编辑。</p><h3 id="远程仓库-中央仓库"><a href="#远程仓库-中央仓库" class="headerlink" title="远程仓库-中央仓库"></a>远程仓库-中央仓库</h3><p>由于最原始的本地仓库是空的，Maven必须知道至少一个可用的远程仓库，才能在执行Maven命令的时候下载到需要的构件。中央仓库就是这样一个默认的远程仓库，Maven的安装文件自带了中央仓库的配置。</p><p>中央仓库包含了这个世界上绝大多数流行的开源Java构件，以及源码、作者信息、SCM,信息、许可证信息等，每个月这里都会接受全世界Java程序员大概1亿次的访问，它对全世界Java开发者的贡献由此可见一斑。</p><h3 id="远程仓库-私服"><a href="#远程仓库-私服" class="headerlink" title="远程仓库-私服"></a>远程仓库-私服</h3><p>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。因此，一些无法从外部仓库下载到的构件也能从本地上传到私服上供大家使用。 私服的好处：</p><ul><li>节省自己的外网速度</li><li>加速Maven构建</li><li>部署第三方构建</li><li>提高稳定性，增强控制</li><li>降低中央仓库的负荷</li></ul><h2 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h2><p>在平时的开发中，我们往往不会使用默认的中央仓库，默认的中央仓库访问的速度比较慢，访问的人或许很多，有时候也无法满足我们项目的需求，可能项目需要的某些构件中央仓库中是没有的，而在其他远程仓库中有，如JBoss Maven仓库。这时，可以在pom.xml中配置该仓库，代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>jboss<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>JBoss Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repository.jboss.com/maven2/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span>&gt;</span>daily<span class="tag">&lt;/<span class="name">updatePolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">checksumPolicy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>**repository:**在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。</li><li><strong>id：</strong>仓库声明的唯一id，尤其需要注意的是，Maven自带的中央仓库使用的id为central，如果其他仓库声明也使用该id，就会覆盖中央仓库的配置。</li><li><strong>name：</strong>仓库的名称，让我们直观方便的知道仓库是哪个，暂时没发现其他太大的含义。</li><li><strong>url：</strong>指向了仓库的地址，一般来说，该地址都基于http协议，Maven用户都可以在浏览器中打开仓库地址浏览构件。</li><li>**releases和snapshots：**用来控制Maven对于发布版构件和快照版构件的下载权限。需要注意的是**enabled**子元素，该例中releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持，而snapshots的enabled值为false，表示关闭JBoss仓库的快照版本的下载支持。根据该配置，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。</li><li><strong>layout：</strong>元素值default表示仓库的布局是Maven2及Maven3的默认布局，而不是Maven1的布局。基本不会用到Maven1的布局。</li><li><strong>其他：**对于releases和snapshots来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy。<br>1：元素**updatePolicy**用来配置Maven从远处仓库检查更新的频率，默认值是daily，表示Maven每天检查一次。其他可用的值包括：never-从不检查更新；always-每次构建都检查更新；interval：X-每隔X分钟检查一次更新（X为任意整数）。<br>2：元素</strong>checksumPolicy**用来配置Maven检查校验和文件的策略。当构建被部署到Maven仓库中时，会同时部署对应的检验和文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其他可用的值包括：fail-Maven遇到校验和错误就让构建失败；ignore-使Maven完全忽略校验和错误。</li></ul><h2 id="远程仓库认证"><a href="#远程仓库认证" class="headerlink" title="远程仓库认证"></a>远程仓库认证</h2><p>大部分的远程仓库不需要认证，但是如果是自己内部使用，为了安全起见，还是要配置认证信息的。配置认证信息和配置远程仓库不同，远程仓库可以直接在pom.xml中配置，但是认证信息必须配置在settings.xml文件中。这是因为pom往往是被提交到代码仓库中供所有成员访问的，而settings.xml一般只存在于本机。因此，在settings.xml中配置认证信息更为安全。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">username</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">password</span>&gt;</span>admin123<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里除了配置账号密码之外，值关键的就是id了，这个id要跟你在pom.xml里面配置的远程仓库repository的id一致，正是这个id将认证信息与仓库配置联系在了一起。</p><h2 id="部署构件至远程仓库"><a href="#部署构件至远程仓库" class="headerlink" title="部署构件至远程仓库"></a>部署构件至远程仓库</h2><p>我们自己搭建远程仓库的目的就是为了可以方便部署我们自己项目的构件以及一些无法从外部仓库直接获取的构件。这样才能在开发时，供其他对团队成员使用。 Maven除了能对项目进行编译、测试、打包之外，还能将项目生成的构件部署到远程仓库中。首先，需要编辑项目的pom.xml文件。配置distributionManagement元素，代码如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>public<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>地址<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>地址<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>repository表示表示发布版本（稳定版本）构件的仓库，snapshotRepository表示快照版本（开发测试版本）的仓库。这两个元素都需要配置id、name和url，id为远程仓库的唯一标识，name是为了方便人阅读，关键的url表示该仓库的地址。</p><p>配置完成后运行命令mvn clean deploy，Maven就会将项目构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本的仓库地址，否则就部署到发布版本的仓库地址。当前项目是快照还是发布版本是通过 true 这个来区分的</p><h2 id="仓库服务搜索"><a href="#仓库服务搜索" class="headerlink" title="仓库服务搜索"></a>仓库服务搜索</h2><ul><li>Sonatype Nexus：<a href="https://link.juejin.cn/?target=https://repository.sonatype.org/">repository.sonatype.org&#x2F;</a></li><li>MVNrepository：<a href="https://link.juejin.cn/?target=http://mvnrepository.com/">mvnrepository.com&#x2F;</a></li></ul><p>另外推荐一个插件：Maven Search，可以快速找到需要的jar包</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb技术（下）</title>
      <link href="/inori/7786d571.html"/>
      <url>/inori/7786d571.html</url>
      
        <content type="html"><![CDATA[<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><blockquote><p><code>前端工程化</code>是使用<code>软件工程的方法</code>来<code>单独</code>解决<code>前端</code>的开发流程中<code>模块化、组件化、规范化、自动化</code>的问题,其主要目的为了提高效率和降低成本。 </p></blockquote><h3 id="实现技术栈"><a href="#实现技术栈" class="headerlink" title="实现技术栈"></a>实现技术栈</h3><blockquote><p>前端工程化实现的技术栈有很多,在这里采用ES6+nodejs+npm+Vite+VUE3+router+pinia+axios+Element-plus组合实现</p></blockquote><ul><li>ECMAScript6       VUE3中大量使用ES6语法</li><li>Nodejs                前端项目运行环境</li><li>npm                    依赖下载工具</li><li>vite                      前端项目构建工具</li><li>VUE3                   优秀的渐进式前端框架</li><li>router                 通过路由实现页面切换</li><li>pinia                   通过状态管理实现组件数据传递</li><li>axios                   ajax异步请求封装技术实现前后端数据交互</li><li>Element-plus     可以提供丰富的快速构建网页的组件仓库</li></ul><h2 id="ECMAScript6"><a href="#ECMAScript6" class="headerlink" title="ECMAScript6"></a>ECMAScript6</h2><blockquote><p>ECMAScript6，简称ES6，是<strong>JavaScript</strong>语言的一次重大更新。ES6带来了大量的新特性，包括箭头函数、模板字符串、let和const关键字、解构、默认参数值、模块系统等等，大大提升了JavaScript的开发体验。</p></blockquote><p>ES6对JavaScript的改进在以下几个方面：</p><ol><li>更加简洁：ES6引入了一些新的语法，如箭头函数、类和模板字符串等，使代码更加简洁易懂。</li><li>更强大的功能：ES6引入了一些新的API、解构语法和迭代器等功能，从而使得JavaScript更加强大。</li><li>更好的适用性：ES6引入的模块化功能为JavaScript代码的组织和管理提供了更好的方式，不仅提高了程序的可维护性，还让JavaScript更方便地应用于大型的应用程序。</li></ol><h3 id="变量和模板字符串"><a href="#变量和模板字符串" class="headerlink" title="变量和模板字符串"></a>变量和模板字符串</h3><blockquote><p>ES6 新增了<code>let</code>和<code>const</code>，用来声明变量,使用的细节上也存在诸多差异</p></blockquote><ul><li><p>let和var的差别</p><p>1、let不能重复声明</p><p>2、let有块级作用域，非函数的花括号遇见let会有块级作用域，也就是只能在花括号里面访问。</p><p>3、let不会预解析进行变量提升</p><p>4、let定义的全局变量不会作为window的属性</p></li><li><p>const和var的差异</p><p>1、新增const和let类似，只是const定义的变量不能修改</p><p>2、并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p></li></ul><blockquote><p>模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识  </p></blockquote><p>1、字符串中可以出现换行符</p><p>2、可以使用 ${xxx} 形式输出变量和拼接变量</p><h3 id="解构表达式"><a href="#解构表达式" class="headerlink" title="解构表达式"></a>解构表达式</h3><blockquote><p>ES6 的解构赋值是一种方便的语法，可以快速将数组或对象中的值拆分并赋值给变量。解构赋值的语法使用花括号 <code>&#123;&#125;</code> 表示对象，方括号 <code>[]</code> 表示数组。通过解构赋值，函数更方便进行参数接受等！</p></blockquote><p><strong>数组解构赋值</strong></p><ul><li>可以通过数组解构将数组中的值赋值给变量，语法为：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">//新增变量名任意合法即可，本质是按照顺序进行初始化变量的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>该语句将数组 [1, 2, 3] 中的第一个值赋值给 a 变量，第二个值赋值给 b 变量，第三个值赋值给 c 变量。<br>可以使用默认值为变量提供备选值，在数组中缺失对应位置的值时使用该默认值。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c, d = <span class="number">4</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>对象解构赋值</strong></p></blockquote><ul><li>可以通过对象解构将对象中的值赋值给变量，语法为：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a, b&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">//新增变量名必须和属性名相同，本质是初始化变量的值为对象中同名属性的值</span></span><br><span class="line"><span class="comment">//等价于 let a = 对象.a  let b = 对象.b</span></span><br><span class="line">  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>该语句将对象 {a: 1, b: 2} 中的 a 属性值赋值给 a 变量，b 属性值赋值给 b 变量。<br>可以为标识符分配不同的变量名称，使用 : 操作符指定新的变量名。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: x, <span class="attr">b</span>: y&#125; = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>函数参数解构赋值</strong></p></blockquote><ul><li>解构赋值也可以用于函数参数。例如：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">[x, y]</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li><p>该函数接受一个数组作为参数，将其中的第一个值赋给 x，第二个值赋给 y，然后返回它们的和。</p></li><li><p>ES6 解构赋值让变量的初始化更加简单和便捷。通过解构赋值，我们可以访问到对象中的属性，并将其赋值给对应的变量，从而提高代码的可读性和可维护性。</p></li></ul><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//ES6 允许使用“箭头”（=&gt;）定义函数。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 函数声明</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> fn1 = <span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fn2</span> = (<span class="params"></span>)=&gt;&#123;&#125; <span class="comment">//箭头函数,此处不需要书写function关键字</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fn3</span> = x =&gt;&#123;&#125; <span class="comment">//单参数可以省略(),多参数无参数不可以</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fn4</span> = x =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(x) <span class="comment">//只有一行方法体可以省略&#123;&#125;;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fun5</span> = x =&gt; x + <span class="number">1</span> <span class="comment">//当函数体只有一句返回值时，可以省略花括号和 return 语句</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. 使用特点 箭头函数this关键字</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 在 JavaScript 中，this 关键字通常用来引用函数所在的对象，</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 或者在函数本身作为构造函数时，来引用新对象的实例。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 但是在箭头函数中，this 的含义与常规函数定义中的含义不同，</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 并且是由箭头函数定义时的上下文来决定的，而不是由函数调用时的上下文来决定的。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 箭头函数没有自己的this，this指向的是外层上下文环境的this</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person =&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">showName</span>:<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">//  这里的this是person</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">viewName</span>: <span class="function">() =&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">//  这里的this是window</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    person.<span class="title function_">showName</span>()</span></span><br><span class="line"><span class="language-javascript">    person.<span class="title function_">viewName</span>()</span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//this应用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">count</span> = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 这里的 this 是上一层作用域中的 this，即 Counter实例化对象</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="property">count</span>++;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">count</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="rest和spread"><a href="#rest和spread" class="headerlink" title="rest和spread"></a>rest和spread</h4><blockquote><p>rest参数,在形参上使用和JAVA中的可变参数几乎一样</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 1 参数列表中多个普通参数  普通函数和箭头函数中都支持</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> fun1 = <span class="keyword">function</span> (<span class="params">a,b,c,d=<span class="number">10</span></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c,d)&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fun2</span> = (<span class="params">a,b,c,d=<span class="number">10</span></span>) =&gt;&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c,d)&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun1</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun2</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 2 ...作为参数列表,称之为rest参数 普通函数和箭头函数中都支持 ,因为箭头函数中无法使用arguments,rest是一种解决方案</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> fun3 = <span class="keyword">function</span> (<span class="params">...args</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(args)&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fun4</span> = (<span class="params">...args</span>) =&gt;&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(args)&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun3</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun4</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// rest参数在一个参数列表中的最后一个只,这也就无形之中要求一个参数列表中只能有一个rest参数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//let fun5 =  (...args,...args2) =&gt;&#123;&#125; // 这里报错</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>spread参数,在实参上使用rest</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//let arrSpread = ...arr;// 这样不可以,...arr必须在调用方法时作为实参使用</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fun1</span> =(<span class="params">a,b,c</span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 调用方法时,对arr进行转换 转换为1,2,3 </span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun1</span>(...arr)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//应用场景1 合并数组</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> arr2=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> arr3=[...arr,...arr2]</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr3)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//应用场景2 合并对象属性</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> p1=&#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> p2=&#123;<span class="attr">age</span>:<span class="number">10</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> p3=&#123;<span class="attr">gender</span>:<span class="string">&quot;boy&quot;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person =&#123;...p1,...p2,...p3&#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(person)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="对象创建和拷贝"><a href="#对象创建和拷贝" class="headerlink" title="对象创建和拷贝"></a>对象创建和拷贝</h3><h4 id="对象创建的语法糖"><a href="#对象创建的语法糖" class="headerlink" title="对象创建的语法糖"></a>对象创建的语法糖</h4><blockquote><p>ES6中新增了对象创建的语法糖,支持了class extends constructor等关键字,让ES6的语法和面向对象的语法更加接近</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">      <span class="comment">// 属性</span></span><br><span class="line">      #n;</span><br><span class="line">      age;</span><br><span class="line">      <span class="keyword">get</span> <span class="title function_">name</span>()&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">n</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">n</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">n</span> =n;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 实例方法</span></span><br><span class="line">      <span class="title function_">eat</span>(<span class="params">food</span>)&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>+<span class="string">&quot;岁的&quot;</span>+<span class="variable language_">this</span>.<span class="property">n</span>+<span class="string">&quot;用筷子吃&quot;</span>+food)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 静态方法</span></span><br><span class="line">      <span class="keyword">static</span> <span class="title function_">sum</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> a+b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 构造器</span></span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">n</span>=name;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> person =<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// 访问对象属性</span></span><br><span class="line">  <span class="comment">// 调用对象方法</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">n</span>)</span><br><span class="line">  person.<span class="property">name</span>=<span class="string">&quot;小明&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>)</span><br><span class="line">  person.<span class="title function_">eat</span>(<span class="string">&quot;火锅&quot;</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span>  <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">      grade ;</span><br><span class="line">      score ;</span><br><span class="line">      <span class="title function_">study</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">constructor</span>(<span class="params">name,age </span>) &#123;</span><br><span class="line">          <span class="variable language_">super</span>(name,age);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> stu =<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小李&quot;</span>,<span class="number">18</span>);</span><br><span class="line">  stu.<span class="title function_">eat</span>(<span class="string">&quot;面条&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="模块化处理"><a href="#模块化处理" class="headerlink" title="模块化处理"></a>模块化处理</h3><blockquote><p>模块化是一种组织和管理前端代码的方式，将代码拆分成小的模块单元，使得代码更易于维护、扩展和复用。它包括了定义、导出、导入以及管理模块的方法和规范。前端模块化的主要优势如下：</p></blockquote><ol><li>提高代码可维护性：通过将代码拆分为小的模块单元，使得代码结构更为清晰，可读性更高，便于开发者阅读和维护。</li><li>提高代码可复用性：通过将重复使用的代码变成可复用的模块，减少代码重复率，降低开发成本。</li><li>提高代码可扩展性：通过模块化来实现代码的松耦合，便于更改和替换模块，从而方便地扩展功能。</li></ol><blockquote><p>目前，前端模块化有多种规范和实现，包括 CommonJS、AMD 和 ES6 模块化。ES6 模块化是 JavaScript 语言的模块标准，使用 import 和 export 关键字来实现模块的导入和导出。现在，大部分浏览器都已经原生支持 ES6 模块化，因此它成为了最为广泛使用的前端模块化标准</p></blockquote><ul><li>ES6模块化的几种暴露和导入方式<ol><li>分别导出</li><li>统一导出</li><li>默认导出</li></ol></li><li><code>ES6中无论以何种方式导出,导出的都是一个对象,导出的内容都可以理解为是向这个对象中添加属性或者方法</code></li></ul><h4 id="分别导出"><a href="#分别导出" class="headerlink" title="分别导出"></a>分别导出</h4><ul><li>module.js 向外分别暴露成员</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.分别暴露</span></span><br><span class="line"><span class="comment">// 模块想对外导出,添加export关键字即可!</span></span><br><span class="line"><span class="comment">// 导出一个变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 导出一个函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个类</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>app.js 导入module.js中的成员</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    *代表module.js中的所有成员</span></span><br><span class="line"><span class="comment">    m1代表所有成员所属的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="comment">// 使用暴露的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m1.<span class="property">PI</span>)</span><br><span class="line"><span class="comment">// 调用暴露的方法</span></span><br><span class="line"><span class="keyword">let</span> result =m1.<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="comment">// 使用暴露的Person类</span></span><br><span class="line"><span class="keyword">let</span> person =<span class="keyword">new</span> m1.<span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">person.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><ul><li>index.html作为程序启动的入口  导入 app.js</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入JS文件 添加type=&#x27;module&#x27; 属性,否则不支持ES6的模块化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./app.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> /&gt;</span> </span><br></pre></td></tr></table></figure><h4 id="统一导出"><a href="#统一导出" class="headerlink" title="统一导出"></a>统一导出</h4><ul><li>module.js向外统一导出成员</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.统一暴露</span></span><br><span class="line"><span class="comment">// 模块想对外导出,export统一暴露想暴露的内容!</span></span><br><span class="line"><span class="comment">// 定义一个常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 定义一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 统一对外导出(暴露)</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line"><span class="variable constant_">PI</span>,</span><br><span class="line">    sum,</span><br><span class="line">    <span class="title class_">Person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>app.js导入module.js中的成员</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    &#123;&#125;中导入要使用的来自于module.js中的成员</span></span><br><span class="line"><span class="comment">    &#123;&#125;中导入的名称要和module.js中导出的一致,也可以在此处起别名</span></span><br><span class="line"><span class="comment">    &#123;&#125;中如果定义了别名,那么在当前模块中就只能使用别名</span></span><br><span class="line"><span class="comment">    &#123;&#125;中导入成员的顺序可以不是暴露的顺序</span></span><br><span class="line"><span class="comment">    一个模块中可以同时有多个import</span></span><br><span class="line"><span class="comment">    多个import可以导入多个不同的模块,也可以是同一个模块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//import &#123;PI ,Person ,sum &#125;  from &#x27;./module.js&#x27;</span></span><br><span class="line"><span class="comment">//import &#123;PI as pi,Person as People,sum as add&#125;  from &#x27;./module.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">PI</span> ,<span class="title class_">Person</span> ,sum,<span class="variable constant_">PI</span> <span class="keyword">as</span> pi,<span class="title class_">Person</span> <span class="keyword">as</span> <span class="title class_">People</span>,sum <span class="keyword">as</span> add&#125;  <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="comment">// 使用暴露的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pi)</span><br><span class="line"><span class="comment">// 调用暴露的方法</span></span><br><span class="line"><span class="keyword">let</span> result1 =<span class="title function_">sum</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1)</span><br><span class="line"><span class="keyword">let</span> result2 =<span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line"><span class="comment">// 使用暴露的Person类</span></span><br><span class="line"><span class="keyword">let</span> person1 =<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">person1.<span class="title function_">sayHello</span>()</span><br><span class="line"><span class="keyword">let</span> person2 =<span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&#x27;李四&#x27;</span>,<span class="number">11</span>)</span><br><span class="line">person2.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><h4 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h4><ul><li>modules混合向外导出</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3默认和混合暴露</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    默认暴露语法  export default sum</span></span><br><span class="line"><span class="comment">    默认暴露相当于是在暴露的对象中增加了一个名字为default的属性</span></span><br><span class="line"><span class="comment">    三种暴露方式可以在一个module中混合使用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="number">3.14</span></span><br><span class="line"><span class="comment">// 导出一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 导出一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>, I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出默认</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum</span><br><span class="line"><span class="comment">// 统一导出</span></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">   <span class="title class_">Person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>app.js的default和其他导入写法混用</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    *代表module.js中的所有成员</span></span><br><span class="line"><span class="comment">    m1代表所有成员所属的对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m1 <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> add&#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span> <span class="comment">// 用的少</span></span><br><span class="line"><span class="keyword">import</span> add2 <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span> <span class="comment">// 等效于 import &#123;default as add2&#125; from &#x27;./module.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用暴露的方法</span></span><br><span class="line"><span class="keyword">let</span> result =m1.<span class="title function_">default</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result)</span><br><span class="line"><span class="keyword">let</span> result2 =<span class="title function_">add</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2)</span><br><span class="line"><span class="keyword">let</span> result3 =<span class="title function_">add2</span>(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入其他方式暴露的内容</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">PI</span>,<span class="title class_">Person</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span></span><br><span class="line"><span class="comment">// 使用暴露的Person类</span></span><br><span class="line"><span class="keyword">let</span> person =<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;张三&#x27;</span>,<span class="number">10</span>)</span><br><span class="line">person.<span class="title function_">sayHello</span>()</span><br><span class="line"><span class="comment">// 使用暴露的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">PI</span>)</span><br></pre></td></tr></table></figure><h2 id="前端工程化环境搭建"><a href="#前端工程化环境搭建" class="headerlink" title="前端工程化环境搭建"></a>前端工程化环境搭建</h2><h3 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h3><blockquote><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，可以使 JavaScript 运行在服务器端。使用 Node.js，可以方便地开发服务器端应用程序，如 Web 应用、API、后端服务，还可以通过 Node.js 构建命令行工具等。相比于传统的服务器端语言（如 PHP、Java、Python 等），Node.js 具有以下特点：</p></blockquote><ul><li>单线程，但是采用了事件驱动、异步 I&#x2F;O 模型，可以处理高并发请求。</li><li>轻量级，使用 C++ 编写的 V8 引擎让 Node.js 的运行速度很快。</li><li>模块化，Node.js 内置了大量模块，同时也可以通过第三方模块扩展功能。</li><li>跨平台，可以在 Windows、Linux、Mac 等多种平台下运行。</li></ul><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><blockquote><p>NPM全称Node Package Manager，是Node.js包管理工具，是全球最大的模块生态系统，里面所有的模块都是开源免费的；也是Node.js的包管理工具，相当于后端的Maven 。</p></blockquote><h4 id="npm配置"><a href="#npm配置" class="headerlink" title="npm配置"></a>npm配置</h4><blockquote><p>配置依赖下载使用阿里镜像</p></blockquote><ul><li>npm 安装依赖包时默认使用的是官方源，由于国内网络环境的原因，有时会出现下载速度过慢的情况。为了解决这个问题，可以配置使用阿里镜像来加速 npm 的下载速度，具体操作如下：</li><li>打开命令行终端，执行以下命令，配置使用阿里镜像：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><ul><li>确认配置已生效，可以使用以下命令查看当前 registry 的配置：如果输出结果为 <code>https://registry.npmmirror.com</code>，说明配置已成功生效。</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><ul><li>如果需要恢复默认的官方源，可以执行以下命令：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm config set registry <span class="attr">https</span>:<span class="comment">//registry.npmjs.org/</span></span><br></pre></td></tr></table></figure><blockquote><p>配置全局依赖下载后存储位置</p></blockquote><ul><li><p>在 Windows 系统上，npm 的全局依赖默认安装在 <code>&lt;用户目录&gt;\AppData\Roaming\npm</code> 目录下。</p></li><li><p>如果需要修改全局依赖的安装路径，可以按照以下步骤操作：</p><ol><li><p>创建一个新的全局依赖存储目录</p></li><li><p>打开命令行终端，执行以下命令来配置新的全局依赖存储路径：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set prefix &quot;存储位置&quot;</span><br></pre></td></tr></table></figure></li><li><p>确认配置已生效，可以使用以下命令查看当前的全局依赖存储路径：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config get prefix</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a>npm常用命令</h4><blockquote><p>1.项目初始化</p></blockquote><ul><li>npm init<ul><li>进入一个vscode创建好的项目中, 执行 npm init 命令后，npm 会引导您在命令行界面上回答一些问题,例如项目名称、版本号、作者、许可证等信息，并最终生成一个package.json 文件。package.json信息会包含项目基本信息！类似maven的pom.xml</li></ul></li><li>npm init -y<ul><li>执行，-y yes的意思，所有信息使用当前文件夹的默认值</li></ul></li></ul><blockquote><p>2.安装依赖  (<a href="https://www.npmjs.com/">查看所有依赖地址</a>)</p></blockquote><ul><li>npm install 包名 或者 npm install 包名@版本号<ul><li>安装包或者指定版本的依赖包(安装到当前项目中)</li></ul></li><li>npm install -g 包名<ul><li>安装全局依赖包(安装到默认全局目录)则可以在任何项目中使用它，而无需在每个项目中独立安装该包。</li></ul></li><li>npm install<ul><li>安装package.json中的所有记录的依赖</li></ul></li></ul><blockquote><p>3.升级依赖</p></blockquote><ul><li>npm update 包名<ul><li>将依赖升级到最新版本</li></ul></li></ul><blockquote><p>4.卸载依赖</p></blockquote><ul><li>npm uninstall 包名</li></ul><blockquote><p>5.查看依赖</p></blockquote><ul><li><p>npm ls</p><ul><li>查看项目依赖</li></ul></li><li><p>npm list -g</p><ul><li>查看全局依赖</li></ul></li></ul><blockquote><p>6.运行命令</p></blockquote><ul><li><p>npm run 命令是在执行 npm 脚本时使用的命令。npm 脚本是一组在 package.json 文件中定义的可执行命令。npm 脚本可用于启动应用程序，运行测试，生成文档等，还可以自定义命令以及配置需要运行的脚本。</p></li><li><p>在 package.json 文件中，scripts 字段是一个对象，其中包含一组键值对，键是要运行的脚本的名称，值是要执行的命令。例如，以下是一个简单的 package.json 文件：</p></li><li><p>scripts 对象包含 start、test 和 build 三个脚本。当您运行 npm run start 时，将运行 node index.js，并启动应用程序。同样，运行 npm run test 时，将运行 Jest 测试套件，而 npm run build 将运行 webpack 命令以生成最终的构建输出。</p></li><li><p>总之，npm run 命令提供了一种在 package.json 文件中定义和管理一组指令的方法，可以在项目中快速且灵活地运行各种操作。</p></li></ul><h2 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h2><p> <strong>Vue的两个核心功能：</strong></p><ul><li><strong>声明式渲染</strong>：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。</li><li><strong>响应性</strong>：Vue 会自动跟踪 JavaScript 状态并在其发生变化时响应式地更新DOM</li></ul><p><a href="https://cn.vuejs.org/guide/introduction.html">Vue文档</a></p><h3 id="通过Vite实现工程化"><a href="#通过Vite实现工程化" class="headerlink" title="通过Vite实现工程化"></a>通过Vite实现工程化</h3><blockquote><p>Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，且越来越多 JavaScript 工具使用编译型语言编写。<a href="https://cn.vitejs.dev/guide/why.html">https://cn.vitejs.dev/guide/why.html</a></p></blockquote><p>前端工程化的作用包括但不限于：</p><ol><li>快速创建项目：使用脚手架可以快速搭建项目基本框架，避免从零开始搭建项目的重复劳动和繁琐操作，从而节省时间和精力。</li><li>统一的工程化规范：前端脚手架可以预设项目目录结构、代码规范、git提交规范等统一的工程化规范，让不同开发者在同一个项目上编写出风格一致的代码，提高协作效率和质量。</li><li>代码模板和组件库：前端脚手架可以包含一些常用的代码模板和组件库，使开发者在实现常见功能时不再重复造轮子，避免因为轮子质量不高带来的麻烦，能够更加专注于项目的业务逻辑。</li><li>自动化构建和部署：前端脚手架可以自动进行代码打包、压缩、合并、编译等常见的构建工作，可以通过集成自动化部署脚本，自动将代码部署到测试、生产环境等。</li></ol><h4 id="Vite创建Vue3工程化项目"><a href="#Vite创建Vue3工程化项目" class="headerlink" title="Vite创建Vue3工程化项目"></a>Vite创建Vue3工程化项目</h4><blockquote><p>1 使用命令行创建工程</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm create vite@latest</span><br></pre></td></tr></table></figure><ul><li>第一次使用vite时会提示下载vite,输入y回车即可,下次使用vite就不会出现了</li></ul><blockquote><p>2 安装项目所需依赖</p></blockquote><ul><li>npm install命令安装基础依赖</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ./vue3-demo1</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><blockquote><p>3 启动项目</p></blockquote><ul><li>查看项目下的package.json</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue3-demo1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bootstrap&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^5.2.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;sass&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^1.62.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^3.2.47&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@vitejs/plugin-vue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;vite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^4.3.2&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h4 id="Vite-Vue3项目的目录结构"><a href="#Vite-Vue3项目的目录结构" class="headerlink" title="Vite+Vue3项目的目录结构"></a>Vite+Vue3项目的目录结构</h4><ul><li>public&#x2F; 目录：用于存放一些公共资源，如 HTML 文件、图像、字体等，这些资源会被直接复制到构建出的目标目录中。</li><li>src&#x2F; 目录：存放项目的源代码，包括 JavaScript、CSS、Vue 组件、图像和字体等资源。在开发过程中，这些文件会被 Vite 实时编译和处理，并在浏览器中进行实时预览和调试。以下是src内部划分建议：<ol><li><code>assets/</code> 目录：用于存放一些项目中用到的静态资源，如图片、字体、样式文件等。</li><li><code>components/</code> 目录：用于存放组件相关的文件。组件是代码复用的一种方式，用于抽象出一个可复用的 UI 部件，方便在不同的场景中进行重复使用。</li><li><code>layouts/</code> 目录：用于存放布局组件的文件。布局组件通常负责整个应用程序的整体布局，如头部、底部、导航菜单等。</li><li><code>pages/</code> 目录：用于存放页面级别的组件文件，通常是路由对应的组件文件。在这个目录下，可以创建对应的文件夹，用于存储不同的页面组件。</li><li><code>plugins/</code> 目录：用于存放 Vite 插件相关的文件，可以按需加载不同的插件来实现不同的功能，如自动化测试、代码压缩等。</li><li><code>router/</code> 目录：用于存放 Vue.js 的路由配置文件，负责管理视图和 URL 之间的映射关系，方便实现页面之间的跳转和数据传递。</li><li><code>store/</code> 目录：用于存放 Vuex 状态管理相关的文件，负责管理应用程序中的数据和状态，方便统一管理和共享数据，提高开发效率。</li><li><code>utils/</code> 目录：用于存放一些通用的工具函数，如日期处理函数、字符串操作函数等。</li></ol></li><li>vite.config.js 文件：Vite 的配置文件，可以通过该文件配置项目的参数、插件、打包优化等。该文件可以使用 CommonJS 或 ES6 模块的语法进行配置。</li><li>package.json 文件：标准的 Node.js 项目配置文件，包含了项目的基本信息和依赖关系。其中可以通过 scripts 字段定义几个命令，如 dev、build、serve 等，用于启动开发、构建和启动本地服务器等操作。</li><li>Vite 项目的入口为 src&#x2F;main.js 文件，这是 Vue.js 应用程序的启动文件，也是整个前端应用程序的入口文件。在该文件中，通常会引入 Vue.js 及其相关插件和组件，同时会创建 Vue 实例，挂载到 HTML 页面上指定的 DOM 元素中。</li></ul><blockquote><p> 2.vite的运行界面</p></blockquote><ul><li>在安装了 Vite 的项目中，可以在 npm scripts 中使用 <code>vite</code> 可执行文件。下面是通过脚手架创建的 Vite 项目中默认的 npm scripts：(package.json)</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite&quot;</span><span class="punctuation">,</span> <span class="comment">// 启动开发服务器，别名：`vite dev`，`vite serve`</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build&quot;</span><span class="punctuation">,</span> <span class="comment">// 为生产环境构建产物</span></span><br><span class="line">    <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span> <span class="comment">// 本地预览生产构建产物</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>运行设置端口号：(vite.config.js)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改vite项目配置文件 vite.config.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="title function_">vue</span>()],</span><br><span class="line">  <span class="attr">server</span>:&#123;</span><br><span class="line">    <span class="attr">port</span>:<span class="number">3000</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="Vite-Vue3项目组件-SFC入门"><a href="#Vite-Vue3项目组件-SFC入门" class="headerlink" title="Vite+Vue3项目组件(SFC入门)"></a>Vite+Vue3项目组件(SFC入门)</h4><blockquote><p>什么是VUE的组件?</p></blockquote><ul><li>一个页面作为整体,是由多个部分组成的,每个部分在这里就可以理解为一个组件</li><li>每个.vue文件就可以理解为一个组件,多个.vue文件可以构成一个整体页面</li><li>组件化给我们带来的另一个好处就是组件的复用和维护非常的方便</li></ul><blockquote><p>什么是.vue文件?</p></blockquote><ul><li><p>传统的页面有.html文件.css文件和.js文件三个文件组成(多文件组件) </p></li><li><p>vue将这文件合并成一个.vue文件(Single-File Component，简称 SFC,单文件组件)</p></li><li><p>.vue文件对js&#x2F;css&#x2F;html统一封装,这是VUE中的概念 该文件由三个部分组成<code>&lt;script&gt;    &lt;template&gt;    &lt;style&gt;</code></p><ul><li>template标签     代表组件的html部分代码代替传统的.html文件</li><li>script标签           代表组件的js代码 代替传统的.js文件</li><li>style标签            代表组件的css样式代码 代替传统的.css文件</li></ul></li></ul><p></p><blockquote><p>工程化vue项目如何组织这些组件?</p></blockquote><ul><li>index.html是项目的入口,其中 <code>&lt;div id =&#39;app&#39;&gt;&lt;/div&gt;</code>是用于挂载所有组建的元素</li><li>index.html中的script标签引入了一个main.js文件,具体的挂载过程在main.js中执行</li><li>main.js是vue工程中非常重要的文件,他决定这项目使用哪些依赖,导入的第一个组件</li><li>App.vue是vue中的核心组件,所有的其他组件都要通过该组件进行导入,该组件通过路由可以控制页面的切换</li></ul><h4 id="Vite-Vue3响应式和setup函数"><a href="#Vite-Vue3响应式和setup函数" class="headerlink" title="Vite+Vue3响应式和setup函数"></a>Vite+Vue3响应式和setup函数</h4><blockquote><p>使用vite创建一个vue+JavaScript项目</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm create vite</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><blockquote><p>vue3响应式数据入门</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//存储vue页面逻辑js代码</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">setup</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//非响应式数据: 修改后VUE不会更新DOM</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//响应式数据:   修改后VUE会更新DOM</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//VUE2中数据默认是响应式的</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//VUE3中数据要经过ref或者reactive处理后才是响应式的</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//ref是VUE3框架提供的一个函数,需要导入</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//let counter = 1</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//ref处理的响应式数据在js编码修改的时候需要通过.value操作</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//ref响应式数据在绑定到html上时不需要.value</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> counter = <span class="title function_">ref</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">increase</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// 通过.value修改响应式数据</span></span></span><br><span class="line"><span class="language-javascript">                counter.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span> <span class="title function_">decrease</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                counter.<span class="property">value</span>--</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                counter,</span></span><br><span class="line"><span class="language-javascript">                increase,</span></span><br><span class="line"><span class="language-javascript">                decrease</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrease()&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      &#123;&#123; counter &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increase()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">button</span>&#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>setup函数和语法糖</p></blockquote><ul><li>src&#x2F;App.vue</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;module&quot; setup&gt;</span><br><span class="line"></span><br><span class="line">/* &lt;script type=&quot;module&quot; setup&gt; 通过setup关键字</span><br><span class="line">可以省略 export default &#123;setup()&#123;   return&#123;&#125;&#125;&#125;这些冗余的语法结构 */</span><br><span class="line">    import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">    // 定义响应式数据</span><br><span class="line">    let counter = ref(1)</span><br><span class="line">    // 定义函数</span><br><span class="line">    function increase()&#123;</span><br><span class="line">        counter.value++</span><br><span class="line">    &#125;</span><br><span class="line">    function decrease()&#123;</span><br><span class="line">        counter.value--</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button @click=&quot;decrease()&quot;&gt;-&lt;/button&gt;</span><br><span class="line">      &#123;&#123; counter &#125;&#125;</span><br><span class="line">      &lt;button @click=&quot;increase()&quot;&gt;+&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">    button&#123;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="Vue3视图渲染技术"><a href="#Vue3视图渲染技术" class="headerlink" title="Vue3视图渲染技术"></a>Vue3视图渲染技术</h3><blockquote><p>Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。</p></blockquote><h4 id="插值表达式和文本渲染"><a href="#插值表达式和文本渲染" class="headerlink" title="插值表达式和文本渲染"></a>插值表达式和文本渲染</h4><blockquote><p>插值表达式:最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 ,即双大括号<code>&#123;&#123;&#125;&#125;</code></p></blockquote><ul><li>插值表达式是将数据渲染到元素的指定位置的手段之一</li><li>插值表达式不绝对依赖标签,其位置相对自由</li><li>插值表达式中支持javascript的运算表达式</li><li>插值表达式中也支持函数的调用</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> msg =<span class="string">&quot;hello vue3&quot;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getMsg</span>= (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="string">&#x27;hello vue3 message&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> age = <span class="number">19</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> bee = <span class="string">&#x27;蜜 蜂&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 购物车</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> carts = [&#123;<span class="attr">name</span>:<span class="string">&#x27;可乐&#x27;</span>,<span class="attr">price</span>:<span class="number">3</span>,<span class="attr">number</span>:<span class="number">10</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">&#x27;薯片&#x27;</span>,<span class="attr">price</span>:<span class="number">6</span>,<span class="attr">number</span>:<span class="number">8</span>&#125;];</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//计算购物车总金额</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">compute</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> count = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">for</span>(<span class="keyword">let</span> index <span class="keyword">in</span> carts)&#123;</span></span><br><span class="line"><span class="language-javascript">          count += carts[index].<span class="property">price</span>*carts[index].<span class="property">number</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> count;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    msg的值为: &#123;&#123; msg &#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    getMsg返回的值为:&#123;&#123; getMsg() &#125;&#125;  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    是否成年: &#123;&#123; age&gt;=18?&#x27;true&#x27;:&#x27;false&#x27; &#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    反转: &#123;&#123; bee.split(&#x27; &#x27;).reverse().join(&#x27;-&#x27;) &#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    购物车总金额: &#123;&#123; compute() &#125;&#125; <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    购物车总金额: &#123;&#123;carts[0].price*carts[0].number + carts[1].price*carts[1].number&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>为了渲染双标中的文本,我们也可以选择使用<code>v-text</code>和<code>v-html</code>命令</p></blockquote><ul><li>v-***这种写法的方式使用的是vue的命令</li><li>v-***的命令必须依赖元素,并且要写在元素的开始标签中</li><li>v-***指令支持ES6中的字符串模板</li><li>插值表达式中支持javascript的运算表达式</li><li>插值表达式中也支持函数的调用</li><li>v-text可以将数据渲染成双标签中间的文本,但是不识别html元素结构的文本</li><li>v-html可以将数据渲染成双标签中间的文本,识别html元素结构的文本</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> msg =<span class="string">&#x27;hello vue3&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getMsg</span>= (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> msg</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> age = <span class="number">19</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> bee = <span class="string">&#x27;蜜 蜂&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> redMsg =<span class="string">&#x27;&lt;font color=\&#x27;red\&#x27;&gt;msg&lt;/font&gt;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> greenMsg =<span class="string">`&lt;font color=\&#x27;green\&#x27;&gt;<span class="subst">$&#123;msg&#125;</span>&lt;/font&gt;`</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&#x27;redMsg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&#x27;getMsg()&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&#x27;age&gt;18?&quot;成年&quot;:&quot;未成年&quot;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&#x27;bee.split(&quot; &quot;).reverse().join(&quot;-&quot;)&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&#x27;msg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&#x27;redMsg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&#x27;greenMsg&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;`&lt;font color=&#x27;green&#x27;&gt;$&#123;msg&#125;&lt;/font&gt;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Attribute属性渲染"><a href="#Attribute属性渲染" class="headerlink" title="Attribute属性渲染"></a>Attribute属性渲染</h4><blockquote><p>想要渲染一个元素的attribute，应该使用<code>v-bind</code>指令</p></blockquote><ul><li>由于插值表达式不能直接放在标签的属性中,所有要渲染元素的属性就应该使用v-bind</li><li>v-bind可以用于渲染任何元素的属性,语法为 <code>v-bind:属性名=&#39;数据名&#39;</code>, 可以简写为 <code>:属性名=&#39;数据名&#39;</code></li></ul><h4 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h4><blockquote><p>我们可以使用 <code>v-on</code> 来监听 DOM 事件，并在事件触发时执行对应的 Vue的JavaScript代码。</p></blockquote><ul><li>用法：<code>v-on:click=&quot;handler&quot;</code> 或简写为 <code>@click=&quot;handler&quot;</code></li><li>vue中的事件名&#x3D;原生事件名去掉<code>on</code> 前缀   如:<code>onClick --&gt; click</code></li><li>handler的值可以是方法事件处理器,也可以是内联事件处理器</li><li>绑定事件时,可以通过一些绑定的修饰符,常见的事件修饰符如下<ul><li><code>.once：只触发一次事件。[重点]</code></li><li><code>.prevent：阻止默认事件。[重点]</code></li><li>.stop：阻止事件冒泡。</li><li>.capture：使用事件捕获模式而不是冒泡模式。</li><li>.self：只在事件发送者自身触发时才触发事件。</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 响应式数据 当发生变化时,会自动更新 dom树</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> count=<span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">addCount</span>= (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">incrCount</span>= (<span class="params">event</span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    count.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 通过事件对象阻止组件的默认行为</span></span></span><br><span class="line"><span class="language-javascript">    event.<span class="title function_">preventDefault</span>();</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>count的值是:&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 方法事件处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;addCount()&quot;</span>&gt;</span>addCount<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联事件处理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>incrCount<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 事件修饰符 once 只绑定事件一次 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>addOnce<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 事件修饰符 prevent 阻止组件的默认行为 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>prevent<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 原生js方式阻止组件默认行为--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;incrCount($event)&quot;</span>&gt;</span>prevent<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="响应式基础"><a href="#响应式基础" class="headerlink" title="响应式基础"></a>响应式基础</h4><blockquote><p> 此处的响应式是指: 数据模型发生变化时,自动更新DOM树内容,页面上显示的内容会进行同步变化,vue3的数据模型不是自动响应式的,需要我们做一些特殊的处理</p></blockquote><h5 id="响应式实现关键字ref"><a href="#响应式实现关键字ref" class="headerlink" title="响应式实现关键字ref"></a>响应式实现关键字ref</h5><blockquote><p><code>ref</code> 可以将一个基本类型的数据（如字符串，数字等）转换为一个响应式对象。 <code>ref</code> 只能包裹单一元素</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* 从vue中引入ref方法 */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> counter = <span class="title function_">ref</span>(<span class="number">0</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(counter.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* 函数中要操作ref处理过的数据,需要通过.value形式 */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">decr</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      counter.<span class="property">value</span>--;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">incr</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      counter.<span class="property">value</span>++;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decr()&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    &#123;&#123; counter &#125;&#125; </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;counter++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;incr()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show()&quot;</span>&gt;</span>显示counter值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在上面的例子中，我们使用 <code>ref</code> 包裹了一个数字，在代码中给这个数字加 1 后，视图也会跟着动态更新。需要注意的是，由于使用了 <code>ref</code>，因此需要在访问该对象时使用 <code>.value</code> 来获取其实际值。</li></ul><h5 id="响应式实现关键字reactive"><a href="#响应式实现关键字reactive" class="headerlink" title="响应式实现关键字reactive"></a>响应式实现关键字reactive</h5><blockquote><p>我们可以使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#reactive" title="reactive()">reactive()</a> 函数创建一个响应式对象或数组：</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* 从vue中引入reactive方法 */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref,reactive&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = <span class="title function_">reactive</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">counter</span>:<span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">show</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(data.<span class="property">counter</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* 函数中要操作reactive处理过的数据,需要通过 对象名.属性名的方式 */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">decr</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      data.<span class="property">counter</span>--;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">incr</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      data.<span class="property">counter</span>++;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;data.counter--&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decr()&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    &#123;&#123; data.counter &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;data.counter++&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;incr()&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;show()&quot;</span>&gt;</span>显示counter值<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>对比ref和reactive:</p></blockquote><ul><li><p>使用 <code>ref</code> 适用于以下开发场景：</p><ul><li>包装基本类型数据：<code>ref</code> 主要用于包装基本类型数据（如字符串、数字等），即只有一个值的数据，如果你想监听这个值的变化，用 <code>ref</code> 最为方便。在组件中使用时也很常见。</li><li>访问方式简单：<code>ref</code> 对象在访问时与普通的基本类型值没有太大区别，只需要通过 <code>.value</code> 访问其实际值即可。</li></ul></li><li><p>使用 <code>reactive</code> 适用于以下开发场景：</p><ul><li>包装复杂对象：<code>reactive</code> 可以将一个普通对象转化为响应式对象，这样在数据变化时会自动更新界面，特别适用于处理复杂对象或者数据结构。</li><li>需要递归监听的属性：使用 <code>reactive</code> 可以递归追踪所有响应式对象内部的变化，从而保证界面的自动更新。</li></ul></li><li><p>综上所述，<code>ref</code> 适用与简单情形下的数据双向绑定，对于只有一个字符等基本类型数据或自定义组件等情况，建议可以使用 <code>ref</code>；而对于对象、函数等较为复杂的数据结构，以及需要递归监听的属性变化，建议使用 <code>reactive</code>。当然，在实际项目中根据需求灵活选择也是十分必要的。</p></li></ul><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><blockquote><p><code>v-if</code> 条件渲染</p></blockquote><ul><li><p><code>v-if=&#39;表达式&#39; </code>只会在指令的表达式返回真值时才被渲染</p></li><li><p>也可以使用 <code>v-else</code> 为 <code>v-if</code> 添加一个“else 区块”。</p></li><li><p>一个 <code>v-else</code> 元素必须跟在一个 <code>v-if</code> 元素后面，否则它将不会被识别。</p></li></ul><blockquote><p><code>v-show</code>条件渲染扩展：</p></blockquote><ul><li><p>另一个可以用来按条件显示一个元素的指令是 <code>v-show</code>。其用法基本一样：</p></li><li><p>不同之处在于 <code>v-show</code> 会在 DOM 渲染中保留该元素；<code>v-show</code> 仅切换了该元素上名为 <code>display</code> 的 CSS 属性。</p></li><li><p><code>v-show</code> 不支持在 <code>&lt;template&gt;</code> 元素上使用，也不能和 <code>v-else</code> 搭配使用。</p></li></ul><blockquote><p><strong><code>v-if</code></strong> <strong>vs</strong> <strong><code>v-show</code></strong></p></blockquote><ul><li><p><code>v-if</code> 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。</p></li><li><p><code>v-if</code> 也是<strong>惰性</strong>的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。</p></li><li><p>相比之下，<code>v-show</code> 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS <code>display</code> 属性会被切换。</p></li><li><p>总的来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要频繁切换，则使用 <code>v-show</code> 较好；如果在运行时绑定条件很少改变，则 <code>v-if</code> 会更合适。</p></li></ul><h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><blockquote><p>我们可以使用 <code>v-for</code> 指令基于一个数组来渲染一个列表。</p></blockquote><ul><li><p><code>v-for</code> 指令的值需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据的数组，而 <code>item</code> 是迭代项的<strong>别名</strong>：</p></li><li><p>在 <code>v-for</code> 块中可以完整地访问父作用域内的属性和变量。<code>v-for</code> 也支持使用可选的第二个参数表示当前项的位置索引。</p></li><li><p>案例：实现购物车显示和删除购物项</p></li></ul><h4 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h4><blockquote><p>单项绑定和双向绑定</p></blockquote><ul><li>单向绑定: 响应式数据的变化会更新dom树,但是dom树上用户的操作造成的数据改变不会同步更新到响应式数据</li><li>双向绑定: 响应式数据的变化会更新dom树,但是dom树上用户的操作造成的数据改变会同步更新到响应式数据<ul><li>用户通过表单标签才能够输入数据,所以双向绑定都是应用到表单标签上的,其他标签不行</li><li>v-model专门用于双向绑定表单标签的value属性,语法为 <code>v-model:value=&#39;&#39;</code>,可以简写为 <code>v-model=&#39;&#39;</code></li><li>v-model还可以用于各种不同类型的输入，<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code> 元素</li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//引入模块</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; reactive,ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> hbs = <span class="title function_">ref</span>([]); <span class="comment">//装爱好的值</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> user = <span class="title function_">reactive</span>(&#123;<span class="attr">username</span>:<span class="literal">null</span>,<span class="attr">password</span>:<span class="literal">null</span>,<span class="attr">introduce</span>:<span class="literal">null</span>,<span class="attr">pro</span>:<span class="literal">null</span>&#125;)   </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">login</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(hbs.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user));</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">clearx</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//user = &#123;&#125;;// 这中写法会将数据变成非响应的,应该是user.username=&quot;&quot;</span></span></span><br><span class="line"><span class="language-javascript">    user.<span class="property">username</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    user.<span class="property">password</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    user.<span class="property">introduce</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    user.<span class="property">pro</span>=<span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    hbs.<span class="property">value</span>.<span class="title function_">splice</span>(<span class="number">0</span>,hbs.<span class="property">value</span>.<span class="property">length</span>);;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      账号： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入账号！&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user.username&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      密码： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入账号！&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;user.password&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      爱好： </span><br><span class="line">        吃 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吃&quot;</span>&gt;</span> </span><br><span class="line">        喝 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;喝&quot;</span>&gt;</span></span><br><span class="line">        玩 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;玩&quot;</span>&gt;</span></span><br><span class="line">        乐 <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hbs&quot;</span> <span class="attr">value</span>=<span class="string">&quot;乐&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      简介:<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">&quot;user.introduce&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      籍贯:</span><br><span class="line">          <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;user.pro&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>黑<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>吉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>辽<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span>&gt;</span>津<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;6&quot;</span>&gt;</span>冀<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;login()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;clearx()&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      显示爱好:&#123;&#123; hbs &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      显示用户信息:&#123;&#123; user &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="数据监听器"><a href="#数据监听器" class="headerlink" title="数据监听器"></a>数据监听器</h4><blockquote><p>计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。我们可以使用 <a href="https://cn.vuejs.org/api/reactivity-core.html#watch" title="watch">watch</a><a href="https://cn.vuejs.org/api/reactivity-core.html#watch" title=" 函数"> 函数</a>在每次响应式状态发生变化时触发回调函数：</p></blockquote><ul><li>watch主要用于以下场景：<ul><li>当数据发生变化时需要执行相应的操作</li><li>监听数据变化，当满足一定条件时触发相应操作</li><li>在异步操作前或操作后需要执行相应的操作</li></ul></li></ul><blockquote><p>监控响应式数据(watchEffect)：</p></blockquote><ul><li>watchEffect默认监听所有的响应式数据</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//引入模块</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref,reactive,watch, watchEffect&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"> </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> firstname=<span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> lastname=<span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> fullname=<span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//监听所有响应式数据</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//直接在内部使用监听属性即可，不用外部声明</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//也不需要，即时回调设置，默认初始化就加载</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(firstname.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(lastname.<span class="property">name</span>)</span></span><br><span class="line"><span class="language-javascript">    fullname.<span class="property">value</span>=<span class="string">`<span class="subst">$&#123;firstname.value&#125;</span><span class="subst">$&#123;lastname.name&#125;</span>`</span></span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    全名:&#123;&#123;fullname&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    姓氏:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    名字:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastname.name&quot;</span> &gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><blockquote><p>每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为<code>生命周期钩子的函数</code>，让开发者有机会在特定阶段运行自己的代码</p></blockquote><ul><li>周期图解：</li></ul><img src="D:/BaiduNetdiskDownload/images/image_elceCM4Wbp.png" style="zoom: 50%;"><ul><li>常见钩子函数<ul><li>onMounted()              注册一个回调函数，在组件挂载完成后执行。 </li><li>onUpdated()               注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。 </li><li>onUnmounted()         注册一个回调函数，在组件实例被卸载之后调用。 </li><li>onBeforeMount()       注册一个钩子，在组件被挂载之前被调用。 </li><li>onBeforeUpdate()      注册一个钩子，在组件即将因为响应式状态变更而更新其 DOM 树之前调用。 </li><li>onBeforeUnmount()  注册一个钩子，在组件实例被卸载之前调用。</li></ul></li></ul><h3 id="Vue组件"><a href="#Vue组件" class="headerlink" title="Vue组件"></a>Vue组件</h3><blockquote><p>组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考。组件就是实现应用中局部功能代码和资源的集合！在实际应用中，组件常常被组织成层层嵌套的树状结构，这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。</p></blockquote><ul><li><p>组件化：对js&#x2F;css&#x2F;html统一封装,这是VUE中的概念</p></li><li><p>模块化：对js的统一封装,这是ES6中的概念</p></li><li><p>组件化中,对js部分代码的处理使用ES6中的模块化</p></li></ul><h4 id="组件之间传递数据"><a href="#组件之间传递数据" class="headerlink" title="组件之间传递数据"></a>组件之间传递数据</h4><h5 id="父传子"><a href="#父传子" class="headerlink" title="父传子"></a>父传子</h5><blockquote><p>Vue3 中父组件向子组件传值可以通过 props 进行，具体操作如下：</p></blockquote><ol><li><p>首先，在父组件中定义需要传递给子组件的值，接着，在父组件的模板中引入子组件，同时在引入子组件的标签中添加 props 属性并为其设置需要传递的值。</p></li><li><p>在 Vue3 中，父组件通过 props 传递给子组件的值是响应式的。也就是说，如果在父组件中的传递的值发生了改变，子组件中的值也会相应地更新。</p></li></ol><ul><li>父组件代码</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Son</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Son.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref,reactive,toRefs&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;parent data!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> title = <span class="title function_">ref</span>(<span class="number">42</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">changeMessage</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    message.<span class="property">value</span> = <span class="string">&#x27;修改数据！&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    title.<span class="property">value</span>++</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用子组件，并且传递数据！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Son</span> <span class="attr">:message</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeMessage&quot;</span>&gt;</span>点击更新<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子组件代码：Son.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref,isRef,defineProps&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//声明父组件传递属性值</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>:<span class="title class_">String</span> ,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">title</span>:<span class="title class_">Number</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="子传父"><a href="#子传父" class="headerlink" title="子传父"></a>子传父</h5><ul><li>父组件：</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> <span class="title class_">Son</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Son.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> pdata = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">padd</span> = (<span class="params">data</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2222&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        pdata.<span class="property">value</span> =data;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//自定义接收，子组件传递数据方法！ 参数为数据！</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> <span class="title function_">psub</span> = (<span class="params">data</span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;11111&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        pdata.<span class="property">value</span> = data;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 声明@事件名应该等于子模块对应事件名！调用方法可以是当前自定义！--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Son</span> @<span class="attr">add</span>=<span class="string">&quot;padd&quot;</span> @<span class="attr">sub</span>=<span class="string">&quot;psub&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        &#123;&#123; pdata &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子组件：Son.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref,defineEmits&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.定义要发送给父组件的方法，可以1或者多个</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> emites = <span class="title function_">defineEmits</span>([<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;sub&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> data = <span class="title function_">ref</span>(<span class="number">1</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">sendMsgToParent</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.出发父组件对应的方法，调用defineEmites对应的属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">emites</span>(<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;add data!&#x27;</span>+data.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">emites</span>(<span class="string">&#x27;sub&#x27;</span>,<span class="string">&#x27;sub data!&#x27;</span>+data.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        data.<span class="property">value</span> ++;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sendMsgToParent&quot;</span>&gt;</span>发送消息给父组件<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="兄弟传参"><a href="#兄弟传参" class="headerlink" title="兄弟传参"></a>兄弟传参</h5><ul><li>Navigator.vue: 发送数据到App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;defineEmits&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> emits = <span class="title function_">defineEmits</span>([<span class="string">&#x27;sendMenu&#x27;</span>]);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//触发事件，向父容器发送数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params">data</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">emits</span>(<span class="string">&#x27;sendMenu&#x27;</span>,data);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 推荐写一个根标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;send(&#x27;学员管理&#x27;)&quot;</span>&gt;</span>学员管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;send(&#x27;图书管理&#x27;)&quot;</span>&gt;</span>图书管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;send(&#x27;请假管理&#x27;)&quot;</span>&gt;</span>请假管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;send(&#x27;考试管理&#x27;)&quot;</span>&gt;</span>考试管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;send(&#x27;讲师管理&#x27;)&quot;</span>&gt;</span>讲师管理<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>App.vue: 发送数据到Content.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Header</span>  <span class="keyword">from</span> <span class="string">&#x27;./components/Header.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Navigator</span>  <span class="keyword">from</span> <span class="string">&#x27;./components/Navigator.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">Content</span>  <span class="keyword">from</span> <span class="string">&#x27;./components/Content.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//定义接受navigator传递参数</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> navigator_menu = <span class="title function_">ref</span>(<span class="string">&#x27;ceshi&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> <span class="title function_">receiver</span> = (<span class="params">data</span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    navigator_menu.<span class="property">value</span> = data;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      &#123;&#123; navigator_menu &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">Header</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Header</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">Navigator</span> @<span class="attr">sendMenu</span>=<span class="string">&quot;receiver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;navigator&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Navigator</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 向子组件传递数据--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">Content</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span> <span class="attr">:message</span>=<span class="string">&quot;navigator_menu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Content</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Content.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">defineProps</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">message</span>:<span class="title class_">String</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        展示的主要内容！</span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        &#123;&#123; message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="router"><a href="#router" class="headerlink" title="router"></a>router</h2><blockquote><p>1 什么是路由？</p></blockquote><ul><li>定义：路由就是根据不同的 URL 地址展示不同的内容或页面。</li><li>通俗理解：路由就像是一个地图，我们要去不同的地方，需要通过不同的路线进行导航。</li></ul><blockquote><p>2 路由的作用</p></blockquote><ul><li>单页应用程序（SPA）中，路由可以实现不同视图之间的无刷新切换，提升用户体验；</li><li>路由还可以实现页面的认证和权限控制，保护用户的隐私和安全；</li><li>路由还可以利用浏览器的前进与后退，帮助用户更好地回到之前访问过的页面。</li></ul><h3 id="router重定向"><a href="#router重定向" class="headerlink" title="router重定向"></a>router重定向</h3><blockquote><p>重定向的作用：将一个路由重定向到另一个路由上</p></blockquote><ul><li>修改示例：访问&#x2F;list和&#x2F;showAll都定向到List.vue</li><li>router.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入路由创建的相关方法</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入vue组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">List</span> <span class="keyword">from</span> <span class="string">&#x27;../components/List.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Add</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Add.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Update</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Update.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由对象,声明路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                <span class="attr">default</span>:<span class="title class_">Home</span>,</span><br><span class="line">                <span class="attr">homeView</span>:<span class="title class_">Home</span></span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                listView : <span class="title class_">List</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/showAll&#x27;</span>,</span><br><span class="line">            <span class="comment">// 重定向</span></span><br><span class="line">            redirect :<span class="string">&#x27;/list&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/add&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                <span class="attr">addView</span>:<span class="title class_">Add</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/update&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                <span class="attr">updateView</span>:<span class="title class_">Update</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 路由的连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>home页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/list&quot;</span>&gt;</span>list页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/showAll&quot;</span>&gt;</span>showAll页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/add&quot;</span>&gt;</span>add页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/update&quot;</span>&gt;</span>update页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 路由连接对应视图的展示位置 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      默认展示位置:<span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Home视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;homeView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      List视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;listView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Add视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;addView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Update视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;updateView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编程式路由-useRouter"><a href="#编程式路由-useRouter" class="headerlink" title="编程式路由(useRouter)"></a>编程式路由(useRouter)</h3><blockquote><p>普通路由</p></blockquote><ul><li><code>&lt;router-link to=&quot;/list&quot;&gt;list页&lt;/router-link&gt;  </code>这种路由,to中的内容目前是固定的,点击后只能切换&#x2F;list对象组件(声明式路由)</li></ul><blockquote><p>编程式路由</p></blockquote><ul><li>通过useRouter,动态决定向那个组件切换的路由</li><li>在 Vue 3 和 Vue Router 4 中，可以使用 <code>useRouter</code> 来实现动态路由(编程式路由)</li><li>这里的 <code>useRouter</code> 方法返回的是一个 router 对象，你可以用它来做如导航到新页面、返回上一页面等操作</li></ul><blockquote><p>案例需求: 通过普通按钮配合事件绑定实现路由页面跳转,不直接使用router-link标签</p></blockquote><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//创建动态路由对象</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> router = <span class="title function_">useRouter</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span>  routePath =<span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span>  <span class="title function_">showList</span>= (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 编程式路由</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 直接push一个路径</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// router.push(&#x27;/list&#x27;)</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// push一个带有path属性的对象</span></span></span><br><span class="line"><span class="language-javascript">      router.<span class="title function_">push</span>(&#123;<span class="attr">path</span>:<span class="string">&#x27;/list&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 路由的连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>home页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/list&quot;</span>&gt;</span>list页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/showAll&quot;</span>&gt;</span>showAll页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/add&quot;</span>&gt;</span>add页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/update&quot;</span>&gt;</span>update页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 动态输入路径,点击按钮,触发单击事件的函数,在函数中通过编程是路由切换页面 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showList()&quot;</span>&gt;</span>showList<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 路由连接对应视图的展示位置 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      默认展示位置:<span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Home视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;homeView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      List视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;listView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Add视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;addView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      Update视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;updateView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="路由传参-useRoute"><a href="#路由传参-useRoute" class="headerlink" title="路由传参(useRoute)"></a>路由传参(useRoute)</h3><blockquote><p>路径参数</p></blockquote><ul><li>在路径中使用一个动态字段来实现，我们称之为 <strong>路径参数</strong><ul><li>例如：查看数据详情  <code>/showDetail/1</code>,<code>1</code>就是要查看详情的id,可以动态添值</li></ul></li></ul><blockquote><p>键值对参数</p></blockquote><ul><li><p>类似与get请求通过url传参,数据是键值对形式的</p><ul><li><p>例如: 查看数据详情<code>/showDetail?hid=1</code>,<code>hid=1</code>就是要传递的键值对参数</p></li><li><p>在 Vue 3 和 Vue Router 4 中，你可以使用  <code>useRoute</code> 这个函数从 Vue 的组合式 API 中获取路由对象</p></li><li><p><code>useRoute</code> 方法返回的是当前的 route 对象，你可以用它来获取关于当前路由的信息，如当前的路径、查询参数等</p></li></ul></li></ul><blockquote><p>案例需求:切换到ShowDetail.vue组件时,向该组件通过路由传递参数</p></blockquote><ul><li>修改App.vue文件</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123;useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//创建动态路由对象</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> router = <span class="title function_">useRouter</span>()</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//动态路由路径传参方法</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">showDetail</span>= (<span class="params">id,language</span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 尝试使用拼接字符串方式传递路径参数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//router.push(`showDetail/$&#123;id&#125;/$&#123;languange&#125;`)</span></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">/*路径参数,需要使用params  */</span></span></span><br><span class="line"><span class="language-javascript">      router.<span class="title function_">push</span>(&#123;<span class="attr">name</span>:<span class="string">&quot;showDetail&quot;</span>,<span class="attr">params</span>:&#123;<span class="attr">id</span>:id,<span class="attr">language</span>:language&#125;&#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">showDetail2</span>= (<span class="params">id,language</span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">/*uri键值对参数,需要使用query */</span></span></span><br><span class="line"><span class="language-javascript">      router.<span class="title function_">push</span>(&#123;<span class="attr">path</span>:<span class="string">&quot;/showDetail2&quot;</span>,<span class="attr">query</span>:&#123;<span class="attr">id</span>:id,<span class="attr">language</span>:language&#125;&#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 路径参数   --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/showDetail/1/JAVA&quot;</span>&gt;</span>showDetail路径传参显示JAVA<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showDetail(1,&#x27;JAVA&#x27;)&quot;</span>&gt;</span>showDetail动态路由路径传参显示JAVA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 键值对参数 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">v-bind:to</span>=<span class="string">&quot;&#123;path:&#x27;/showDetail2&#x27;,query:&#123;id:1,language:&#x27;Java&#x27;&#125;&#125;&quot;</span>&gt;</span>showDetail2键值对传参显示JAVA<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showDetail2(1,&#x27;JAVA&#x27;)&quot;</span>&gt;</span>showDetail2动态路由键值对传参显示JAVA<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      showDetail视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;showDetailView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      showDetail2视图展示:<span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;showDetailView2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>修改router.js增加路径参数占位符</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入路由创建的相关方法</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入vue组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ShowDetail</span> <span class="keyword">from</span> <span class="string">&#x27;../components/ShowDetail.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ShowDetail2</span> <span class="keyword">from</span> <span class="string">&#x27;../components/ShowDetail2.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建路由对象,声明路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 此处:id  :language作为路径的占位符 */</span></span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/showDetail/:id/:language&#x27;</span>,</span><br><span class="line">            <span class="comment">/* 动态路由传参时,根据该名字找到该路由 */</span></span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;showDetail&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                <span class="attr">showDetailView</span>:<span class="title class_">ShowDetail</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/showDetail2&#x27;</span>,</span><br><span class="line">            <span class="attr">components</span>:&#123;</span><br><span class="line">                <span class="attr">showDetailView2</span>:<span class="title class_">ShowDetail2</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><ul><li>ShowDetail.vue 通过useRoute获取路径参数</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span>&#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; onUpdated,ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取当前的route对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> route =<span class="title function_">useRoute</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> languageId = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> languageName = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//  借助更新时生命周期,将数据更新进入响应式对象</span></span></span><br><span class="line"><span class="language-javascript">    onUpdated (<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取对象中的参数</span></span></span><br><span class="line"><span class="language-javascript">        languageId.<span class="property">value</span>=route.<span class="property">params</span>.<span class="property">id</span></span></span><br><span class="line"><span class="language-javascript">        languageName.<span class="property">value</span>=route.<span class="property">params</span>.<span class="property">language</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(languageId.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(languageName.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ShowDetail页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>编号&#123;&#123;route.params.id&#125;&#125;:&#123;&#123;route.params.language&#125;&#125;是世界上最好的语言<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>编号&#123;&#123;languageId&#125;&#125;:&#123;&#123;languageName&#125;&#125;是世界上最好的语言<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>ShowDetail2.vue通过useRoute获取键值对参数</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span>&#123;useRoute&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; onUpdated,ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取当前的route对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> route =<span class="title function_">useRoute</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> languageId = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> languageName = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//  借助更新时生命周期,将数据更新进入响应式对象</span></span></span><br><span class="line"><span class="language-javascript">    onUpdated (<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 获取对象中的参数(通过query获取参数,此时参数是key-value形式的)</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(route.<span class="property">query</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(languageId.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(languageName.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        languageId.<span class="property">value</span>=route.<span class="property">query</span>.<span class="property">id</span></span></span><br><span class="line"><span class="language-javascript">        languageName.<span class="property">value</span>=route.<span class="property">query</span>.<span class="property">language</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>ShowDetail2页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>编号&#123;&#123;route.query.id&#125;&#125;:&#123;&#123;route.query.language&#125;&#125;是世界上最好的语言<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>编号&#123;&#123;languageId&#125;&#125;:&#123;&#123;languageName&#125;&#125;是世界上最好的语言<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><blockquote><p>在 Vue3 中，路由守卫是用于在路由切换期间进行一些特定任务的回调函数。路由守卫可以用于许多任务，例如验证用户是否已登录、在路由切换前提供确认提示、请求数据等。Vue3 为路由守卫提供了全面的支持，并提供了以下几种类型的路由守卫：</p></blockquote><ol><li><strong>全局前置守卫</strong>：在路由切换前被调用，可以用于验证用户是否已登录、中断导航、请求数据等。</li><li><strong>全局后置守卫</strong>：在路由切换之后被调用，可以用于处理数据、操作 DOM 、记录日志等。</li><li><strong>守卫代码的位置</strong>: 在router.js中</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置路由守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>( <span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//to 是目标地包装对象  .path属性可以获取地址</span></span><br><span class="line">    <span class="comment">//from 是来源地包装对象 .path属性可以获取地址</span></span><br><span class="line">    <span class="comment">//next是方法，不调用默认拦截！ next() 放行,直接到达目标组件</span></span><br><span class="line">    <span class="comment">//next(&#x27;/地址&#x27;)可以转发到其他地址,到达目标组件前会再次经过前置路由守卫</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(to.<span class="property">path</span>,<span class="keyword">from</span>.<span class="property">path</span>,next)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要判断，注意避免无限重定向</span></span><br><span class="line">    <span class="keyword">if</span>(to.<span class="property">path</span> == <span class="string">&#x27;/index&#x27;</span>)&#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_">next</span>(<span class="string">&#x27;/index&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置路由守卫</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Navigate from <span class="subst">$&#123;<span class="keyword">from</span>.path&#125;</span> to <span class="subst">$&#123;to.path&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>登录案例，登录以后才可以进入home,否则必须进入login</p></blockquote><ul><li>定义Login.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123;useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> username =<span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> password =<span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> router = <span class="title function_">useRouter</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">login</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(username.<span class="property">value</span>,password.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(username.<span class="property">value</span> == <span class="string">&#x27;root&#x27;</span> &amp; password.<span class="property">value</span> == <span class="string">&#x27;123456&#x27;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            router.<span class="title function_">push</span>(&#123;<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,<span class="attr">query</span>:&#123;<span class="string">&#x27;username&#x27;</span>:username.<span class="property">value</span>&#125;&#125;)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//登录成功利用前端存储机制，存储账号！</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;username&#x27;</span>,username.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//sessionStorage.setItem(&#x27;username&#x27;,username)</span></span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;登录失败，账号或者密码错误！&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        账号： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入账号！&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        密码： <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码！&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;login()&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>定义Home.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">import</span> &#123;useRoute,useRouter&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">let</span> route =<span class="title function_">useRoute</span>()</span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">let</span> router = <span class="title function_">useRouter</span>()</span></span><br><span class="line"><span class="language-javascript"> <span class="comment">//  并不是每次进入home页时,都有用户名参数传入</span></span></span><br><span class="line"><span class="language-javascript"> <span class="comment">//let username = route.query.username</span></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">let</span> username =<span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;username&#x27;</span>); </span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">let</span> <span class="title function_">logout</span>= (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 清除localStorge中的username</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//window.sessionStorage.removeItem(&#x27;username&#x27;)</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;username&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 动态路由到登录页</span></span></span><br><span class="line"><span class="language-javascript">    router.<span class="title function_">push</span>(<span class="string">&quot;/login&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"> &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Home页面<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span>&gt;</span>欢迎&#123;&#123;username&#125;&#125;登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;logout&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>定义routers.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入路由创建的相关方法</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入vue组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Login</span> <span class="keyword">from</span> <span class="string">&#x27;../components/login.vue&#x27;</span></span><br><span class="line"><span class="comment">// 创建路由对象,声明路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="attr">redirect</span>:<span class="string">&quot;/home&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Login</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置路由的全局前置守卫</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    to 要去那</span></span><br><span class="line"><span class="comment">    from 从哪里来</span></span><br><span class="line"><span class="comment">    next 放行路由时需要调用的方法,不调用则不放行</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`从哪里来:<span class="subst">$&#123;<span class="keyword">from</span>.path&#125;</span>,到哪里去:<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(to.<span class="property">path</span> == <span class="string">&#x27;/login&#x27;</span>)&#123;</span><br><span class="line">        <span class="comment">//放行路由  注意放行不要形成循环  </span></span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//let username =window.sessionStorage.getItem(&#x27;username&#x27;); </span></span><br><span class="line">        <span class="keyword">let</span> username =<span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;username&#x27;</span>); </span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">null</span> != username)&#123;</span><br><span class="line">            <span class="title function_">next</span>()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="title function_">next</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 设置路由的全局后置守卫</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`从哪里来:<span class="subst">$&#123;<span class="keyword">from</span>.path&#125;</span>,到哪里去:<span class="subst">$&#123;to.path&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对外暴露路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><ul><li>启动测试</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><h2 id="数据交互axios"><a href="#数据交互axios" class="headerlink" title="数据交互axios"></a>数据交互axios</h2><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><h4 id="普通函数和回调函数"><a href="#普通函数和回调函数" class="headerlink" title="普通函数和回调函数"></a>普通函数和回调函数</h4><blockquote><p>普通函数: 正常调用的函数,一般函数执行完毕后才会继续执行下一行代码</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">fun1</span> = (<span class="params"></span>) =&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fun1 invoked&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 调用函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">fun1</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 函数执行完毕,继续执行后续代码</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;other code processon&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>回调函数: 一些特殊的函数,表示未来才会执行的一些功能,后续代码不会等待该函数执行完毕就开始执行了</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 设置一个2000毫秒后会执行一次的定时任务</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout invoked&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;,<span class="number">2000</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;other code processon&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Promise简介"><a href="#Promise简介" class="headerlink" title="Promise简介"></a>Promise简介</h4><blockquote><p>前端中的异步编程技术，类似Java中的多线程+线程结果回调</p></blockquote><ul><li><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了<code>Promise</code>对象。</p></li><li><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的API，各种异步操作都可以用同样的方法进行处理。</p></li></ul><p><code>Promise</code>对象有以下两个特点：</p><ol><li>Promise对象代表一个异步操作，有三种状态：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成，又称 Fulfilled）和<code>Rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li><li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从<code>Pending</code>变为<code>Resolved</code>和从<code>Pending</code>变为<code>Rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。</li></ol><h4 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise基本用法</h4><blockquote><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">/*  </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    1.实例化promise对象,并且执行(类似Java创建线程对象,并且start)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    参数: resolve,reject随意命名,但是一般这么叫!</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    参数: resolve,reject分别处理成功和失败的两个函数! 成功resolve(结果)  失败reject(结果)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    参数: 在function中调用这里两个方法,那么promise会处于两个不同的状态</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    状态: promise有三个状态</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            pending   正在运行</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            resolved  内部调用了resolve方法</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            rejected  内部调用了reject方法</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    参数: 在第二步回调函数中就可以获取对应的结果 </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> promise =<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise do some code ... ...&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//resolve(&quot;promise success&quot;)</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">reject</span>(<span class="string">&quot;promise fail&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;other code1111 invoked&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2.获取回调函数结果  then在这里会等待promise中的运行结果,但是不会阻塞代码继续运行</span></span></span><br><span class="line"><span class="language-javascript">    promise.<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span>(<span class="params">value</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`promise中执行了resolve:<span class="subst">$&#123;value&#125;</span>`</span>)&#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span>(<span class="params">error</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`promise中执行了reject:<span class="subst">$&#123;error&#125;</span>`</span>)&#125;</span></span><br><span class="line"><span class="language-javascript">    )</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 3 其他代码执行   </span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;other code2222 invoked&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="catch"><a href="#catch" class="headerlink" title="catch()"></a>catch()</h4><blockquote><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数，用法类似于<code>try-catch</code></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> promise =<span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve,reject</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise do some code ... ...&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 故意响应一个异常对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;error message&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;other code1111 invoked&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        then中的reject()的对应方法可以在产生异常时执行,接收到的就是异常中的提示信息</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        then中可以只留一个resolve()的对应方法,reject()方法可以用后续的catch替换</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        then中的reject对应的回调函数被后续的catch替换后,catch中接收的数据是一个异常对象</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        */</span></span></span><br><span class="line"><span class="language-javascript">    promise.<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span>(<span class="params">resolveValue</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`promise中执行了resolve:<span class="subst">$&#123;resolveValue&#125;</span>`</span>)&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//,</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//function(rejectValue)&#123;console.log(`promise中执行了reject:$&#123;rejectValue&#125;`)&#125;</span></span></span><br><span class="line"><span class="language-javascript">    ).<span class="title function_">catch</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span>(<span class="params">error</span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(error)&#125; </span></span><br><span class="line"><span class="language-javascript">    )</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;other code2222 invoked&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="async和await的使用"><a href="#async和await的使用" class="headerlink" title="async和await的使用"></a>async和await的使用</h4><blockquote><p>&#x20;async和await是ES6中用于处理异步操作的新特性。通常，异步操作会涉及到Promise对象，而async&#x2F;await则是在Promise基础上提供了更加直观和易于使用的语法。</p></blockquote><blockquote><p> async 用于标识函数的</p></blockquote><ol><li><p>async标识函数后,async函数的返回值会变成一个promise对象</p></li><li><p>如果函数内部返回的数据是一个非promise对象,async函数的结果会返回一个成功状态 promise对象</p></li><li><p>如果函数内部返回的是一个promise对象,则async函数返回的状态与结果由该对象决定</p></li><li><p>如果函数内部抛出的是一个异常,则async函数返回的是一个失败的promise对象</p></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        async 用于标识函数的</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            1. async标识函数后,async函数的返回值会变成一个promise对象</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            2. 如果函数内部返回的数据是一个非promise对象,async函数的结果会返回一个成功状态 promise对象</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            3. 如果函数内部返回的是一个promise对象,则async函数返回的状态与结果由该对象决定</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            4. 如果函数内部抛出的是一个异常,则async函数返回的是一个失败的promise对象</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript"></span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        */</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//return 10</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//throw new Error(&quot;something wrong&quot;)</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> promise = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;heihei&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> promise</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> promise =<span class="title function_">fun1</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        promise.<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;success:&quot;</span>+value)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        ).<span class="title function_">catch</span>(</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">function</span>(<span class="params">value</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fail:&quot;</span>+value)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        )</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>await</p></blockquote><ol><li>await右侧的表达式一般为一个promise对象,但是也可以是一个其他值</li><li>如果表达式是promise对象,await返回的是promise成功的值</li><li>await会等右边的promise对象执行结束,然后再获取结果,后续代码也会等待await的执行</li><li>如果表达式是其他值,则直接返回该值</li><li>await必须在async函数中,但是async函数中可以没有await</li><li>如果await右边的promise失败了,就会抛出异常,需要通过 try … catch捕获处理</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            1. await右侧的表达式一般为一个promise对象,但是也可以是一个其他值</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            2. 如果表达式是promise对象,await返回的是promise成功的值</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            3. await会等右边的promise对象执行结束,然后再获取结果,后续代码也会等待await的执行</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            4. 如果表达式是其他值,则直接返回该值</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            5. await必须在async函数中,但是async函数中可以没有await</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            6. 如果await右边的promise失败了,就会抛出异常,可以通过 try ... catch捕获处理</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        */</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> <span class="number">10</span></span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="language-javascript">                </span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">let</span> res = <span class="keyword">await</span> <span class="title function_">fun1</span>()</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//let res = await Promise.reject(&quot;something wrong&quot;)</span></span></span><br><span class="line"><span class="language-javascript">            &#125;<span class="keyword">catch</span>(e)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;catch got:&quot;</span>+e)   </span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            </span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;await got:&quot;</span>+res)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fun2</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="什么是axios"><a href="#什么是axios" class="headerlink" title="什么是axios"></a><a href="https://axios-http.com/zh/docs/intro">什么是axios</a></h3><ul><li>Axios 是一个基于 <a href="https://javascript.info/promise-basics" title="promise"><em>promise</em></a> 网络请求库，作用于<a href="https://nodejs.org/" title="node.js">node.js</a>和浏览器中，算是VUE提供发送ajax请求的方式。 它是 <a href="https://www.lullabot.com/articles/what-is-an-isomorphic-application" title="isomorphic"><em>isomorphic</em></a> 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js <code>http</code> 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。它有如下特性:<ul><li>从浏览器创建 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" title="XMLHttpRequests">XMLHttpRequests</a></li><li>从 node.js 创建 <a href="http://nodejs.org/api/http.html" title="http">http</a> 请求</li><li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" title="Promise">Promise</a> API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防御<a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery" title="XSRF">XSRF</a></li></ul></li></ul><h3 id="Axios入门"><a href="#Axios入门" class="headerlink" title="Axios入门"></a>Axios入门</h3><blockquote><p>1 案例需求:请求后台获取随机网站数据</p></blockquote><ul><li>请求的url</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">https://api.uomg.com/api/rand.qinghua?format=json</span><br></pre></td></tr></table></figure><ul><li>请求的方式</li></ul><figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET/POST</span><br></pre></td></tr></table></figure><ul><li>数据返回的格式</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">,</span><span class="attr">&quot;content&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxxxxxxx&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p> 2 安装axios</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><blockquote><p>3 设计页面（App.Vue）</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; onMounted,reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> jsonData =<span class="title function_">reactive</span>(&#123;<span class="attr">code</span>:<span class="number">1</span>,<span class="attr">content</span>:<span class="string">&#x27;xxxxxx&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveMessage</span> =(<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>, <span class="comment">// 请求方式</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">url</span>:<span class="string">&quot;https://api.uomg.com/api/rand.qinghua?format=json&quot;</span>,  <span class="comment">// 请求的url</span></span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>:&#123; <span class="comment">// 当请求方式为post时,data下的数据以JSON串放入请求体,否则以key=value形式放url后</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">username</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">then</span>( <span class="keyword">function</span> (<span class="params">response</span>)&#123;<span class="comment">//响应成功时要执行的函数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">Object</span>.<span class="title function_">assign</span>(jsonData,response.<span class="property">data</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">error</span>)&#123;<span class="comment">// 响应失败时要执行的函数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 通过onMounted生命周期,自动加载一次 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveMessage</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;jsonData.content&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">&quot;getLoveMessage&quot;</span>&gt;</span>更新数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>异步响应的数据结构</p></blockquote><ul><li>响应的数据是经过包装返回的，一个请求的响应包含以下信息。</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  data<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `status` 来自服务器响应的 HTTP 状态码</span></span><br><span class="line">  status<span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  statusText<span class="punctuation">:</span> &#x27;OK&#x27;<span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `headers` 是服务器响应头</span></span><br><span class="line">  <span class="comment">// 所有的 header 名称都是小写，而且可以使用方括号语法访问</span></span><br><span class="line">  <span class="comment">// 例如: `response.headers[&#x27;content-type&#x27;]`</span></span><br><span class="line">  headers<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `config` 是 `axios` 请求的配置信息</span></span><br><span class="line">  config<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `request` 是生成此响应的请求</span></span><br><span class="line">  <span class="comment">// 在node.js中它是最后一个ClientRequest实例 (in redirects)，</span></span><br><span class="line">  <span class="comment">// 在浏览器中则是 XMLHttpRequest 实例</span></span><br><span class="line">  request<span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>then取值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">data</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">headers</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">config</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>4 通过async和await处理异步请求</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; onMounted,reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> jsonData =<span class="title function_">reactive</span>(&#123;<span class="attr">code</span>:<span class="number">1</span>,<span class="attr">content</span>:<span class="string">&#x27;xxxxxxxx&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveWords</span> = <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">url</span>:<span class="string">&quot;https://api.uomg.com/api/rand.qinghua?format=json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">username</span>:<span class="string">&quot;123456&quot;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveMessage</span> =(<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> &#123;data&#125;  = <span class="keyword">await</span> <span class="title function_">getLoveWords</span>()</span></span><br><span class="line"><span class="language-javascript">     <span class="title class_">Object</span>.<span class="title function_">assign</span>(message,data)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 通过onMounted生命周期,自动加载一次 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveMessage</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;jsonData.content&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span>  @<span class="attr">click</span>=<span class="string">&quot;getLoveMessage&quot;</span>&gt;</span>更新数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p> axios在发送异步请求时的可选配置：</p></blockquote><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="comment">// `url` 是用于请求的服务器 URL</span></span><br><span class="line">  url<span class="punctuation">:</span> &#x27;/user&#x27;<span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `method` 是创建请求时使用的方法</span></span><br><span class="line">  method<span class="punctuation">:</span> &#x27;get&#x27;<span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span></span><br><span class="line">  <span class="comment">// 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span></span><br><span class="line">  baseURL<span class="punctuation">:</span> &#x27;https<span class="punctuation">:</span><span class="comment">//some-domain.com/api/&#x27;,</span></span><br><span class="line">  <span class="comment">// `transformRequest` 允许在向服务器发送前，修改请求数据</span></span><br><span class="line">  <span class="comment">// 它只能用于 &#x27;PUT&#x27;, &#x27;POST&#x27; 和 &#x27;PATCH&#x27; 这几个请求方法</span></span><br><span class="line">  <span class="comment">// 数组中最后一个函数必须返回一个字符串， 一个Buffer实例，ArrayBuffer，FormData，或 Stream</span></span><br><span class="line">  <span class="comment">// 你可以修改请求头。</span></span><br><span class="line">  transformRequest<span class="punctuation">:</span> <span class="punctuation">[</span>function (data<span class="punctuation">,</span> headers) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 对发送的 data 进行任意转换处理</span></span><br><span class="line">    return data;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span></span><br><span class="line">  transformResponse<span class="punctuation">:</span> <span class="punctuation">[</span>function (data) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 对接收的 data 进行任意转换处理</span></span><br><span class="line">    return data;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 自定义请求头</span></span><br><span class="line">  headers<span class="punctuation">:</span> <span class="punctuation">&#123;</span>&#x27;X-Requested-With&#x27;<span class="punctuation">:</span> &#x27;XMLHttpRequest&#x27;<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `params` 是与请求一起发送的 URL 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个简单对象或 URLSearchParams 对象</span></span><br><span class="line">  params<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    ID<span class="punctuation">:</span> <span class="number">12345</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `paramsSerializer`是可选方法，主要用于序列化`params`</span></span><br><span class="line">  <span class="comment">// (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span></span><br><span class="line">  paramsSerializer<span class="punctuation">:</span> function (params) <span class="punctuation">&#123;</span></span><br><span class="line">    return Qs.stringify(params<span class="punctuation">,</span> <span class="punctuation">&#123;</span>arrayFormat<span class="punctuation">:</span> &#x27;brackets&#x27;<span class="punctuation">&#125;</span>)</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `data` 是作为请求体被发送的数据</span></span><br><span class="line">  <span class="comment">// 仅适用 &#x27;PUT&#x27;, &#x27;POST&#x27;, &#x27;DELETE 和 &#x27;PATCH&#x27; 请求方法</span></span><br><span class="line">  <span class="comment">// 在没有设置 `transformRequest` 时，则必须是以下类型之一:</span></span><br><span class="line">  <span class="comment">// - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line">  <span class="comment">// - 浏览器专属: FormData, File, Blob</span></span><br><span class="line">  <span class="comment">// - Node 专属: Stream, Buffer</span></span><br><span class="line">  data<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    firstName<span class="punctuation">:</span> &#x27;Fred&#x27;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// 发送请求体数据的可选语法</span></span><br><span class="line">  <span class="comment">// 请求方式 post</span></span><br><span class="line">  <span class="comment">// 只有 value 会被发送，key 则不会</span></span><br><span class="line">  data<span class="punctuation">:</span> &#x27;Country=Brasil&amp;City=Belo Horizonte&#x27;<span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `timeout` 指定请求超时的毫秒数。</span></span><br><span class="line">  <span class="comment">// 如果请求时间超过 `timeout` 的值，则请求会被中断</span></span><br><span class="line">  timeout<span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span> <span class="comment">// 默认值是 `0` (永不超时)</span></span><br><span class="line">  <span class="comment">// `withCredentials` 表示跨域请求时是否需要使用凭证</span></span><br><span class="line">  withCredentials<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span> <span class="comment">// default</span></span><br><span class="line">  <span class="comment">// `adapter` 允许自定义处理请求，这使测试更加容易。</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并提供一个有效的响应 （参见 lib/adapters/README.md）。</span></span><br><span class="line">  adapter<span class="punctuation">:</span> function (config) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `auth` HTTP Basic Auth</span></span><br><span class="line">  auth<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    username<span class="punctuation">:</span> &#x27;janedoe&#x27;<span class="punctuation">,</span></span><br><span class="line">    password<span class="punctuation">:</span> &#x27;s00pers3cret&#x27;</span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `responseType` 表示浏览器将要响应的数据类型</span></span><br><span class="line">  <span class="comment">// 选项包括: &#x27;arraybuffer&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span></span><br><span class="line">  <span class="comment">// 浏览器专属：&#x27;blob&#x27;</span></span><br><span class="line">  responseType<span class="punctuation">:</span> &#x27;json&#x27;<span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `responseEncoding` 表示用于解码响应的编码 (Node.js 专属)</span></span><br><span class="line">  <span class="comment">// 注意：忽略 `responseType` 的值为 &#x27;stream&#x27;，或者是客户端请求</span></span><br><span class="line">  <span class="comment">// Note: Ignored for `responseType` of &#x27;stream&#x27; or client-side requests</span></span><br><span class="line">  responseEncoding<span class="punctuation">:</span> &#x27;utf8&#x27;<span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `xsrfCookieName` 是 xsrf token 的值，被用作 cookie 的名称</span></span><br><span class="line">  xsrfCookieName<span class="punctuation">:</span> &#x27;XSRF-TOKEN&#x27;<span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `xsrfHeaderName` 是带有 xsrf token 值的http 请求头名称</span></span><br><span class="line">  xsrfHeaderName<span class="punctuation">:</span> &#x27;X-XSRF-TOKEN&#x27;<span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `onUploadProgress` 允许为上传处理进度事件</span></span><br><span class="line">  <span class="comment">// 浏览器专属</span></span><br><span class="line">  onUploadProgress<span class="punctuation">:</span> function (progressEvent) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `onDownloadProgress` 允许为下载处理进度事件</span></span><br><span class="line">  <span class="comment">// 浏览器专属</span></span><br><span class="line">  onDownloadProgress<span class="punctuation">:</span> function (progressEvent) <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 处理原生进度事件</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `maxContentLength` 定义了node.js中允许的HTTP响应内容的最大字节数</span></span><br><span class="line">  maxContentLength<span class="punctuation">:</span> <span class="number">2000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `maxBodyLength`（仅Node）定义允许的http请求内容的最大字节数</span></span><br><span class="line">  maxBodyLength<span class="punctuation">:</span> <span class="number">2000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `validateStatus` 定义了对于给定的 HTTP状态码是 resolve 还是 reject promise。</span></span><br><span class="line">  <span class="comment">// 如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，</span></span><br><span class="line">  <span class="comment">// 则promise 将会 resolved，否则是 rejected。</span></span><br><span class="line">  validateStatus<span class="punctuation">:</span> function (status) <span class="punctuation">&#123;</span></span><br><span class="line">    return status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认值</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `maxRedirects` 定义了在node.js中要遵循的最大重定向数。</span></span><br><span class="line">  <span class="comment">// 如果设置为0，则不会进行重定向</span></span><br><span class="line">  maxRedirects<span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="comment">// 默认值</span></span><br><span class="line">  <span class="comment">// `socketPath` 定义了在node.js中使用的UNIX套接字。</span></span><br><span class="line">  <span class="comment">// e.g. &#x27;/var/run/docker.sock&#x27; 发送请求到 docker 守护进程。</span></span><br><span class="line">  <span class="comment">// 只能指定 `socketPath` 或 `proxy` 。</span></span><br><span class="line">  <span class="comment">// 若都指定，这使用 `socketPath` 。</span></span><br><span class="line">  socketPath<span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="comment">// default</span></span><br><span class="line">  <span class="comment">// `httpAgent` and `httpsAgent` define a custom agent to be used when performing http</span></span><br><span class="line">  <span class="comment">// and https requests, respectively, in node.js. This allows options to be added like</span></span><br><span class="line">  <span class="comment">// `keepAlive` that are not enabled by default.</span></span><br><span class="line">  httpAgent<span class="punctuation">:</span> new http.Agent(<span class="punctuation">&#123;</span> keepAlive<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">  httpsAgent<span class="punctuation">:</span> new https.Agent(<span class="punctuation">&#123;</span> keepAlive<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `proxy` 定义了代理服务器的主机名，端口和协议。</span></span><br><span class="line">  <span class="comment">// 您可以使用常规的`http_proxy` 和 `https_proxy` 环境变量。</span></span><br><span class="line">  <span class="comment">// 使用 `false` 可以禁用代理功能，同时环境变量也会被忽略。</span></span><br><span class="line">  <span class="comment">// `auth`表示应使用HTTP Basic auth连接到代理，并且提供凭据。</span></span><br><span class="line">  <span class="comment">// 这将设置一个 `Proxy-Authorization` 请求头，它会覆盖 `headers` 中已存在的自定义 `Proxy-Authorization` 请求头。</span></span><br><span class="line">  <span class="comment">// 如果代理服务器使用 HTTPS，则必须设置 protocol 为`https`</span></span><br><span class="line">  proxy<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    protocol<span class="punctuation">:</span> &#x27;https&#x27;<span class="punctuation">,</span></span><br><span class="line">    host<span class="punctuation">:</span> &#x27;<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">    port<span class="punctuation">:</span> <span class="number">9000</span><span class="punctuation">,</span></span><br><span class="line">    auth<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      username<span class="punctuation">:</span> &#x27;mikeymike&#x27;<span class="punctuation">,</span></span><br><span class="line">      password<span class="punctuation">:</span> &#x27;rapunz3l&#x27;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// see https://axios-http.com/zh/docs/cancellation</span></span><br><span class="line">  cancelToken<span class="punctuation">:</span> new CancelToken(function (cancel) <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">&#125;</span>)<span class="punctuation">,</span></span><br><span class="line">  <span class="comment">// `decompress` indicates whether or not the response body should be decompressed </span></span><br><span class="line">  <span class="comment">// automatically. If set to `true` will also remove the &#x27;content-encoding&#x27; header </span></span><br><span class="line">  <span class="comment">// from the responses objects of all decompressed responses</span></span><br><span class="line">  <span class="comment">// - Node only (XHR cannot turn off decompression)</span></span><br><span class="line">  decompress<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// 默认值</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Axios-get和post"><a href="#Axios-get和post" class="headerlink" title="Axios get和post"></a>Axios get和post</h3><blockquote><p>配置添加语法</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(url[, config])</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">get</span>(url,&#123;</span><br><span class="line">   上面指定配置<span class="attr">key</span>:配置值,</span><br><span class="line">   上面指定配置<span class="attr">key</span>:配置值</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">post</span>(url[, data[, config]])</span><br><span class="line"></span><br><span class="line">axios.<span class="title function_">post</span>(url,&#123;<span class="attr">key</span>:value <span class="comment">//此位置数据，没有空对象即可&#123;&#125;&#125;,&#123;</span></span><br><span class="line">   上面指定配置<span class="attr">key</span>:配置值,</span><br><span class="line">   上面指定配置<span class="attr">key</span>:配置值</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>测试get参数</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; onMounted,ref,reactive,toRaw &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> jsonData =<span class="title function_">reactive</span>(&#123;<span class="attr">code</span>:<span class="number">1</span>,<span class="attr">content</span>:<span class="string">&#x27;xxxxxxx&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveWords</span>= <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> axios.<span class="title function_">get</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;https://api.uomg.com/api/rand.qinghua&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">params</span>:&#123;<span class="comment">// 向url后添加的键值对参数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">format</span>:<span class="string">&#x27;json&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>:<span class="string">&#x27;zhangsan&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>:<span class="string">&#x27;123456&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">headers</span>:&#123;<span class="comment">// 设置请求头</span></span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;Accept&#x27;</span> : <span class="string">&#x27;application/json, text/plain, text/html,*/*&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      )</span></span><br><span class="line"><span class="language-javascript">    &#125;<span class="keyword">catch</span> (e)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> e</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveMessage</span> =(<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">let</span> &#123;data&#125;  = <span class="keyword">await</span> <span class="title function_">getLoveWords</span>()</span></span><br><span class="line"><span class="language-javascript">     <span class="title class_">Object</span>.<span class="title function_">assign</span>(message,data)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 通过onMounted生命周期,自动加载一次 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveMessage</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>测试post参数</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; onMounted,ref,reactive,toRaw &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> jsonData =<span class="title function_">reactive</span>(&#123;<span class="attr">code</span>:<span class="number">1</span>,<span class="attr">content</span>:<span class="string">&#x27;xxxxxxxx&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveWords</span>= <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> axios.<span class="title function_">post</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;https://api.uomg.com/api/rand.qinghua&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="comment">//请求体中的JSON数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>:<span class="string">&#x27;zhangsan&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>:<span class="string">&#x27;123456&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="comment">// 其他参数</span></span></span><br><span class="line"><span class="language-javascript">         <span class="attr">params</span>:&#123;<span class="comment">// url上拼接的键值对参数</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">format</span>:<span class="string">&#x27;json&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          &#125;,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">headers</span>:&#123;<span class="comment">// 请求头</span></span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;Accept&#x27;</span> : <span class="string">&#x27;application/json, text/plain, text/html,*/*&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="string">&#x27;X-Requested-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      )</span></span><br><span class="line"><span class="language-javascript">    &#125;<span class="keyword">catch</span> (e)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> e</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveMessage</span> =(<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">     <span class="keyword">let</span> &#123;data&#125;  = <span class="keyword">await</span> <span class="title function_">getLoveWords</span>()</span></span><br><span class="line"><span class="language-javascript">     <span class="title class_">Object</span>.<span class="title function_">assign</span>(message,data)</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 通过onMounted生命周期,自动加载一次 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveMessage</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Axios-拦截器"><a href="#Axios-拦截器" class="headerlink" title="Axios 拦截器"></a>Axios 拦截器</h3><blockquote><p>如果想在axios发送请求之前,或者是数据响应回来在执行then方法之前做一些额外的工作,可以通过拦截器完成</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加请求拦截器 请求发送之前</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">config</span>) &#123;</span><br><span class="line">    <span class="comment">// 在发送请求之前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 对请求错误做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器 数据响应回来</span></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">    <span class="comment">// 2xx 范围内的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应数据做点什么</span></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="keyword">function</span> (<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 超出 2xx 范围的状态码都会触发该函数。</span></span><br><span class="line">    <span class="comment">// 对响应错误做点什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>定义src&#x2F;axios.js提取拦截器和配置语法</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  创建instance实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>:<span class="string">&#x27;https://api.uomg.com&#x27;</span>,</span><br><span class="line">    <span class="attr">timeout</span>:<span class="number">10000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  添加请求拦截</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="comment">// 设置请求头配置信息</span></span><br><span class="line">    <span class="function"><span class="params">config</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//处理指定的请求头</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;before request&quot;</span>)</span><br><span class="line">        config.<span class="property">headers</span>.<span class="property">Accept</span> = <span class="string">&#x27;application/json, text/plain, text/html,*/*&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 设置请求错误处理函数</span></span><br><span class="line">    <span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;request error&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="comment">// 设置响应正确时的处理函数</span></span><br><span class="line">    <span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after success response&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 设置响应异常时的处理函数</span></span><br><span class="line">    <span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after fail response&quot;</span>)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(error)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 导入我们自己定义的axios.js文件,而不是导入axios依赖  </span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;./axios.js&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; onMounted,ref,reactive,toRaw &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> jsonData =<span class="title function_">reactive</span>(&#123;<span class="attr">code</span>:<span class="number">1</span>,<span class="attr">content</span>:<span class="string">&#x27;我努力不是为了你而是因为你&#x27;</span>&#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveWords</span>= <span class="keyword">async</span> (<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">try</span>&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> axios.<span class="title function_">post</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="string">&#x27;api/rand.qinghua&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">username</span>:<span class="string">&#x27;zhangsan&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">password</span>:<span class="string">&#x27;123456&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;,<span class="comment">//请求体中的JSON数据</span></span></span><br><span class="line"><span class="language-javascript">        &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">params</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">format</span>:<span class="string">&#x27;json&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="comment">// 其他键值对参数</span></span></span><br><span class="line"><span class="language-javascript">      )</span></span><br><span class="line"><span class="language-javascript">    &#125;<span class="keyword">catch</span> (e)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">await</span> e</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> <span class="title function_">getLoveMessage</span> =(<span class="params"></span>)=&gt;&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 这里返回的是一个fullfilled状态的promise</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveWords</span>().<span class="title function_">then</span>(</span></span><br><span class="line"><span class="language-javascript">        <span class="function">(<span class="params">response</span>) =&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;after getloveWords&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(response)</span></span><br><span class="line"><span class="language-javascript">          <span class="title class_">Object</span>.<span class="title function_">assign</span>(jsonData,response.<span class="property">data</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    )</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/* 通过onMounted生命周期,自动加载一次 */</span></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">getLoveMessage</span>()</span></span><br><span class="line"><span class="language-javascript">  &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="状态管理Pinia"><a href="#状态管理Pinia" class="headerlink" title="状态管理Pinia"></a>状态管理Pinia</h2><h3 id="Pinia介绍"><a href="#Pinia介绍" class="headerlink" title="Pinia介绍"></a>Pinia介绍</h3><blockquote><p>如何实现多个组件之间的数据传递?</p></blockquote><ul><li><p>方式1 组件传参   </p></li><li><p>方式2 路由传参  </p></li><li><p>方式3 通过pinia状态管理定义共享数据</p></li></ul><blockquote><p>当我们有<code>多个组件共享一个共同的状态(数据源)</code>时，多个视图可能都依赖于同一份状态。来自不同视图的交互也可能需要更改同一份状态。虽然我们的手动状态管理解决方案（props,组件间通信,模块化）在简单的场景中已经足够了，但是在大规模的生产应用中还有很多其他事项需要考虑：</p></blockquote><ul><li>更强的团队协作约定</li><li>与 Vue DevTools 集成，包括时间轴、组件内部审查和时间旅行调试</li><li>模块热更新 (HMR)</li><li>服务端渲染支持</li></ul><blockquote><p> <a href="https://pinia.vuejs.org/zh/" title="Pinia">Pinia</a> 就是一个实现了上述需求的状态管理库，由 Vue 核心团队维护，对 Vue 2 和 Vue 3 都可用。<a href="https://pinia.vuejs.org/zh/introduction.html">https://pinia.vuejs.org/zh/introduction.html</a></p></blockquote><h3 id="Pinia基本用法"><a href="#Pinia基本用法" class="headerlink" title="Pinia基本用法"></a>Pinia基本用法</h3><blockquote><p> 安装pinia</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install pinia</span><br></pre></td></tr></table></figure><blockquote><p>定义pinia store对象 src&#x2F;store&#x2F;store.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数据并且对外暴露</span></span><br><span class="line"><span class="comment">// store就是定义共享状态的包装对象</span></span><br><span class="line"><span class="comment">// 内部包含四个属性： id 唯一标识 state 完整类型推理，推荐使用箭头函数 存放的数据 getters 类似属性计算，存储放对数据</span></span><br><span class="line"><span class="comment">// 操作的方法  actions 存储数据的复杂业务逻辑方法</span></span><br><span class="line"><span class="comment">// 理解： store类似Java中的实体类， id就是类名， state 就是装数据值的属性  getters就是get方法，actions就是对数据操作的其他方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> definedPerson = <span class="title function_">defineStore</span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;personPinia&#x27;</span>, <span class="comment">//必须唯一</span></span><br><span class="line">        <span class="attr">state</span>:<span class="function">()=&gt;</span>&#123; <span class="comment">// state中用于定义数据</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">username</span>:<span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">                <span class="attr">age</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="attr">hobbies</span>:[<span class="string">&#x27;唱歌&#x27;</span>,<span class="string">&#x27;跳舞&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">getters</span>:&#123;<span class="comment">// 用于定义一些通过数据计算而得到结果的一些方法 一般在此处不做对数据的修改操作</span></span><br><span class="line">                 <span class="comment">// getters中的方法可以当做属性值方式使用</span></span><br><span class="line">            <span class="title function_">getHobbiesCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hobbies</span>.<span class="property">length</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">getAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">actions</span>:&#123; <span class="comment">// 用于定义一些对数据修改的方法</span></span><br><span class="line">            <span class="title function_">doubleAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">age</span>=<span class="variable language_">this</span>.<span class="property">age</span>*<span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p> 在main.js配置pinia组件到vue中 </p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./routers/router.js&#x27;</span></span><br><span class="line"><span class="comment">// 导pinia</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="comment">// 创建pinia对象</span></span><br><span class="line"><span class="keyword">let</span> pinia= <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="keyword">let</span> app =<span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line"><span class="comment">// app中使用pinia功能</span></span><br><span class="line">app.<span class="title function_">use</span>(pinia) </span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>Operate.vue 中操作Pinia数据</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; definedPerson&#125; <span class="keyword">from</span> <span class="string">&#x27;../store/store&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 读取存储的数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person= <span class="title function_">definedPerson</span>()</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> hobby = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>operate视图,用户操作Pinia中的数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        请输入姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.username&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        请输入年龄:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.age&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        请增加爱好:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吃饭&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 吃饭</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;睡觉&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 睡觉</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;打豆豆&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 打豆豆 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用person的doubleAge()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.doubleAge()&quot;</span>&gt;</span>年龄加倍<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用pinia提供的$reset()方法恢复数据的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.$reset()&quot;</span>&gt;</span>恢复默认值<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用$patch方法一次性修改多个属性值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.$patch(&#123;username:&#x27;奥特曼&#x27;,age:100,hobbies:[&#x27;晒太阳&#x27;,&#x27;打怪兽&#x27;]&#125;)&quot;</span>&gt;</span>变身奥特曼<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">显示pinia中的person数据:&#123;&#123;person&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>List.vue中展示Pinia数据</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; definedPerson&#125; <span class="keyword">from</span> <span class="string">&#x27;../store/store&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 读取存储的数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person= <span class="title function_">definedPerson</span>()</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>List页面,展示Pinia中的数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        读取姓名:&#123;&#123;person.username&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        读取年龄:&#123;&#123;person.age&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        通过get年龄:&#123;&#123;person.getAge&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        爱好数量:&#123;&#123;person.getHobbiesCount&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        所有的爱好:</span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&#x27;(hobby,index) in person.hobbies&#x27;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">v-text</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>定义组件路由router.js</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入路由创建的相关方法</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRouter,createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入vue组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">List</span>  <span class="keyword">from</span> <span class="string">&#x27;../components/List.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Operate</span>  <span class="keyword">from</span> <span class="string">&#x27;../components/Operate.vue&#x27;</span></span><br><span class="line"><span class="comment">// 创建路由对象,声明路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(&#123;</span><br><span class="line">    <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">    <span class="attr">routes</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/opearte&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Operate</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/list&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">List</span></span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 对外暴露路由对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><blockquote><p>App.vue中通过路由切换组件</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/opearte&quot;</span>&gt;</span>显示操作页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/list&quot;</span>&gt;</span>显示展示页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Pinia其他细节"><a href="#Pinia其他细节" class="headerlink" title="Pinia其他细节"></a>Pinia其他细节</h3><blockquote><p> State在大多数情况下，都是store的核心。人们通常会先定义能代表他们 APP 的 state。在 Pinia 中，state 被定义为一个返回初始状态的函数。</p></blockquote><ul><li>store.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineStore&#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> definedPerson = <span class="title function_">defineStore</span>(<span class="string">&#x27;personPinia&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">state</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                <span class="attr">username</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                <span class="attr">age</span>:<span class="number">0</span>,</span><br><span class="line">                <span class="attr">hobbies</span>:[<span class="string">&#x27;唱歌&#x27;</span>,<span class="string">&#x27;跳舞&#x27;</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">getters</span>:&#123;</span><br><span class="line">            <span class="title function_">getHobbiesCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hobbies</span>.<span class="property">length</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="title function_">getAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">actions</span>:&#123;</span><br><span class="line">            <span class="title function_">doubleAge</span>(<span class="params"></span>)&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">age</span>=<span class="variable language_">this</span>.<span class="property">age</span>*<span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>Operate.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; ref&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">import</span> &#123; definedPerson&#125; <span class="keyword">from</span> <span class="string">&#x27;../store/store&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 读取存储的数据</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> person= <span class="title function_">definedPerson</span>()</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> hobby = <span class="title function_">ref</span>(<span class="string">&#x27;&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> <span class="title function_">addHobby</span>= (<span class="params"></span>)=&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(hobby.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">        person.<span class="property">hobbies</span>.<span class="title function_">push</span>(hobby.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 监听状态</span></span></span><br><span class="line"><span class="language-javascript">    person.$subscribe(<span class="function">(<span class="params">mutation,state</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;---subscribe---&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">/* </span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        mutation.storeId</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            person.$id一样</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        mutation.payload</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">            传递给 cartStore.$patch() 的补丁对象。</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        state 数据状态,其实是一个代理</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        */</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation.<span class="property">type</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation.<span class="property">payload</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(mutation.<span class="property">storeId</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">$id</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 数据 其实是一个代理对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(state)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>operate视图,用户操作Pinia中的数据<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        请输入姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.username&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        请输入年龄:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;person.age&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        请增加爱好:</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;吃饭&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 吃饭</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;睡觉&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 睡觉</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;打豆豆&quot;</span>  <span class="attr">v-model</span>=<span class="string">&quot;person.hobbies&quot;</span>&gt;</span> 打豆豆 <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;addHobby&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用person的doubleAge()方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.doubleAge()&quot;</span>&gt;</span>年龄加倍<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用pinia提供的$reset()方法恢复数据的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.$reset()&quot;</span>&gt;</span>恢复默认值<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 事件中调用$patch方法一次性修改多个属性值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;person.$patch(&#123;username:&#x27;奥特曼&#x27;,age:100,hobbies:[&#x27;晒太阳&#x27;,&#x27;打怪兽&#x27;]&#125;)&quot;</span>&gt;</span>变身奥特曼<span class="tag">&lt;/<span class="name">button</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">person:&#123;&#123;person&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p> Getter 完全等同于 store 的 state 的<a href="https://cn.vuejs.org/guide/essentials/computed.html" title="计算值">计算值</a>。可以通过 <code>defineStore()</code> 中的 <code>getters</code> 属性来定义它们。<strong>推荐</strong>使用箭头函数，并且它将接收 <code>state</code> 作为第一个参数：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doubleCount</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">count</span> * <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p> Action 相当于组件中的 <a href="https://v3.vuejs.org/guide/data-methods.html#methods" title="method">method</a>。它们可以通过 <code>defineStore()</code> 中的 <code>actions</code> 属性来定义，<strong>并且它们也是定义业务逻辑的完美选择。</strong>类似 <a href="https://pinia.vuejs.org/zh/core-concepts/getters.html" title="getter">getter</a>，action 也可通过 <code>this</code> 访问<strong>整个 store 实例</strong>，并支持**完整的类型标注(以及自动补全)**。不同的是，<code>action</code> 可以是异步的，你可以在它们里面 <code>await</code> 调用任何 API，以及其他 action！</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;main&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">randomizeCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span> = <span class="title class_">Math</span>.<span class="title function_">round</span>(<span class="number">100</span> * <span class="title class_">Math</span>.<span class="title function_">random</span>())</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="Element-plus"><a href="#Element-plus" class="headerlink" title="Element-plus"></a>Element-plus</h2><blockquote><p>Element Plus 是一套基于 Vue 3 的开源 UI 组件库，是由饿了么前端团队开发的升级版本 Element UI。Element Plus 提供了丰富的 UI 组件、易于使用的 API 接口和灵活的主题定制功能，可以帮助开发者快速构建高质量的 Web 应用程序。</p></blockquote><ul><li>Element Plus 支持按需加载，且不依赖于任何第三方 CSS 库，它可以轻松地集成到任何 Vue.js 项目中。Element Plus 的文档十分清晰，提供了各种组件的使用方法和示例代码，方便开发者快速上手。</li><li>Element Plus 目前已经推出了大量的常用 UI 组件，如按钮、表单、表格、对话框、选项卡等，此外还提供了一些高级组件，如日期选择器、时间选择器、级联选择器、滑块、颜色选择器等。这些组件具有一致的设计和可靠的代码质量，可以为开发者提供稳定的使用体验。</li><li>与 Element UI 相比，Element Plus 采用了现代化的技术架构和更加先进的设计理念，同时具备更好的性能和更好的兼容性。Element Plus 的更新迭代也更加频繁，可以为开发者提供更好的使用体验和更多的功能特性。</li><li>Element Plus 可以在支持 <a href="https://caniuse.com/?feats=mdn-javascript_builtins_regexp_dotall,mdn-javascript_builtins_regexp_lookbehind_assertion,mdn-javascript_builtins_regexp_named_capture_groups,mdn-javascript_builtins_regexp_property_escapes,mdn-javascript_builtins_symbol_asynciterator,mdn-javascript_functions_method_definitions_async_generator_methods,mdn-javascript_grammar_template_literals_template_literal_revision,mdn-javascript_operators_destructuring_rest_in_objects,mdn-javascript_operators_spread_spread_in_destructuring,promise-finally" title="ES2018">ES2018</a> 和 <a href="https://caniuse.com/resizeobserver" title="ResizeObserver">ResizeObserver</a> 的浏览器上运行。 如果您确实需要支持旧版本的浏览器，请自行添加 <a href="https://babeljs.io/" title="Babel">Babel</a> 和相应的 Polyfill</li><li>官网<a href="https://element-plus.gitee.io/zh-CN/">https://element-plus.gitee.io/zh-CN/</a></li><li>由于 Vue 3 不再支持 IE11，Element Plus 也不再支持 IE 浏览器。</li><li><a href="https://element-plus.gitee.io/zh-CN/component/button.html">Element-plus常用组件</a></li></ul><h3 id="Element-plus示例"><a href="#Element-plus示例" class="headerlink" title="Element-plus示例"></a>Element-plus示例</h3><blockquote><p> 1 准备vite项目</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm create vite  // 注意选择 vue+TypeScript</span><br><span class="line">npm install </span><br><span class="line">npm install pinia</span><br><span class="line">npm install axios</span><br></pre></td></tr></table></figure><blockquote><p> 2 安装element-plus</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install element-plus</span><br></pre></td></tr></table></figure><blockquote><p>3 完整引入element-plus</p></blockquote><ul><li>main.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//导入element-plus相关内容</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ElementPlus</span> <span class="keyword">from</span> <span class="string">&#x27;element-plus&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-plus/dist/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">ElementPlus</span>)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>App.vue</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> value = <span class="title function_">ref</span>(<span class="literal">true</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 直接使用element-plus组件即可 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-switch</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">size</span>=<span class="string">&quot;large&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">active-text</span>=<span class="string">&quot;Open&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">inactive-text</span>=<span class="string">&quot;Close&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-switch</span> <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span> <span class="attr">active-text</span>=<span class="string">&quot;Open&quot;</span> <span class="attr">inactive-text</span>=<span class="string">&quot;Close&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-switch</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">size</span>=<span class="string">&quot;small&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">active-text</span>=<span class="string">&quot;Open&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">inactive-text</span>=<span class="string">&quot;Close&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb技术（上）</title>
      <link href="/inori/72bd32c0.html"/>
      <url>/inori/72bd32c0.html</url>
      
        <content type="html"><![CDATA[<h2 id="Html、CSS、JavaScript基础语法"><a href="#Html、CSS、JavaScript基础语法" class="headerlink" title="Html、CSS、JavaScript基础语法"></a>Html、CSS、JavaScript基础语法</h2><p><a href="https://www.zhihu.com/tardis/bd/art/583518241?source_id=1001">点击这里</a>了解</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>前后端都是使用对象来存储数据的，但是JS的对象和Java的对象并不能互通，两者是将数据转化成JSON进行传输的。</p><p>JSON(JavaScript Object Notation)JS对象简谱，采用完全独立于编程语言的文本格式来存储和表示数据。JSON是一种字符串格式，这种格式无论是在前端还是后端，都可以很容易的转换成对象，所以常用于前后端数据传递。</p><ul><li><p>JSON语法：<code>var obj = &#39;&#123;&quot;属性名&quot;: &quot;属性值&quot;, ...&#125;&#39;</code></p></li><li><p>JSON在客户端（前端）的使用：</p><ol><li>获取JSON字符串</li><li>使用<code>JSON.parse(jsonStr)</code>将JSON转化成对象</li></ol></li><li><p>JSON在服务端（后端）的使用：</p><ol><li>编写需要转化成JSON的对象或者获取到JSON时</li><li>使用<u>GSON</u>、<u>Jackson</u>、<u>Fastjson</u>等第三方工具类（需要导入jar包），将对象转化成JSON字符串。Jackson语法为：<code>new ObjectMapper().writeValueAsString(jsonStr)</code>和<code>new ObjectMapper().readValue(jsonStr, 需要转化的类名.class)</code></li></ol></li></ul><h3 id="BOM编程"><a href="#BOM编程" class="headerlink" title="BOM编程"></a>BOM编程</h3><p>​BOM(Browser Object Model)浏览器对象模型，BOM由一系列对象组成，是访问、控制、修改浏览器的属性和方法(通过window对象及属性的一系列方法控制浏览器行为的一种编程)，BOM没有统一的标准(每种客户端都可以自定标准)，BOM编程是将浏览器窗口的各个组成部分抽象成各个对象,通过各个对象的API操作组件行为的一种编程。<br>BOM编程的对象结构如下：</p><ul><li>window：顶级对象,代表整个浏览器窗口</li><li>location：window对象的属性之一,代表浏览器的地址栏</li><li>history：window对象的属性之一,代表浏览器的访问历史</li><li>screen：window对象的属性之一,代表屏幕</li><li>navigator：window对象的属性之一,代表浏览器软件本身</li><li>document：window对象的属性之一,代表浏览器窗口目前解析的html文档</li><li>console：window对象的属性之一,代表浏览器开发者工具的控制台</li><li>localStorage：window对象的属性之一,代表浏览器的本地数据持久化存储</li><li>sessionStorage window对象的属性之一,代表浏览器的本地数据会话级存储（暂时存储）</li></ul><h3 id="DOM编程"><a href="#DOM编程" class="headerlink" title="DOM编程"></a>DOM编程</h3><p>​DOM(Document Object Model)文档对象模型编程，就是使用document对象的API完成对网页HTML文档进行动态修改,以实现网页数据和样式动态变化效果的编程</p><h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model），HTML DOM 模型被结构化为对象树：</p><p>HTML DOM 是 HTML 的标准对象模型和编程接口。它定义了：</p><ul><li>作为对象的 HTML 元素</li><li>所有 HTML 元素的属性</li><li>访问所有 HTML 元素的方法</li><li>所有 HTML 元素的事件</li></ul><p><strong>文档：一个页面就是一个文档，DOM中使用<code>document</code> 表示。</strong><br><strong>网页：框架标记（<code>frameset</code> <code>iframe</code>）一个页面中包含了多个文档<code>documen</code>对象</strong><br><strong>元素：页面中所有的标签都是元素，DOM中使用<code>element</code>表示</strong><br><strong>节点：页面中所有内容都是节点（标签、属性、文本、注释等），DOM中使用<code>node</code>表示</strong></p><h4 id="DOM基本方法"><a href="#DOM基本方法" class="headerlink" title="DOM基本方法"></a>DOM基本方法</h4><p>DOM能通过JS进行访问，DOM中所有HTML元素都被定义为对象。我们通过JS对这些对象操作，改变HTML元素的内容</p><ul><li>使用<code>getElementByID()</code>方法可以获取带有ID的元素对象</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> mydiv=<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mydiv&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">console</span>.<span class="title function_">log</span>(mydiv);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;mydiv&quot;</span>&gt;</span>my id a nice man<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>getElementByTagname()</code>方法可以返回带有指定标签名的对象集合</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementByTagname</span>(<span class="string">&#x27;标签名&#x27;</span>)</span><br></pre></td></tr></table></figure><p>也可以获取（父元素）内部所有指定标签名的子元素。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">dlement.<span class="title function_">getElementBytagName</span>(<span class="string">&#x27;标签名&#x27;</span>);</span><br><span class="line"><span class="comment">//父元素必须是单个对象（必须指明）。</span></span><br></pre></td></tr></table></figure><ul><li><code>getElementByName()</code>方法可返回带有指定名称的对象的集合，它查询的元素是name属性，返回的是数组，不是一个元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据类名返回元素对象集合</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;类名&#x27;</span>);</span><br><span class="line"><span class="comment">//根据指定选择器返回第一个元素对象 里面的选择器需要加符号</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;选择器&#x27;</span>);</span><br><span class="line"><span class="comment">//根据指定选择器返回</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;选择器&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>获取body元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span></span><br></pre></td></tr></table></figure><ul><li>获取html元素</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">dovumentElement</span></span><br></pre></td></tr></table></figure><h4 id="改变HTML元素"><a href="#改变HTML元素" class="headerlink" title="改变HTML元素"></a>改变HTML元素</h4><blockquote><p>JavaScript的DOM操作可以改变网页内容、结构和样式，我们可以利用DOm操作元素来改变元素李的内容、属性等操作</p></blockquote><p><code>element.innerHtml=new htmlcontent</code> ：改变元素的HTML<br><code>element.innerTEXT=new text</code>：改变元素的文本内容<br><code>element.attribute=new value</code>：改变HTML元素的属性值<br><code>element.setAttribute(attribuute,value)</code>：改变HTML元素的属性值<br><code>element.hasAttribute(attribute)</code>：删除元素属性<br><code>element.removeAttribute(attribute)</code>：删除元素属性<br><code>element.style.property=new style</code>：改变html元素的样式</p><ul><li>元素属性innerHtml就是元素的html代码，查找到元素后，可以对其innerHtml属性进行重新赋值修改</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> h1=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">h1.<span class="property">innerHTML</span>=<span class="string">&quot;&lt;h2&gt;World&lt;/h2&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>element.innerText</code>改变element中的文本</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> h1=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//改变文本，html不解析，同时去空格、换行</span></span></span><br><span class="line"><span class="language-javascript">h1.<span class="property">innerText</span>=<span class="string">&quot;&lt;h2&gt;World&lt;/h2&gt;&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>attribute 是代词，具体看元素属性。如a标签有href属性，可以使用<code>element.gref</code>来改变</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.4399.com&quot;</span>&gt;</span>网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    a.<span class="property">href</span> = <span class="string">&quot;https://www.qq.com&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过 <code>element.setAttribute </code>方法来改变元素属性值</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.<span class="title function_">setAttribute</span>(attribute, value)</span><br></pre></td></tr></table></figure><p><code>attribute</code>：属性名<br><code>value</code>：属性值</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;hightlight&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://www.4399.com&quot;</span>&gt;</span>网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="keyword">var</span> a = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;a&quot;</span>); </span></span><br><span class="line"><span class="language-javascript"><span class="comment">//更改属性</span></span></span><br><span class="line"><span class="language-javascript"> a.<span class="title function_">setAttribute</span>(<span class="string">&quot;href&quot;</span>,<span class="string">&quot;https://www.qq.com&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 用className方法更改 class 属性使用 </span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 注意空格，这里是增加一个class</span></span></span><br><span class="line"><span class="language-javascript">    a.<span class="property">className</span> += <span class="string">&quot; hidden&quot;</span>;  </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 用 setAttribute 更改 class 属性直接用 class</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 也可写两个属性</span></span></span><br><span class="line"><span class="language-javascript">    a.<span class="title function_">setAttribute</span>(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;hightlight hidden&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>element.hasAttribute</code>判断是否有指定属性</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.baidu.com&quot;</span>&gt;</span>bd<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> a=documnet.<span class="title function_">querySelector</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">a.<span class="title function_">hasAttribute</span>(<span class="string">&quot;href&quot;</span>);<span class="comment">//返回true</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>element.removeAttribute</code>移除指定元素</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">date-index</span>=<span class="string">&quot;1&quot;</span>&gt;</span>123<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> a=documnet.<span class="title function_">querySelector</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">a.<span class="title function_">removeAttribute</span>(<span class="string">&quot;date-index&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>使用元素中style 属性可以修改元素样式，修改的样式直接作用在css样式里</p><ul><li><p>css中原本使用“-”连接的名字要转换成驼峰式，如background-color -&gt; backgroundColor</p></li><li><p>修改样式的属性名需要改写</p></li><li><p>属性值都是字符串，设置是必须包括单位</p></li></ul></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.4399.com&quot;</span>&gt;</span>网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> a =<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;a&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">a.<span class="property">style</span>.<span class="property">fontSize</span>=<span class="string">&quot;30px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="获取HTML元素"><a href="#获取HTML元素" class="headerlink" title="获取HTML元素"></a>获取HTML元素</h4><ul><li>利用DOM树可把节点划分不同的关系，<code>node.parentNode</code>:可返回最近的一个父节点，如果没有返回null</li><li><code>parentNode.childNodes(标准)</code>：返回指定节点的子节点的集合;返回值包括所有的子节点、元素节点、文本节点。</li><li><code>parentNodes.children(非标准)</code>：一个只读属性，只返回所有子元素节点，其他节点不返回；获取所有元素节点，需要其他特殊处理，一般不推荐使用<code>childNode</code>，但浏览器都支持。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul=<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ul.<span class="property">childNodes</span>.<span class="property">lenth</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(ul.<span class="property">childNodes</span>[i].<span class="property">nodeType</span> == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">//ul.childNodes[i] 是元素节点</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ul.<span class="property">childNodes</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>parentNode.firstChild</code>:返回一个子节点，找不到返回null，包含所有的节点。</li><li><code>parentNode.lastChild</code>:返回最后一个子节点，找不到返回null，也包含所有节点<br><strong>以下两个只支持IE9以上</strong></li><li><code>parentNode.firstElementChild</code>:返回第一个子节点，找不到返回null。</li><li><code>parentNode.lastElementChild</code>:返回最后一个元素节点，找不到返回null。</li><li><code>node.nextSibling</code>:返回当前元素的下一个兄弟节点，找不到返回null，包括所有节点。</li><li><code>node.previousSibling</code>:返回当前元素的上一个兄弟节点，找不到返回null，包括所有节点。<br><strong>指定节点</strong>（只支持IE9以上）</li><li><code>node.nextElementSibling</code>:返回当前元素下一个兄弟元素节点，找不到返回null。</li><li><code>node.nextpreviousElementSibling</code>:返回当前元素上一个兄弟节点，找不到返回null。</li></ul><h4 id="操作HTML元素"><a href="#操作HTML元素" class="headerlink" title="操作HTML元素"></a>操作HTML元素</h4><ul><li><p><code>document.createElement()</code>:方法创建由tagName指定的html元素（动态创建元素点）。</p></li><li><p><code>node.appendChild()</code>:方法将一个节点添加到父节点的子节点列表末尾。</p></li><li><p><code>node.insertBefore(child,指定元素)</code>:</p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加节点 node.appendChild(child)  node 父级  child子级</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;ul&#x27;</span>);</span><br><span class="line">ul.<span class="title function_">appendChild</span>(li);</span><br><span class="line"><span class="comment">//node.insertBefore(child,指定元素);</span></span><br><span class="line"><span class="keyword">var</span> lili = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">ul.<span class="title function_">insertBefore</span>(lili,ul.<span class="property">children</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><ul><li><code>node.removeChild(child)</code>:方法从DOM中删除一个子节点，返回删除的节点</li></ul><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Tomcat是一款JavaWeb服务器，Tomcat技术先进、性能稳定，而且免费开源，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为比较流行的Web应用服务器</p><h3 id="Tomcat目录及测试"><a href="#Tomcat目录及测试" class="headerlink" title="Tomcat目录及测试"></a>Tomcat目录及测试</h3><ul><li><p>bin：该目录下存放的是二进制可执行文件，如果是安装版，那么这个目录下会有两个exe文件：tomcat10.exe、tomcat10w.exe，前者是在控制台下启动Tomcat，后者是弹出GUI窗口启动Tomcat；如果是解压版，那么会有startup.bat和shutdown.bat文件，startup.bat用来启动Tomcat，但需要先配置JAVA_HOME环境变量才能启动，shutdawn.bat用来停止Tomcat</p></li><li><p>conf：这个目录下有四个最为重要的文件：</p><ul><li><p><strong>server.xml：配置整个服务器信息。例如修改端口号。默认HTTP请求的端口号是：8080</strong></p></li><li><p>tomcat-users.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tomcat-users</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://tomcat.apache.org/xml&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin-gui&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin-script&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-gui&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-script&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-jmx&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-status&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;admin&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">password</span>=<span class="string">&quot;admin&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">roles</span>=<span class="string">&quot;admin-gui,admin-script,manager-gui,manager-script,manager-jmx,manager-status&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tomcat-users</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text&#x2F;html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了。当然是在浏览器中显示这个html文件了。但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。MIME是用来说明文档的内容是什么类型的</p></li><li><p>context.xml：对所有应用的统一配置，通常不会去配置它</p></li></ul></li><li><p>lib：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的jar包了，所以建议只把Tomcat需要的jar包放到这个目录下；</p></li><li><p>logs：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中</p></li><li><p>temp：存放临时文件</p></li><li><p><strong>webapps：存放web项目的目录，其中每个文件夹都是一个项目</strong>；如果这个目录下已经存在了目录，那么都是tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中访问<a href="http://127.0.0.1:8080，没有给出项目目录时，对应的就是ROOT项目.http://localhost:8080/examples，进入示例项目">http://127.0.0.1:8080，没有给出项目目录时，对应的就是ROOT项目.http://localhost:8080/examples，进入示例项目</a></p></li><li><p>work：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成。可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下</p></li></ul><h3 id="Web项目的标准结构"><a href="#Web项目的标准结构" class="headerlink" title="Web项目的标准结构"></a>Web项目的标准结构</h3><p>app：应用根目录</p><ul><li>static 非必要目录,约定俗成的名字,一般在此处放静态资源 ( css  js  img)</li><li>WEB-INF：必要目录,必须叫WEB-INF,受保护的资源目录,浏览器通过url不可以直接访问的目录<ul><li>classes：必要目录,src下源代码,配置文件,编译后会在该目录下,web项目中如果没有源码,则该目录不会出现</li><li>lib：必要目录,项目依赖的jar编译后会出现在该目录下,web项目要是没有依赖任何jar,则该目录不会出现</li><li>web.xml：必要文件,web项目的基本配置文件. 较新的版本中可以没有该文件,但是学习过程中还是需要该文件</li></ul></li><li>index.html：非必要文件,index.html&#x2F;index.htm&#x2F;index.jsp为默认的欢迎页</li></ul><h3 id="Web项目的部署方式"><a href="#Web项目的部署方式" class="headerlink" title="Web项目的部署方式"></a>Web项目的部署方式</h3><blockquote><p>方式1   直接将编译好的项目放在webapps目录下</p></blockquote><blockquote><p>方式2   将编译好的项目打成war包放在webapps目录下,tomcat启动后会自动解压war包</p></blockquote><blockquote><p>方式3   可以将项目放在非webapps的其他目录下,在tomcat中通过配置文件指向app的实际磁盘路径</p></blockquote><ul><li><p>在磁盘的自定义目录上准备一个app</p></li><li><p>在tomcat的conf下创建Catalina&#x2F;localhost目录,并在该目录下准备一个app.xml文件</p></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">path: 项目的访问路径,也是项目的上下文路径,就是在浏览器中,输入的项目名称</span></span><br><span class="line"><span class="comment">    docBase: 项目在磁盘中的实际路径</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/app&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot;D:\mywebapps\app&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>启动tomcat访问测试即可</li></ul><h3 id="IDEA部署项目并运行的原理"><a href="#IDEA部署项目并运行的原理" class="headerlink" title="IDEA部署项目并运行的原理"></a>IDEA部署项目并运行的原理</h3><ul><li>idea并没有直接进将编译好的项目放入tomcat的webapps中</li><li>idea根据关联的tomcat,创建了一个tomcat副本,将项目部署到了这个副本中</li><li>idea的tomcat副本在C:\用户\当前用户\AppData\Local\JetBrains\IntelliJIdea\tomcat\</li><li>idea的tomcat副本并不是一个完整的tomcat,副本里只是准备了和当前项目相关的配置文件</li><li>idea启动tomcat时,是让本地tomcat程序按照tomcat副本里的配置文件运行</li><li>idea的tomcat副本部署项目的模式通过conf&#x2F;Catalina&#x2F;localhost&#x2F;*.xml配置文件的形式实现项目部署</li></ul><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote><p>Servlet  (server applet) 是运行在服务端(tomcat)的Java小程序，是sun公司提供一套定义动态资源规范; 从代码层面上来讲Servlet就是一个接口</p></blockquote><ul><li><p>Servlet用来接收、处理客户端请求、响应给浏览器的动态资源。在整个Web应用中，Servlet主要负责接收处理请求、协同调度功能以及响应数据。我们可以把Servlet称为Web应用中的<strong>控制器</strong></p></li><li><p>不是所有的JAVA类都能用于处理客户端请求,能处理客户端请求并做出响应的一套技术标准就是Servlet</p></li><li><p>Servlet是运行在服务端的,所以Servlet必须在WEB项目##中开发且在Tomcat这样的服务容器中运行</p></li></ul><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><blockquote><p>步骤1 开发一个web类型的module </p></blockquote><blockquote><p>步骤2 开发一个UserServlet</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServlet</span>  <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;atguigu&quot;</span>.equals(username))&#123;</span><br><span class="line">            <span class="comment">//通过响应对象响应信息</span></span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义一个类,要继承HttpServlet类</li><li>重写service方法,该方法主要就是用于处理用户请求的服务方法</li><li>HttpServletRequest 代表请求对象,是有请求报文经过tomcat转换而来的,通过该对象可以获取请求中的信息</li><li>HttpServletResponse 代表响应对象,该对象会被tomcat转换为响应的报文,通过该对象可以设置响应中的信息</li><li>Servlet对象的生命周期(创建,初始化,处理服务,销毁)是由tomcat管理的,无需我们自己new</li><li>HttpServletRequest HttpServletResponse 两个对象也是有tomcat负责转换,在调用service方法时传入给我们用的</li></ul><blockquote><p>步骤3 在web.xml为UseServlet配置请求的映射路径</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给UserServlet起一个别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.UserServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关联别名和映射路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>userServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以为一个Servlet匹配多个不同的映射路径,但是不同的Servlet不能使用相同的url-pattern--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/userServlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;url-pattern&gt;/userServlet2&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            /        表示通配所有资源,不包括jsp文件</span></span><br><span class="line"><span class="comment">            /*       表示通配所有资源,包括jsp文件</span></span><br><span class="line"><span class="comment">            /a/*     匹配所有以a前缀的映射路径</span></span><br><span class="line"><span class="comment">            *.action 匹配所有以action为后缀的映射路径</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>Servlet并不是文件系统中实际存在的文件或者目录,所以为了能够请求到该资源,我们需要为其配置映射路径</li><li>servlet的请求映射路径配置在web.xml中</li><li>servlet-name作为servlet的别名,可以自己随意定义,见名知意就好</li><li>url-pattern标签用于定义Servlet的请求映射路径</li><li>一个servlet可以对应多个不同的url-pattern</li><li>多个servlet不能使用相同的url-pattern</li><li>url-pattern中可以使用一些通配写法<ul><li>&#x2F;        表示通配所有资源,不包括jsp文件</li><li>&#x2F;*      表示通配所有资源,包括jsp文件</li><li>&#x2F;a&#x2F;*     匹配所有以a前缀的映射路径</li><li>*.action 匹配所有以action为后缀的映射路径</li></ul></li></ul><blockquote><p>步骤4 开发一个form表单,向servlet发送一个get请求并携带username参数</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;userServlet&quot;</span>&gt;</span></span><br><span class="line">        请输入用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;校验&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>启动项目,访问index.html ,提交表单测试</p></blockquote><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><blockquote><p>什么是Servlet的生命周期</p></blockquote><ul><li>应用程序中的对象不仅在空间上有层次结构的关系，在时间上也会因为处于程序运行过程中的不同阶段而表现出不同状态和不同行为——这就是对象的生命周期。</li><li>简单的叙述生命周期，就是对象在容器中从开始创建到销毁的过程。</li></ul><blockquote><p>Servlet容器</p></blockquote><ul><li>Servlet对象是Servlet容器创建的，生命周期方法都是由容器(目前我们使用的是Tomcat)调用的。这一点和我们之前所编写的代码有很大不同。在今后的学习中我们会看到，越来越多的对象交给容器或框架来创建，越来越多的方法由容器或框架来调用，开发人员要尽可能多的将精力放在业务逻辑的实现上。</li></ul><blockquote><p>Servlet主要的生命周期执行特点</p></blockquote><table><thead><tr><th>生命周期</th><th>对应方法</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>构造对象</td><td>构造器</td><td>第一次请求或者容器启动</td><td>1</td></tr><tr><td>初始化</td><td>init()</td><td>构造完毕后</td><td>1</td></tr><tr><td>处理服务</td><td>service(HttpServletRequest req,HttpServletResponse resp)</td><td>每次请求</td><td>多次</td></tr><tr><td>销毁</td><td>destory()</td><td>容器关闭时</td><td>1</td></tr></tbody></table><ol><li>Servlet对象在容器中是单例的</li><li>容器是可以处理并发的用户请求的,每个请求在容器中都会开启一个线程</li><li>多个线程可能会使用相同的Servlet对象,所以在Servlet中,我们不要轻易定义一些容易经常发生修改的成员变量</li><li>load-on-startup中定义的正整数表示实例化顺序,如果数字重复了,容器会自行解决实例化顺序问题,但是应该避免重复</li><li>Tomcat容器中,已经定义了一些随系统启动实例化的servlet,我们自定义的servlet的load-on-startup尽量不要占用数字1-5</li></ol><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><ul><li>ServletConfig为Servlet提供初始配置参数的一种对象,每个Servlet都有自己独立唯一的ServletConfig对象</li><li>容器会为每个Servlet实例化一个ServletConfig对象,并通过Servlet生命周期的init方法传入给Servlet作为属性</li></ul><p>了解是什么即可</p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><ul><li>ServletContext对象有称呼为上下文对象,或者叫应用域对象</li><li>容器会为每个app创建一个独立的唯一的ServletContext对象</li><li>ServletContext对象为所有的Servlet所共享</li><li>ServletContext可以为所有的Servlet提供初始配置参数</li></ul><h4 id="ServletContext重要API"><a href="#ServletContext重要API" class="headerlink" title="ServletContext重要API"></a>ServletContext重要API</h4><blockquote><p>获取资源的真实路径</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> servletContext.getRealPath(<span class="string">&quot;资源在web目录中的路径&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>例如我们的目标是需要获取项目中某个静态资源的路径，不是工程目录中的路径，而是<strong>部署目录中的路径</strong>；我们如果直接拷贝其在我们电脑中的完整路径的话其实是有问题的，因为如果该项目以后部署到公司服务器上的话，路径肯定是会发生改变的，所以我们需要使用代码动态获取资源的真实路径.  只要使用了servletContext动态获取资源的真实路径，<strong>那么无论项目的部署路径发生什么变化，都会动态获取项目运行时候的实际路径</strong>，所以就不会发生由于写死真实路径而导致项目部署位置改变引发的路径错误问题</li></ul><blockquote><p>获取项目的上下文路径</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> servletContext.getContextPath();</span><br></pre></td></tr></table></figure><ul><li>项目的部署名称,也叫项目的上下文路径,在部署进入tomcat时所使用的路径,该路径是可能发生变化的,通过该API动态获取项目真实的上下文路径,可以<strong>帮助我们解决一些后端页面渲染技术或者请求转发和响应重定向中的路径问题</strong></li></ul><blockquote><p> 域对象的相关API</p></blockquote><ul><li>域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同</li><li>ServletContext代表应用,所以ServletContext域也叫作应用域,是webapp中最大的域,可以在本应用内实现数据的共享和传递</li><li>webapp中的三大域对象,分别是应用域,会话域,请求域</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void setAttribute(String key,Object value);</td><td>向域中存储&#x2F;修改数据</td></tr><tr><td>Object getAttribute(String key);</td><td>获得域中的数据</td></tr><tr><td>void removeAttribute(String key);</td><td>移除域中的数据</td></tr></tbody></table><h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><ul><li>HttpServletRequest是一个接口,其父接口是ServletRequest</li><li>HttpServletRequest是Tomcat将请求报文转换封装而来的对象,在Tomcat调用service方法时传入</li><li>HttpServletRequest代表客户端发来的请求,所有请求中的信息都可以通过该对象获得</li></ul><h3 id="HttpServletRequest常见API"><a href="#HttpServletRequest常见API" class="headerlink" title="HttpServletRequest常见API"></a>HttpServletRequest常见API</h3><ul><li>获取请求行信息相关(方式,请求的url,协议及版本)</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>StringBuffer getRequestURL();</td><td>获取客户端请求的url</td></tr><tr><td>String getRequestURI();</td><td>获取客户端请求项目中的具体资源</td></tr><tr><td>int getServerPort();</td><td>获取客户端发送请求时的端口</td></tr><tr><td>int getLocalPort();</td><td>获取本应用在所在容器的端口</td></tr><tr><td>int getRemotePort();</td><td>获取客户端程序的端口</td></tr><tr><td>String getScheme();</td><td>获取请求协议</td></tr><tr><td>String getProtocol();</td><td>获取请求协议及版本号</td></tr><tr><td>String getMethod();</td><td>获取请求方式</td></tr></tbody></table><ul><li>获得请求头信息相关</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>String getHeader(String headerName);</td><td>根据头名称获取请求头</td></tr><tr><td>Enumeration<String> getHeaderNames();</String></td><td>获取所有的请求头名字</td></tr><tr><td>String getContentType();</td><td>获取content-type请求头</td></tr></tbody></table><ul><li>获得请求参数相关</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>String getParameter(String parameterName);</td><td>根据请求参数名获取请求单个参数值</td></tr><tr><td>String[] getParameterValues(String parameterName);</td><td>根据请求参数名获取请求多个参数值数组</td></tr><tr><td>Enumeration<String> getParameterNames();</String></td><td>获取所有请求参数名</td></tr><tr><td>Map&lt;String, String[]&gt; getParameterMap();</td><td>获取所有请求参数的键值对集合</td></tr><tr><td>BufferedReader getReader() throws IOException;</td><td>获取读取请求体的字符输入流</td></tr><tr><td>ServletInputStream getInputStream() throws IOException;</td><td>获取读取请求体的字节输入流</td></tr><tr><td>int getContentLength();</td><td>获得请求体长度的字节数</td></tr></tbody></table><ul><li>其他API</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>String getServletPath();</td><td>获取请求的Servlet的映射路径</td></tr><tr><td>ServletContext getServletContext();</td><td>获取ServletContext对象</td></tr><tr><td>Cookie[] getCookies();</td><td>获取请求中的所有cookie</td></tr><tr><td>HttpSession getSession();</td><td>获取Session对象</td></tr><tr><td>void setCharacterEncoding(String encoding) ;</td><td>设置请求体字符集</td></tr></tbody></table><h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><ul><li>HttpServletResponse是一个接口,其父接口是ServletResponse</li><li>HttpServletResponse是Tomcat预先创建的,在Tomcat调用service方法时传入</li><li>HttpServletResponse代表对客户端的响应,该对象会被转换成响应的报文发送给客户端,通过该对象我们可以设置响应信息</li></ul><h3 id="HttpServletResponse的常见API"><a href="#HttpServletResponse的常见API" class="headerlink" title="HttpServletResponse的常见API"></a>HttpServletResponse的常见API</h3><ul><li>设置响应行相关</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void setStatus(int  code);</td><td>设置响应状态码</td></tr></tbody></table><ul><li>设置响应头相关</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void setHeader(String headerName, String headerValue);</td><td>设置&#x2F;修改响应头键值对</td></tr><tr><td>void setContentType(String contentType);</td><td>设置content-type响应头及响应字符集(设置MIME类型)</td></tr></tbody></table><ul><li>设置响应体相关</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>PrintWriter getWriter() throws IOException;</td><td>获得向响应体放入信息的字符输出流</td></tr><tr><td>ServletOutputStream getOutputStream() throws IOException;</td><td>获得向响应体放入信息的字节输出流</td></tr><tr><td>void setContentLength(int length);</td><td>设置响应体的字节长度,其实就是在设置content-length响应头</td></tr></tbody></table><ul><li>其他API</li></ul><table><thead><tr><th>API</th><th>功能解释</th></tr></thead><tbody><tr><td>void sendError(int code, String message) throws IOException;</td><td>向客户端响应错误信息的方法,需要指定响应码和响应信息</td></tr><tr><td>void addCookie(Cookie cookie);</td><td>向响应体中增加cookie</td></tr><tr><td>void setCharacterEncoding(String encoding);</td><td>设置响应体字符集</td></tr></tbody></table><blockquote><p>MIME类型</p></blockquote><ul><li>MIME类型,可以理解为文档类型,用户表示传递的数据是属于什么类型的文档</li><li>浏览器可以根据MIME类型决定该用什么样的方式解析接收到的响应体数据</li><li>可以这样理解: 前后端交互数据时,告诉对方发给对方的是 html&#x2F;css&#x2F;js&#x2F;图片&#x2F;声音&#x2F;视频&#x2F;… …</li><li>tomcat&#x2F;conf&#x2F;web.xml中配置了常见文件的拓展名和MIMIE类型的对应关系</li><li>常见的MIME类型举例如下</li></ul><table><thead><tr><th>文件拓展名</th><th>MIME类型</th></tr></thead><tbody><tr><td>.html</td><td>text&#x2F;html</td></tr><tr><td>.css</td><td>text&#x2F;css</td></tr><tr><td>.js</td><td>application&#x2F;javascript</td></tr><tr><td>.png &#x2F;.jpeg&#x2F;.jpg&#x2F;… …</td><td>image&#x2F;jpeg</td></tr><tr><td>.mp3&#x2F;.mpe&#x2F;.mpeg&#x2F; … …</td><td>audio&#x2F;mpeg</td></tr><tr><td>.mp4</td><td>video&#x2F;mp4</td></tr><tr><td>.m1v&#x2F;.m1v&#x2F;.m2v&#x2F;.mpe&#x2F;… …</td><td>video&#x2F;mpeg</td></tr></tbody></table><h2 id="请求转发和响应重定向"><a href="#请求转发和响应重定向" class="headerlink" title="请求转发和响应重定向"></a>请求转发和响应重定向</h2><ul><li>请求转发和响应重定向是web应用中间接访问项目资源的两种手段,也是Servlet控制页面跳转的两种手段</li><li>请求转发通过HttpServletRequest实现,响应重定向通过HttpServletResponse实现</li></ul><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><ul><li>请求转发通过HttpServletRequest对象获取请求转发器实现</li><li>请求转发是服务器内部的行为,对客户端是屏蔽的</li><li>客户端只发送了一次请求,客户端地址栏不变</li><li>服务端只产生了一对请求和响应对象,这一对请求和响应对象会继续传递给下一个资源</li><li>因为全程只有一个HttpServletRequset对象,所以请求参数可以传递,请求域中的数据也可以传递</li><li>请求转发可以转发给其他Servlet动态资源,也可以转发给一些静态资源以实现页面跳转</li><li>请求转发可以转发给WEB-INF下受保护的资源</li><li>请求转发不能转发到本项目以外的外部资源</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul><li>ServletA</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//  获取请求转发器</span></span><br><span class="line">        <span class="comment">//  转发给servlet  ok</span></span><br><span class="line">        <span class="type">RequestDispatcher</span>  <span class="variable">requestDispatcher</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;servletB&quot;</span>);</span><br><span class="line">        <span class="comment">//  转发给一个视图资源 ok</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;welcome.html&quot;);</span></span><br><span class="line">        <span class="comment">//  转发给WEB-INF下的资源  ok</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;WEB-INF/views/view1.html&quot;);</span></span><br><span class="line">        <span class="comment">//  转发给外部资源   no</span></span><br><span class="line">        <span class="comment">//RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;http://www.atguigu.com&quot;);</span></span><br><span class="line">        <span class="comment">//  获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">//  向请求域中添加数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;reqKey&quot;</span>,<span class="string">&quot;requestMessage&quot;</span>);</span><br><span class="line">        <span class="comment">//  做出转发动作</span></span><br><span class="line">        requestDispatcher.forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ServletB</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">// 获取请求域中的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reqMessage</span> <span class="operator">=</span> (String)req.getAttribute(<span class="string">&quot;reqKey&quot;</span>);</span><br><span class="line">        System.out.println(reqMessage);</span><br><span class="line">        <span class="comment">// 做出响应</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;servletB response&quot;</span>);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应重定向"><a href="#响应重定向" class="headerlink" title="响应重定向"></a>响应重定向</h3><ul><li>响应重定向通过HttpServletResponse对象的sendRedirect方法实现</li><li>响应重定向是服务端通过302响应码和路径,告诉客户端自己去找其他资源,是在服务端提示下的,客户端的行为</li><li>客户端至少发送了两次请求,客户端地址栏是要变化的</li><li>服务端产生了多对请求和响应对象,且请求和响应对象不会传递给下一个资源</li><li>因为全程产生了多个HttpServletRequset对象,所以请求参数不可以传递,请求域中的数据也不可以传递</li><li>重定向可以是其他Servlet动态资源,也可以是一些静态资源以实现页面跳转</li><li>重定向不可以到给WEB-INF下受保护的资源</li><li>重定向可以到本项目以外的外部资源</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul><li>ServletA</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//  获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">//  向请求域中添加数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;reqKey&quot;</span>,<span class="string">&quot;requestMessage&quot;</span>);</span><br><span class="line">        <span class="comment">//  响应重定向</span></span><br><span class="line">        <span class="comment">// 重定向到servlet动态资源 OK</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;servletB&quot;</span>);</span><br><span class="line">        <span class="comment">// 重定向到视图静态资源 OK</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;welcome.html&quot;);</span></span><br><span class="line">        <span class="comment">// 重定向到WEB-INF下的资源 NO</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;WEB-INF/views/view1&quot;);</span></span><br><span class="line">        <span class="comment">// 重定向到外部资源</span></span><br><span class="line">        <span class="comment">//resp.sendRedirect(&quot;http://www.atguigu.com&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ServletB</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">// 获取请求域中的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reqMessage</span> <span class="operator">=</span> (String)req.getAttribute(<span class="string">&quot;reqKey&quot;</span>);</span><br><span class="line">        System.out.println(reqMessage);</span><br><span class="line">        <span class="comment">// 做出响应</span></span><br><span class="line">        resp.getWriter().write(<span class="string">&quot;servletB response&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u><strong>同样实现页面跳转，只要重定向能做到，就优先使用重定向！！！</strong></u></p><h2 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h2><blockquote><p> MVC（Model View Controller）是软件工程中的一种**<code>软件架构模式</code><strong>，它把软件系统分为</strong><code>模型</code><strong>、</strong><code>视图</code><strong>和</strong><code>控制器</code>**三个基本部分。用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p></blockquote><ul><li><p><strong>M</strong>：Model 模型层,具体功能如下</p><ol><li>存放和数据库对象的实体类以及一些用于存储非数据库表完整相关的VO对象</li><li>存放一些对数据进行逻辑运算操作的的一些业务处理代码</li></ol></li><li><p><strong>V</strong>：View 视图层,具体功能如下</p><ol><li>存放一些视图文件相关的代码 html css js等</li><li>在前后端分离的项目中,后端已经没有视图文件,该层次已经衍化成独立的前端项目</li></ol></li><li><p><strong>C</strong>：Controller 控制层,具体功能如下</p><ol><li>接收客户端请求,获得请求数据</li><li>将准备好的数据响应给客户端</li></ol></li></ul><blockquote><p>MVC模式下,项目中的常见包</p></blockquote><ul><li>M:<ol><li>实体类包(pojo &#x2F;entity &#x2F;bean) 专门存放和数据库对应的实体类和一些VO对象</li><li>数据库访问包(dao&#x2F;mapper)  专门存放对数据库不同表格CURD方法封装的一些类</li><li>服务包(service)                       专门存放对数据进行业务逻辑运算的一些类</li></ol></li><li>C: 控制层包(controller)</li><li>V:<ol><li>web目录下的视图资源 html css js img 等</li><li>前端工程化后,在后端项目中已经不存在了</li></ol></li></ul><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><h3 id="为什么需要会话管理"><a href="#为什么需要会话管理" class="headerlink" title="为什么需要会话管理"></a>为什么需要会话管理</h3><blockquote><p>HTTP是无状态协议</p></blockquote><ul><li>无状态就是不保存状态,即无状态协议(stateless),HTTP协议自身不对请求和响应之间的通信状态进行保存,也就是说,在HTTP协议这个级别,协议对于发送过的请求或者响应都不做持久化处理</li><li>简单理解:浏览器发送请求,服务器接收并响应,但是服务器不记录请求是否来自哪个浏览器,服务器没记录浏览器的特征,就是客户端的状态</li></ul><h3 id="会话管理实现的手段"><a href="#会话管理实现的手段" class="headerlink" title="会话管理实现的手段"></a>会话管理实现的手段</h3><blockquote><p>Cookie和Session配合解决</p></blockquote><ul><li>cookie是在客户端保留少量数据的技术,主要通过响应头向客户端响应一些客户端要保留的信息</li><li>session是在服务端保留更多数据的技术,主要通过HttpSession对象保存一些和客户端相关的信息</li><li>cookie和session配合记录请求状态</li></ul><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><blockquote><p>cookie是一种客户端会话技术,cookie由服务端产生,它是服务器存放在浏览器的一小份数据,浏览器以后每次访问该服务器的时候都会将这小份数据携带到服务器去。</p></blockquote><ul><li>服务端创建cookie,将cookie放入响应对象中,Tomcat容器将cookie转化为set-cookie响应头,响应给客户端</li><li>客户端在收到cookie的响应头时,在下次请求该服务的资源时,会以cookie请求头的形式携带之前收到的Cookie</li><li>cookie是一种键值对格式的数据,从tomcat8.5开始可以保存中文,但是不推荐</li><li>由于cookie是存储于客户端的数据,比较容易暴露,一般不存储一些敏感或者影响安全的数据</li></ul><h3 id="Cookie的使用"><a href="#Cookie的使用" class="headerlink" title="Cookie的使用"></a>Cookie的使用</h3><blockquote><p>servletA向响应中增加Cookie</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>servletB从请求中读取Cookie</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求中的cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">//迭代cookies数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != cookies &amp;&amp; cookies.length!= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                System.out.println(cookie.getName()+<span class="string">&quot;:&quot;</span>+cookie.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cookie时效性"><a href="#Cookie时效性" class="headerlink" title="Cookie时效性"></a>Cookie时效性</h3><blockquote><p>默认情况下Cookie的有效期是一次会话范围内，我们可以通过cookie的setMaxAge()方法让Cookie持久化保存到浏览器上</p></blockquote><ul><li>会话级Cookie<ul><li>服务器端并没有明确指定Cookie的存在时间</li><li>在浏览器端，Cookie数据存在于内存中</li><li>只要浏览器还开着，Cookie数据就一直都在</li><li>浏览器关闭，内存中的Cookie数据就会被释放</li></ul></li><li>持久化Cookie<ul><li>服务器端明确设置了Cookie的存在时间</li><li>在浏览器端，Cookie数据会被保存到硬盘上</li><li>Cookie在硬盘上存在的时间根据服务器端限定的时间来管控，不受浏览器关闭的影响</li><li>持久化Cookie到达了预设的时间会被释放</li></ul></li></ul><blockquote><p>cookie.setMaxAge(int expiry)参数单位是秒，表示cookie的持久化时间，如果设置参数为0，表示将浏览器中保存的该cookie删除</p></blockquote><ul><li>servletA设置一个Cookie为持久化cookie</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        cookie1.setMaxAge(<span class="number">60</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>servletB接收Cookie,浏览器中间发生一次重启再请求servletB测试</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//获取请求中的cookie</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">//迭代cookies数组</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != cookies &amp;&amp; cookies.length != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                System.out.println(cookie.getName()+<span class="string">&quot;:&quot;</span>+cookie.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cookie的提交路径"><a href="#Cookie的提交路径" class="headerlink" title="Cookie的提交路径"></a>Cookie的提交路径</h3><blockquote><p>访问互联网资源时不能每次都需要把所有Cookie带上。访问不同的资源时,可以携带不同的cookie,我们可以通过cookie的setPath(String path) 对cookie的路径进行设置</p></blockquote><ul><li>从ServletA中获取cookie</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 创建Cookie</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie1</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c1&quot;</span>,<span class="string">&quot;c1_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置cookie的提交路径，向ServletB请求时会携带c1，向其他资源请求时不携带c1</span></span><br><span class="line">        cookie1.setPath(<span class="string">&quot;/web03_war_exploded/servletB&quot;</span>);</span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie2</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;c2&quot;</span>,<span class="string">&quot;c2_message&quot;</span>);</span><br><span class="line">        <span class="comment">// 将cookie放入响应对象</span></span><br><span class="line">        resp.addCookie(cookie1);</span><br><span class="line">        resp.addCookie(cookie2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><blockquote><p> HttpSession是一种保留更多信息在服务端的一种技术,服务器会为每一个客户端开辟一块内存空间,即session对象. 客户端在发送请求时,都可以使用自己的session. 这样服务端就可以通过session来记录某个客户端的状态了</p></blockquote><ul><li>服务端在为客户端创建session时,会同时将session对象的id,即JSESSIONID以cookie的形式放入响应对象</li><li>后端创建完session后,客户端会收到一个特殊的cookie,叫做JSESSIONID</li><li>客户端下一次请求时携带JSESSIONID,后端收到后,根据JSESSIONID找到对应的session对象</li><li>通过该机制,服务端通过session就可以存储一些专门针对某个客户端的信息了</li><li>session也是域对象</li></ul><h3 id="HttpSession的使用"><a href="#HttpSession的使用" class="headerlink" title="HttpSession的使用"></a>HttpSession的使用</h3><blockquote><p>用户提交form表单到ServletA,携带用户名,ServletA获取session 将用户名存到Session,用户再请求其他任意Servlet,获取之间存储的用户</p></blockquote><ul><li>定义表单页,提交用户名,提交后</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;servletA&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    用户名:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>定义ServletA,将用户名存入session</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取请求中的参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">         <span class="comment">// 获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jSessionId</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(jSessionId);</span><br><span class="line">        <span class="comment">// 判断session是不是新创建的session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> session.isNew();</span><br><span class="line">        System.out.println(isNew);</span><br><span class="line">        <span class="comment">// 向session对象中存入数据</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;username&quot;</span>,username);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义其他Servlet,从session中读取用户名</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 获取session对象</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">         <span class="comment">// 获取Session的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jSessionId</span> <span class="operator">=</span> session.getId();</span><br><span class="line">        System.out.println(jSessionId);</span><br><span class="line">        <span class="comment">// 判断session是不是新创建的session</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNew</span> <span class="operator">=</span> session.isNew();</span><br><span class="line">        System.out.println(isNew);</span><br><span class="line">        <span class="comment">// 从session中取出数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String)session.getAttribute(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>getSession方法的处理逻辑</p></blockquote><p><img src="/inori/72bd32c0/JavaWeb_getSession.png" alt="JavaWeb_getSession"></p><h3 id="HttpSession时效性"><a href="#HttpSession时效性" class="headerlink" title="HttpSession时效性"></a>HttpSession时效性</h3><blockquote><p>为什么要设置session的时效</p></blockquote><ul><li>用户量很大之后，Session对象相应的也要创建很多。如果一味创建不释放，那么服务器端的内存迟早要被耗尽。</li><li>客户端关闭行为无法被服务端直接侦测,或者客户端较长时间不操作也经常出现,类似这些的情况,就需要对session的时限进行设置了</li><li>默认的session最大闲置时间(两次使用同一个session中的间隔时间) 在tomcat&#x2F;conf&#x2F;web.xml配置为30分钟</li></ul><blockquote><p>可以通过HttpSession的API对最大闲置时间进行设定</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置最大闲置时间</span></span><br><span class="line">session.setMaxInactiveInterval(<span class="number">60</span>);</span><br></pre></td></tr></table></figure><blockquote><p>可以直接让session失效</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接让session失效</span></span><br><span class="line">session.invalidate();</span><br></pre></td></tr></table></figure><h2 id="三大域对象"><a href="#三大域对象" class="headerlink" title="三大域对象"></a>三大域对象</h2><blockquote><p>域对象: 一些用于存储数据和传递数据的对象,传递数据不同的范围,我们称之为不同的域,不同的域对象代表不同的域,共享数据的范围也不同</p></blockquote><ul><li>web项目中,我们一定要熟练使用的域对象分别是:<u>请求域,会话域,应用域</u></li><li>请求域对象是HttpServletRequest,传递数据的范围是一次请求之内及请求转发</li><li>会话域对象是HttpSession,传递数据的范围是一次会话之内,可以跨多个请求</li><li>应用域对象是ServletContext,传递数据的范围是本应用之内,可以跨多个会话</li></ul><blockquote><p>三大域对象的数据作用范围</p></blockquote><img src="/inori/72bd32c0/JavaWeb_domainType.png" alt="1682488186891" style="zoom:60%;"><h3 id="域对象常用API"><a href="#域对象常用API" class="headerlink" title="域对象常用API"></a>域对象常用API</h3><table><thead><tr><th>API</th><th>功能</th></tr></thead><tbody><tr><td>void setAttribute(String name,String value)</td><td>向域对象中添加&#x2F;修改数据</td></tr><tr><td>Object getAttribute(String name);</td><td>从域对象中获取数据</td></tr><tr><td>removeAttribute(String name);</td><td>移除域对象中的数据</td></tr></tbody></table><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ul><li>ServletA向三大域中放入数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletA&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 向请求域中放入数据</span></span><br><span class="line">        req.setAttribute(<span class="string">&quot;request&quot;</span>,<span class="string">&quot;request-message&quot;</span>);</span><br><span class="line">        <span class="comment">//req.getRequestDispatcher(&quot;servletB&quot;).forward(req,resp);</span></span><br><span class="line">        <span class="comment">// 向会话域中放入数据</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        session.setAttribute(<span class="string">&quot;session&quot;</span>,<span class="string">&quot;session-message&quot;</span>);</span><br><span class="line">        <span class="comment">// 向应用域中放入数据</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        application.setAttribute(<span class="string">&quot;application&quot;</span>,<span class="string">&quot;application-message&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>ServletB从三大于中取出数据</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servletB&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 从请求域中获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">reqMessage</span> <span class="operator">=</span>(String)req.getAttribute(<span class="string">&quot;request&quot;</span>);</span><br><span class="line">        System.out.println(reqMessage);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从会话域中获取数据</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sessionMessage</span> <span class="operator">=</span>(String)session.getAttribute(<span class="string">&quot;session&quot;</span>);</span><br><span class="line">        System.out.println(sessionMessage);</span><br><span class="line">        <span class="comment">// 从应用域中获取数据</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">applicationMessage</span> <span class="operator">=</span>(String)application.getAttribute(<span class="string">&quot;application&quot;</span>);</span><br><span class="line">        System.out.println(applicationMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>请求转发时,请求域可以传递数据<code>请求域内一般放本次请求业务有关的数据,如:查询到的所有的部门信息</code></li><li>同一个会话内,不用请求转发,会话域可以传递数据<code>会话域内一般放本次会话的客户端有关的数据,如:当前客户端登录的用户</code> </li><li>同一个APP内,不同的客户端,应用域可以传递数据<code>应用域内一般放本程序应用有关的数据 如:Spring框架的IOC容器</code></li></ul><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><blockquote><p>Filter,即过滤器,是JAVAEE技术规范之一,作用目标资源的请求进行过滤的一套技术规范,是Java Web项目中<code>最为实用的技术之一</code></p></blockquote><ul><li>Filter接口定义了过滤器的开发规范,所有的过滤器都要实现该接口</li><li>Filter的工作位置是项目中所有目标资源之前,容器在创建HttpServletRequest和HttpServletResponse对象后,会先调用Filter的doFilter方法</li><li>Filter的doFilter方法可以控制请求是否继续,如果放行,则请求继续,如果拒绝,则请求到此为止,由过滤器本身做出响应</li><li>Filter不仅可以对请求做出过滤,也可以在目标资源做出响应前,对响应再次进行处理</li><li>Filter是GOF中责任链模式的典型案例</li><li>Filter的常用应用包括但不限于: 登录权限检查,解决网站乱码,过滤敏感字符,日志记录,性能分析… …</li></ul><blockquote><p>过滤器开发中应用的场景</p></blockquote><ul><li>日志的记录</li><li>性能的分析</li><li>乱码的处理</li><li>事务的控制</li><li>登录的控制</li><li>跨域的处理</li></ul><blockquote><p>过滤器工作位置图解</p></blockquote><p><img src="/inori/72bd32c0/JavaWeb%E6%8A%80%E6%9C%AF%5CJavaWeb_Filter.png" alt="1682494494396"></p><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><table><thead><tr><th>API</th><th>目标</th></tr></thead><tbody><tr><td>default public void init(FilterConfig filterConfig)</td><td>初始化方法,由容器调用并传入初始配置信息filterConfig对象</td></tr><tr><td>public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</td><td>过滤方法,核心方法,过滤请求,决定是否放行,响应之前的其他处理等都在该方法中</td></tr><tr><td>default public void destroy()</td><td>销毁方法,容器在回收过滤器对象之前调用的方法</td></tr></tbody></table><h3 id="Filter使用实例"><a href="#Filter使用实例" class="headerlink" title="Filter使用实例"></a>Filter使用实例</h3><blockquote><p>目标:开发一个日志记录过滤器</p></blockquote><ul><li>用户请求到达目标资源之前,记录用户的请求资源路径</li><li>响应之前记录本次请求目标资源运算的耗时</li><li>可以选择将日志记录进入文件,为了方便测试,这里将日志直接在控制台打印</li></ul><blockquote><p> 定义一个过滤器类,编写功能代码</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span>  <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">SimpleDateFormat</span> <span class="variable">dateFormat</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 参数父转子</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span>(HttpServletRequest)  servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span>  <span class="variable">response</span> <span class="operator">=</span>(HttpServletResponse)  servletResponse;</span><br><span class="line">        <span class="comment">// 拼接日志文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">beforeLogging</span> <span class="operator">=</span>requestURI+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;被请求了&quot;</span>;</span><br><span class="line">        System.out.println(beforeLogging);</span><br><span class="line">        <span class="comment">// 放行请求</span></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">        System.out.println(afterLogging);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>说明<ul><li>doFilter方法中的请求和响应对象是以父接口的形式声明的,实际传入的实参就是HttpServletRequest和HttpServletResponse子接口级别的,可以安全强转</li><li>filterChain.doFilter(request,response); 这行代码的功能是放行请求,如果没有这一行代码,则请求到此为止</li><li>filterChain.doFilter(request,response);在放行时需要传入request和response,意味着请求和响应对象要继续传递给后续的资源,这里没有产生新的request和response对象</li></ul></li></ul><blockquote><p>定义两个Servlet作为目标资源</p></blockquote><ul><li>ServletA</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 处理器请求</span></span><br><span class="line">        System.out.println(<span class="string">&quot;servletA处理请求的方法,耗时10毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟处理请求耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ServletB</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 处理器请求</span></span><br><span class="line">        System.out.println(<span class="string">&quot;servletB处理请求的方法,耗时15毫秒&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟处理请求耗时</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">15</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>配置过滤器以及过滤器的过滤范围</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;5.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置filter,并为filter起别名--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.LoggingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为别名对应的filter配置要过滤的目标资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过映射路径确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletA<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过后缀名确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通过servlet别名确定过滤资源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletBName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>说明</p><ul><li>filter-mapping标签中定义了过滤器对那些资源进行过滤</li><li>子标签url-pattern通过映射路径确定过滤范围<ul><li>&#x2F;servletA  精确匹配,表示对servletA资源的请求进行过滤</li><li>*.html 表示对以.action结尾的路径进行过滤</li><li>&#x2F;* 表示对所有资源进行过滤</li><li>一个filter-mapping下可以配置多个url-pattern</li></ul></li><li>子标签servlet-name通过servlet别名确定对那些servlet进行过滤<ul><li>使用该标签确定目标资源的前提是servlet已经起了别名</li><li>一个filter-mapping下可以定义多个servlet-name</li><li>一个filter-mapping下,servlet-name和url-pattern子标签可以同时存在</li></ul></li></ul></li></ul><h3 id="Filter生命周期"><a href="#Filter生命周期" class="headerlink" title="Filter生命周期"></a>Filter生命周期</h3><blockquote><p>过滤器作为web项目的组件之一,和Servlet的生命周期类似,略有不同,没有servlet的load-on-startup的配置,默认就是系统启动立刻构造</p></blockquote><table><thead><tr><th>阶段</th><th>对应方法</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>创建对象</td><td>构造器</td><td>web应用启动时</td><td>1</td></tr><tr><td>初始化方法</td><td>void init(FilterConfig filterConfig)</td><td>构造完毕</td><td>1</td></tr><tr><td>过滤请求</td><td>void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</td><td>每次请求</td><td>多次</td></tr><tr><td>销毁</td><td>default void destroy()</td><td>web应用关闭时</td><td>1次</td></tr></tbody></table><h3 id="Filter链"><a href="#Filter链" class="headerlink" title="Filter链"></a>Filter链</h3><blockquote><p>一个web项目中,可以同时定义多个过滤器,多个过滤器对同一个资源进行过滤时,工作位置有先后,整体形成一个工作链,称之为过滤器链</p></blockquote><ul><li>过滤器链中的过滤器的顺序由filter-mapping顺序决定</li><li>每个过滤器过滤的范围不同,针对同一个资源来说,过滤器链中的过滤器个数可能是不同的</li><li>如果某个Filter是使用ServletName进行匹配规则的配置，那么这个Filter执行的优先级要更低</li></ul><h4 id="注解方式配置过滤器-WebFilter"><a href="#注解方式配置过滤器-WebFilter" class="headerlink" title="注解方式配置过滤器@WebFilter"></a>注解方式配置过滤器@WebFilter</h4><ul><li>一个比较完整的Filter的XML配置</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置filter,并为filter起别名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filters.LoggingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置filter的初始参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>dateTimePattern<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>yyyy-MM-dd HH:mm:ss<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--为别名对应的filter配置要过滤的目标资源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loggingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过映射路径确定过滤资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/servletA<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过后缀名确定过滤资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--通过servlet别名确定过滤资源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>servletBName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>将xml配置转换成注解方式实现</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter(</span></span><br><span class="line"><span class="meta">        filterName = &quot;loggingFilter&quot;,</span></span><br><span class="line"><span class="meta">        initParams = &#123;@WebInitParam(name=&quot;dateTimePattern&quot;,value=&quot;yyyy-MM-dd HH:mm:ss&quot;)&#125;,</span></span><br><span class="line"><span class="meta">        urlPatterns = &#123;&quot;/servletA&quot;,&quot;*.html&quot;&#125;,</span></span><br><span class="line"><span class="meta">        servletNames = &#123;&quot;servletBName&quot;&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingFilter</span>  <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SimpleDateFormat dateFormat ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*init初始化方法,通过filterConfig获取初始化参数</span></span><br><span class="line"><span class="comment">    * init方法中,可以用于定义一些其他初始化功能代码</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 获取初始参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dateTimePattern</span> <span class="operator">=</span> filterConfig.getInitParameter(<span class="string">&quot;dateTimePattern&quot;</span>);</span><br><span class="line">        <span class="comment">// 初始化成员变量</span></span><br><span class="line">        dateFormat=<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(dateTimePattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 参数父转子</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span>(HttpServletRequest)  servletRequest;</span><br><span class="line">        <span class="type">HttpServletResponse</span>  <span class="variable">response</span> <span class="operator">=</span>(HttpServletResponse)  servletResponse;</span><br><span class="line">        <span class="comment">// 拼接日志文本</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="type">String</span> <span class="variable">time</span> <span class="operator">=</span> dateFormat.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="type">String</span> <span class="variable">beforeLogging</span> <span class="operator">=</span>requestURI+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;被请求了&quot;</span>;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        System.out.println(beforeLogging);</span><br><span class="line">        <span class="comment">// 获取系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 放行请求</span></span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">        <span class="comment">// 获取系统时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">t2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">afterLogging</span> <span class="operator">=</span>requestURI+<span class="string">&quot;在&quot;</span>+time+<span class="string">&quot;的请求耗时:&quot;</span>+(t2-t1)+<span class="string">&quot;毫秒&quot;</span>;</span><br><span class="line">        <span class="comment">// 打印日志</span></span><br><span class="line">        System.out.println(afterLogging);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><blockquote><p>监听器：专门用于对域对象对象身上发生的事件或状态改变进行监听和相应处理的对象</p></blockquote><ul><li><p>监听器是GOF设计模式中,观察者模式的典型案例</p></li><li><p>观察者模式: 当被观察的对象发生某些改变时, 观察者自动采取对应的行动的一种设计模式</p></li><li><p>监听器使用的感受类似JS中的事件,被观察的对象发生某些情况时,自动触发代码的执行</p></li><li><p>监听器并不监听web项目中的所有组件,仅仅是对三大域对象做相关的事件监听</p></li></ul><blockquote><p>监听器的分类</p></blockquote><ul><li><p>web中定义八个监听器接口作为监听器的规范,这八个接口按照不同的标准可以形成不同的分类</p></li><li><p>按监听的对象划分</p><ul><li>application域监听器 ServletContextListener  ServletContextAttributeListener </li><li>session域监听器 HttpSessionListener  HttpSessionAttributeListener  HttpSessionBindingListener  HttpSessionActivationListener  </li><li>request域监听器 ServletRequestListener  ServletRequestAttributeListener</li></ul></li><li><p>按监听的事件分</p><ul><li>域对象的创建和销毁监听器 ServletContextListener   HttpSessionListener   ServletRequestListener  </li><li>域对象数据增删改事件监听器 ServletContextAttributeListener  HttpSessionAttributeListener   ServletRequestAttributeListener </li><li>其他监听器  HttpSessionBindingListener  HttpSessionActivationListener</li></ul></li></ul><h3 id="application域监听器"><a href="#application域监听器" class="headerlink" title="application域监听器"></a>application域监听器</h3><blockquote><p>ServletContextListener  监听ServletContext对象的创建与销毁</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>contextInitialized(ServletContextEvent sce)</td><td>ServletContext创建时调用</td></tr><tr><td>contextDestroyed(ServletContextEvent sce)</td><td>ServletContext销毁时调用</td></tr></tbody></table><ul><li>ServletContextEvent对象代表从ServletContext对象身上捕获到的事件，通过这个事件对象我们可以获取到ServletContext对象。</li></ul><blockquote><p>ServletContextAttributeListener 监听ServletContext中属性的添加、移除和修改</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(ServletContextAttributeEvent scab)</td><td>向ServletContext中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletContextAttributeEvent scab)</td><td>从ServletContext中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletContextAttributeEvent scab)</td><td>当ServletContext中的属性被修改时调用</td></tr></tbody></table><ul><li>ServletContextAttributeEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletContext()</td><td>获取ServletContext对象</td></tr></tbody></table><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><ul><li>定义监听器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span> , ServletContextAttributeListener &#123;</span><br><span class="line">    <span class="comment">// 监听初始化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        System.out.println(<span class="string">&quot;application&quot;</span>+application.hashCode()+<span class="string">&quot; initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听销毁</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> sce.getServletContext();</span><br><span class="line">        System.out.println(<span class="string">&quot;application&quot;</span>+application.hashCode()+<span class="string">&quot; destroyed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听数据增加</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeAdded</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scae.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> scae.getValue();</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        System.out.println(<span class="string">&quot;application&quot;</span>+application.hashCode()+<span class="string">&quot; add:&quot;</span>+name+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听数据移除</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeRemoved</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scae.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> scae.getValue();</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        System.out.println(<span class="string">&quot;application&quot;</span>+application.hashCode()+<span class="string">&quot; remove:&quot;</span>+name+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听数据修改</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attributeReplaced</span><span class="params">(ServletContextAttributeEvent scae)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scae.getName();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> scae.getValue();</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> scae.getServletContext();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">newValue</span> <span class="operator">=</span> application.getAttribute(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;application&quot;</span>+application.hashCode()+<span class="string">&quot; change:&quot;</span>+name+<span class="string">&quot;=&quot;</span>+value+<span class="string">&quot; to &quot;</span>+newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义触发监听器的代码</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ServletA用于向application域中放入数据</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/servletA&quot;,name = &quot;servletAName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 向application域中放入数据</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        application.setAttribute(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>);</span><br><span class="line">        application.setAttribute(<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;v2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ServletB用于向application域中修改和移除数据</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/servletB&quot;, name = &quot;servletBName&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">appliation</span>  <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="comment">//  修改application域中的数据</span></span><br><span class="line">        appliation.setAttribute(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        <span class="comment">//  删除application域中的数据</span></span><br><span class="line">        appliation.removeAttribute(<span class="string">&quot;k2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="session域监听器"><a href="#session域监听器" class="headerlink" title="session域监听器"></a>session域监听器</h3><blockquote><p>HttpSessionListener  监听HttpSession对象的创建与销毁</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>sessionCreated(HttpSessionEvent hse)</td><td>HttpSession对象创建时调用</td></tr><tr><td>sessionDestroyed(HttpSessionEvent hse)</td><td>HttpSession对象销毁时调用</td></tr></tbody></table><ul><li>HttpSessionEvent对象代表从HttpSession对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpSession对象。</li></ul><blockquote><p>HttpSessionAttributeListener 监听HttpSession中属性的添加、移除和修改</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(HttpSessionBindingEvent se)</td><td>向HttpSession中添加属性时调用</td></tr><tr><td>attributeRemoved(HttpSessionBindingEvent se)</td><td>从HttpSession中移除属性时调用</td></tr><tr><td>attributeReplaced(HttpSessionBindingEvent se)</td><td>当HttpSession中的属性被修改时调用</td></tr></tbody></table><ul><li>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getSession()</td><td>获取触发事件的HttpSession对象</td></tr></tbody></table><h3 id="request域监听器"><a href="#request域监听器" class="headerlink" title="request域监听器"></a>request域监听器</h3><blockquote><p>ServletRequestListener 监听ServletRequest对象的创建与销毁</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>requestInitialized(ServletRequestEvent sre)</td><td>ServletRequest对象创建时调用</td></tr><tr><td>requestDestroyed(ServletRequestEvent sre)</td><td>ServletRequest对象销毁时调用</td></tr></tbody></table><ul><li>ServletRequestEvent对象代表从HttpServletRequest对象身上捕获到的事件，通过这个事件对象我们可以获取到触发事件的HttpServletRequest对象。另外还有一个方法可以获取到当前Web应用的ServletContext对象。</li></ul><blockquote><p>ServletRequestAttributeListener 监听ServletRequest中属性的添加、移除和修改</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>attributeAdded(ServletRequestAttributeEvent srae)</td><td>向ServletRequest中添加属性时调用</td></tr><tr><td>attributeRemoved(ServletRequestAttributeEvent srae)</td><td>从ServletRequest中移除属性时调用</td></tr><tr><td>attributeReplaced(ServletRequestAttributeEvent srae)</td><td>当ServletRequest中的属性被修改时调用</td></tr></tbody></table><ul><li>ServletRequestAttributeEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取修改或添加的属性名</td></tr><tr><td>getValue()</td><td>获取被修改或添加的属性值</td></tr><tr><td>getServletRequest ()</td><td>获取触发事件的ServletRequest对象</td></tr></tbody></table><h3 id="sessionBinding监听器"><a href="#sessionBinding监听器" class="headerlink" title="sessionBinding监听器"></a>sessionBinding监听器</h3><blockquote><p>HttpSessionBindingListener 监听当前监听器对象在Session域中的增加与移除</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>valueBound(HttpSessionBindingEvent event)</td><td>该类的实例被放到Session域中时调用</td></tr><tr><td>valueUnbound(HttpSessionBindingEvent event)</td><td>该类的实例从Session中移除时调用</td></tr></tbody></table><ul><li>HttpSessionBindingEvent对象代表属性变化事件，它包含的方法如下：</li></ul><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>getName()</td><td>获取当前事件涉及的属性名</td></tr><tr><td>getValue()</td><td>获取当前事件涉及的属性值</td></tr><tr><td>getSession()</td><td>获取触发事件的HttpSession对象</td></tr></tbody></table><h3 id="钝化活化监听器"><a href="#钝化活化监听器" class="headerlink" title="钝化活化监听器"></a>钝化活化监听器</h3><blockquote><p>HttpSessionActivationListener  监听某个对象在Session中的序列化与反序列化。</p></blockquote><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>sessionWillPassivate(HttpSessionEvent se)</td><td>该类实例和Session一起钝化到硬盘时调用</td></tr><tr><td>sessionDidActivate(HttpSessionEvent se)</td><td>该类实例和Session一起活化到内存时调用</td></tr></tbody></table><ul><li>HttpSessionEvent对象代表事件对象，通过getSession()方法获取事件涉及的HttpSession对象。</li></ul><blockquote><p>什么是钝化活化</p></blockquote><ul><li>session对象在服务端是以对象的形式存储于内存的,session过多,服务器的内存也是吃不消的</li><li>而且一旦服务器发生重启,所有的session对象都将被清除,也就意味着session中存储的不同客户端的登录状态丢失</li><li>为了分摊内存 压力并且为了保证session重启不丢失,我们可以设置将session进行钝化处理</li><li>在关闭服务器前或者到达了设定时间时,对session进行序列化到磁盘,这种情况叫做session的钝化</li><li>在服务器启动后或者再次获取某个session时,将磁盘上的session进行反序列化到内存,这种情况叫做session的活化</li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ul><li><p>AJAX &#x3D; Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。</p></li><li><p>AJAX 不是新的编程语言，而是一种使用现有标准的新方法。</p></li><li><p>AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p></li><li><p>AJAX 不需要任何浏览器插件，但需要用户允许 JavaScript 在浏览器上执行。</p></li><li><p>XMLHttpRequest 只是实现 Ajax 的一种方式。</p></li></ul><h3 id="ajax工作原理"><a href="#ajax工作原理" class="headerlink" title="ajax工作原理"></a>ajax工作原理</h3><p><img src="/inori/72bd32c0/JavaWeb_ajax.png"></p><ul><li>简单来说,我们之前发的请求通过类似  form表单标签,a标签 这种方式,现在通过 运行js代码动态决定什么时候发送什么样的请求</li><li>通过运行JS代码发送的请求浏览器可以不用跳转页面 ,我们可以在JS代码中决定是否要跳转页面</li><li>通过运行JS代码发送的请求,接收到返回结果后,我们可以将结果通过dom编程渲染到页面的某些元素上,实现局部更新</li></ul><h3 id="原生js方式实现ajax"><a href="#原生js方式实现ajax" class="headerlink" title="原生js方式实现ajax"></a>原生js方式实现ajax</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">loadXMLDoc</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> xmlhttp=<span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 设置回调函数处理响应结果</span></span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="property">onreadystatechange</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (xmlhttp.<span class="property">readyState</span>==<span class="number">4</span> &amp;&amp; xmlhttp.<span class="property">status</span>==<span class="number">200</span>)</span></span><br><span class="line"><span class="language-javascript">      &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myDiv&quot;</span>).<span class="property">innerHTML</span>=xmlhttp.<span class="property">responseText</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 设置请求方式和请求的资源路径</span></span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;/try/ajax/ajax_info.txt&quot;</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 发送请求</span></span></span><br><span class="line"><span class="language-javascript">    xmlhttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> javaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java命名规范</title>
      <link href="/inori/1761bce2.html"/>
      <url>/inori/1761bce2.html</url>
      
        <content type="html"><![CDATA[<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol><li>由字母、下划线、美元符号和数字组成，长度不限</li><li>首字符不能是数字</li><li>不能是关键字</li><li>不能是true、false和null，尽管这三个不是关键字</li><li>区分大小写</li></ol><h2 id="变量名（驼峰命名法）"><a href="#变量名（驼峰命名法）" class="headerlink" title="变量名（驼峰命名法）"></a>变量名（驼峰命名法）</h2><p>​    变量的名字可大小写混用，但首字符应小写。词由大写字母分隔，限制用下划线，限制使用美元符（$），因为这个字符对内部类有特殊的含义。</p><p>​    如：inputTextSize。</p><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p>​    包的名字应该都是由一个小写单词组成。</p><p>​    如：net.test.modules。</p><h2 id="类名和接口名"><a href="#类名和接口名" class="headerlink" title="类名和接口名"></a>类名和接口名</h2><p>​    类名每个单词的首字母都要大写，通常由多个单词合成一个类名。</p><p>​    如：DataFile、InfoParser。</p><h2 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h2><p>​    常量命名则前面应该是static final，后面变量的名字全部大写。</p><p>​    如：static final MAX &#x3D; 1024。</p><h2 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h2><p>​    方法名的第一个单词应该是动词，但首字母小写，后面每个单词的首字母大写。大写字母将词分隔并限制使用下划线。方法如果有传入参数，参数的名字必须和变量的命名规范一致。使用有意义的参数命名，如果可能的话，使用和要赋值的字段一样的名字。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC和连接池</title>
      <link href="/inori/78c36787.html"/>
      <url>/inori/78c36787.html</url>
      
        <content type="html"><![CDATA[<p>​JDBC是为访问不同数据库提供的统一接口，为使用者屏蔽了细节问题。可以利用JDBC连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。</p><h2 id="数据库连接方式"><a href="#数据库连接方式" class="headerlink" title="数据库连接方式"></a>数据库连接方式</h2><p>连接数据库主要有2种方式</p><ol><li>使用Class.forName自动完成注册驱动，直接连接数据库：</li></ol><blockquote><p>Class.forName(“com.mysql.cj.jdbc.Driver”);</p><p>Connection connection &#x3D; DriverManager.getConnection(url, user, password);&#x2F;&#x2F;其中的参数最好在使用时从文件中提取出来，方便修改</p></blockquote><ol start="2"><li>jdk1.5以后使用了jdbc4，不再需要显示调用Class.forName注册驱动，可以直接使用语句<code>Connection connection = DriverManager.getConnection(url, info);</code>连接数据库</li></ol><h2 id="在Java中输入SQL语句"><a href="#在Java中输入SQL语句" class="headerlink" title="在Java中输入SQL语句"></a>在Java中输入SQL语句</h2><p>在连接建立后，如果需要对数据库进行访问，执行命名或者SQL语句，可以通过Statement、<u>PreparedStatement</u>、CallableStatement，在开发中不会使用Statement，因为其存在SQL注入问题，一般使用PerparedStatement：</p><ul><li>PreparedStatement：执行的SQL语句中的参数用问号(?)来表示，调用相应的set方法来设置对应的参数。set方法有两个参数，第一个参数要设置SQL语句中的?的参数索引（从1开始），第二个是设置SQL语句中参数的值</li></ul><p>在使用DML语句时，直接使用String即可，在使用DQL语句时需要借助ResultSet获取结果：</p><ul><li>ResultSet：保持一个光标指向其当前的数据行。最初光标位于第一行之前。next方法可以将光标移动到下一行，并且在ResultSet对象中没有更多行时返回false，所以可以用while循环遍历结果集。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>使用localhost的test数据库，登录root用户完成对emp表的增删改查。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">// 从Properties文件中获取数据</span></span><br><span class="line">        info.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;driver&quot;</span>);     <span class="comment">// com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;url&quot;</span>);           <span class="comment">// jdbc:mysql://localhost/test</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        <span class="type">String</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="string">&quot;insert into emp values(null, &#x27;小明&#x27;, 18)&quot;</span>;<span class="comment">// 增</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">update</span> <span class="operator">=</span> <span class="string">&quot;update emp set name=&#x27;小红&#x27; where id = 1&quot;</span>;<span class="comment">// 改</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">select</span> <span class="operator">=</span> <span class="string">&quot;select id from emp where name=?&quot;</span>;<span class="comment">// 查</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">drop</span> <span class="operator">=</span> <span class="string">&quot;delete from emp where id = 1&quot;</span>;<span class="comment">// 删</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);<span class="comment">// 连接数据库</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(select);</span><br><span class="line">        preparedStatement.executeUpdate(insert);</span><br><span class="line">        preparedStatement.executeUpdate(update);</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>);<span class="comment">// 设置第一个问号处填写的值</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();<span class="comment">// 使用ResultSet获取select的返回结果</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">        preparedStatement.executeUpdate(drop);</span><br><span class="line">        preparedStatement.close();<span class="comment">// 关闭连接</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDBC处理事务"><a href="#JDBC处理事务" class="headerlink" title="JDBC处理事务"></a>JDBC处理事务</h3><p>使用<code>Connection connection = DriverManager.getConnection(url, user, password);</code>得到数据库连接之后，可以<code>connection.setAutoCommit(false)</code>设置事务不自动提交，然后在正常结束的逻辑后面使用<code>connection.commit()</code>提交事务，如果发生了异常，使用<code>connection.rollback()</code>回滚事务</p><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。使用批处理功能时需要在url后面加入参数<code>?rewriteBatchedStatements=true</code>。批处理往往和PreparedStatement一起使用。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>addBatch():添加需要批量处理的SQL语句或参数</p></li><li><p>executeBatch():执行批量处理语句</p></li><li><p>clearBatch():清空批处理的语句</p></li></ul><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><h3 id="传统连接的问题"><a href="#传统连接的问题" class="headerlink" title="传统连接的问题"></a>传统连接的问题</h3><ul><li>传统的JDBC数据库连接使用DriverManager获取，每次向数据库建立连接时都要将Connection加载到内存中，再验证IP地址，用户名和密码。频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃</li><li>每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致数据库重启</li><li>传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，数据库崩溃。</li><li>解决传统开发中的数据库连接问题,可以采用数据库连接池技术</li></ul><h3 id="连接池原理"><a href="#连接池原理" class="headerlink" title="连接池原理"></a>连接池原理</h3><ol><li>预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从中取出一个，使用完毕之后再放回去</li><li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</li><li>当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中</li></ol><h3 id="连接池种类"><a href="#连接池种类" class="headerlink" title="连接池种类"></a>连接池种类</h3><ol><li>JDBC的数据库连接池使用javax.sql.DataSource表示，DataSource是一个接口，通常由第三方提供实现</li><li><u>C3P0</u>连接池，速度相对较慢，稳定性强(hibernate, spring底层使用该连接池)</li><li>DBCP连接池，速度较快，不稳定</li><li>Proxool数据库连接池，可以监控连接池状态，稳定性较差</li><li>BoneCP数据库连接池，速度快</li><li><u>Druid</u>(德鲁伊)是阿里提供的连接池，集DBCP、C3PO、Proxool优点于一身的数据库连接池</li></ol><h3 id="C3P0连接池"><a href="#C3P0连接池" class="headerlink" title="C3P0连接池"></a>C3P0连接池</h3><p>要使用C3P0连接池，首先要导入C3P0的jar包，并且把jar包当做library加入到项目中</p><p>使用时：</p><ol><li>实例化<code>ComboPooledDataSource</code>数据源对象</li><li>通过配置文件获取数据库相关信息</li><li>通过方法给数据源设置相关参数<code>setDriverClass</code>、<code>setJdbcUrl</code>、<code>setUser</code>、<code>setPassword</code></li><li>设置初始化连接数（连接池中一开始的连接数量）和最大连接数（最多能有多少连接）：<code>setInitialPoolSize(n)</code>、<code>setMaxPoolSize(n)</code></li><li>拿到连接：<code>Connection connection = comboPooledDataSource.getConnection()</code></li></ol><h3 id="Druid连接池"><a href="#Druid连接池" class="headerlink" title="Druid连接池"></a>Druid连接池</h3><ol><li>首先配置Properties文件，在文件中写明driver、url、user、password、initialSize、minIdle、maxActive、maxWait参数</li><li>创建指定参数的数据库连接池<code>DataSource ds = DruidDataSourceFactory.createDataSource(properties)</code></li><li>拿到连接：<code>Connection connection = ds.getConnection()</code></li></ol><h2 id="ApDBUtils"><a href="#ApDBUtils" class="headerlink" title="ApDBUtils"></a>ApDBUtils</h2><p>commons-dbutils是一个JDBC工具类库，可以极大简化jdbc编码的工作量。</p><h3 id="DbUtils类"><a href="#DbUtils类" class="headerlink" title="DbUtils类"></a>DbUtils类</h3><ul><li>QueryRunner类：封装了SQL的执行，可以实现增删改查和批处理操作，线程安全</li><li>ResultSetHandler：用于出来ResultSet，按照数据要求转换成另一种形式<ul><li>BeanHandler:将结果集中的第一行数据封装到一个对应的JavaBean实例中</li><li>BeanListHandler:将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里</li><li>ScalarHandler:查询单行单列信息时，将该信息包装成一个Object对象返回</li><li>update:执行增删改操作，返回受影响的行数</li></ul></li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>首先导入commons-dbutils.jar包，然后才能使用其提供的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        data.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));<span class="comment">// 从文件中读取driver、url、user、password</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(data);<span class="comment">// 创建德鲁伊数据源对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ds.getConnection();·<span class="comment">// 获取连接</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">select</span> <span class="operator">=</span> <span class="string">&quot;select * from emp where id &gt;= ?&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">update</span> <span class="operator">=</span> <span class="string">&quot;update emp set name = ? where id = ?&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="string">&quot;insert into emp values(null, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">update</span> <span class="operator">=</span> <span class="string">&quot;delete from emp where id = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// query执行sql语句，得到resultset并封装到ArrayList中，需要传入connection、sql语句、BeanListHandler对象, 最后的数字是给?赋值，可以有多个</span></span><br><span class="line">        List&lt;Actor&gt; list = queryRunner.query(connection, select, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(Actor.class), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 执行DML语句使用update方法，传入连接，sql和需要赋值的?</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> queryRunner.update(connection, update, <span class="string">&quot;小明&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        rows = queryRunner.update(connection, insert, <span class="string">&quot;小白&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        rows = queryRunner.update(connection, drop, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(Actor a: list)&#123;</span><br><span class="line">            System.out.println(a.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();<span class="comment">// 只需要关闭connection，resultset和perparedStatement由queryRunner自动关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL进阶篇</title>
      <link href="/inori/f4c950eb.html"/>
      <url>/inori/f4c950eb.html</url>
      
        <content type="html"><![CDATA[<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，也可以被成为表类型。</p><ul><li>创建表时可以指定存储引擎，在CREATE TABLE语句后面添加<code>ENGINE=存储引擎名</code></li><li>查询数据库支持的存储引擎：<code>SHOW ENGINES;</code></li></ul><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="/inori/f4c950eb/MySQL%5CmysqlStruct.png" alt="mysqlStruct"></p><p>MySQL的服务端是分层实现的：</p><ol><li>连接层：接收客户端连接，完成安全处理，授权和校验权限等操作</li><li>服务层：核心部分，实现SQL接口，解析器，查询优化器，缓存等，所有跨存储引擎的功能也在这一层实现，如过程，函数等</li><li>引擎层：存储引擎负责MySQL中数据的存储和提取的方式，服务器通过API和存储引擎通信。不同的存储引擎有不同的功能</li><li>存储层：存储数据库数据</li></ol><h2 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，MySQL5.5之后默认的存储引擎为InnoDB</p><p>特点：</p><ul><li>DML操作遵循ACID模型，支持事务</li><li>行级锁，提高并发访问性能</li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性</li></ul><p>文件：xxx.ibd，xxx表示表名，InnoDB每张表都会对应这样一个表空间文件，存储表结构（frm，sdi）、数据和索引。</p><h4 id="InnoDB的逻辑存储结构"><a href="#InnoDB的逻辑存储结构" class="headerlink" title="InnoDB的逻辑存储结构"></a>InnoDB的逻辑存储结构</h4><p><img src="/inori/f4c950eb/MySQL%5Cmysql_innodb.png" alt="mysql_innodb"></p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MySQL早期的默认存储引擎</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：xxx.MYD、xxx.MYI、xxx.sdi。sdi文件存储表结构信息，MYD文件存放数据，MYI文件存储索引</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>表数据存储在内存中，可能会受到硬件问题或断电问题影响，只能将这些表作为临时表或者缓存使用</p><p>特点：</p><ul><li>存放在内存中，访问速度更快</li><li>支持hash索引</li></ul><p>文件：xxx.sdi。存储表结构信息</p><h3 id="三个存储引擎特点对比"><a href="#三个存储引擎特点对比" class="headerlink" title="三个存储引擎特点对比"></a>三个存储引擎特点对比</h3><p><img src="/inori/f4c950eb/MySQL%5Cmysql_engineSpecial.png" alt="mysql_engineSpecial"></p><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><ul><li><u>InnoDB</u>：适合对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询外还包括更新、删除操作的场景</li><li>MyISAM：适合以读和插入操作为主，对事务的完整性、并发性要求不高的场景，可以被MongoDB替代</li><li>MEMORY：通常作为临时表和缓存，可以被Redis替代</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>​索引是帮助MySQL高效获取数据的<u>有序</u>数据结构。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p>​索引可以提高数据检索的效率，降低数据库的IO成本，并且通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。带来好处的同时，索引降低了更新表的速度，对表进行增删改时效率降低，但是在正常业务中，增删改的频率要远小于查询，基本可以忽略这个缺点。</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：</p><table><thead><tr><th align="center">索引结构</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">B+ Tree</td><td align="center">最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td align="center">Hash</td><td align="center">使用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询。Memory支持该索引</td></tr><tr><td align="center">R-tree空间索引</td><td align="center">主要用于地理空间数据类型，使用较少，MyISAM的特殊索引类型</td></tr><tr><td align="center">Full-text全文索引</td><td align="center">通过建立倒排索引，快速匹配文档的方式，类似于Lucene，Solr，ES。InnoDB和MyISAM支持该索引。</td></tr></tbody></table><p>平常说的索引一般都是B+ Tree索引</p><h4 id="为什么InnoDB存储引擎选择使用B-tree索引"><a href="#为什么InnoDB存储引擎选择使用B-tree索引" class="headerlink" title="为什么InnoDB存储引擎选择使用B+tree索引"></a>为什么InnoDB存储引擎选择使用B+tree索引</h4><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>相对于B Tree，无论是叶子节点还是非叶子节点，都会保存数据，这会导致一页中存储的键值和指针减少，进而导致树的层级变深，性能降低</li><li>相对于Hash索引，B+ Tree支持范围匹配和排序</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><img src="/inori/f4c950eb/MySQL%5Cmysql_indexType.png" alt="mysql_indexType"></p><p>在InnoDB中，根据索引的存储形式，又可以分为<u>聚集索引</u>和<u>二级索引</u>：</p><p><img src="/inori/f4c950eb/MySQL%5Cmysql_InnoDBIndexType.png" alt="mysql_InnoDBIndexType"></p><p>在进行查找时，如果查找的不是主键，则需要先在二级索引找到对应的主键，再去聚集索引找到全部信息，这叫做回表查询。</p><h3 id="索引的语法"><a href="#索引的语法" class="headerlink" title="索引的语法"></a>索引的语法</h3><ul><li>创建索引：<code>CREATE [UNIUQE|FULLTEXT] INDEX 索引名 ON 表名(字段列表);</code></li><li>查看索引：<code>SHOW INDEX FROM 表名;</code></li><li>删除索引：<code>DROP INDEX 索引名 ON 表名;</code></li></ul><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><ul><li><p>SQL执行频率：MySQL客户端连接成功后，通过<code>show[session|global] status</code>命令可以提供服务器状态信息。</p><p>如：<code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code>查看数据库增删改查的使用频率</p></li><li><p>慢查询日志：记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>默认是关闭状态，可以通过sql语句<code>set global slow_query_log=ON;</code>和<code>set long_query_time=x;</code>打开慢查询日志记录和设置慢查询门槛时间</p></li><li><p>profile详情：<code>show profiles</code>能够在做SQL优化时帮助我们了解各种操作耗费时间的详情。</p><p>默认profile是关闭状态，通过<code>set global profiling=1;</code>打开。</p><ul><li>查看每一条SQL语句的耗时情况：<code>show profiles;</code></li><li>查看指定query_id的SQL语句各个阶段的耗时情况：<code>show profile for query query_id;</code></li><li>查看指定query_id的SQL语句CPU使用情况：<code>show prifile cpu for query query_id;</code></li></ul></li><li><p>explain执行计划：可以使用explain或者desc命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。语法为EXPLAIN&#x2F;DESC + SELECT语句。</p><p>explain各字段的含义：</p><ul><li>id：表示查询中执行select子句或者是操作表的顺序（id号大的先执行，id相同，执行顺序从上到下）</li><li>select_type：表示select的类型，常见的取值有simple（简单表，不使用表连接和子查询）、primary（主查询）、union（union后面的查询语句）、subquery（子查询语句）</li><li><u>type</u>：表示连接类型，性能由好到差的连接类型为：NULL、system、const、eq_ref、ref、range、index、all</li><li><u>possible_key</u>：显示可能应用在这张表上的索引</li><li><u>key</u>：实际用到的索引</li><li><u>key_len</u>：索引中使用的字节数，索引字段最大可能长度</li><li>rows：MySQL认为必须要执行查询的行数，估计值</li><li>filtered：表示返回结果的行数占续读取行数的百分比，值越大越好</li></ul></li></ul><h3 id="索引使用注意事项"><a href="#索引使用注意事项" class="headerlink" title="索引使用注意事项"></a>索引使用注意事项</h3><ul><li><p>遵守最左前缀法则：如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是**<u>在查询时</u>**select语句必须要从建立索引的最左列开始，并且不跳过索引中的列。如果跳过某一列，后面字段的索引将失效。</p></li><li><p>避免范围查询：在联合索引中，如果出现了范围查询（&gt;、&lt;），范围查询右侧的列索引失效。但是如果使用(&gt;&#x3D;,&lt;&#x3D;)则不会失效，所以在查询时尽量使用&gt;&#x3D;和&lt;&#x3D;。</p></li><li><p>避免索引列运算：在索引列上进行运算操作，索引会失效</p></li><li><p>字符串加引号：如果查询时字符串不加单引号，索引失效</p></li><li><p>避免头部模糊匹配：使用模糊匹配时，使用尾部模糊匹配，索引不会失效，使用头部模糊匹配时，索引失效</p></li><li><p>or连接：用or关键字分割开的条件，只要有一个条件没有建立索引，所有条件的索引都会失效</p></li><li><p>数据分布影响：如果MySQL评估使用索引比全表扫描还慢，则不使用索引</p></li><li><p>SQL提示：优化数据库的一个重要手段，在SQL语句中加入一些人为的提示信息来达到优化操作的目的</p><ul><li>use index(建议使用):<code>EXPLAIN SELECT 字段名 FROM 表名 USE INDEX(索引名) WHERE 条件;</code></li><li>ignore index(不要使用):<code>EXPLAIN SELECT 字段名 FROM 表名 IGNORE INDEX(索引名) WHERE 条件;</code></li><li>force index(强制使用):<code>EXPLAIN SELECT 字段名 FROM 表名 FORCE INDEX(索引名) WHERE 条件;</code></li></ul></li><li><p>尽量使用覆盖索引（需要查找的字段只需要一次索引就能找全，不需要回表），避免select *</p></li><li><p>前缀索引：当字段类型为字符串时，有时需要索引很长的字符串，可以直将字符串的一部分前缀建立索引，达到节约索引空间，提高效率的效果。</p><p>语法：<code>CREATE INDEX 索引名 ON 表名(字段名(n))</code>其中n是想要建立索引的字段前缀长度</p><p>长度选择：可以通过<code>SELECT COUNT(distinct substring(字段名,1,n))/COUNT(*) FROM 表名;</code>来计算索引性，选择合适的长度，越接近1越好</p></li><li><p>联合索引：如果存在多个查询条件，针对查询字段建立联合索引可以做到覆盖查询，提高效率。建立联合索引时要注意字段位置</p></li></ul><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ol><li>数据量较大（大于一百万），且查询比较频繁的表</li><li>针对于常作为查询条件(where)、排序（order by)、分组(group by)操作的字段建立索引</li><li>选择区分度高的列作为索引，建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段的长度较长，可以针对字段建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，只建立有必要的索引，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，需要在创建表时使用NOT NULL约束。这样优化器知道每列是否包含NULL值，可以更好地确定哪个索引更有效</li></ol><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><ol><li>如果需要一次性插入多条数据，可以从三方面进行优化<ul><li>使用批量插入语句：<code>Insert into test values(1,&#39;name1&#39;),(2,&#39;name2&#39;),(3,&#39;name3&#39;); </code></li><li>手动控制事务，全部插入后再关闭事务</li><li>主键顺序插入</li></ul></li><li>如果要大批量插入数据（几百万条），可以使用<code>load</code>指令进行插入</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 客户端连接服务端加上参数 -–local-infile</span></span><br><span class="line">mysql –<span class="operator">-</span><span class="keyword">local</span><span class="operator">-</span>infile <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line"><span class="comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 执行load指令将准备好的数据，加载到表结构中</span></span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields</span><br><span class="line">terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> ;</span><br></pre></td></tr></table></figure><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>主键顺序插入的性能要高于乱序插入，因为在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table，IOT)。</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h3><p>MySQL的排序，有两种方式：</p><ul><li><code>Using filesort</code>: 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</li><li><code>Using index</code>: 通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。</li></ul><p>对于以上的两种排序方式，<code>Using index</code>的性能高，在优化排序操作时，尽量要优化为<code>Using index</code></p><h4 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h4><ol><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)</li></ol><h3 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h3><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。</p><p>优化思路: 一般分页查询时，通过创建<strong>覆盖索引</strong>能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><h3 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h3><p>当update语句的<code>where</code>条件存在索引时，会使用行锁，锁定这一行的数据，但是当<code>where</code>条件没有索引时，会使用表锁锁住整张表，阻止其他的DML请求，降低效率。</p><p>所以update中的<code>where</code>条件尽量选择有索引的列</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除对传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><p>MySQL中的锁，按照锁的粒度分，分为三类：</p><ul><li>全局锁：粒度最大，锁定数据库中的所有表</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：粒度最小，每次操作锁住对应的行数据</li></ul><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个数据库就处于只读状态，后续的DML的写语句，DDL语句，以及更新操作的事务提交语句都将被阻塞</p><p>典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>加全局锁</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br></pre></td></tr></table></figure><ul><li>数据备份</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="operator">-</span>uroot –p1234 test <span class="operator">&gt;</span> test.sql</span><br></pre></td></tr></table></figure><ul><li>释放锁</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。</p></li></ul><p>在InnoDB引擎中，可以在备份时加上参数<code>--single-transaction</code>参数来完成不加锁的一致性数据备份。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqldump <span class="comment">--single-transaction -uroot –p123456 test &gt; test.sql</span></span><br></pre></td></tr></table></figure><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在MyISAM、InnoDB、BDB等存储引擎中。</p><p>对于表级锁，主要分为以下三类：</p><ul><li><p>表锁</p></li><li><p>元数据锁（meta data lock，MDL）</p></li><li><p>意向锁</p></li></ul><h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁分为两类：</p><ul><li>表共享读锁（read lock）：对指定表加读锁后，不会影响其他客户端的读，但是会阻塞其他客户端的写</li><li>表共享写锁（write lock）：对指定表加写锁后，会阻塞其他客户端的读和写</li></ul><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><p>加锁：lock tables 表名… read&#x2F;write</p><p>释放锁：unlock tables &#x2F; 客户端断开连接</p><h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>元数据锁(meta data lock，MDL)的加锁过程是系统自动控制的，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DM与DDL冲突，保证读写的正确性</p><p>这里的元数据，可以简单理解为就是一张表的表结构。也就是说，某一张表涉及到未提交的事务时，不能修改这张表的表结构</p><p>当对一张表进行增删改查的时候，加MDL读锁(共享)，当对表结构进行变更操作的时候，加MDL写锁(排他)</p><h4 id="常见操作中添加的元数据锁"><a href="#常见操作中添加的元数据锁" class="headerlink" title="常见操作中添加的元数据锁"></a>常见操作中添加的元数据锁</h4><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read&#x2F;write</td><td>SHARED_READ_ONLY &#x2F; SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select 、select … lock in share mode</td><td>SHARED_READ</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>insert 、update、delete、select … for update</td><td>SHARED_WRITE</td><td>与SHARED_READ、SHARED_WRITE兼容，与EXCLUSIVE互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其他的MDL都互斥</td></tr></tbody></table><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</p><p>当一个客户端在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁，其他客户端，在对这张表加表锁时，会根据该表上所加的意向锁来判定是否可以成功加表锁，无需逐行判断行锁情况</p><h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><p>意向共享锁(IS): 由语句select … lock in share mode添加。与表锁共享锁(read)兼容，与表锁排他锁(write)互斥</p><p>意向排他锁(IX): 由insert、update、delete、select…for update添加。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥</p><p><u>事务提交后，意向共享锁、意向排他锁，都会自动释放</u></p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁每次操作锁住对应的行数据。粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：</p><ul><li><p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在读已提交（READ UNCOMMITTED，RC）、可重复读（REPEATABLE READ，RR）隔离级别下支持。</p></li><li><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下支持。</p></li><li><p>临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</p></li></ul><h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><p>InnoDB实现了以下两种类型的行锁：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁</li></ul><p>其中共享锁之与共享锁兼容，排他锁与其他锁都互斥</p><h5 id="常见操作中添加的行锁"><a href="#常见操作中添加的行锁" class="headerlink" title="常见操作中添加的行锁"></a>常见操作中添加的行锁</h5><table><thead><tr><th>对应SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT（正常）</td><td>不加任何锁</td><td></td></tr><tr><td>SELECT … LOCK IN SHARE MODE</td><td>共享锁</td><td>需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td>SELECT … FOR UPDATE</td><td>排他锁</td><td>需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p>默认情况下，InnoDB在RR事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁</li><li>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁</li></ul><p>查看意向锁及行锁的加锁情况：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><h4 id="间隙锁和临键锁"><a href="#间隙锁和临键锁" class="headerlink" title="间隙锁和临键锁"></a>间隙锁和临键锁</h4><p>产生条件：</p><ul><li><p>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁</p></li><li><p>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁</p></li><li><p>索引上的范围查询(唯一索引)，会访问到不满足条件的第一个值为止</p><p>比如查询一张表上<code>id &gt;= 20</code>的数据，并添加共享锁，此时会根据数据库表中现有的数据，将数据分为三个部分：<code>[20]</code>、<code>(20, 表中已有的id最大值)</code>、<code>(id最大值,+∞)</code>，数据库在加锁时会在20加行锁，id最大值的临键锁（包含最大值及最大值之前的间隙），正无穷的临键锁(正无穷及之前的间隙)</p></li></ul><h2 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h2><h3 id="逻辑存储结构"><a href="#逻辑存储结构" class="headerlink" title="逻辑存储结构"></a>逻辑存储结构</h3><p>InnoDB的逻辑存储结构分为表空间、段、区、页、行。</p><p><img src="/inori/f4c950eb/innodb_composition.jpg" alt="innodb_composition"></p><ol><li><p>表空间：表空间是InnoDB存储引擎逻辑结构的最高层，如果用户启用了参数<code>innodb_file_per_table</code>(在8.0版本中默认开启)，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据</p></li><li><p>段：分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）</p></li><li><p>区：区是表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页</p></li><li><p>页：页是InnoDB磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请4-5个区</p></li><li><p>行：InnoDB数据是按行进行存放的。在行中，默认有两个隐藏字段：</p></li></ol><ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>MySQL5.5版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，使用广泛。在InnoDB架构图中，左侧为内存结构，右侧为磁盘结构</p><img src="/inori/f4c950eb/innodb_frame.jpg" alt="innodb_frame" style="zoom:80%;"><h4 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h4><p>内存结构部分主要有：Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer</p><h5 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h5><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I&#x2F;O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>Buffer Pool是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><p>• free page：空闲page，未被使用</p><p>• clean page：被使用page，数据没有被修改过</p><p>• dirty page：脏页，被使用page，数据被修改过，数据与磁盘的数据不一致，</p><p>参数查看：<code>show variables like &#39;innodb_buffer_pool_size&#39;;</code></p><h5 id="Change-Buffer"><a href="#Change-Buffer" class="headerlink" title="Change Buffer"></a>Change Buffer</h5><p>Change Buffer，更改缓冲区（针对于非唯一的二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>非唯一的二级索引页是以相对随机的顺序插入二级索引，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有ChangeBuffer之后，可以在缓冲池中进行合并处理，减少磁盘IO</p><h5 id="Adaptive-Hash-Index"><a href="#Adaptive-Hash-Index" class="headerlink" title="Adaptive Hash Index"></a>Adaptive Hash Index</h5><p>自适应hash索引用于优化对Buffer Pool数据的查询。InnoDB中虽然没有直接支持hash索引，但是提供了自适应hash索引。</p><p>hash索引在进行等值匹配时，一般性能要高于B+树，因为hash索引一般只需要一次IO，B+树可能需要几次匹配。但是hash索引又不适合做范围查询、模糊匹配等操作。</p><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p><p><strong>自适应哈希索引，无需人工干预，系统根据情况自动完成</strong></p><p>参数：<code>adaptive_hash_index</code></p><h5 id="Log-Buffer"><a href="#Log-Buffer" class="headerlink" title="Log Buffer"></a>Log Buffer</h5><p>日志缓冲区用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O</p><p>参数:</p><ul><li><code>innodb_log_buffer_size</code>：缓冲区大小</li><li><code>innodb_flush_log_at_trx_commit</code>：日志刷新到磁盘时机，取值主要包含：<ul><li>日志在每次事务提交时写入并刷新到磁盘，默认值</li><li>每秒将日志写入并刷新到磁盘一次</li><li>日志在每次事务提交后写入，并每秒刷新到磁盘一次</li></ul></li></ul><h4 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h4><h5 id="System-Tablespace"><a href="#System-Tablespace" class="headerlink" title="System Tablespace"></a>System Tablespace</h5><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等）</p><p>参数：<code>innodb_data_file_path</code></p><h5 id="File-Per-Table-Tablespaces"><a href="#File-Per-Table-Tablespaces" class="headerlink" title="File-Per-Table Tablespaces"></a>File-Per-Table Tablespaces</h5><p>每个表的文件表空间包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中，也就是说，每创建一个表，都会产生一个表空间文件</p><p>开关参数：<code>innodb_file_per_table</code>，默认开启</p><h5 id="General-Tablespaces"><a href="#General-Tablespaces" class="headerlink" title="General Tablespaces"></a>General Tablespaces</h5><p>通用表空间，在创建表时，可以指定该表空间</p><ul><li>创建表空间</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE ts_name <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;file_name&#x27;</span> ENGINE <span class="operator">=</span> engine_name;</span><br></pre></td></tr></table></figure><ul><li>创建表空间时制定表</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> xxx ... TABLESPACE ts_name;</span><br></pre></td></tr></table></figure><h5 id="Undo-Tablespaces"><a href="#Undo-Tablespaces" class="headerlink" title="Undo Tablespaces"></a>Undo Tablespaces</h5><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log日志。</p><h5 id="Temporary-Tablespaces"><a href="#Temporary-Tablespaces" class="headerlink" title="Temporary Tablespaces"></a>Temporary Tablespaces</h5><p>InnoDB使用会话时的临时表空间和全局临时表空间，存储用户创建的临时表等数据。</p><h5 id="Doublewrite-Buffer-Files"><a href="#Doublewrite-Buffer-Files" class="headerlink" title="Doublewrite Buffer Files"></a>Doublewrite Buffer Files</h5><p>双写缓冲区，InnoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据</p><h4 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h4><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread、IO Thread、Purge Thread、Page Cleaner Thread</p><h5 id="Master-Thread"><a href="#Master-Thread" class="headerlink" title="Master Thread"></a>Master Thread</h5><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。</p><h5 id="IO-Thread"><a href="#IO-Thread" class="headerlink" title="IO Thread"></a>IO Thread</h5><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调。</p><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区刷新到磁盘</td></tr></tbody></table><p>通过指令，查看到InnoDB的状态信息，其中就包含IO Thread信息：<code>show engine innodb status \G; </code></p><h5 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h5><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就由Purge Thread来回收</p><h5 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h5><p>协助Master Thread刷新脏页到磁盘的线程，Page Cleaner Thread可以减轻Master Thread的工作压力，减少阻塞</p><h4 id="InnoDB中的事务"><a href="#InnoDB中的事务" class="headerlink" title="InnoDB中的事务"></a><strong>InnoDB中的事务</strong></h4><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败</p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><p>对于这四大特性，其中原子性、一致性、持久性，是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。而隔离性是通过数据库的锁，加上MVCC来保证的</p><h5 id="Redo-log"><a href="#Redo-log" class="headerlink" title="Redo log"></a>Redo log</h5><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log），前者在内存中，后者在磁盘中。</p><p>当事务提交之后会把所有修改信息都会存到该日志中，用于在刷新脏页到磁盘时，发生错误时，进行数据恢复，以循环方式写入重做日志文件。</p><p>有了redolog，对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘或者涉及到的数据已经落盘，此时redo log就可以删除了，所以存在的两个redo log文件是循环写的。</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><ol><li>当前读</li></ol><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读</p><ol start="2"><li>快照读</li></ol><p>简单的select（不加锁）就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读</p><ul><li>Read Committed：每次select，都生成一个快照读</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方</li><li>Serializable：快照读会退化为当前读</li></ul><ol start="3"><li>MVCC</li></ol><p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐藏字段、undo log日志、readView</p><h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p>数据库中的表在创建之后，查看表结构时可以显式的看到我们制定创建的字段。实际上除了制定创建的字段以外，InnoDB还会自动的添加三个隐藏字段，及其含义分别是：</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><p>上表中前两个字段是肯定会添加，最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，不会添加该隐藏字段</p><h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>回滚日志，用于记录数据被修改前的信息，作用包含两个: 提供回滚(保证事务的原子性)和MVCC(多版本并发控制) </p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚</p><ul><li><p>Undo log销毁：undo log在事务执行时产生，在事务提交后，insert产生的undo log日志只在回滚时需要，可被立即删除。update、delete产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即</p><p>删除。</p></li><li><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在rollback segment回滚段中，内部包含1024个undo log segment</p></li></ul><h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>当有多个并发事务在访问同一张表时，每个事务提交的sql语句都会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本</p><p>每个并发事务可能都会发起很多次sql请求，最终可以发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undo log生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录</p><h5 id="readview"><a href="#readview" class="headerlink" title="readview"></a>readview</h5><p>ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id</p><p>包含四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p>在readview中规定了版本链数据的访问规则(trx_id代表当前undo log版本链对应事务ID)：</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>说明</th></tr></thead><tbody><tr><td>trx_id &#x3D;&#x3D; creator_trx_id</td><td>可以访问该版本</td><td>说明数据是当前这个事务更改的</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>说明数据已经提交</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>说明该事务是在ReadView生成后才开启</td></tr><tr><td>min_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id</td><td>如果trx_id不在m_ids中，是可以访问该版本的</td><td>说明数据已经提交</td></tr></tbody></table><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li>READ COMMITTED：在事务中每一次执行快照读时生成ReadView</li><li>REPEATABLE READ：在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</li></ul><h2 id="MySQL管理"><a href="#MySQL管理" class="headerlink" title="MySQL管理"></a>MySQL管理</h2><h3 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h3><p>Mysql数据库安装完成后，自带了一下四个数据库，具体作用为：</p><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储MySQL服务器正常运行所需要的各种信息（时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等</td></tr><tr><td>performance_schema</td><td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便DBA和开发人员利用performance_schema性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="mysql客户端工具"><a href="#mysql客户端工具" class="headerlink" title="mysql客户端工具"></a>mysql客户端工具</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line">mysql [options] [database]</span><br><span class="line"># 选项</span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user=name #指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password[=name] #指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host=name #指定服务器IP或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port=port #指定连接端口</span></span><br><span class="line"><span class="operator">-</span>e, <span class="comment">--execute=name #执行SQL语句并退出</span></span><br></pre></td></tr></table></figure><p>-e选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，可以对于一些批处理脚本</p><h4 id="mysqladmin"><a href="#mysqladmin" class="headerlink" title="mysqladmin"></a>mysqladmin</h4><p>mysqladmin是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line">mysqladmin [options] command ...</span><br><span class="line"># 选项</span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user=name #指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password[=name] #指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host=name #指定服务器IP或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port=port #指定连接端口</span></span><br></pre></td></tr></table></figure><h4 id="mysqlbinlog"><a href="#mysqlbinlog" class="headerlink" title="mysqlbinlog"></a>mysqlbinlog</h4><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会用到mysqlbinlog日志管理工具</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#语法</span><br><span class="line">mysqlbinlog [options] log<span class="operator">-</span>files1 log<span class="operator">-</span>files2 ...</span><br><span class="line">#选项</span><br><span class="line"><span class="operator">-</span>d, <span class="comment">--database=name #指定数据库名称，只列出指定的数据库相关操作</span></span><br><span class="line"><span class="operator">-</span>o, <span class="comment">--offset= # 忽略掉日志中的前n行命令</span></span><br><span class="line"><span class="operator">-</span>r,<span class="comment">--result-file=name #将输出的文本格式日志输出到指定文件</span></span><br><span class="line"><span class="operator">-</span>s, <span class="comment">--short-form #显示简单格式,省略掉一些信息</span></span><br><span class="line"><span class="comment">--start-datatime=date1 --stop-datetime=date2 #指定日期间隔内的所有日志</span></span><br><span class="line"><span class="comment">--start-position=pos1 --stop-position=pos2 #指定位置间隔内的所有日志</span></span><br></pre></td></tr></table></figure><h4 id="mysqlshow"><a href="#mysqlshow" class="headerlink" title="mysqlshow"></a>mysqlshow</h4><p>mysqlshow客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line">mysqlshow [options] [db_name [table_name [col_name]]]</span><br><span class="line"># 选项</span><br><span class="line"><span class="comment">--count # 显示数据库及表的统计信息（数据库和表均可以不指定）</span></span><br><span class="line"><span class="operator">-</span>i # 显示指定数据库或者指定表的状态信息</span><br></pre></td></tr></table></figure><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><p>mysqldump客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 语法</span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] <span class="comment">--database/-B db1 [db2 db3...]</span></span><br><span class="line">mysqldump [options] <span class="comment">--all-databases/-A</span></span><br><span class="line"># 连接选项</span><br><span class="line"><span class="operator">-</span>u, <span class="comment">--user=name # 指定用户名</span></span><br><span class="line"><span class="operator">-</span>p, <span class="comment">--password[=name] # 指定密码</span></span><br><span class="line"><span class="operator">-</span>h, <span class="comment">--host=name # 指定服务器ip或域名</span></span><br><span class="line"><span class="operator">-</span>P, <span class="comment">--port= # 指定连接端口</span></span><br><span class="line"># 输出选项</span><br><span class="line"><span class="comment">--add-drop-database # 在每个数据库创建语句前加上drop database语句</span></span><br><span class="line"><span class="comment">--add-drop-table # 在每个表创建语句前加上drop table语句，默认开启;(不开启 (--skip-add-drop-table))</span></span><br><span class="line"><span class="operator">-</span>n, <span class="comment">--no-create-db # 不包含数据库的创建语句</span></span><br><span class="line"><span class="operator">-</span>t, <span class="comment">--no-create-info # 不包含数据表的创建语句</span></span><br><span class="line"><span class="operator">-</span>d <span class="comment">--no-data # 不包含数据</span></span><br><span class="line"><span class="operator">-</span>T, <span class="comment">--tab=name # 自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件</span></span><br></pre></td></tr></table></figure><h4 id="mysqlimport-source"><a href="#mysqlimport-source" class="headerlink" title="mysqlimport&#x2F;source"></a>mysqlimport&#x2F;source</h4><ul><li>mysqlimport是客户端数据导入工具，用来导入mysqldump加 -T 参数后导出的文本文件</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlimport [options] db_name textfile1 [textfile2...]</span><br></pre></td></tr></table></figure><ul><li>source</li></ul><p>如果需要导入sql文件，可以使用mysql中的source指令</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">source <span class="operator">/</span>root<span class="operator">/</span>xxxxx.sql</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础篇</title>
      <link href="/inori/337fcc87.html"/>
      <url>/inori/337fcc87.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h2><table><thead><tr><th align="center">名称</th><th align="center">解释</th><th align="center">简称</th></tr></thead><tbody><tr><td align="center">数据库</td><td align="center">将数据有组织的存储的仓库</td><td align="center">DataBase(DB)</td></tr><tr><td align="center">数据库管理系统</td><td align="center">操纵和管理数据库的大型软件</td><td align="center">DBMS</td></tr><tr><td align="center">SQL</td><td align="center">操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准</td><td align="center">Structured Query Language</td></tr></tbody></table><p>工程师通过SQL操作DBMS，间接管理数据库中的数据</p><p>Oracle、MySQL等系统是关系型数据库管理系统，支持使用SQL语言进行数据库操作。</p><p>关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</p><h3 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h3><p>安装：这里推荐安装Mysql8版本，可以参考<a href="https://zhuanlan.zhihu.com/p/645347983?utm_id=0">这篇文章</a>安装MySQL</p><p>启动与停止：</p><blockquote><p>net start mysql80</p><p>net stop mysql80</p></blockquote><p>客户端连接：<code>mysql [-h 127.0.0.1] [-P 3306] -u root -p</code></p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul><li>SQL语句可以单行或多行书写，以分号结尾</li><li>MySQL中的SQL语句不区分大小写，但是关键字推荐使用大写</li><li>注释：<ul><li>单行注释：<code>-- 注释内容</code>或<code># 注释内容</code>(MySQL特有)</li><li>多行注释：<code>/*注释内容*/</code></li></ul></li></ul><h3 id="SQL数值类型"><a href="#SQL数值类型" class="headerlink" title="SQL数值类型"></a>SQL数值类型</h3><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p><img src="/inori/337fcc87/mysql_intDataType-1741160038841-5.png" alt="mysql_datatype"></p><p>无符号数<code>TINYINT UNSIGNED</code>，DECIMAL类型<code>DECIMAL(x,y)</code>，x代表数字的整体长度&#x3D;整数长度+小数长度，y代表小数的长度</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p><img src="/inori/337fcc87/mysql_charDataType.png" alt="mysql_datatype"></p><p>CHAR为定长字符串，开多少空间就占用多少空间，VARCHAR为变长字符串，根据存储的数据动态计算空间。</p><p>长文本数据分为<u>BLOB</u>和<u>TEXT</u>类型，BLOB表示二进制数据，可以是音频、视频、图像等数据，可以将其存储在数据库中，但是在开发时很少这么做，一般采用专门的文件服务器进行存储。</p><h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><p><img src="/inori/337fcc87/mysql_timeDataType.png" alt="mysql_timeDataType"></p><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><table><thead><tr><th align="center">分类</th><th align="center">全称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DDL</td><td align="center">Data Definition Language</td><td align="center">数据定义语言，定义数据库对象（数据库，表，字段）</td></tr><tr><td align="center">DML</td><td align="center">Data Manipulation Language</td><td align="center">数据操作语言，对数据库表中的数据进行增删改</td></tr><tr><td align="center">DQL</td><td align="center">Data Query Language</td><td align="center">数据查询语言，查询表中的记录</td></tr><tr><td align="center">DCL</td><td align="center">Data Control Language</td><td align="center">数据控制语言，创建数据库用户、控制访问权限</td></tr></tbody></table><h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><p><code>[...]</code>部分为可选参数</p><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><ul><li>查询所有数据库：<code>SHOW DATABASES;</code></li><li>查询当前数据库：<code>SELECT DATABASE();</code></li><li>创建：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; </code></li><li>删除：<code>DROP DATABASE [IF EXISTS] 数据库名;</code></li><li>使用：<code>USE 数据库名;</code></li></ul><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><ul><li>查询数据库所有表：<code>SHOW TABLES;</code></li><li>查询表结构：<code>DESE 表名;</code></li><li>查询指定表的建表语句：<code>SHOW CREATE TABLE 表名;</code></li><li>创建表：</li></ul><blockquote><p>CREATE TABLE 表名(</p><p>​字段1 字段1类型[COMMENT 字段1注释],</p><p>​字段2 字段2类型[COMMENT 字段2注释],</p><p>​…..,</p><p>​字段n 字段n类型[COMMENT 字段n注释]</p><p>)[COMMENT 表注释];</p></blockquote><ul><li>添加字段：<code>ALTER TABLE 表名 ADD 字段名 类型 [comment] [约束];</code></li><li>修改数据类型：<code>ALTER TABLE 表名 MODIFY 字段名 新类型;</code></li><li>修改字段名和类型：<code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 [comment] [约束];</code></li><li>修改表名：<code>ALTER TABLE 表名 RENAME TO 新表名;</code></li><li>删除字段：<code>ALTER TABLE 表名 DROP 字段名;</code></li><li>删除表：<code>DROP TABLE [IF EXISTS] 表名;</code></li><li>删除指定表并重新创建（格式化该表）：<code>TRUNCATE TABLE 表名;</code></li></ul><h3 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h3><ul><li>给指定字段添加数据：<code>INSERT INTO 表名（字段1，字段2...） VALUES（值1，值2...）;</code></li><li>给全部字段添加数据：<code>INSERT INTO 表名 VALUES（值1，值2...）;</code></li><li>批量添加数据：</li></ul><blockquote><p>INSERT INTO 表名（字段1，字段2…） VALUES（值1，值2…）,（值1，值2…）…;</p><p>INSERT INTO 表名 VALUES（值1，值2…）,（值1，值2…）…;</p></blockquote><ul><li>修改数据：<code>UPDATE 表名 SET 字段1=值1, 字段2=值2...[WHERE 条件];</code></li><li>删除数据：<code>DELETE FROM 表名 [WHERE 条件];</code></li></ul><h3 id="DQL语句"><a href="#DQL语句" class="headerlink" title="DQL语句"></a>DQL语句</h3><ul><li><p>查询多个字段：<code>SELECT 字段1,字段2,... FROM 表名;</code></p></li><li><p>查询全部字段：<code>SELECT * FROM 表名;</code></p></li><li><p>设置别名：<code>SELECT 字段1 AS 别名1,字段2 AS 别名2,... FROM 表名;</code></p></li><li><p>去重：<code>SELECT DISTINCT 字段列表 FROM 表名;</code></p></li><li><p>条件查询：<code>SELECT 字段列表 FROM WHERE 条件列表;</code></p><p><u>此处的条件列表与其他编程语言的条件判断基本一致</u>，个别不一样的中常用的有<code>LIKE 占位符</code>表示模糊匹配（_匹配单个字符，%匹配任意字符）</p></li><li><p>使用聚合函数查询：<code>SELECT 聚合函数(字段列表) FROM 表名;</code></p></li></ul><p>​常用的聚合函数有：<u>count(),max(),min(),avg(),sum()</u>,按列进行计算</p><ul><li><p>分组查询：<code>SELECT 字段列表 FROM 表名 [WHERE 分组前过滤条件] GROUP BY 分组字段名 [HAVING 分组后的过滤条件];</code>（其中having中可以使用聚合函数过滤，where中不可以，并且分组之后查询的字段一般为分组字段和聚合函数）</p></li><li><p>排序查询：<code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;</code></p><p><u>排序方式有两种：ASC：升序（默认），DESC：降序。</u>如果是多字段排序，当且仅当第一个字段相同时按照第二个排。</p></li><li><p>分页查询：<code>SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</code></p><ul><li>索引从0开始编号，起始索引&#x3D;（查询页面-1）*每页的记录数</li><li>分页查询时数据库的方言，不同的数据库中实现语句不同，MySQL中是LIMIT</li><li>如果查的是第一页的数据，起始索引可以省略</li></ul></li></ul><h4 id="DQL语句编写顺序与执行顺序"><a href="#DQL语句编写顺序与执行顺序" class="headerlink" title="DQL语句编写顺序与执行顺序"></a>DQL语句编写顺序与执行顺序</h4><p><img src="/inori/337fcc87/mysql_DQLSequence.png" alt="mysql_DQLSequence"></p><h3 id="DCL语句"><a href="#DCL语句" class="headerlink" title="DCL语句"></a>DCL语句</h3><ul><li>查询用户：<code>SELECT * FROM user;</code></li><li>创建用户：<code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></li><li>修改用户密码：<code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password &#39;新密码&#39;;</code></li><li>删除用户：<code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>查询用户权限：<code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>授予权限：<code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>撤销权限：<code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></li></ul><h4 id="常用的权限"><a href="#常用的权限" class="headerlink" title="常用的权限"></a>常用的权限</h4><table><thead><tr><th align="center">权限</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">all&#x2F;all privileges</td><td align="center">所有权限</td></tr><tr><td align="center">select</td><td align="center">查询数据</td></tr><tr><td align="center">insert</td><td align="center">插入数据</td></tr><tr><td align="center">update</td><td align="center">修改数据</td></tr><tr><td align="center">delete</td><td align="center">删除数据</td></tr><tr><td align="center">alter</td><td align="center">修改表</td></tr><tr><td align="center">drop</td><td align="center">删除数据库、表、视图</td></tr><tr><td align="center">create</td><td align="center">创建数据库、表</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在数据库中，函数指的是可以直接被另一段程序调用的程序或代码。</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CONCAT(S1,S2,…,Sn)</td><td align="center">字符串拼接，将给定的字符串拼成一个</td></tr><tr><td align="center">LOWER(str)</td><td align="center">str全部字符转成小写</td></tr><tr><td align="center">UPPER(str)</td><td align="center">str全部字符转成大写</td></tr><tr><td align="center">LPAD(str,n,pad)</td><td align="center">左填充，用字符串pad对str的左边进行填充直到长度到达n</td></tr><tr><td align="center">RPAD(str,n,pad)</td><td align="center">右填充，用字符串pad对str的右边进行填充直到长度到达n</td></tr><tr><td align="center">TRIM(str)</td><td align="center">去掉收尾空格</td></tr><tr><td align="center">SUBSTRING(str,start,len)</td><td align="center">返回字符串str从start开始len长度的字符串，索引从1开始</td></tr><tr><td align="center">LENGTH(str)</td><td align="center">返回字符串长度</td></tr></tbody></table><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CEIL(x)</td><td align="center">上取整</td></tr><tr><td align="center">FLOOR(x)</td><td align="center">下取整</td></tr><tr><td align="center">MOD(x,y)</td><td align="center">返回x&#x2F;y的模</td></tr><tr><td align="center">RAND()</td><td align="center">返回0~1的随机数</td></tr><tr><td align="center">ROUND(x,y)</td><td align="center">求x的四舍五入，保留y位小数</td></tr></tbody></table><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CURDATE()</td><td align="center">返回当前日期</td></tr><tr><td align="center">CURTIME()</td><td align="center">获取当前时间</td></tr><tr><td align="center">NOW()</td><td align="center">获取当前日期和时间</td></tr><tr><td align="center">YEAR(date)</td><td align="center">返回指定date的年份</td></tr><tr><td align="center">MONTH(date)</td><td align="center">返回指定date的月份</td></tr><tr><td align="center">DAY(date)</td><td align="center">返回指定date的日</td></tr><tr><td align="center">DATE_ADD(date,INTERVAL expr type)</td><td align="center">返回一个日期&#x2F;时间加上一个时间间隔expr后的时间</td></tr><tr><td align="center">DATEDIFF(date1,date2)</td><td align="center">返回date1和date2之间间隔的天数，date1-date2</td></tr></tbody></table><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">IF(value,t,f)</td><td align="center">如果value为true，返回t，否则返回f</td></tr><tr><td align="center">IFNULL(value1,value2)</td><td align="center">如果value1不为空，返回value1，否则返回value2</td></tr><tr><td align="center">CASE WHEN [val1] THEN [res1]…ELSE[default]END</td><td align="center">如果val1为true，返回res1,…否则返回默认值</td></tr><tr><td align="center">CASE [expr] WHEN [val1] THEN [res1]…ELSE[default]END</td><td align="center">如果expr的值等于val1，返回res1,…否则返回默认值</td></tr></tbody></table><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>​约束是作用于表中字段上的规则，在创建表或修改表的时候添加约束，用于限制存储在表中的数据。可以保证数据的正确，有效性和完整性。</p><h3 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h3><p><img src="/inori/337fcc87/mysql_limitTyoe.png" alt="mysql_limitTyoe"></p><p>添加约束时只需要在后面直接添加关键字即可，不同约束使用空格隔开</p><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性，具有外键的称为子表&#x2F;从表，外键所关联的表称为父表&#x2F;主表。</p><ul><li>建立外键关联</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可以在创建表时直接指明外键</span><br><span class="line">CREATE TABLE name(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">    ...,</span><br><span class="line">    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 或者建表之后额外添加</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表(主表字段);</span><br></pre></td></tr></table></figure><ul><li>删除外键：<code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></li></ul><h3 id="外键约束-1"><a href="#外键约束-1" class="headerlink" title="外键约束"></a>外键约束</h3><p><img src="/inori/337fcc87/MySQL%5Cmysql_fkType.png" alt="mysql_fkType"></p><p>使用时在外键命令后面添加<code>ON UPDATE 行为 ON DELETE 行为</code></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表查询即从多张表中查询数据。可以分为<u>连接查询</u>和<u>子查询</u></p><ul><li><p>连接查询</p><ul><li><p>内连接</p></li><li><p>外连接</p><ul><li><p>左外连接</p></li><li><p>右外连接</p></li></ul></li><li><p>自连接</p></li></ul></li><li><p>子查询</p></li></ul><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li><p>一对一：</p><ul><li>案例：个人与个人信息</li><li>关系：每个人有每个人自己的个人信息</li><li>实现：将基础字段放在一张表中，详情信息放在另一张表中，在任意一方加入外键，关联另一方的主键，并设置外键为UNIQUE</li></ul></li><li><p>一对多&#x2F;多对一：</p><ul><li>案例：部门与员工</li><li>关系：一个部门对应多个员工，一个员工对应一个部门</li><li>实现：在多的一方建立外键，指向一的一方的主键</li></ul></li><li><p>多对多：</p><ul><li>案例：学生与课程</li><li>关系：一个学生可以选修多门课程，一门课程可以有多个学生选择</li><li>实现：建立一张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul></li></ul><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>查询A、B交集部分的数据</p><ul><li>隐式内连接：<code>SELECT 字段列表 FROM 表1,表2 WHERE 条件;</code></li><li>显示内连接：<code>SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件;</code></li></ul><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>查询左表所有数据，以及两张表交集部分的数据</p><p><code>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件; </code></p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>查询右表所有数据，以及两张表交集部分的数据</p><p><code>SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件; </code></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>当前表与自身的连接查询，自连接必须使用表别名。自连接可以是内连接查询，也可以是外连接查询</p><p><code>SELECT 字段列表 FROM 表1 别名1 JOIN 表2 别名2 ON 条件; </code></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套SELECT语句称为嵌套查询，也叫子查询，子查询外部的语句可以是增删改查任意一个</p><p>例如：<code>SELECT 字段列表 FROM 表1 WHERE 字段1=(SELECT 字段1 FROM 表2); </code></p><p>根据子查询结果不同，分为：</p><ul><li><p>标量子查询（子查询结果为单个值）：直接嵌套查询即可</p></li><li><p>列子查询：</p><p>常用的操作符：IN(指定范围内),NOT IN(不在指定范围内),ANY(返回列表中任意一个满足条件即可),SOME(同ANY),ALL(条件必须全部满足)</p></li><li><p>行子查询:</p><p>常用的操作符：&#x3D;,&lt;&gt;,IN,NOT IN</p></li><li><p>表子查询（多行多列）:</p><p>常用的操作符：IN</p></li></ul><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询使用union(合并后去重)，union all(合并)命令，可以把多次查询的结果合并起来，形成一个新的查询结果集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 ...</span><br><span class="line">UNION[ALL]</span><br><span class="line">SELECT 字段列表 FROM 表1 ...</span><br></pre></td></tr></table></figure><p>联合查询中多张表的列数必须保持一致，字段类型也要一致。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，是不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求。默认MySQL的事务是自动提交的，即执行DML语句时，MySQL会立即隐式的提交事务。</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>操作事务有两种方式：1.关闭事务的自动提交 2.通过指令显式开启事务</p><ul><li>查看事务提交方式：<code>SELECT @@autocommit;</code></li><li>设置事务提交方式(1为自动提交，0为手动提交）：<code>SET @@autocommit=0;</code> </li><li>开启事务：<code>START TRANSACTION;</code></li><li>提交事务：<code>COMMIT;</code></li><li>回滚事务：<code>ROLLBACK;</code></li></ul><h3 id="事务四大特性ACID"><a href="#事务四大特性ACID" class="headerlink" title="事务四大特性ACID"></a>事务四大特性ACID</h3><ul><li>原子性A：事务不可分割，事务中的操作要么同时成功，要么同时失败。</li><li>一致性C：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性I：数据库系统提供的隔离机制，保证事务在不收外部并发操作影响的独立环境下运行</li><li>持久性D：事务一旦提交或回滚，对数据的改变就是永久的</li></ul><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p>多个并发事务在执行过程当中所出现的问题</p><table><thead><tr><th align="center">问题</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">脏读</td><td align="center">一个事务读取到另一个事务还没有提交的数据</td></tr><tr><td align="center">不可重复读</td><td align="center">一个事物先后读取到同一条数据，但两次读取的数据不同</td></tr><tr><td align="center">幻读</td><td align="center">一个事物按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>√表示该隔离级别会出现对应问题，从上到下隔离级别由低到高，性能由高到低</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read committed</td><td align="center">x</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable Read</td><td align="center">x</td><td align="center">x</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><p>MySQL中的默认隔离级别是<u>Repeatable Read</u>，Oracle是<u>Read committed</u></p><ul><li>查看事务隔离级别：<code>SELECT @@transaction_isolation;</code></li><li>设置事务隔离级别：<code>SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;隔离级别&#125;;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射</title>
      <link href="/inori/e29c8e30.html"/>
      <url>/inori/e29c8e30.html</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>利用反射机制，可以通过外部文件配置，在不修改源码的情况下控制程序，符合设计模型中OCP原则</p><ol><li>反射机制允许程序在执行期间借助于<code>Reflection</code>API取得任何类的内部信息（成员变量、构造器、成员方法等），并能操作对象的属性及方法。</li><li>加载类之后，在堆中产生了一个<code>Class</code>类型的对象，这个对象包括了类的完整结构信息。这个对象就像一面镜子，通过这个镜子看到类的结构，所以称之为：反射</li><li>反射可以做到的事：<ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ul></li><li>使用反射后，程序的执行速度会受到影响</li></ol><h2 id="反射相关的类"><a href="#反射相关的类" class="headerlink" title="反射相关的类"></a>反射相关的类</h2><p>常用的反射相关的类都在<code>java.lang</code>包中</p><ol><li>Class:代表一个类，表示某个类加载后在堆中的对象</li><li>reflect.Method:类的方法</li><li>reflect.Field:类的成员变量，<u>不能得到private属性</u></li><li>reflect.Constructor:构造器</li></ol><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ol><li>Class类也是继承Object的类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class对象，在内存中只有一份，因为类只加载一次（比如在使用反射加载类对象之前已经实例化过一次该类，就不会再调用loadClass方法）</li><li>Class对象存放在堆中</li><li>类的字节码二进制数据存放在方法区，称为类的元数据</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">static Class forName（）</td><td align="center">返回指定类名的Class对象</td></tr><tr><td align="center">Object newInstance()</td><td align="center">返回Class对象的一个实例</td></tr><tr><td align="center">String gatName()</td><td align="center">返回Class对象所表示的实体（类，接口，基本类型等）的名称</td></tr><tr><td align="center">Class getSuperClass()</td><td align="center">返回其父类</td></tr><tr><td align="center">Constructor[] getConstructors()</td><td align="center">返回本类的构造器</td></tr><tr><td align="center">ClassLoader getClassLoader()</td><td align="center">返回类的加载器</td></tr><tr><td align="center">Field[] getFields()</td><td align="center">返回所有public修饰的属性，包括本类及父类</td></tr><tr><td align="center">Field[] getDeclaredFields()</td><td align="center">返回本类所有属性</td></tr><tr><td align="center">Method[] getMethods()</td><td align="center">返回所有public修饰的方法，包括本类及父类</td></tr><tr><td align="center">Method[] getDeclaredMethods()</td><td align="center">返回本类所有方法</td></tr></tbody></table><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><ol><li>若已知一个类的完整路径“包名.类名”，可以通过Class类的<code>forName()</code>获取。<u>应用场景</u>：配置文件，读取类全路径，加载类</li><li>若已知具体的类，可以通过<code>类.class</code>获取，该方式也可以获取基本数据类型的Class对象。<u>应用场景</u>：用于参数传递，如通过反射的对应构造器对象。</li><li>如果已经有该类的实例，可以通过<code>对象.getClass()</code>获取Class对象</li><li>通过类加载器获取：</li></ol><blockquote><p>ClassLoader classLoader &#x3D; test.getClass().getClassLoader();</p><p>Class cls &#x3D; classLoader.loadClass(classAllPath);&#x2F;&#x2F; classAllPath为类的完整路径</p></blockquote><ol start="5"><li>基本数据类型的包装类（Integer，Boolean等）可以通过<code>.TYPE</code>获取Class对象</li></ol><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p>类加载分为<u>静态加载</u>和<u>动态加载</u>。</p><p>静态加载：编译时加载相关的类，如果没有则报错，哪怕不一定会用到这个类，也会加载</p><p>动态加载：运行时加载需要的类，如果运行时不用该类就不会报错，反射使用的就是动态加载方案</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanf.nextInt();</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">// 静态加载，哪怕可能不会使用到这个类也会加载，会直接报错</span></span><br><span class="line">                dog.method();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Dog&quot;</span>);<span class="comment">// 动态加载，当使用到的时候才会报错</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">                m.invoke();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h5><p>大体流程如下图所示。</p><p><img src="/inori/e29c8e30/java%E5%8F%8D%E5%B0%84%5CClassLoad.png"></p><p>​首先对源码进行编译，生成字节码文件，在运行时进入类加载，由类加载器将类的class文件读入内存，并创建一个Class对象。</p><p>然后进入连接阶段，把二进制数据合并到JRE中，<u>验证：</u>对文件安全性进行验证，<u>准备：</u>对静态变量进行默认初始化并分配空间，解析：把符号引用转成直接引用（地址引用）。最后进行初始化，由JVM负责，执行<code>&lt;clinit&gt;()</code>方法。</p><p>​<code>&lt;clinit&gt;()</code>方法是由编译器按照语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值动作和静态代码块中的语句，并进行合并。虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁，同步。如果多个线程同时去初始化一个类，同一时间内只允许一个线程执行此方法。</p><h3 id="Field类常用方法"><a href="#Field类常用方法" class="headerlink" title="Field类常用方法"></a>Field类常用方法</h3><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">getModifiers()</td><td align="center">以int形式返回修饰符</td></tr><tr><td align="center">getType()</td><td align="center">以Class形式获取返回类型</td></tr><tr><td align="center">getName()</td><td align="center">返回属性名</td></tr><tr><td align="center">getParameterTypes()</td><td align="center">以Class[] 返回参数类型数组</td></tr></tbody></table><p>注：在<code>getModifiers()</code>方法中，返回的int形式为：默认是0，public是1，private是2，protected是4，static是8，final是16。如果有多个修饰符就代数相加。</p><h2 id="反射暴破"><a href="#反射暴破" class="headerlink" title="反射暴破"></a>反射暴破</h2><p>使用反射机制访问private属性、方法、构造器，称为暴破（暴力破解），可以破坏封装特性。  </p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取person类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; person = Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> person.getDeclaredConstructor().newInstance();  <span class="comment">// 创建无参实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建private有参实例</span></span><br><span class="line">        Constructor&lt;?&gt; privateConstructor = person.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        privateConstructor.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴破</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> privateConstructor.newInstance(<span class="string">&quot;Mary&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> person.getDeclaredField(<span class="string">&quot;name&quot;</span>);   <span class="comment">// 获取name属性</span></span><br><span class="line">        name.set(o, <span class="string">&quot;Jack&quot;</span>);    <span class="comment">// 修改name</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">toString</span> <span class="operator">=</span> person.getMethod(<span class="string">&quot;toString&quot;</span>);     <span class="comment">// 获取toString方法</span></span><br><span class="line">        <span class="comment">// 如果方法有返回值，统一返回Object，但是运行类型和方法定义的返回类型一致</span></span><br><span class="line">        System.out.println(toString.invoke(o));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取private属性age</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> person.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.setAccessible(<span class="literal">true</span>);    <span class="comment">// 暴破</span></span><br><span class="line">        age.set(o, <span class="number">23</span>); <span class="comment">// 修改age</span></span><br><span class="line">        System.out.println(age.get(o)); <span class="comment">// 获取age的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取private方法say，如果方法中要求传参，则需要在后面输入参数对应的Class类</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">say</span> <span class="operator">=</span> person.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">        say.setAccessible(<span class="literal">true</span>);    <span class="comment">// 暴破</span></span><br><span class="line">        say.invoke(o1, <span class="string">&quot;success&quot;</span>, <span class="number">1</span>);  <span class="comment">// 激活方法并传入参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String word, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用say方法：&quot;</span> + word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程基础</title>
      <link href="/inori/bc47619b.html"/>
      <url>/inori/bc47619b.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p> 大都是计算机网络的基础知识，这里仅复习一下重点概念。</p><ol><li>IP地址&#x3D;网络地址+主机地址</li><li>IPv4最大的问题在于网络地址资源有限，制约了互联网的应用与发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</li><li>端口号用于标识计算机上某个特定的网络程序，范围是<strong>0~65535</strong>，其中<strong>0~1024</strong>已经被占用，当浏览器或程序要请求特定IP的某些服务时，需要使用IP地址+端口号的形式访问</li><li>常见的端口号：</li></ol><blockquote><p>ssh:22 ftp:21 smtp:25 http: 80</p><p>tomcat: 8080 mysql:3306 oracle:1521 sqlserver:1433</p></blockquote><ol start="5"><li>OSI七层模型是理论上的，并没有实际使用。主要使用的是TCP&#x2F;IP模型四层模型，分为：应用层、传输层、网际层、网络接口层</li><li>TCP协议：<ul><li>使用TCP前需要“三次握手”建立连接，形成传输数据通道，进行可靠传输</li><li>TCP协议进行通信的两个应用进程：客户端、服务端</li><li>在连接中可进行大数据量的传输</li><li>传输完毕需要释放已建立的连接，效率较低</li></ul></li><li>UDP协议：<ul><li>将数据、源、目的地封装成数据包，不需要建立连接，不可靠传输</li><li>每个数据包大小限制64KB</li><li>传输效率高</li></ul></li></ol><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><p>一般使用java.net包进行网络编程</p><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><ol><li>getLocalHost:获取本机的InetAddress对象</li><li>getByName:根据指定的主机名&#x2F;域名获取IP地址对象</li><li>getHostName:获取InetAddress对象的主机名</li><li>getHostAddress:获取InetAddress对象的IP地址</li></ol><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket（套接字）已经成为开发网络应用程序的标准，两台机器进行网络通信时，两端都要有Socket，作为两台机器间通信的端点，网络通信本质上就是Socket间的通信。</p><p>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输，一般主动发起通信的应用程序为客服端，等待通信请求的是服务端。</p><h4 id="Socket-TCP通信"><a href="#Socket-TCP通信" class="headerlink" title="Socket-TCP通信"></a>Socket-TCP通信</h4><p>当需要TCP进行通讯时，使用<code>socket.getOutputStream()和socket.getInputStream()</code>，当客户端连接到服务端时，客户端会由TCP&#x2F;IP协议分配一个端口与服务端进行通信。</p><p>服务器端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端正在侦听&quot;</span> + port + <span class="string">&quot;端口&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();  <span class="comment">// 没侦听到程序就会阻塞在这，如果侦听到了就会返回Socket对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> readLen;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>((readLen = inputStream.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            str += <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用完毕后要关闭连接</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLoaclHost(), <span class="number">9999</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;Hello,Server&quot;</span>.getBytes());</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Socket-UDP通信"><a href="#Socket-UDP通信" class="headerlink" title="Socket-UDP通信"></a>Socket-UDP通信</h4><ol><li>类<strong>DategramSocket</strong>和<strong>DatagramPacket</strong>实现了基于UDP协议的网络通信</li><li>没有明确的服务端和客户端，只有数据的发送端与接收端，并且两者身份可互换</li><li>接收数据和发送数据是通过<strong>DatagramSocket</strong>对象完成</li><li>将数据封装到<strong>DatagramPacket</strong>对象中装包</li><li>当接收到<strong>DatagramPacket</strong>对象时需要进行拆包，取出数据</li></ol><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>端口1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Port1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">        ds.receive(res);<span class="comment">// 开一个缓冲区，从其他端口处接收消息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> res.getLength();</span><br><span class="line">        <span class="type">byte</span>[] data = res.getData();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        ds.close();<span class="comment">// 最后要关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>端口2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Port2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你想说什么？&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanf.next();</span><br><span class="line">        <span class="type">byte</span>[] buf = s.getBytes();</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">sen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, InetAddress.getLocalHost(), <span class="number">9999</span>);<span class="comment">// 发送数据到指定端口</span></span><br><span class="line">        ds.send(sen);</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaIO流</title>
      <link href="/inori/47e3b155.html"/>
      <url>/inori/47e3b155.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>​文件在程序中是以流的形式来操作的，文件保存在硬盘中，通过输入流被java程序读取，程序再通过输出流输出进文件中。流是数据在数据源和程序之间经历的路径，输入流是数据从数据源到程序的路径，输出流是程序到数据源的路径。</p><p>​java.io包中提供了各种流类和接口，以获取不同种类的数据，并通过方法输入或输出数据。</p><h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ul><li>按照数据单位可以分为：字节流（8bit）、字符流</li><li>按照数据流向分为：输入流、输出流</li><li>按照流的角色不同分为：节点流、处理流&#x2F;包装流</li></ul><h2 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a>常用的文件操作</h2><ol><li><p>创建文件对象相关构造器和方法</p><ul><li><code>new File(String pathname)</code>：根据路径创建文件对象</li><li><code>new File(File parent, String child)</code>：根据父目录文件+子路径构建</li><li><code>new File(String parent, String child)</code>：同上</li></ul></li><li><p>获取文件相关信息</p><ul><li><code>getName</code>：获取文件名</li><li><code>getAbsolutePath</code>：获取绝对路径</li><li><code>getParent</code>：获取文件父目录</li><li><code>length</code>：获取文件占用字节</li><li><code>exists</code>：文件是否存在</li><li><code>isFile</code>：是否为文件</li><li><code>isDirectory</code>：是否为文件夹</li><li><code>delete</code>：删除文件</li><li><code>mkdir/mkdirs</code>创建目录&#x2F;多级目录</li></ul></li></ol><h2 id="常用IO类"><a href="#常用IO类" class="headerlink" title="常用IO类"></a>常用IO类</h2><ol><li><p>InputStream&#x2F;OutputStream：从文件中读取字节的类，有基本的字节输入输出功能，常使用byte数组进行接收和写入</p><ul><li>使用<code>getBytes</code>将字符串转成Byte数组，从而对文件进行写入</li><li>使用完输出输入流之后一定要关闭流，可以使用<code>try-with-resources</code>语句来确保资源的正确关闭。</li></ul></li></ol><p>综合使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="string">&quot;/source.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destinationFilePath</span> <span class="operator">=</span> <span class="string">&quot;/destination.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try-with-resources语法：在try语句中初始化流类</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFilePath));</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destinationFilePath))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取并写入文件</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;File copied successfully.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Reader&#x2F;Writer：从文件中读取字符的类，主要用于处理字符数据。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="string">&quot;/source.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destinationFilePath</span> <span class="operator">=</span> <span class="string">&quot;/destination.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try-with-resources语法：在try语句中初始化流类</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(sourceFilePath);</span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destinationFilePath)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取并写入文件</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;File copied successfully.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>节点流可以从一个特定的数据源读写数据，如上面使用的FileReader、FileWriter。节点流是底层流，直接与数据源相接。</p></li><li><p>处理流（包装流）是连接已存在的流，以增加缓冲的方式来提高输入输出的效率，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWritter。处理流既可以消除不同节点流的实现差异，也可以提供方便的方法来完成输入输出。处理流使用了修改器设计模式，不会与数据直接相连。</p></li><li><p>对象流ObjectInputStream&#x2F;ObjectOutputStream是用于对象序列化和反序列化的类。它们可以将对象转换为字节流，以便在网络上传输或保存到文件中。</p><ul><li><p>序列化就是在保存数据时，保存数据的值和数据类型</p></li><li><p>反序列就是在恢复数据时，恢复数据的值和数据类型</p></li><li><p>如果想让某个对象支持序列化，则其类必须实现<strong>Serializable</strong>(推荐，该类为标记接口，不需要实现方法）和<strong>Externalizable</strong>两个接口<u>其中之一</u></p></li><li><p>反序列化时，读取的顺序需要和序列化的顺序一致，并且返回的是Object类型，需要向下转型</p></li><li><p>序列化的类中建议添加<code>SerialVersionUID</code>，为了提高版本兼容性</p></li><li><p>序列化对象时，默认里面所有属性都会序列化（所以要求该类中所有的属性必须可序列化），除了<code>static</code>或<code>transient</code>修饰的成员</p></li><li><p>序列化可继承，父类实现了序列化，则其所有子类都可以序列化</p></li></ul></li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">testPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\test.dat&quot;</span>;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(testPath));</span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(testPath));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person_</span> <span class="operator">=</span> (Person)ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;<span class="comment">// 测试用的序列化类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String likedColor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String likedColor)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.likedColor = likedColor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, likedColor=&#x27;&quot;</span> + likedColor + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>标准输入输出流<code>System.in/System.out</code>：</p><ul><li><p><code>System.in</code>编译类型为InputStream，运行类型为BufferedInputStream，输入对象为键盘</p></li><li><p><code>System.out</code>编译类型和运行类型均为PrintStream，输出对象为显示器</p></li></ul></li><li><p>转换流<code>InputStreamReader/OutputStreamWriter</code>：</p><ul><li><code>InputStreamReader</code>：可以将<code>InputStream</code>包装成<code>Reader</code></li><li><code>OutputStreamWriter</code>：可以将<code>OutputStream</code>包装成<code>Writer</code></li><li>可以在使用时指定编码格式</li></ul></li></ol><p><img src="/inori/47e3b155/javaIO%E6%B5%81%5CIOType.png"></p><h2 id="Properties读写文件"><a href="#Properties读写文件" class="headerlink" title="Properties读写文件"></a>Properties读写文件</h2><p>​在java集合类中介绍过，Properties类是一种专门用于读写配置文件的集合类。在项目过程中经常要从数据库中读文件，读取的文件类型经常是.properties文件。在Properties文件中配置文件的格式为：<code>key=value</code>，默认格式为String。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol><li>load：加载配置文件的键值对到Properties对象</li><li>store：将Properties中的键值对存储到配置文件，在IDEA中，保存时如果有中文，会存储为unicode码</li><li>list：将数据显示到指定设备&#x2F;流对象</li><li><code>getProperty(key)</code>：根据键获取值</li><li><code>setProperty(key, value)</code>：设置键值对到Properties对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pro.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">// 把键值对显示到控制台</span></span><br><span class="line">        pro.list(System.out);</span><br><span class="line">        <span class="comment">// 根据键获取值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="comment">// 存储键值对到Properties文件中</span></span><br><span class="line">        pro.setProperty(<span class="string">&quot;user2&quot;</span>, <span class="string">&quot;inori&quot;</span>);</span><br><span class="line">        pro.setProperty(<span class="string">&quot;pwd2&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        pro.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/mysql2.properties&quot;</span>), <span class="literal">null</span>); <span class="comment">// 想要写入必须保存，第二个参数为想要写入的注释，如果不为null的话会写在文件的第一行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础</title>
      <link href="/inori/9da8abfe.html"/>
      <url>/inori/9da8abfe.html</url>
      
        <content type="html"><![CDATA[<p>在操作系统之上，可以同时运行很多个进程，并且每个进程之间相互隔离互不干扰。CPU会通过时间片轮转算法，为每一个进程分配时间片，并在时间片使用结束后切换下一个进程继续执行，通过这种方式来实现宏观上的多个程序同时运行。</p><p>由于每个进程都有一个自己的内存空间，进程之间的通信就变得非常麻烦（比如要共享某些数据）而且执行不同进程会产生上下文切换，非常耗时</p><p>后来，线程的概念被提出，一个进程可以有多个线程，线程是程序执行中一个单一的顺序控制流程，现在线程才是程序执行流的最小单元，各个线程之间共享程序的内存空间（也就是所在进程的内存空间），上下文切换速度也高于进程。</p><p>很多框架都在使用多线程，比如Tomcat服务器，所有用户的请求都是通过不同的线程来进行处理的，这样网站才可以同时响应多个用户的请求。</p><p>虽然多线程能够解决很多问题，但是，如何才能正确地使用多线程，如何才能将多线程的资源合理使用，这都是我们需要关心的问题。</p><p>在Jdk1.5的时候，新增了java.util.concurrent（JUC）包，其中包括大量用于多线程编程的工具类，目的是为了更好的支持高并发任务，让开发者进行多线程编程时减少竞争条件和死锁的问题！通过使用这些工具类，我们的程序会更加合理地使用多线程。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>线程：</p><ul><li>程序执行的最小单元，是进程中的一个独立执行流</li><li>一个进程可以包含多个线程，这些线程共享进程的资源（如内存、文件等）</li></ul><p>多线程（Multithreading）：在一个进程中同时运行多个线程，每个线程执行不同的任务</p><p>并发（Concurrency）：多个任务在同一时间段内交替执行，看起来像是同时执行</p><p>并行（Parallelism）：多个任务在同一时刻同时执行，通常需要多核CPU的支持</p><h3 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h3><ul><li>继承<code>Thread</code>类并重写<code>run()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程运行中: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现<code>Runnable</code>接口并将其实例传递给<code>Thread</code>对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程运行中: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现 <code>Callable</code> 接口，可以返回线程的执行结果，并通过 <code>Future</code> 获取结果</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;线程运行结果: &quot;</span> + Thread.currentThread().getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">MyCallable</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start(); <span class="comment">// 启动线程</span></span><br><span class="line">        System.out.println(futureTask.get()); <span class="comment">// 获取线程执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li><code>start()</code>：启动线程，使其进入就绪状态</li><li><code>run()</code>：线程执行的主体方法</li><li><code>sleep(long millis)</code>：让线程休眠指定的毫秒数</li><li><code>join()</code>：等待线程执行完毕</li><li><code>interrupt()</code>：中断线程</li><li><code>isAlive()</code>：判断线程是否处于活动状态</li></ul><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><p>使用<code>synchronized</code>关键字来实现锁，能够很好地解决线程之间争抢资源的情况。<code>synchronized</code>底层如何实现的？</p><p>使用<code>synchronized</code>，一定是和某个对象相关联的，比如要对某一段代码加锁，就需要提供一个对象来作为锁本身：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Main.class) &#123;</span><br><span class="line">        <span class="comment">//这里使用的是Main类的Class对象作为锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序变成字节码之后，会使用<code>monitorenter</code>和<code>monitorexit</code>分别对应加锁和释放锁，在执行<code>monitorenter</code>之前需要尝试获取锁，每个对象都有一个<code>monitor</code>监视器与之对应，而这里正是去获取对象监视器的所有权，一旦<code>monitor</code>所有权被某个线程持有，那么其他线程将无法获得（管程模型的一种实现）。</p><p><img src="/inori/9da8abfe/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%5Csynchronized_byteCode.png"></p><p>在代码执行完成之后，可以观察到字节码中一共有两个<code>monitorexit</code>，那么为什么这里会有两个呢？</p><p>第一个，在释放锁之后，会马上进入到一个goto指令，跳转到方法的返回指令，正常情况下只会执行第一个<code>monitorexit</code>释放锁，在释放锁之后就接着同步代码块后面的内容继续向下执行了。</p><p>第二个，其实是用来处理异常的，如果程序运行发生异常，那么就会执行第二个<code>monitorexit</code>，并且会继续向下通过<code>athrow</code>指令抛出异常</p><p>在 JVM中，锁的开销很大，为了提高效率，Java 采用了一种<strong>逐步升级的锁优化机制</strong>，即：</p><ol><li><strong>无锁状态（Normal Object）</strong></li><li><strong>偏向锁（Biased Locking）</strong></li><li><strong>轻量级锁（Lightweight Locking）</strong></li><li><strong>重量级锁（Heavyweight Locking）</strong></li></ol><p>升级原则：</p><ul><li>当锁竞争激烈时，锁会逐步升级（偏向锁 → 轻量级锁 → 重量级锁）</li><li><strong>锁不会降级</strong>（为了避免频繁升级&#x2F;降级带来的性能开销）</li></ul><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>在JDK6之前，<code>synchronized</code>一直被称为重量级锁，<code>monitor</code>依赖于底层操作系统的Lock实现，Java的线程是映射到操作系统的原生线程上，切换成本较高。而在JDK6之后，锁的实现得到了改进。</p><p>在Java虚拟机（HotSpot）中，monitor是由ObjectMonitor实现的，每个等待锁的线程都会被封装成ObjectWaiter对象</p><p><img src="/inori/9da8abfe/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%5Clock1.png"></p><p>ObjectWaiter首先会进入Entry Set，当线程获取到对象的<code>monitor</code>后进入The Owner区域并把<code>monitor</code>中的<code>owner</code>变量设置为当前线程，同时<code>monitor</code>中的计数器<code>count ++</code>，若线程调用<code>wait()</code>方法，将释放当前持有的<code>monitor</code>，<code>owner</code>变量恢复为<code>null</code>，<code>count --</code>，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放<code>monitor</code>并复位变量的值，以便其他线程进入获取对象的<code>monitor</code>.</p><p>在JDK1.4.2时，引入了自旋锁（JDK6之后默认开启），它不会将处于等待状态的线程挂起，而是通过循环的方式，不断检测是否能够获取锁，由于单个线程占用锁的时间非常短，所以说循环次数不会太多，可能很快就能够拿到锁并运行，这就是自旋锁。当然，仅仅是在等待时间非常短的情况下，自旋锁的表现会很好，但是如果等待时间太长，由于循环是需要处理器继续运算的，所以这样只会浪费处理器资源，因此自旋锁的等待时间是有限制的，默认情况下为10次，如果失败，那么会进而采用重量级锁机制。</p><p>在JDK1.6之后，自旋锁得到了一次优化，自旋的次数限制不再是固定的，而是自适应变化的，比如在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么这次自旋也是有可能成功的，所以会允许自旋更多次。当然，如果某个锁经常都自旋失败，那么有可能会不再采用自旋策略，而是直接使用重量级锁。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>基于操作系统的互斥锁（Mutex）实现，涉及线程阻塞和内核态切换</li><li>当一个线程获取锁，其他线程必须等待，会导致线程进入阻塞（Blocking）状态</li><li>加锁和解锁的开销较高，因为涉及线程切换和操作系统调度</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>线程竞争严重（多个线程频繁竞争同一个锁）</li><li>需要避免CPU自旋浪费资源（比如轻量级锁在竞争过高时，会导致 CPU 资源被自旋锁消耗）</li><li>适用于IO密集型任务（比如数据库操作、文件读写等场景）</li></ul><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>从JDK1.6开始，为了减少获得锁和释放锁带来的性能消耗，就引入了轻量级锁</p><p>轻量级锁的目标是，如果一个线程想获取锁，它不会立刻进入阻塞状态，而是尝试使用 CAS 进行自旋获取锁，减少线程上下文切换的开销。它不像是重量级锁那样，需要向操作系统申请互斥量。</p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>锁对象的Mark Word结构</li></ol><ul><li>Java中每个对象的对象头（Header）中都有一个Mark Word，其中存储了锁的信息</li><li>默认情况下（无锁状态），Mark Word存储的是对象的hashCode、GC信息等</li><li>当线程尝试获取锁时：<ul><li>JVM会尝试使用CAS将对象头的Mark Word设置为线程ID</li><li>如果CAS成功，则表示线程获取到锁，进入轻量级锁状态</li><li>如果CAS失败，则表示有其他线程竞争该锁，会进入自旋状态继续尝试</li></ul></li></ul><ol start="2"><li>自旋锁</li></ol><ul><li>线程会通过短时间循环尝试获取锁（自旋），如果成功，则进入同步代码块</li><li>如果自旋失败（即有多个线程竞争锁），轻量级锁会升级为重量级锁</li></ul><ol start="3"><li>释放锁</li></ol><ul><li>线程退出同步代码块时，JVM会使用CAS操作，将对象的Mark Word还原为无锁状态</li><li>如果在执行过程中没有发生锁升级（没有其他线程竞争），那么整个加锁解锁过程仅使用CAS，没有线程阻塞或上下文切换</li></ul><p><img src="/inori/9da8abfe/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%5Clock2.png"></p><h4 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h4><p>CAS（Compare-And-Swap）是一种无锁编程技术，用于实现多线程环境下的原子操作，用于比较并交换内存中的值</p><p>CAS采用乐观锁机制，假设操作不会发生冲突，只有在冲突时才会重试</p><p>CAS操作包含3个参数：</p><ul><li>预期值（expected value，E）：期望变量的原始值</li><li>目标变量（memory location，V）：需要修改的内存地址</li><li>新值（new value，N）：要更新的值</li></ul><p>执行逻辑：</p><p>如果<code>V == E</code>（变量的当前值等于期望值），则将<code>V</code>更新为<code>N</code></p><p>否则，说明有其他线程修改了<code>V</code>，不执行更新，继续重试（通常是自旋）</p><p>比如有两个线程都需要修改变量<code>i</code>的值，默认为10，现在一个线程要将其修改为20，另一个要修改为30，如果他们都使用CAS算法，那么并不会加锁访问<code>i</code>，而是直接尝试修改<code>i</code>的值，但是在修改时，需要确认<code>i</code>是不是10，如果是，表示其他线程还没对其进行修改，如果不是，那么说明其他线程已经将其修改，此时不能完成修改任务，修改失败</p><h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><p>每个Java对象在内存中都有一个对象头，对象头包括以下两部分：</p><ol><li><strong>Mark Word</strong>：存储对象的运行时数据，如锁状态、哈希码、GC分代年龄等</li><li><strong>Klass Pointer</strong>：指向对象的类元数据（Class Metadata）的指针</li></ol><p>在 64 位 JVM 中，对象头的结构如下：</p><ul><li><strong>Mark Word</strong>：64 位（8 字节）</li><li><strong>Klass Pointer</strong>：64 位（8 字节）</li></ul><h5 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h5><p>Mark Word 的存储内容根据对象的状态动态变化，主要包括以下几类信息：</p><ol><li>锁状态：无锁、偏向锁、轻量级锁、重量级锁等</li><li>哈希码：对象的默认哈希码（<code>hashCode()</code> 方法返回的值）</li><li>GC 分代年龄：对象在垃圾回收过程中的年龄（用于分代回收）</li><li>其他标志位：用于标记对象的状态，如是否被锁定、是否偏向锁等</li></ol><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁旨在减少无竞争情况下的同步开销。如果一个锁对象（<code>ObjectMonitor</code>）在整个生命周期中只被一个线程访问，那这个线程可以“偏向”该锁，无需进行CAS操作，避免锁的竞争。只有当其他线程尝试竞争锁时，才会撤销偏向锁，升级为轻量级锁甚至重量级锁。</p><h4 id="过程-1"><a href="#过程-1" class="headerlink" title="过程"></a>过程</h4><p>加锁过程：</p><ol><li>线程进入同步代码块，尝试获取对象的锁</li><li>如果该对象是无锁状态（即Mark Word里线程ID为空）</li></ol><ul><li>直接将当前线程ID记录到对象的Mark Word中</li><li>偏向该线程，以后该线程进入同步块时，无需CAS操作</li></ul><ol start="3"><li>如果Mark Word里的<code>线程ID==当前线程ID</code>，说明这个线程已经获得偏向锁，直接进入同步块</li></ol><p>解锁过程：</p><ol><li>线程退出同步块时，不会释放锁，仍然偏向该线程，避免下次加锁时CAS操作</li><li>只有当其他线程尝试获取锁（其他线程访问锁对象时，发现Mark Word中的线程ID不属于自己）时，才会撤销偏向锁（升级为轻量级锁）</li></ol><p><img src="/inori/9da8abfe/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%5Clock3.png"></p><h3 id="三种锁的对比"><a href="#三种锁的对比" class="headerlink" title="三种锁的对比"></a>三种锁的对比</h3><table><thead><tr><th><strong>锁类型</strong></th><th><strong>适用场景</strong></th><th><strong>加锁方式</strong></th><th><strong>开销</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>偏向锁</strong></td><td><strong>无竞争</strong></td><td>记录线程 ID</td><td><strong>最小</strong></td><td>无需 CAS，效率最高</td><td>竞争时需要STW（暂停线程）</td></tr><tr><td><strong>轻量级锁</strong></td><td><strong>少量竞争</strong></td><td>CAS + 自旋</td><td><strong>较低</strong></td><td>避免线程阻塞</td><td>竞争高时 CPU 消耗大</td></tr><tr><td><strong>重量级锁</strong></td><td><strong>高竞争</strong></td><td>内核阻塞</td><td><strong>最高</strong></td><td>线程安全性强</td><td>线程切换开销大</td></tr></tbody></table><h3 id="锁消除和锁粗化"><a href="#锁消除和锁粗化" class="headerlink" title="锁消除和锁粗化"></a>锁消除和锁粗化</h3><p>锁消除和锁粗化都是在运行时的一些优化方案，锁消除是比如我们某段代码虽然加了锁，但是在运行时根本不可能出现各个线程之间资源争夺的情况，这种情况下，完全不需要任何加锁机制，所以锁会被消除。锁粗化则是我们代码中频繁地出现互斥同步操作，比如在一个循环内部加锁，这样明显是非常消耗性能的，所以虚拟机一旦检测到这种操作，会将整个同步范围进行扩展。</p><h2 id="JMM内存模型（JMM）"><a href="#JMM内存模型（JMM）" class="headerlink" title="JMM内存模型（JMM）"></a>JMM内存模型（JMM）</h2><p>这里提到的内存模型和JVM中介绍的内存模型不在同一个层次，JVM中的内存模型是虚拟机规范对整个内存区域的规划，而Java内存模型，是在JVM内存模型之上的抽象模型，具体实现依然是基于JVM内存模型实现的。</p><p>主要解决的问题：</p><ul><li>原子性：一个操作是不可分割的整体</li><li>可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</li><li>有序性：代码的执行顺序与编写顺序一致</li></ul><p>JMM（Java Memory Model）内存模型规定：</p><ul><li>所有的变量全部存储在主内存（指的是会出现竞争的变量，包括成员变量、静态变量等，而局部变量这种属于线程私有，不包括在内）</li><li>每条线程有着自己的工作内存（可以类比CPU的高速缓存）线程对变量的所有操作，必须在工作内存中进行，不能直接操作主内存中的数据</li><li>不同线程之间的工作内存相互隔离，如果需要在线程之间传递内容，只能通过主内存完成，无法直接访问对方的工作内存</li></ul><p><img src="/inori/9da8abfe/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%5Cjmm.png"></p><p>也就是说，每一条线程如果要操作主内存中的数据，那么得先拷贝到自己的工作内存中，并对工作内存中数据的副本进行操作，操作完成之后，也需要从工作副本中将结果拷贝回主内存中，具体的操作就是<code>Save</code>（保存）和<code>Load</code>（加载）操作。</p><p>内存模型具体实现：</p><ul><li>主内存：对应堆中存放对象的实例的部分</li><li>工作内存：对应线程的虚拟机栈的部分区域，虚拟机可能会对这部分内存进行优化，将其放在CPU的寄存器或是高速缓存中。比如在访问数组时，由于数组是一段连续的内存空间，所以可以将一部分连续空间放入到CPU高速缓存中，那么之后如果我们顺序读取这个数组，那么大概率会直接缓存命中</li></ul><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p><code>volatile</code>关键字可以解决可见性问题。</p><p>如果多线程访问同一个变量，那么这个变量会被线程拷贝到自己的工作内存中进行操作，而不是直接对主内存中的变量本体进行操作，下面这个操作看起来是一个有限循环：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>);<span class="comment">// 线程永远不会结束</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在修改a的值...&quot;</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决这种问题，使用加锁的方法同一时间只能有一个线程使用，这样的话是可以解决问题的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Main.class)&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在修改a的值...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (Main.class)&#123;</span><br><span class="line">            a = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，除了硬加一把锁的方案，也可以使用<code>volatile</code>关键字来解决，此关键字的第一个作用，就是保证变量的可见性。当写一个<code>volatile</code>变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去，并且这个写会操作会导致其他线程中的<code>volatile</code>变量缓存无效，这样，另一个线程修改了这个变时，当前线程会立即得知，并将工作内存中的变量更新为最新的版本。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">//添加volatile关键字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (a == <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程结束！&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;正在修改a的值...&quot;</span>);</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当a发生改变时，循环立即结束。</p><p>虽然说<code>volatile</code>能够保证可见性，但是不能保证原子性，保证原子性可以使用原子类来解决</p><p><code>volatile</code>会禁止指令重排，即volatile变量不会出现重排序的情况</p><p>若用volatile修饰共享变量，在编译时，会在指令序列中插入<code>内存屏障</code>来禁止特定类型的处理器重排序</p><blockquote><p>内存屏障（Memory Barrier）是一个CPU指令，它的作用有两个：</p><ol><li>保证特定操作的顺序</li><li>保证某些变量的内存可见性（volatile的内存可见性，其实就是依靠这个实现的）</li></ol><p>由于编译器和处理器都能执行指令重排的优化，如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序</p><p><img src="https://oss.itbaima.cn/internal/markdown/2023/03/06/upc28A41DwCBNO9.png" alt="image-20230306171216983"></p></blockquote><h3 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h3><p>JMM提出了<code>happens-before</code>（先行发生）原则，定义一些禁止编译优化的场景，只要是按照原则进行编程，那么就能够保持并发编程的正确性</p><ul><li><p><strong>程序次序规则：</strong>同一个线程中，按照程序的顺序，前面的操作happens-before后续的任何操作</p><ul><li>同一个线程内，代码的执行结果是有序的。其实就是，可能会发生指令重排，但是保证代码的执行结果一定是和按照顺序执行得到的一致，程序前面对某一个变量的修改一定对后续操作可见的，不可能会出现前面才把a修改为1，接着读a居然是修改前的结果，这也是程序运行最基本的要求</li></ul></li><li><p><strong>监视器锁规则：</strong>对一个锁的解锁操作，happens-before后续对这个锁的加锁操作</p><ul><li>就是无论是在单线程环境还是多线程环境，对于同一个锁来说，一个线程对这个锁解锁之后，另一个线程获取了这个锁都能看到前一个线程的操作结果。比如前一个线程将变量<code>x</code>的值修改为了<code>12</code>并解锁，之后另一个线程拿到了这把锁，对之前线程的操作是可见的，可以得到<code>x</code>是前一个线程修改后的结果<code>12</code>（所以synchronized是有happens-before规则的）</li></ul></li><li><p><strong>volatile变量规则：</strong>对一个volatile变量的写操作happens-before后续对这个变量的读操作</p><ul><li>就是如果一个线程先去写一个<code>volatile</code>变量，紧接着另一个线程去读这个变量，那么这个写操作的结果一定对读的这个变量的线程可见</li></ul></li><li><p><strong>线程启动规则：</strong>主线程A启动线程B，线程B中可以看到主线程启动B之前的操作</p><ul><li>在主线程A执行过程中，启动子线程B，那么线程A在启动子线程B之前对共享变量的修改结果对线程B可见</li></ul></li><li><p><strong>线程加入规则：</strong>如果线程A执行操作<code>join()</code>线程B并成功返回，那么线程B中的任意操作happens-before线程A<code>join()</code>操作成功返回</p></li><li><p><strong>传递性规则：</strong>如果A happens-before B，B happens-before C，那么A happens-before C</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="/inori/4b0d9081.html"/>
      <url>/inori/4b0d9081.html</url>
      
        <content type="html"><![CDATA[<h2 id="集合的好处"><a href="#集合的好处" class="headerlink" title="集合的好处"></a>集合的好处</h2><p>之前保存多个数据的时候一直都是用的数组，但是数组</p><ol><li>长度开始时必须指定，而且一旦指定，不能更改</li><li>保存的必须为同一类型的元素</li><li>使用数组进行增加&#x2F;删除元素时比较麻烦</li></ol><p>但是集合避免了这些缺点，可以动态保存任意多个对象。</p><p>常用的集合主要可以分为两类</p><ol><li>单列集合Collection<ul><li>List：ArrayList、LinkedList、Vector</li><li>Set：HashSet、TreeSet</li></ul></li><li>双列集合Map：HashMap、TreeMap、Hashtable、Properties</li></ol><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection是一个接口，不可以实例化。该类提供了一些通用方法，供实现该接口的类使用。</p><ol><li>size：集合中元素个数</li><li>isEmpty：检查集合是否为空</li><li>clear：清空集合</li></ol><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List实现了Collection接口，除了通用方法外，还含有：</p><ol><li>add（i,b)：把b元素添加到集合的i位置</li><li>addAll(i,b)：从i位置开始，把b中所有元素添加进来</li><li>get(i)：得到i位置上的元素</li><li>indexOf(a)&#x2F;lastIndexOf(a)：返回a在List中第一次&#x2F;最后一次出现的位置</li><li>remove(i)：移除并返回i位置上的元素</li><li>set(i,a)：将位置i上的元素替换成a</li><li>subList(i,j)：返回集合下标[i,j)的子集</li></ol><p><strong>ArrayList的扩容机制</strong>：当实例化对象时，可以指定大小。如果使用的无参构造器，则初始化大小为0，添加元素时，扩容为10。无论是否指定了初始大小，如果需要再次扩容，则每次扩充为原大小的1.5倍。</p><p><strong>Vector的扩容机制</strong>：当实例化对象时，可以指定大小。如果使用无参构造器，则初始化大小为10。如果需要扩容则按照两倍扩容。</p><p>Vector相比于ArrayList效率较低，但是Vector在源码中添加了<code>synchronized</code>修饰，保证了线程安全，因此在开发中，需要线程同步安全时，要考虑Vector。</p><p><strong>LinkedList</strong>：本质是双向链表，具有双向链表的一切特性，头尾部增删很快，改查很慢，不适合改查操作多的环境。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合内元素唯一，且不能通过索引查找，遍历顺序不能保证与插入顺序一致。可以使用<code>add</code>、<code>remove</code>方法。</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li>HashSet的底层是HashMap</li><li>添加一个元素时，先得到hash值，使用hash值转化成索引值</li><li>找到存储数据表table，看这个索引位置是否有已经存放的元素，如果没有就加入，如果有并且元素不同（使用equals比较），就添加到最后</li><li>在jdk8中，如果一条链表长度超过<code>TREEIFY_THRESHOLD</code>（默认是8），并且table大小≥<code>MIN_TREEIFY_CAPACITY</code>（默认是64），就会变成红黑树。</li><li>第一次添加元素时，table数组扩容到16，<code>临界值=threShold*loadFactor=最大长度*0.75=16*0.75=12</code></li><li>如果数组长度到了临界值，就会再次进行扩容，<code>容量=当前最大长度*2</code>，直到达到了树化条件，<code>新的临界值=最大长度*0.75</code></li><li>如果想保证元素的遍历顺序等于插入顺序，可以使用<strong>LinkedHashSet</strong>。</li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet是即有序集合，底层基于红黑树，能够确保集合元素按照升序或降序排列。</p><p>相比于HashSet新增的方法有：</p><ol><li>firse&#x2F;last：获取第一个&#x2F;最后一个元素</li><li>floor(a)&#x2F;ceiling(a)：获取小于等于&#x2F;大于等于a的最大&#x2F;最小元素</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map与Collection并列存在，用于保存具有映射关系的数据：键值对。Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中。</p><p>Map接口常用方法：</p><ol><li><code>put(key, value)</code>：添加键值对</li><li><code>remove()</code>：根据键删除映射关系</li><li><code>get(key)</code>：根据键获取值</li><li>size：获取元素个数</li><li>isEmpty：判断Map是否为空</li><li>clear：清空</li><li>containsKey：查找键是否存在</li><li>keySet：返回所有键的集合</li></ol><p>HashMap键值对的两种遍历方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.遍历键，找到值</span></span><br><span class="line">        <span class="keyword">for</span> (String key: hashMap.keySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> hashMap.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.使用entrySet获取键值对</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap没有实现同步，不保证线程安全。</p><p>HashTable与HashMap使用的方法基本一致，区别在于：</p><ol><li>HashTable的键和值都不能为null，否则会报空指针异常</li><li>HashTable是线程安全的，多个线程不能同时修改HashTable中的内容</li><li>HashTable在性能上比HashMap略差</li></ol><p>Properties类是用于处理属性文件的类，继承自HashTable类，并实现了Map接口，特点与HashTable类似。Properties主要用于从properties文件中加载数据到Properties类对象，并进行读取和修改。</p><p>方法：</p><ol><li><code>setProperty(key, value)</code>：添加属性</li><li><code>getProperty(key)</code>：获取属性</li><li>load：加载属性文件</li><li>store：保存属性文件</li></ol><p>TreeMap即有序键值对，可以保证插入的键有序排列，方法与HashMap大致相同，但是TreeMap不允许键为null，只允许值接null。</p><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>Collections是一个操作Set、List、Map等集合的工具类，其中提供了一系列的static方法对元素进行排序、查询和修改等操作。</p><p>主要方法：</p><ol><li>sort：对List进行升序排序，其中可以编写比较器对List指定排序方法</li><li>shuffle：打乱List中元素的顺序</li><li>reverse：对List进行翻转</li><li>swap：交换List中两个元素的位置</li><li>max&#x2F;min：返回集合中最大&#x2F;最小的元素</li><li><code>frequency(Collection, Object)</code>：返回Collection集合中Object的出现次数</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常用类及其方法</title>
      <link href="/inori/12697782.html"/>
      <url>/inori/12697782.html</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>针对八种基本数据类型相应的引用类型，有了类的特点，就能调用类中的方法。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>​这两个过程的主要用途在于使得在需要使用对象的场景中能够使用基本数据类型，以及在需要使用基本数据类型的场景中能够使用对象。例如，在集合类中，只能存储对象而不能存储基本数据类型，因此需要通过装箱将基本数据类型转换为对应的包装类对象。</p><p>​在jdk5之前，需要手动装箱与拆箱，jdk5及之后使用自动装箱与拆箱。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 手动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(num);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> Integer.valueOf(num);</span><br><span class="line">        <span class="comment">// 手动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自动装箱和拆箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ol><li>字符串的字符使用Unicode字符编码，无论字母还是汉字都占2字节</li><li>String类有很多构造器和构造器的重载，常用的有：</li></ol><blockquote><p>String s1 &#x3D; new String();</p><p>String s2 &#x3D; new String(String original);</p><p>String s3 &#x3D; new String(char[] a);</p><p>String s4 &#x3D; new String(char[] a, int startIndex, int count);</p><p>String s5 &#x3D; new String(byte[] b);</p></blockquote><ol start="3"><li>String类实现了接口Serializable（串行化：可以在网络传输）和接口Comparable（比较大小）</li><li>String是final类，不能被继承</li><li>String有属性private final char value[]，用于存放字符串内容</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li>equals：区分大小写，判断内容是否相等</li><li>equalsIgnoreCase：忽略大小写，判断内容是否相等</li><li>length：返回字符串长度</li><li>substring：截取指定范围的子串，前闭后开区间</li><li>trim：去掉前后空格</li><li>charAt：获取索引处字符</li><li>toUpperCase：把字符串全部转换成大写</li><li>toLowerCase：把字符串全部转换成小写</li><li>replace：<code>str.replace(a,b)</code>将str中所有的a替换成b</li><li>split：字符串分割，类似于Python的split，需要用列表接收</li><li>toCharArray：将字符串转化成字符数组<code>char[]</code></li><li>format：用法类似于c的printf</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14159265</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(<span class="string">&quot;a=%d,b=%s,c=%c,d=%.2f&quot;</span>, a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>​StringBuffer是一个容器，因为是线程安全的(方法添加了synchronized修饰)，所以一般用于多线程，代表可变的字符序列，可以对字符串内容进行增删，方法与String大体相同。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><blockquote><p>StringBuffer()：构造一个不带字符的缓冲区，大小为16</p><p>StringBuffer(int capacity)：构造一个不带字符，容量为capacity的缓冲区</p><p>StringBuffer(String str)：构造一个内容为str，大小为str.length()+16的缓冲区</p></blockquote><h4 id="转换机制"><a href="#转换机制" class="headerlink" title="转换机制"></a>转换机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String -&gt; StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer -&gt; String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li>append：向后面添加字符串</li><li>delete：<code>delete(a,b)</code>删除指定范围的字符，左闭右开，即删除[a,b)内的字符</li><li>replace：<code>replace(a,b)</code>用法同delete，删除改为替换</li><li>indexOf：查找指定子串在字符串中第一次出现的位置，没找到返回-1</li><li>insert：<code>insert(a,b)</code>在a位置插入字符串b</li></ol><h3 id="StringBulider类"><a href="#StringBulider类" class="headerlink" title="StringBulider类"></a>StringBulider类</h3><p>​StringBulider和StringBuffer类均代表可变的字符序列，但是StringBulider效率更高，两者方法相同，所以使用和StringBuffer一样，但是StringBulider一般用于单线程。</p><p>效率：StringBulider &gt; StringBuffer &gt; String</p><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>包含用于执行基本数学运算的方法。</p><ol><li>abs：绝对值</li><li>pow：幂运算，<code>pow(a,b)</code>指求a的b次方</li><li>ceil：向上取整</li><li>floor：向下取整</li><li>sqrt：开方</li><li>random：返回一个[0,1)之间的double类型的随机数</li><li>max&#x2F;min：求最值</li></ol><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays用于管理或操作数组。</p><ol><li>toString：将数组内容变成字符串，便于输出查看内容</li><li>sort：将数组排序，可以使用匿名内部类改变排序方法</li><li>binarySearch：通过二分查找有序数组的某一个数，如果存在返回索引。不存在返回<code>-(本应该在的位置+1)</code></li><li>fill：<code>fill(arr, num)</code>将arr数组内容全部变成num</li><li>asList：将一组值转换成list</li></ol><h2 id="大数处理方案"><a href="#大数处理方案" class="headerlink" title="大数处理方案"></a>大数处理方案</h2><p><strong>BigInteger</strong>适合保存超出<code>long</code>表示范围的整数。<strong>BigDecimal</strong>适合保存超出<code>double</code>表示范围的浮点型。</p><p>加减乘除不能使用正常的数学符号，必须使用类给定的方法。</p><p>用法（以BigInteger为例，BigDecimal与之相同）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;9999999999999999999999999999999999&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">add</span> <span class="operator">=</span> num1.add(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">sub</span> <span class="operator">=</span> num1.subtract(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">mul</span> <span class="operator">=</span> num1.multiply(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">div</span> <span class="operator">=</span> num1.divide(num2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意，BigDecimal的除法可能与BigInteger不同</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10.999999999999999999999999999999999991&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果除数除不尽的话会报异常，解决办法：</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">div2</span> <span class="operator">=</span> num3.divide(num4, BigDecimal.ROUND_CEILING); <span class="comment">// 保留与被除数相同的精度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p>用于获得系统时间。</p><ol><li>Date：<code>new Date()</code>获取当前系统时间。</li><li>SimpleDateFormat：将日期转换成指定格式的字符串<code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;)</code>E表示星期</li></ol><h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p>指Calendar类，Calendar是一个抽象类，构造器使用private修饰。可以通过getInstance()获取实例。Calendar没有专门的格式化方法，需要自己组合显示。</p><ol><li><code>Calendar c = Calendar.getInstance()</code>创建日历类对象，包含Calendar字段</li><li>获取日历：</li></ol><blockquote><p>c.get(Calendar.YEAR)</p><p>c.get(Calendar.MONTH) + 1 &#x2F;&#x2F; 月默认从0开始</p><p>c.get(Calendar.DAY_OF_MONTH)</p><p>c.get(Calendar.HOUR)</p><p>c.get(Calendar.MINUTE)</p><p>c.get(Calendar.SECOND)</p></blockquote><h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>为了改善前两代日期类的不足，在jdk8中推出了第三代日期类</p><ol><li>LocalDate：年月日</li><li>LocalTime：时分秒</li><li>LocalDateTime：日期+时间</li></ol><blockquote><p>LocalDateTime ldt &#x3D; LoaclDateTime.now()</p><p>ldt.getYear()</p><p>ldt.getMonthValue()</p><p>ldt.getDayOfMonth()</p><p>ldt.getHour()</p><p>ldt.getMinute()</p><p>ldt.getSecond()</p></blockquote><ol start="4"><li>SimpleDateFormat：格式日期类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LoaclDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format();</span><br></pre></td></tr></table></figure><ol start="5"><li>plus系列方法：<code>plusDay</code>、<code>plusMinutes</code>等方法，可以查看多少天&#x2F;分钟后的日期是什么</li><li>minus系列方法：可以查看给定时间之前的日期是什么</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>​泛型是一种在设计和使用类、接口和方法时，允许更广泛地操作各种数据类型的机制。泛型提供了一种在代码中使用一般类型而不是具体类型的方式，在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值类型、参数类型，这样可以提高代码的重用性、可读性和类型安全性，使用任何字母都可以，通常使用<code>&lt;E&gt;</code>、<code>&lt;T&gt;</code>、<code>&lt;K&gt;</code>表示。Java的源码中使用了大量泛型以提高代码复用性。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Test&lt;Integer&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(<span class="number">1</span>);<span class="comment">// 使用Integer代替E</span></span><br><span class="line">        System.out.println(test.function()); <span class="comment">// 返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt;&#123;</span><br><span class="line">T s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(T s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t, R r)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>给泛型指定数据类型时，只能使用引用类型，不能是基本数据类型</li><li>在给泛型指定具体类型时，可以传入该类型或者该类型的子类型</li><li>使用泛型的数组不能初始化（因为不知道这里要用什么样的类型，不知道要开多大空间）</li><li>静态属性和静态方法中不能使用泛型（因为静态是和类相关的，在类加载时，对象还没有创建，如果静态属性和静态方法使用了泛型，JVM就无法完成初始化）</li><li>泛型方法可以在普通类中，也可以在泛型类中</li><li>如果创建类时没有指定类型，默认为Object</li><li>若在接口类中使用泛型，类型在继承接口或者实现接口时确定</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IUsb</span>&lt;U, R&gt;&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    R <span class="title function_">get</span><span class="params">(U u)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(R r)</span>;</span><br><span class="line">    <span class="keyword">default</span> R <span class="title function_">method</span><span class="params">(U u)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> <span class="keyword">extends</span> <span class="title class_">IUsb</span>&lt;String, Double&gt; &#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">implements</span> <span class="title class_">IUsb</span>&lt;String, Double&gt; &#123;......&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>泛型的通配符：<ul><li><code>&lt;?&gt;</code>代表支持任意泛型类型</li><li><code>&lt;? extends A&gt;</code>代表支持A类以及A的子类，规定了泛型类型的上限</li><li><code>&lt;? super A&gt;</code>代表支持A类以及A的父类，规定了泛型类型的下限</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（三）</title>
      <link href="/inori/9235e063.html"/>
      <url>/inori/9235e063.html</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>使用关键字enum代替class，默认会继承Enum类</li><li><code>public static final 类名 = new 类名(参数)</code>直接使用<code>类名(参数)</code>代替，这种语法会默认调用该类的构造器，如果有无参构造器可以不填参数</li><li>如果有多个常量对象，使用<code>,</code>间隔</li><li>创建的对象放在枚举类的行首</li><li>Enum类不可在外部创建对象，因为其构造器为私有</li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="center">方法名</th><th align="left">详细描述</th></tr></thead><tbody><tr><td align="center">valueOf</td><td align="left">通过字符串找到叫该名字的枚举对象，如果没找到会报异常</td></tr><tr><td align="center">toString</td><td align="left">返回枚举对象的名称，通常会在枚举类中重写该方法</td></tr><tr><td align="center">values</td><td align="left">隐藏在枚举类中的方法，返回一个数组，含有全部定义的枚举对象</td></tr><tr><td align="center">ordinal</td><td align="left">输出该枚举对象的定义次序，从0开始编号</td></tr><tr><td align="center">compareTo</td><td align="left">比较两个枚举对象，按照定义次序比较，返回前面的枚举常量编号减去后面的枚举常量编号</td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>使用enum关键字后不能继承其他类（enum会隐式的继承Enum类）</li><li>枚举类的普通类一样可以实现接口</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解(Annotation)也叫做元数据(Metadata)，用于解释包、类、方法、属性、构造器、局部变量等数据信息。注解不影响程序逻辑，但是可以被编译，相当于嵌入在代码中的补充信息。</p><h3 id="常用的注解符号"><a href="#常用的注解符号" class="headerlink" title="常用的注解符号"></a>常用的注解符号</h3><ol><li><p><code>@Override</code>重写某个父类方法，该注解只能用于方法</p></li><li><p><code>@Deprecated</code>表示某个程序元素已过时，即不推荐使用</p></li><li><p><code>@SuppressWarnings</code>抑制编译器警告，一般使用all，语法<code>@SuppressWarnings(&#123;&quot;all&quot;&#125;)</code></p></li><li><p><code>@interface</code>用于定义了注解类，之后用到再细说</p></li><li><p>元注解</p><ul><li><code>@Retention</code>指定注解的作用范围，有三种类型：<code>SOURCE</code>源码时，<code>CLASS</code>类中，<code>RUNTIME</code>运行时</li><li><code>@Target</code>指定注解可以在哪些地方使用</li><li><code>@Documented</code>指定该注解是否会在javadoc体现</li><li><code>@Inherited</code>子类继承父类的注解</li></ul></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>​在程序执行中发生的不正常行为称为异常，异常不是语法或逻辑错误。</p><p>​正常来说，当程序出现异常时，会立即终止，不会执行后面的代码，但是这样会导致因为一点小错误而耽误整个程序的执行。为了避免这种事情发生，引入异常处理机制进行异常处理，那么即使出现了异常，程序也可以继续执行。</p><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><ol><li>Error：JVM无法解决的严重问题。如：JVM系统内部错误，资源耗尽等严重情况。StackOverflowError、OutOfMemoryError等。Error属于严重错误，程序会崩溃。</li><li>Exception：其他外在因素导致的一般性问题，可以使用<code>try-catch</code>语句跳过避免程序崩溃。比如NullPointerException，ArithmeticException等。Exception分为<strong>运行时异常</strong>和<strong>编译时异常</strong>。</li></ol><h3 id="try-catch用法及注意事项"><a href="#try-catch用法及注意事项" class="headerlink" title="try-catch用法及注意事项"></a>try-catch用法及注意事项</h3><p><code>try-catch</code>类似于Python的<code>try-except</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>, num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> num1 / num2; <span class="comment">// 除0异常</span></span><br><span class="line">        <span class="comment">// 之后的代码不执行，直接进入到catch</span></span><br><span class="line">        <span class="comment">// 若try中没有异常，则不进入catch块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">System.out.println(e.getMessage());  <span class="comment">// 输出异常信息</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;  <span class="comment">// catch语句可以有多个,子类异常在前，父类在后</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">// finally可加可不加</span></span><br><span class="line">        <span class="comment">// 如果加了意味无论try是否有异常，catch是否捕获了异常，都一定会执行finally中的语句</span></span><br><span class="line">        <span class="comment">// 通常将关闭资源的代码放在finally中</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="throws用法"><a href="#throws用法" class="headerlink" title="throws用法"></a>throws用法</h3><p>​如果一个方法中可能产生某种异常，但是不能确定如何处理这种异常，则可以显示地声明抛出异常，表示由该方法的<u>调用者</u>负责处理。</p><p>​throws可以声明抛出的异常列表，可以是异常类型或者异常的父类类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, Exception&#123;</span><br><span class="line">        FileInputStream fis;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d://aa.txt&quot;</span>);<span class="comment">// 不存在此文件会产生FileNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>对于编译异常，程序必须处理。对于运行异常，若程序不处理，默认使用throws向上抛出，直到抛到JVM处终止程序。</li><li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，抛出的异常要么和父类的异常一致，要么为父类抛出异常的子类。</li><li>如果有try-catch语句，就不必用throws</li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义一个异常，用于规定程序必须按照某个指定的逻辑来编写或运行。</p><h4 id="用法及注意事项"><a href="#用法及注意事项" class="headerlink" title="用法及注意事项"></a>用法及注意事项</h4><p>一般情况下，继承<code>RuntimeException</code>类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">50</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumException</span>(<span class="string">&quot;num is too big&quot;</span>);<span class="comment">// 抛出一个自定义异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throws与throw"><a href="#throws与throw" class="headerlink" title="throws与throw"></a>throws与throw</h2><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面接</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（二）</title>
      <link href="/inori/df2b4331.html"/>
      <url>/inori/df2b4331.html</url>
      
        <content type="html"><![CDATA[<h2 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h2><p>在类中定义的变量，加上<code>static</code>称为类变量，否则称为实例变量&#x2F;普通变量。</p><p>性质：</p><ol><li>类中使用<code>static</code>修饰的变量将会被所有同类共享。</li><li><code>static</code>类变量，在类加载时就生成了，不需要创建对象实例就可以访问（以该变量不是<code>private</code>修饰为前提）。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>什么时候需要使用类变量？</li></ol><p>  当我们需要让某个类的所有对象对共享一个变量时可以使用。</p><ol start="2"><li>类变量与实例变量的区别：</li></ol><p>  类变量是该类的所有对象共享的，而实例变量时每个对象独享的。</p><ol start="3"><li>类变量的生命周期随着类加载开始，随着类消亡而被销毁。</li></ol><h2 id="类方法（静态方法）"><a href="#类方法（静态方法）" class="headerlink" title="类方法（静态方法）"></a>类方法（静态方法）</h2><p>类似于类变量，就是在类中定义的方法前使用<code>static</code>修饰。</p><p>使用时不需要将类实例化，直接用类名.方法使用。</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>类方法和普通方法一样，随着类加载而加载，将结构信息存在方法区</li><li>类方法中无<code>this</code>参数，不能使用与对象有关的关键字，如<code>this</code>和<code>super</code>。</li><li>类方法只能访问静态变量和静态方法。</li><li>普通成员方法可以访问静态方法和普通方法。</li></ol><h2 id="理解main方法"><a href="#理解main方法" class="headerlink" title="理解main方法"></a>理解main方法</h2><blockquote><p>public static void main(String[] args){}</p></blockquote><ol><li>main方法由JVM调用</li><li>JVM需要调用类的main()方法，所以该方法的访问权限必须是public</li><li>JVM在执行main()方法时不需要创建对象，所以该方法必须是static</li><li>main方法会接受String类型的数组参数args，该数组中保存着执行java命令时传递给所运行的类的参数</li><li>main方法中想要访问非静态的变量和方法需要先实例化再用。</li></ol><h2 id="代码块的使用"><a href="#代码块的使用" class="headerlink" title="代码块的使用"></a>代码块的使用</h2><p>没有方法名的方法。使用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>或者什么都不写 &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  相当于另外一种形式的构造器，可以做初始化操作，在使用构造器之前会调 用代码块，也就是说优先级高于构造器内的代码。可以将多次出现的重复代码放到代码块中。</p><p>注：如果使用static修饰代码块，则总共只会调用一次。如果是普通代码块，则每创建一次这个类都会执行一次。</p><p>创建对象时，在类中的调用顺序：</p><ol><li>调用静态代码块和静态属性初始化</li><li>调用普通代码块和普通属性初始化</li><li>调用构造方法</li></ol><p>当创建一个子类对象时（继承父类），调用顺序为：</p><ol><li>父类的静态代码块和静态属性</li><li>子类的静态代码块和静态属性</li><li>父类的普通代码块和普通属性</li><li>父类的构造方法</li><li>子类的普通..</li><li>子类的构造方法</li></ol><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final可以修饰类、属性、方法和局部变量，final修饰的属性又叫做常量。</p><p>用法：</p><ol><li>当不希望类被继承时。</li><li>当不希望父类的某个方法被子类覆盖或重写时。</li><li>当不希望类的某个属性的值被修改时。</li><li>当不希望某个局部变量被修改时。</li></ol><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>final修饰的属性一般用XX_XX_XX命名（大写，字母间使用下划线隔开）</p></li><li><p>final属性在定义时必须赋初值，赋值的位置可以在：</p><ul><li><p>定义时直接赋值</p></li><li><p>在构造器中赋值（仅限非static）</p></li><li><p>在代码块中赋值（static时使用静态代码块）</p></li></ul></li><li><p>如果一个类已经是final类了，其中的属性和方法就不要用final修饰了</p></li><li><p>final不能修饰构造器</p></li><li><p>final往往与static一起使用，效率更高，不会导致类加载</p></li><li><p>包装类（Integer、Double、Float、Boolean等）都是使用final修饰的，不可被继承</p></li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>​当在父类中声明了一个方法，但是不知道该如何实现时，就可以不实现，而是把该方法声明为一个抽象方法，同时该类变成一个抽象类。</p><ol><li>用abstract关键字来修饰一个类&#x2F;方法时，这个类就叫做抽象类&#x2F;方法</li><li>抽象类的价值更多作用在于设计，是设计者设计好后，让子类继承并实现抽象类</li><li>抽象类不能被实例化</li><li>抽象方法一定在抽象类中，但是抽象类不一定有抽象方法</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也是抽象类</li><li>抽象方法不能使用private、final和static修饰，因为这三个关键字都与重写相违背（用这三个关键字修饰方法不许被修改）</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  <span class="comment">//抽象类不能有主体&quot;&#123;&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是给出一些没有实现的方法，封装到一起，当某个类要用时，根据具体情况把接口中的方法写出来。</p><p>java8之后，接口中可以有方法的具体实现，但是非静态方法需要使用<code>default</code>修饰。</p><p><strong>接口中的方法都默认使用<code>public abstract</code>修饰，属性默认使用<code>public static final</code>修饰。</strong></p><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">XXX</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">XXXX</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要用到接口时</span></span><br><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>接口不能被实例化（同抽象类）</li><li>一个类可以同时实现多个接口</li></ol><blockquote><p>class X implements Y, Z {}</p></blockquote><ol start="3"><li>接口不能继承类，但是可以继承其他接口(接口与接口之间是继承关系，接口与类之间是实现关系)</li></ol><blockquote><p>interface A extends B, C {}</p></blockquote><ol start="4"><li>接口的修饰符只能是public和默认</li></ol><h4 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h4><p>​当子类继承父类时，自动拥有父类的功能。但因为一个子类只能继承一个父类，如果子类需要扩展功能，就可以通过实现接口的方式扩展。<u>可以理解为实现接口是对java单继承机制的扩展。</u></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类的内部又完整的嵌套了另一个类，被嵌套的类叫做内部类。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类定义在外部类的局部位置，通常在方法或代码块中，有类名。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>可以直接访问外部类的全部成员，包括私有</li><li>不能添加访问修饰符，因为局部内部类的地位相当于一个局部变量。但是可以用final修饰</li><li>作用域：在定义它的方法或代码块中</li><li>外部类想访问局部内部类的成员需要先new一个再访问</li><li>如果外部类中成员和局部内部类中成员重名，访问时使用就近原则，如果想访问外部类，可以使用<code>外部类.this.成员</code>访问</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>​匿名内部类没有类名（但是底层实现的时候有名字），不仅是一个类，还是一个对象，所有它同时拥有类和对象的特性，可以当做实参直接传递。</p><p>特点与局部内部类类似。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类或接口 变量名 = <span class="keyword">new</span> 类或接口(参数)&#123;</span><br><span class="line"><span class="comment">// 类体</span></span><br><span class="line">&#125;;</span><br><span class="line">变量名.方法名();</span><br><span class="line"><span class="comment">// -----------或者--------------</span></span><br><span class="line"><span class="keyword">new</span> 类或接口(参数)&#123;</span><br><span class="line">    <span class="comment">// 类体</span></span><br><span class="line">&#125;.方法名();</span><br></pre></td></tr></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类定义在外部类的成员位置，没有static修饰。其定位是一个类成员，可以添加任意修饰符。并且作用域为整个外部类体。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>假设<code>Outer</code>类中有一个名为<code>Inner</code>的成员内部类，当外部其他类想使用成员内部时：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inn</span> <span class="operator">=</span> out.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：在Outer类中声明一个方法，可以返回Inner对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    .....;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inn</span> <span class="operator">=</span> out.getInnerInstance();</span><br></pre></td></tr></table></figure><p>其他使用方式跟其他内部类相同。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是在成员内部类的基础上，有static修饰，有内部类和静态方法的全部特性。</p><p>当外部其他类想访问静态内部类时,因为是静态的，所以不需要实例化，通过类名直接访问：</p><blockquote><p>Inner inn &#x3D; new Outer.Inner();</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（一）</title>
      <link href="/inori/ef3dafe9.html"/>
      <url>/inori/ef3dafe9.html</url>
      
        <content type="html"><![CDATA[<h2 id="idea常用快捷键"><a href="#idea常用快捷键" class="headerlink" title="idea常用快捷键"></a>idea常用快捷键</h2><ol><li><p>Ctrl + Alt + L  格式化</p></li><li><p>Shift + F10  编译运行</p></li><li><p>Alt + Insert  插入构造器</p></li><li><p>Ctrl + H  显示继承关系</p></li><li><p>Alt+Enter  new完对象后可以直接分配变量名</p></li></ol><h2 id="idea-断点调试"><a href="#idea-断点调试" class="headerlink" title="idea 断点调试"></a>idea 断点调试</h2><ol><li>跳入（F7): 跳入方法内（可以查看JDK原码）</li><li>跳过（F8): 逐行执行代码</li><li>跳出（shift+F8)：跳出方法</li><li>继续（F9)：跳到下一个断点</li></ol><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>JUnit是一个Java语言的单元测试框架，多数Java的开发环境已经继承了JUnit作为单元测试工具。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>​如果在编写主方法时添加了很多非静态的方法，则在逐个测试方法时需要在main()函数中挨个new出来，再逐个测试。这样做非常的麻烦，可以点击<code>Alt + Enter</code>安装JUnit框架，在需要测试的方法上加<code>@Test</code>标识，则该方法前面会出现绿色的运行按钮，这样不需要在main()函数中声明也可以快速执行方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// new Test().m1();</span></span><br><span class="line">        <span class="comment">// new Test().m2();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 is Testing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 is Testing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h2><p>包本质就是文件夹，创建不同的文件夹&#x2F;目录来保存类文件。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>区分相同名字的类</li><li>更好的管理类</li><li>控制访问范围</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>package 文件夹名.文件夹名…</p></blockquote><p>在import上面写，使用idea时会自动添加。</p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table><thead><tr><th align="center">访问级别</th><th align="center">访问控制修饰符</th><th align="center">同类</th><th align="center">同包</th><th align="center">子类</th><th align="center">不同包</th></tr></thead><tbody><tr><td align="center">公开</td><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">受保护</td><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">默认</td><td align="center">无修饰符</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">私有</td><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>封装、继承、多态</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>​封装（encapsulation）就是把抽象出的属性和方法封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作[方法]，才能对数据进行操作。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li><p>将属性私有化</p></li><li><p>提供一个public的类set方法，用于对属性判断并赋值</p></li><li><p>提供一个public的类get方法，用于获取属性的值</p></li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>​当两个类的属性和方法有很多相同部分时，需要继承。即当多个类存在相同的属性和方法时，可以抽象出父类，在父类中定义这些相同的属性和方法，子类不需要重新定义这些属性和方法，只需要通过<code>extends</code>来声明继承。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>提高代码复用性</li><li>提高代码扩展性和可维护性</li></ol><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 子类 extends 父类&#123;</span><br><span class="line"><span class="comment">// 类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>子类自动拥有父类定义的属性和方法</li><li>父类又叫超类，基类</li><li>子类又叫派生类</li><li>一个子类只能有一个直接父类（只能继承一个类），但是可以有很多祖宗类（父类又继承了一个超类，那个超类又继承了一个超类……)</li><li>子类必须调用父类的构造器， 完成父类的初始化</li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器。如果父类没有提供无参构造器，则必须在子类的构造器中用<code>super</code>去指定使用父类的哪个构造器完成对父类的初始化工作</li><li><code>super</code>和<code>this</code>都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>java所有类都是<code>Object</code>类的子类,<code>Object</code>是所有类的基类</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态,多态是建立在封装和继承基础之上的。</p><h4 id="具体体现"><a href="#具体体现" class="headerlink" title="具体体现"></a>具体体现</h4><ol><li>方法的多态（重载和重写等）</li><li>对象的多态<ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时即确定，运行类型可以变化。</li></ul></li></ol><h4 id="对象的向上转型"><a href="#对象的向上转型" class="headerlink" title="对象的向上转型"></a>对象的向上转型</h4><p>父类的引用指向子类的对象</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li><p>可以调用父类中所有成员（遵守访问权限）</p></li><li><p>不能调用子类特有的方法（编译阶段能调用哪些成员，由编译类型决定）</p></li><li><p>最终运行效果看子类(运行类型)的具体实现，即调用方法时，按照从子类（运行类型）开始查找方法。</p></li></ol><h4 id="对象的向下转型"><a href="#对象的向下转型" class="headerlink" title="对象的向下转型"></a>对象的向下转型</h4><p>父类对象转换成子类对象。与向上转型不同，向下转型是不安全的</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">// 编译类型是A，运行类型是B</span></span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">C</span>(); <span class="comment">// 编译类型是A，运行类型是C</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B)a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><ol><li><p>当调用对象方法时，该方法会和该对象的内存地址（运行类型）绑定</p></li><li><p>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用。</p></li></ol><p>补充：<code>instanceOf</code>是比较操作符，用于判断对象的运行类型是否为某类型或某类型的子类型。</p><h2 id="类的五大成员"><a href="#类的五大成员" class="headerlink" title="类的五大成员"></a>类的五大成员</h2><p><strong>属性、方法、构造器、代码块、内部类</strong></p><h3 id="属性-成员变量-字段"><a href="#属性-成员变量-字段" class="headerlink" title="属性&#x2F;成员变量&#x2F;字段"></a>属性&#x2F;成员变量&#x2F;字段</h3><p>就是类中定义的变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>属性的定义方法用变量：<code>访问修饰符 属性类型 属性名</code></li><li>属性如果不赋值会使用默认值。<code>byte、short、int、long</code>赋0，<code>float、double</code>赋0.0，<code>char</code>赋\u0000，<code>boolean</code>赋false，<code>String</code>赋null。</li></ol><h3 id="方法-成员方法"><a href="#方法-成员方法" class="headerlink" title="方法&#x2F;成员方法"></a>方法&#x2F;成员方法</h3><p>就是类中定义的函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSalary</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载(overload)"></a>方法重载(overload)</h4><p>java中允许同一个类中，多个同名方法的存在，但要求形参不一致(变量类型或者变量数量)</p><ol><li>减轻了起名的麻烦</li><li>减轻了记名的麻烦</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalculator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">double</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculator</span><span class="params">(<span class="type">double</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2,<span class="type">int</span> n3)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2 + n3;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重写-override"><a href="#方法重写-override" class="headerlink" title="方法重写(override)"></a>方法重写(override)</h4><ol><li><p>即在子类中重新写一遍父类中的方法，需要和父类方法的参数，名称完全一样</p></li><li><p>返回类型要么一样，要么是父类返回类型的子类，比如<code>Object -&gt; String</code></p></li><li><p>子类方法的访问权限必须大于等于父类方法</p></li></ol><h4 id="方法重载与重写的区别"><a href="#方法重载与重写的区别" class="headerlink" title="方法重载与重写的区别"></a>方法重载与重写的区别</h4><table><thead><tr><th align="center">名称访问</th><th align="center">范围</th><th align="center">方法名</th><th align="center">形参</th><th align="center">返回类型</th><th align="center">修饰符</th></tr></thead><tbody><tr><td align="center">重载</td><td align="center">本类</td><td align="center">相同</td><td align="center">类型、个数或者顺序至少有一个不同</td><td align="center">随意</td><td align="center">随意</td></tr><tr><td align="center">重写</td><td align="center">protected</td><td align="center">相同</td><td align="center">相同</td><td align="center">一致或子类</td><td align="center">大于等于父类</td></tr></tbody></table><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>构造器是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</li><li>如果一个类不写构造器，则默认会有一个无参构造器</li><li>构造器的调用自动完成</li></ol><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问修饰符] 方法名(形参列表)&#123; </span><br><span class="line">     方法体;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>接下来见<a href="/inori/df2b4331">java基础入门（二）</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题.2</title>
      <link href="/inori/3b25fa04.html"/>
      <url>/inori/3b25fa04.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode每日一题"><a href="#LeetCode每日一题" class="headerlink" title="LeetCode每日一题"></a>LeetCode每日一题</h1><p>​今天的每日一题是<a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a>，简单题，直接做。</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出：false</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出：false</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出：true</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>把字符串中每一个字符映射到哈希表上，统计数字，如果ransomNote中的对应字母数量小于magazine就可以返回true。</p><p>优化点：如果ransomNote长度大于magazine了，则直接返回false。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.length() &gt; magazine.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">            map1.put(c, map1.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">            map2.put(c, map2.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> key : map1.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map2.containsKey(key) || map2.get(key) &lt; map1.get(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ransomNote) &gt; <span class="built_in">len</span>(magazine):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tab1, tab2 = Counter(ransomNote), Counter(magazine)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> tab1:</span><br><span class="line">            <span class="keyword">if</span> tab2[key] &lt; tab1[key]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(m+n)，n和m是两个字符串的长度。</li><li>空间复杂度：O(s)，s为字符数量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第379场周赛</title>
      <link href="/inori/d63cc9f2.html"/>
      <url>/inori/d63cc9f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode第379场周赛"><a href="#LeetCode第379场周赛" class="headerlink" title="LeetCode第379场周赛"></a>LeetCode第379场周赛</h1><p>​这场比赛感觉来恶心人的，一堆边界条件，又让我疯狂WA，简单题也WA，受不了了。</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>dimensions</code>。</p><p>对于所有下标 <code>i</code>（<code>0 &lt;= i &lt; dimensions.length</code>），<code>dimensions[i][0]</code> 表示矩形 <code>i</code> 的长度，而 <code>dimensions[i][1]</code> 表示矩形<code>i</code>的宽度。</p><p>返回对角线最<strong>长</strong>的矩形的<strong>面积</strong>。如果存在多个对角线长度相同的矩形，返回面积最<strong>大</strong>的矩形的面积。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：dimensions &#x3D; [[9,3],[8,6]]<br>输出：48<br>解释：<br>下标 &#x3D; 0，长度 &#x3D; 9，宽度 &#x3D; 3。对角线长度 &#x3D; sqrt(9 * 9 + 3 * 3) &#x3D; sqrt(90) ≈ 9.487。<br>下标 &#x3D; 1，长度 &#x3D; 8，宽度 &#x3D; 6。对角线长度 &#x3D; sqrt(8 * 8 + 6 * 6) &#x3D; sqrt(100) &#x3D; 10。<br>因此，下标为 1 的矩形对角线更长，所以返回面积 &#x3D; 8 * 6 &#x3D; 48。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：dimensions &#x3D; [[3,4],[4,3]]<br>输出：12<br>解释：两个矩形的对角线长度相同，为 5，所以最大面积 &#x3D; 12。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= dimensions.length &lt;= 100</code></li><li><code>dimensions[i].length == 2</code></li><li><code>1 &lt;= dimensions[i][0], dimensions[i][1] &lt;= 100</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>又是阅读理解题。</p><p>注意最后一句：如果存在多个对角线长度相同的矩形，返回面积最<strong>大</strong>的矩形的面积。这就需要特判一下了，如果对角线等于当前最大值就更新矩形面积。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">areaOfMaxDiagonal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dimensions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> nums: dimensions)&#123;</span><br><span class="line">            <span class="type">int</span> a = nums[<span class="number">0</span>], b = nums[<span class="number">1</span>];</span><br><span class="line">            <span class="type">double</span> tmp = <span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; s)&#123;<span class="comment">// 当对角线大时直接更新ans</span></span><br><span class="line">                s = tmp;</span><br><span class="line">                ans = a * b;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp == s)&#123;<span class="comment">// 相等时再判断最值</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, a * b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">areaOfMaxDiagonal</span><span class="params">(<span class="type">int</span>[][] dimensions)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] nums: dimensions)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> nums[<span class="number">0</span>], b = nums[<span class="number">1</span>];</span><br><span class="line">            <span class="type">double</span> <span class="variable">tmp</span> <span class="operator">=</span> Math.sqrt(a * a + b * b);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; s)&#123;<span class="comment">// 当对角线大时直接更新ans</span></span><br><span class="line">                s = Math.sqrt(a * a + b * b);</span><br><span class="line">                ans = a * b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp == s)&#123;<span class="comment">// 相等时再判断最值</span></span><br><span class="line">                ans = Math.max(ans, a * b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">areaOfMaxDiagonal</span>(<span class="params">self, dimensions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> dimensions:</span><br><span class="line">            tmp = sqrt(a * a + b * b)</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; s:</span><br><span class="line">                s = tmp</span><br><span class="line">                ans = a * b</span><br><span class="line">            <span class="keyword">elif</span> tmp == s:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, a * b)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)，n为数组长度。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>现有一个下标从 <strong>0</strong> 开始的 <code>8 x 8</code> 棋盘，上面有 <code>3</code> 枚棋子。</p><p>给你 <code>6</code> 个整数 <code>a</code> 、<code>b</code> 、<code>c</code> 、<code>d</code> 、<code>e</code> 和 <code>f</code> ，其中：</p><ul><li><code>(a, b)</code> 表示白色车的位置。</li><li><code>(c, d)</code> 表示白色象的位置。</li><li><code>(e, f)</code> 表示黑皇后的位置。</li></ul><p>假定你只能移动白色棋子，返回捕获黑皇后所需的<strong>最少</strong>移动次数。</p><p><strong>请注意</strong>：</p><ul><li>车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。</li><li>象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。</li><li>如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。</li><li>皇后不能移动。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/12/21/ex1.png" alt="img"></p><blockquote><p>输入：a &#x3D; 1, b &#x3D; 1, c &#x3D; 8, d &#x3D; 8, e &#x3D; 2, f &#x3D; 3<br>输出：2<br>解释：将白色车先移动到 (1, 3) ，然后移动到 (2, 3) 来捕获黑皇后，共需移动 2 次。<br>由于起始时没有任何棋子正在攻击黑皇后，要想捕获黑皇后，移动次数不可能少于 2 次。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/12/21/ex2.png" alt="img"></p><blockquote><p>输入：a &#x3D; 5, b &#x3D; 3, c &#x3D; 3, d &#x3D; 4, e &#x3D; 5, f &#x3D; 2<br>输出：1<br>解释：可以通过以下任一方式移动 1 次捕获黑皇后：</p><ul><li>将白色车移动到 (5, 2) 。</li><li>将白色象移动到 (5, 2) 。</li></ul></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a, b, c, d, e, f &lt;= 8</code></li><li>两枚棋子不会同时出现在同一个格子上。</li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>恶心人的题，分类讨论。</p><ol><li><p>如果车能直接攻击到皇后，或者象能直接攻击到皇后，那么返回1。</p></li><li><p>如果车被象挡住，那么移走象，车就可以攻击到皇后，返回2。</p></li><li><p>如果象被车挡住，那么移走车，象就可以攻击到皇后，返回2。</p></li><li><p>如果车不能直接攻击到皇后，那么车可以水平移动或者垂直移动，其中一个位置必定不会被象挡住，可以攻击到皇后，返回2。</p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMovesToCaptureTheQueen</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span>, c: <span class="built_in">int</span>, d: <span class="built_in">int</span>, e: <span class="built_in">int</span>, f: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="number">9</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="number">9</span> <span class="keyword">and</span> j &lt; <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a == e <span class="keyword">and</span> a != c): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(b == f <span class="keyword">and</span> b != d): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(a == c <span class="keyword">and</span> a == e <span class="keyword">and</span> <span class="built_in">abs</span>(b - f) != <span class="built_in">abs</span>(b - d) + <span class="built_in">abs</span>(d - f)): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(b == d <span class="keyword">and</span> b == f <span class="keyword">and</span> <span class="built_in">abs</span>(a - e) != <span class="built_in">abs</span>(a - c) + <span class="built_in">abs</span>(c - e)): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：<code>O(9 * 4) = O(1)</code>。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们的长度都是偶数<code> n</code> 。</p><p>你必须从 <code>nums1</code> 中移除 <code>n / 2</code> 个元素，同时从 <code>nums2</code> 中也移除 <code>n / 2</code> 个元素。移除之后，你将 <code>nums1</code> 和 <code>nums2</code> 中剩下的元素插入到集合 <code>s</code> 中。</p><p>返回集合 <code>s</code>可能的 <strong>最多</strong> 包含多少元素。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,2,1,2], nums2 &#x3D; [1,1,1,1]<br>输出：2<br>解释：从 nums1 和 nums2 中移除两个 1 。移除后，数组变为 nums1 &#x3D; [2,2] 和 nums2 &#x3D; [1,1] 。因此，s &#x3D; {1,2} 。<br>可以证明，在移除之后，集合 s 最多可以包含 2 个元素。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [2,3,2,3,2,3]<br>输出：5<br>解释：从 nums1 中移除 2、3 和 6 ，同时从 nums2 中移除两个 3 和一个 2 。移除后，数组变为 nums1 &#x3D; [1,4,5] 和 nums2 &#x3D; [2,3,2] 。因此，s &#x3D; {1,2,3,4,5} 。<br>可以证明，在移除之后，集合 s 最多可以包含 5 个元素。 </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,1,2,2,3,3], nums2 &#x3D; [4,4,5,5,6,6]<br>输出：6<br>解释：从 nums1 中移除 1、2 和 3 ，同时从 nums2 中移除 4、5 和 6 。移除后，数组变为 nums1 &#x3D; [1,2,3] 和 nums2 &#x3D; [4,5,6] 。因此，s &#x3D; {1,2,3,4,5,6} 。<br>可以证明，在移除之后，集合 s 最多可以包含 6 个元素。 </p></blockquote><p><strong>提示：</strong></p><ul><li><code>n == nums1.length == nums2.length</code></li><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li><li><code>n</code>是偶数。</li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^9</code></li></ul><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>这题一看，好像很难，但其实就是简单的求交集，数学找规律求方程即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSetSize</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums1)&#123;</span><br><span class="line">            set1.add(i);    <span class="comment">// nums1的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums2)&#123;</span><br><span class="line">            set2.add(i);    <span class="comment">// nums2的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(set1);</span><br><span class="line">        set.addAll(set2);   <span class="comment">// set1和set2的并集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, set1.size() - n / <span class="number">2</span>), x2 = Math.max(<span class="number">0</span>, set2.size() - n / <span class="number">2</span>);   <span class="comment">// nums1和nums2仍需要删除的数的数量</span></span><br><span class="line">        <span class="keyword">if</span>(x1 == <span class="number">0</span> &amp;&amp; x2 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> set.size();  <span class="comment">// 如果不需要删除了，就直接返回两者的并集的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(set1);</span><br><span class="line">        s.retainAll(set2);  <span class="comment">// 两者的交集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Math.min(<span class="number">0</span>, s.size() - x1 - x2);    <span class="comment">// 通过统计找到的规律，先从两者交集中移除元素，如果够用了x=0，不够的话x&lt;0,然后再从两者的并集中移除元素。</span></span><br><span class="line">        <span class="keyword">return</span> set.size() + x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumSetSize</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums1)</span><br><span class="line">        s1, s2 = <span class="built_in">set</span>(nums1), <span class="built_in">set</span>(nums2)</span><br><span class="line">        x1, x2 = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1) - n // <span class="number">2</span>), <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">len</span>(s2) - n // <span class="number">2</span>) <span class="comment"># nums1和nums2仍需要删除的数的数量</span></span><br><span class="line">        <span class="keyword">if</span> (x1 == <span class="number">0</span> <span class="keyword">and</span> x2 == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(s1 | s2)<span class="comment"># 如果不需要删除了，就直接返回两者的并集的长度</span></span><br><span class="line">        </span><br><span class="line">        s = s1 &amp; s2</span><br><span class="line">        x = <span class="built_in">min</span>(<span class="built_in">len</span>(s) - x1 - x2, <span class="number">0</span>) <span class="comment"># 通过统计找到的规律，先从两者交集中移除元素，如果够用了x=0，不够的话x&lt;0,然后再从两者的并集中移除元素。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s1 | s2) + x</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：<code>O(n * 4) = O(n)</code>，定义了4个哈希集合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第121场双周赛</title>
      <link href="/inori/6b6c0081.html"/>
      <url>/inori/6b6c0081.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode第121场双周赛"><a href="#LeetCode第121场双周赛" class="headerlink" title="LeetCode第121场双周赛"></a>LeetCode第121场双周赛</h1><p>​每次这么晚打比赛脑子都要抽风，这次周赛疯狂WA，第一道简单题更是WA了4次，受不了了。每次打比赛我都是能AC三题就是胜利，第四题看一眼题干，能看懂就做，看不懂就不做了，这次确实是A掉三题，只不过罚时了很久就是了…</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>如果一个前缀 <code>nums[0..i]</code> 满足对于 <code>1 &lt;= j &lt;= i</code> 的所有元素都有 <code>nums[j] = nums[j - 1] + 1</code> ，那么我们称这个前缀是一个 <strong>顺序前缀</strong> 。特殊情况是，只包含 <code>nums[0]</code> 的前缀也是一个 <strong>顺序前缀</strong> 。</p><p>请你返回 <code>nums</code> 中没有出现过的 <strong>最小</strong> 整数 <code>x</code> ，满足 <code>x</code> 大于等于 <strong>最长</strong> 顺序前缀的和。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [1,2,3,2,5]<br>输出：6<br>解释：nums 的最长顺序前缀是 [1,2,3] ，和为 6 ，6 不在数组中，所以 6 是大于等于最长顺序前缀和的最小整数。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums &#x3D; [3,4,5,1,12,14,13]<br>输出：15<br>解释：nums 的最长顺序前缀是 [3,4,5] ，和为 12 ，12、13 和 14 都在数组中，但 15 不在，所以 15 是大于等于最长顺序前缀和的最小整数。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= 50</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>纯纯阅读理解题，我就是因为没理解到位WA了三次。</p><ol><li><p>必须<code>1 &lt;= j &lt;= i</code>之间的所有元素全都满足才算一个顺序前缀。并且**nums[0]**也算一个顺序前缀。</p></li><li><p>需要返回的是最长顺序前缀的和，并且这个和在数组中没出现过，如果出现过，就一直+1直到满足条件。</p></li></ol><p>明白了以上几点，再看数据范围：50，啥都不用想了，直接<code>n^2</code>暴力解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingInteger</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, s = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; hashSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            hashSet.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">1</span>, ts = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    tmp ++;</span><br><span class="line">                    ts += nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">// 如果不满足条件直接break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmp);</span><br><span class="line">            <span class="keyword">if</span>(ans == tmp)&#123;<span class="comment">// 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">                s = <span class="built_in">max</span>(s, ts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">50</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s; i &lt;= <span class="number">51</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.<span class="built_in">find</span>(i) == hashSet.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingInteger</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>, ts = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    tmp ++;</span><br><span class="line">                    ts += nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">// 如果不满足条件直接break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, tmp);</span><br><span class="line">            <span class="keyword">if</span>(ans == tmp) s = Math.max(s, ts);<span class="comment">// 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">50</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s; i &lt;= <span class="number">51</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingInteger</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, ans, s = <span class="built_in">len</span>(nums), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        hashSet = <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tmp, ts = <span class="number">1</span>, nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>:</span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">                    ts += nums[j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmp)</span><br><span class="line">            <span class="keyword">if</span> ans == tmp:<span class="comment"># 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">                s = <span class="built_in">max</span>(s, ts)</span><br><span class="line">        <span class="keyword">if</span> s &gt; <span class="number">50</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s, <span class="number">52</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hashSet:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n^2)，n为数组长度。</li><li>空间复杂度：O(n)，定义了一个哈希集合，最坏情况下有n个数。</li></ul><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p><p>你可以对数组执行以下操作 <strong>任意次</strong> ：</p><ul><li>选择数组里的 <strong>任意</strong> 一个元素，并将它的 <strong>二进制</strong> 表示 <strong>翻转</strong> 一个数位，翻转数位表示将 <code>0</code> 变成 <code>1</code> 或者将 <code>1</code> 变成 <code>0</code> 。</li></ul><p>你的目标是让数组里 <strong>所有</strong> 元素的按位异或和得到 <code>k</code> ，请你返回达成这一目标的 <strong>最少</strong> 操作次数。</p><p><strong>注意</strong>，你也可以将一个数的前导 0 翻转。比方说，数字 <code>(101)2</code> 翻转第四个数位，得到 <code>(1101)2</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [2,1,3,4], k &#x3D; 1<br>输出：2<br>解释：我们可以执行以下操作：</p><ul><li>选择下标为 2 的元素，也就是 3 &#x3D;&#x3D; (011)2 ，我们翻转第一个数位得到 (010)2 &#x3D;&#x3D; 2 。数组变为 [2,1,2,4] 。</li><li>选择下标为 0 的元素，也就是 2 &#x3D;&#x3D; (010)2 ，我们翻转第三个数位得到 (110)2 &#x3D;&#x3D; 6 。数组变为 [6,1,2,4] 。<br>最终数组的所有元素异或和为 (6 XOR 1 XOR 2 XOR 4) &#x3D;&#x3D; 1 &#x3D;&#x3D; k 。<br>无法用少于 2 次操作得到异或和等于 k 。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums &#x3D; [2,0,2,0], k &#x3D; 0<br>输出：0<br>解释：数组所有元素的异或和为 (2 XOR 0 XOR 2 XOR 0) &#x3D;&#x3D; 0 &#x3D;&#x3D; k 。所以不需要进行任何操作。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^6</code></li><li><code>0 &lt;= k &lt;= 10^6</code></li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>这道题看似很唬人，其实是纸老虎。</p><p>设nums的异或和为s。</p><p>令<code>s=k</code>就等于<code>s⊕k=0</code>。也就是把数组中所有数全部异或，令其为x，只需要比较x和k有多少位不一样即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            s ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        s ^= k;<span class="comment">// 想知道s和k有几位数不一样只需要异或一次后数1的个数即可</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s)&#123;</span><br><span class="line">            ans += s &amp; <span class="number">1</span>;</span><br><span class="line">            s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            s ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(s ^ k);<span class="comment">// 想知道s和k有几位数不一样只需要异或一次后数1的个数即可,bitCount方法可以直接获取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            s ^= i</span><br><span class="line">        <span class="keyword">return</span> (s ^ k).bit_count()</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)，n为数组长度。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>给你两个正整数 <code>x</code> 和 <code>y</code> 。</p><p>一次操作中，你可以执行以下四种操作之一：</p><ol><li>如果 <code>x</code> 是 <code>11</code> 的倍数，将 <code>x</code> 除以 <code>11</code> 。</li><li>如果 <code>x</code> 是 <code>5</code> 的倍数，将 <code>x</code> 除以 <code>5</code> 。</li><li>将 <code>x</code> 减 <code>1</code> 。</li><li>将 <code>x</code> 加 <code>1</code> 。</li></ol><p>请你返回让 <code>x</code> 和 <code>y</code> 相等的 <strong>最少</strong> 操作次数。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：x &#x3D; 26, y &#x3D; 1<br>输出：3<br>解释：我们可以通过以下操作将 26 变为 1 ：</p><ol><li>将 x 减 1</li><li>将 x 除以 5</li><li>将 x 除以 5<br>将 26 变为 1 最少需要 3 次操作。</li></ol></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：x &#x3D; 54, y &#x3D; 2<br>输出：4<br>解释：我们可以通过以下操作将 54 变为 2 ：</p><ol><li>将 x 加 1</li><li>将 x 除以 11</li><li>将 x 除以 5</li><li>将 x 加 1<br>将 54 变为 2 最少需要 4 次操作。</li></ol></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：x &#x3D; 25, y &#x3D; 30<br>输出：5<br>解释：我们可以通过以下操作将 25 变为 30 ：</p><ol><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1<br>将 25 变为 30 最少需要 5 次操作。</li></ol></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x, y &lt;= 10^4</code></li></ul><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>这题我第一眼看以为是模拟，仔细看了一下样例发现没有这么复杂，可以抽象成最短路问题，直接BFS即可。</p><p>这里有一点可以优化的方法：注意x想要增加只有+1这种方法，所有如果<code>y &gt;= x</code>时，直接返回<code>y - x</code>即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperationsToMakeEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        deque&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(x, <span class="number">0</span>));</span><br><span class="line">        visited.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="type">int</span> tmp = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(now);</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(now);</span><br><span class="line">            <span class="keyword">if</span> (tmp == y)&#123;</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">11</span> == <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp / <span class="number">11</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp / <span class="number">11</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp / <span class="number">11</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp / <span class="number">5</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp / <span class="number">5</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp / <span class="number">5</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp - <span class="number">1</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp - <span class="number">1</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp - <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">find</span>(tmp + <span class="number">1</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp + <span class="number">1</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp + <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperationsToMakeEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        ArrayDeque&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, <span class="number">0</span>&#125;);</span><br><span class="line">        set.add(x);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] now = q.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> now[<span class="number">0</span>], cnt = now[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmp == y) <span class="keyword">return</span> cnt;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">11</span> == <span class="number">0</span> &amp;&amp; !set.contains(tmp / <span class="number">11</span>))&#123;</span><br><span class="line">                set.add(tmp / <span class="number">11</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp / <span class="number">11</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; !set.contains(tmp / <span class="number">5</span>))&#123;</span><br><span class="line">                set.add(tmp / <span class="number">5</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp / <span class="number">5</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span> &amp;&amp; !set.contains(tmp - <span class="number">1</span>))&#123;</span><br><span class="line">                set.add(tmp - <span class="number">1</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp - <span class="number">1</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(tmp + <span class="number">1</span>))&#123;</span><br><span class="line">                set.add(tmp + <span class="number">1</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp + <span class="number">1</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumOperationsToMakeEqual</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> y &gt;= x:</span><br><span class="line">            <span class="keyword">return</span> y - x</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        q.append((x, <span class="number">0</span>))</span><br><span class="line">        visited.add(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp, cnt = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> tmp == y:</span><br><span class="line">                <span class="keyword">return</span> cnt</span><br><span class="line">            <span class="keyword">if</span> tmp % <span class="number">11</span> == <span class="number">0</span> <span class="keyword">and</span> tmp // <span class="number">11</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp // <span class="number">11</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp // <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp % <span class="number">5</span> == <span class="number">0</span> <span class="keyword">and</span> tmp // <span class="number">5</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp // <span class="number">5</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp // <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span> <span class="keyword">and</span> tmp - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp - <span class="number">1</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp + <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp + <span class="number">1</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(x)。</li><li>空间复杂度：O(x)，定义了一个哈希集合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题.1</title>
      <link href="/inori/7752405a.html"/>
      <url>/inori/7752405a.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode每日一题"><a href="#LeetCode每日一题" class="headerlink" title="LeetCode每日一题"></a>LeetCode每日一题</h1><p>​今天的每日一题是<a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/">2807. 在链表中插入最大公约数</a>，难度标的中等，不过我认为应该是简单题</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你一个链表的头 <code>head</code> ，每个结点包含一个整数值。</p><p>在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 <strong>最大公约数</strong> 。</p><p>请你返回插入之后的链表。</p><p>两个数的 <strong>最大公约数</strong> 是可以被两个数字整除的最大正整数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/07/18/ex1_copy.png" alt="img"></p><blockquote><p>输入：head &#x3D; [18,6,10,3]<br>输出：[18,6,6,2,10,1,3]<br>解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。</p><ul><li>18 和 6 的最大公约数为 6 ，插入第一和第二个结点之间。</li><li>6 和 10 的最大公约数为 2 ，插入第二和第三个结点之间。</li><li>10 和 3 的最大公约数为 1 ，插入第三和第四个结点之间。<br>所有相邻结点之间都插入完毕，返回链表。</li></ul></blockquote><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/07/18/ex2_copy1.png" alt="img"></p><blockquote><p>输入：head &#x3D; [7]<br>输出：[7]<br>解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。<br>没有相邻结点，所以返回初始链表。</p></blockquote><p><strong>提示：</strong></p><ul><li>链表中结点数目在 <code>[1, 5000]</code> 之间。</li><li><code>1 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>​这道题很直观，明显是考差欧几里得算法(辗转相除法)<code>gcd(a,b) = gcd(b,a mod b)</code>原理为：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。</p><p>​明白了考察的知识点，这道题就非常简单了，直接遍历链表，在每两个节点直接插入这两个节点的值的最大公约数<code>gcd(node1.val, node2.val)</code>即可，计算gcd的方法可以是 <code>Math.gcd</code>或者自定义方法。</p><p>​有一点需要注意，只有节点数大于1时才需要插入，否则直接返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">insertGreatestCommonDivisors</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = head, *ne = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(ne)&#123;</span><br><span class="line">            ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="built_in">gcd</span>(pre-&gt;val, ne-&gt;val), ne);</span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">            pre = ne;</span><br><span class="line">            ne = ne-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">insertGreatestCommonDivisors</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, ne = head.next;</span><br><span class="line">        <span class="keyword">while</span>(ne != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> gcd(pre.val, ne.val);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(g, ne);</span><br><span class="line">            pre.next = newNode;</span><br><span class="line">            pre = ne;</span><br><span class="line">            ne = ne.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertGreatestCommonDivisors</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">            <span class="keyword">return</span> a <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        pre, ne = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> ne:</span><br><span class="line">            node = ListNode(gcd(pre.val, ne.val), ne)</span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">            pre = ne</span><br><span class="line">            ne = ne.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(nlog⁡M)，其中n为链表长度，M是节点最大可能的值，每次计算要O(logM)的时间。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些碎碎念</title>
      <link href="/inori/303572a2.html"/>
      <url>/inori/303572a2.html</url>
      
        <content type="html"><![CDATA[<h3 id="2024-1-1"><a href="#2024-1-1" class="headerlink" title="2024.1.1"></a>2024.1.1</h3><p>​很久以前就想着搭一个个人博客，但是一直拖着没搞，昨天晚上闲来无事，突然想到这件事，一口气搞出来了。说是个人博客，主要是当我的笔记本用吧，博客里面很多东西都没弄懂，也没弄好。</p><p>​目标是缓慢且持续的更新，学啥更啥…</p><h3 id="2024-1-26"><a href="#2024-1-26" class="headerlink" title="2024.1.26"></a>2024.1.26</h3><p>​终于把期末考试的事搞完了，我认为研究生上的课，不对，应该是本科和研究生上的课不能说是毫无用处，只能说是屁用没有，占用自学的时间，在那坐着浪费时间，老师在课上讲一些已经与当前正在应用的技术脱节很久的老知识，关键是课程报告和结课论文还需要用这些东西，学这些东西以后又用不上，又要浪费一大段时间。唉</p><h3 id="2024-2-1"><a href="#2024-2-1" class="headerlink" title="2024.2.1"></a>2024.2.1</h3><p>​放寒假了，实验室布置了一堆任务，但是我自己还想要自学很多东西，好像放假比不放假还难受。现在开始继续学习并且更新博客了。</p><h3 id="2024-2-9"><a href="#2024-2-9" class="headerlink" title="2024.2.9"></a>2024.2.9</h3><p>​今天除夕，我依旧在学习，得完成自己给自己下定的目标才行，已经拖了好几天了，这两天把它非得干掉。但是在家学不下去啊，学几分钟就想玩，一玩一小时就过去了…太浮躁了，不知道怎么改正，只能是硬学了。</p><h3 id="2024-3-23"><a href="#2024-3-23" class="headerlink" title="2024.3.23"></a>2024.3.23</h3><p>​最近跟组里的师兄聊了聊，感觉写小论文要提上日程了，但是我强化学习还没入门…目前打算学完Redis就开始全力进攻强化学习（目前学到SSM），直到写完小论文和搭好大论文框架，争取今年可以写完，明年找实习。</p><h3 id="2024-5-8"><a href="#2024-5-8" class="headerlink" title="2024.5.8"></a>2024.5.8</h3><p>​压力好大，组里的横向好多，我身上压着三个任务，再加上科研和开发，真的喘不过气……目前科研仍然还没开始，当初想着学完redis就开始，现在springCloud快学完了还没开始，再拖一阵吧，，，导师也不放实习，科研之后慢慢搞</p><h3 id="2024-5-18"><a href="#2024-5-18" class="headerlink" title="2024.5.18"></a>2024.5.18</h3><p>​找工作技术的学习我感觉可以告一段落了，剩下Redis后面的高级篇和原理篇还没学，JVM和JUC还没学，Spring底层原理还没学，做的几个项目还没有整合……这些我感觉不用提前学，因为后续需要读论文搞科研，等我搞完小论文可能学的这些也都忘了…所以我打算从明天开始搞科研，争取今年把小论文写完，大论文框架搭好，然后再学上面的知识点。就这么办吧</p><h3 id="2024-8-6"><a href="#2024-8-6" class="headerlink" title="2024.8.6"></a>2024.8.6</h3><p>​好久没更新了，最近开摆了…论文读不下去，idea想不出来，开题报告也写的依托答辩，想混到毕业回去找个2,3k的工作躺平算了</p><h3 id="2025-2-17"><a href="#2025-2-17" class="headerlink" title="2025.2.17"></a>2025.2.17</h3><p>​小论文写完了，今年要着手找实习找工作了，博客继续开更！就当鼓励自己学习了！</p><h3 id="2025-3-5"><a href="#2025-3-5" class="headerlink" title="2025.3.5"></a>2025.3.5</h3><p>​周围同学好多都开始投实习了，有些都已经找到了，我发现我以前学的好多都忘了，而且还差一些没学，进度差不少，抓点紧吧……</p><h3 id="2025-3-21"><a href="#2025-3-21" class="headerlink" title="2025.3.21"></a>2025.3.21</h3><p>​把之前遗留的JUC和JVM学了一下，改好了一版简历，打算下周就开始投了！不过八股我几乎没背过，感觉人有点虚，面试的时候一问三不知怎么办？</p><h3 id="2025-4-21"><a href="#2025-4-21" class="headerlink" title="2025.4.21"></a>2025.4.21</h3><p>​找实习找的心累……这辈子没这么难受过，做了一大堆测评和笔试，面试几乎没有，一个月过去了还是小白，唉。一转眼四月底了，不知道还有hc吗…..不行就0实习备战秋招了</p><h3 id="2025-5-9"><a href="#2025-5-9" class="headerlink" title="2025.5.9"></a>2025.5.9</h3><p>​最想去的米哈游二面挂了，第二天就感谢信了，难受！！继续沉淀</p><h3 id="2025-5-16"><a href="#2025-5-16" class="headerlink" title="2025.5.16"></a>2025.5.16</h3><p>​今天面试阅文，面试官直说了，我的项目太烂大街，没有亮点。我觉得很有道理，真的要好好准备一下项目！继续沉淀</p><h3 id="2025-5-22"><a href="#2025-5-22" class="headerlink" title="2025.5.22"></a>2025.5.22</h3><p>​终于把所有面试流程都走完了，肯定全g了，想都不用想，简历还是太单薄，学点新技术投中小厂试一下</p><h3 id="2025-5-30"><a href="#2025-5-30" class="headerlink" title="2025.5.30"></a>2025.5.30</h3><p>​说是把所有面试流程都走完了，但是后面还是有网易和海尔消金的流程，这俩的流程都推到比较后面了，但是还是在泡池子！！现在有好几家都在泡池子，也不挂我，也不推进流程，qaq</p><h3 id="2025-6-9"><a href="#2025-6-9" class="headerlink" title="2025.6.9"></a>2025.6.9</h3><p>​全都挂完了，集齐了一面挂，二面挂，三面挂，我最近完善了一下我的简历，但是我发现之前投过的不能修改，也不能重投了，只能再找新的机会了</p><h3 id="2025-6-11"><a href="#2025-6-11" class="headerlink" title="2025.6.11"></a>2025.6.11</h3><p>​无人问津也好，技不如人也罢，都要试着安静下来，去做自己该做的事，而不是让烦恼和焦虑毁掉本就不多的热情和定力，心可以碎，手不能停，该干嘛干嘛，在崩溃中继续前行，这才是一个成年人的素养。我们还年轻，我们还在路上，总有一天我们可以成为自己想成为的人！</p><h3 id="2025-6-17"><a href="#2025-6-17" class="headerlink" title="2025.6.17"></a>2025.6.17</h3><p>真的是金五银六，我的所有面试几乎都在五月六月，最近又接到好多面试，oc了一家，还有一家走到hr面了，但同时又有些焦虑，真的能安稳实习吗，是否能适应上班的节奏呢</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/inori/4a17b156.html"/>
      <url>/inori/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>费了不少劲！终于把我的博客搭好了！</p><h3 id="所用技术"><a href="#所用技术" class="headerlink" title="所用技术"></a>所用技术</h3><p>​本网站使用GitHub服务器+Hexo框架+Butterfly渲染，并在基础上做出了一小部分魔改，加了些花里胡哨的东西，域名在阿里云选购。</p><hr><p>​就说这么多吧，后续我争取做到把学到的东西做一个总结，更新在这里，希望可以用这种方法来加深我对知识的理解与记忆。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
