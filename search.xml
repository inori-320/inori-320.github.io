<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java常用类及其方法</title>
      <link href="/inori/12697782.html"/>
      <url>/inori/12697782.html</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>针对八种基本数据类型相应的引用类型，有了类的特点，就能调用类中的方法。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>​这两个过程的主要用途在于使得在需要使用对象的场景中能够使用基本数据类型，以及在需要使用基本数据类型的场景中能够使用对象。例如，在集合类中，只能存储对象而不能存储基本数据类型，因此需要通过装箱将基本数据类型转换为对应的包装类对象。</p><p>​在jdk5之前，需要手动装箱与拆箱，jdk5及之后使用自动装箱与拆箱。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 手动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(num);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> Integer.valueOf(num);</span><br><span class="line">        <span class="comment">// 手动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自动装箱和拆箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ol><li>字符串的字符使用Unicode字符编码，无论字母还是汉字都占2字节</li><li>String类有很多构造器和构造器的重载，常用的有：</li></ol><blockquote><p>String s1 &#x3D; new String();</p><p>String s2 &#x3D; new String(String original);</p><p>String s3 &#x3D; new String(char[] a);</p><p>String s4 &#x3D; new String(char[] a, int startIndex, int count);</p><p>String s5 &#x3D; new String(byte[] b);</p></blockquote><ol start="3"><li>String类实现了接口Serializable（串行化：可以在网络传输）和接口Comparable（比较大小）</li><li>String是final类，不能被继承</li><li>String有属性private final char value[]，用于存放字符串内容</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li>equals：区分大小写，判断内容是否相等</li><li>equalsIgnoreCase：忽略大小写，判断内容是否相等</li><li>length：返回字符串长度</li><li>substring：截取指定范围的子串，前闭后开区间</li><li>trim：去掉前后空格</li><li>charAt：获取索引处字符</li><li>toUpperCase：把字符串全部转换成大写</li><li>toLowerCase：把字符串全部转换成小写</li><li>replace：<code>str.replace(a,b)</code>将str中所有的a替换成b</li><li>split：字符串分割，类似于Python的split，需要用列表接收</li><li>toCharArray：将字符串转化成字符数组<code>char[]</code></li><li>format：用法类似于c的printf</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14159265</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(<span class="string">&quot;a=%d,b=%s,c=%c,d=%.2f&quot;</span>, a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>​StringBuffer是一个容器，因为是线程安全的(方法添加了synchronized修饰)，所以一般用于多线程，代表可变的字符序列，可以对字符串内容进行增删，方法与String大体相同。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><blockquote><p>StringBuffer()：构造一个不带字符的缓冲区，大小为16</p><p>StringBuffer(int capacity)：构造一个不带字符，容量为capacity的缓冲区</p><p>StringBuffer(String str)：构造一个内容为str，大小为str.length()+16的缓冲区</p></blockquote><h4 id="转换机制"><a href="#转换机制" class="headerlink" title="转换机制"></a>转换机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String -&gt; StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer -&gt; String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li>append：向后面添加字符串</li><li>delete：<code>delete(a,b)</code>删除指定范围的字符，左闭右开，即删除[a,b)内的字符</li><li>replace：<code>replace(a,b)</code>用法同delete，删除改为替换</li><li>indexOf：查找指定子串在字符串中第一次出现的位置，没找到返回-1</li><li>insert：<code>insert(a,b)</code>在a位置插入字符串b</li></ol><h3 id="StringBulider类"><a href="#StringBulider类" class="headerlink" title="StringBulider类"></a>StringBulider类</h3><p>​StringBulider和StringBuffer类均代表可变的字符序列，但是StringBulider效率更高，两者方法相同，所以使用和StringBuffer一样，但是StringBulider一般用于单线程。</p><p>效率：StringBulider &gt; StringBuffer &gt; String</p><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>包含用于执行基本数学运算的方法。</p><ol><li>abs：绝对值</li><li>pow：幂运算，<code>pow(a,b)</code>指求a的b次方</li><li>ceil：向上取整</li><li>floor：向下取整</li><li>sqrt：开方</li><li>random：返回一个[0,1)之间的double类型的随机数</li><li>max&#x2F;min：求最值</li></ol><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays用于管理或操作数组。</p><ol><li>toString：将数组内容变成字符串，便于输出查看内容</li><li>sort：将数组排序，可以使用匿名内部类改变排序方法</li><li>binarySearch：通过二分查找有序数组的某一个数，如果存在返回索引。不存在返回<code>-(本应该在的位置+1)</code></li><li>fill：<code>fill(arr, num)</code>将arr数组内容全部变成num</li><li>asList：将一组值转换成list</li></ol><h2 id="大数处理方案"><a href="#大数处理方案" class="headerlink" title="大数处理方案"></a>大数处理方案</h2><p><strong>BigInteger</strong>适合保存超出<code>long</code>表示范围的整数。<strong>BigDecimal</strong>适合保存超出<code>double</code>表示范围的浮点型。</p><p>加减乘除不能使用正常的数学符号，必须使用类给定的方法。</p><p>用法（以BigInteger为例，BigDecimal与之相同）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;9999999999999999999999999999999999&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">add</span> <span class="operator">=</span> num1.add(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">sub</span> <span class="operator">=</span> num1.subtract(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">mul</span> <span class="operator">=</span> num1.multiply(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">div</span> <span class="operator">=</span> num1.divide(num2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意，BigDecimal的除法可能与BigInteger不同</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10.999999999999999999999999999999999991&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果除数除不尽的话会报异常，解决办法：</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">div2</span> <span class="operator">=</span> num3.divide(num4, BigDecimal.ROUND_CEILING); <span class="comment">// 保留与被除数相同的精度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p>用于获得系统时间。</p><ol><li>Date：<code>new Date()</code>获取当前系统时间。</li><li>SimpleDateFormat：将日期转换成指定格式的字符串<code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;)</code>E表示星期</li></ol><h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p>指Calendar类，Calendar是一个抽象类，构造器使用private修饰。可以通过getInstance()获取实例。Calendar没有专门的格式化方法，需要自己组合显示。</p><ol><li><code>Calendar c = Calendar.getInstance()</code>创建日历类对象，包含Calendar字段</li><li>获取日历：</li></ol><blockquote><p>c.get(Calendar.YEAR)</p><p>c.get(Calendar.MONTH) + 1 &#x2F;&#x2F; 月默认从0开始</p><p>c.get(Calendar.DAY_OF_MONTH)</p><p>c.get(Calendar.HOUR)</p><p>c.get(Calendar.MINUTE)</p><p>c.get(Calendar.SECOND)</p></blockquote><h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>为了改善前两代日期类的不足，在jdk8中推出了第三代日期类</p><ol><li>LocalDate：年月日</li><li>LocalTime：时分秒</li><li>LocalDateTime：日期+时间</li></ol><blockquote><p>LocalDateTime ldt &#x3D; LoaclDateTime.now()</p><p>ldt.getYear()</p><p>ldt.getMonthValue()</p><p>ldt.getDayOfMonth()</p><p>ldt.getHour()</p><p>ldt.getMinute()</p><p>ldt.getSecond()</p></blockquote><ol start="4"><li>SimpleDateFormat：格式日期类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LoaclDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format();</span><br></pre></td></tr></table></figure><ol start="5"><li>plus系列方法：<code>plusDay</code>、<code>plusMinutes</code>等方法，可以查看多少天&#x2F;分钟后的日期是什么</li><li>minus系列方法：可以查看给定时间之前的日期是什么</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（三）</title>
      <link href="/inori/9235e063.html"/>
      <url>/inori/9235e063.html</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>使用关键字enum代替class，默认会继承Enum类</li><li><code>public static final 类名 = new 类名(参数)</code>直接使用<code>类名(参数)</code>代替，这种语法会默认调用该类的构造器，如果有无参构造器可以不填参数</li><li>如果有多个常量对象，使用<code>,</code>间隔</li><li>创建的对象放在枚举类的行首</li><li>Enum类不可在外部创建对象，因为其构造器为私有</li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="center">方法名</th><th align="left">详细描述</th></tr></thead><tbody><tr><td align="center">valueOf</td><td align="left">通过字符串找到叫该名字的枚举对象，如果没找到会报异常</td></tr><tr><td align="center">toString</td><td align="left">返回枚举对象的名称，通常会在枚举类中重写该方法</td></tr><tr><td align="center">values</td><td align="left">隐藏在枚举类中的方法，返回一个数组，含有全部定义的枚举对象</td></tr><tr><td align="center">ordinal</td><td align="left">输出该枚举对象的定义次序，从0开始编号</td></tr><tr><td align="center">compareTo</td><td align="left">比较两个枚举对象，按照定义次序比较，返回前面的枚举常量编号减去后面的枚举常量编号</td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>使用enum关键字后不能继承其他类（enum会隐式的继承Enum类）</li><li>枚举类的普通类一样可以实现接口</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解(Annotation)也叫做元数据(Metadata)，用于解释包、类、方法、属性、构造器、局部变量等数据信息。注解不影响程序逻辑，但是可以被编译，相当于嵌入在代码中的补充信息。</p><h3 id="常用的注解符号"><a href="#常用的注解符号" class="headerlink" title="常用的注解符号"></a>常用的注解符号</h3><ol><li><p><code>@Override</code>重写某个父类方法，该注解只能用于方法</p></li><li><p><code>@Deprecated</code>表示某个程序元素已过时，即不推荐使用</p></li><li><p><code>@SuppressWarnings</code>抑制编译器警告，一般使用all，语法<code>@SuppressWarnings(&#123;&quot;all&quot;&#125;)</code></p></li><li><p><code>@interface</code>用于定义了注解类，之后用到再细说</p></li><li><p>元注解</p><ul><li><code>@Retention</code>指定注解的作用范围，有三种类型：<code>SOURCE</code>源码时，<code>CLASS</code>类中，<code>RUNTIME</code>运行时</li><li><code>@Target</code>指定注解可以在哪些地方使用</li><li><code>@Documented</code>指定该注解是否会在javadoc体现</li><li><code>@Inherited</code>子类继承父类的注解</li></ul></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>​在程序执行中发生的不正常行为称为异常，异常不是语法或逻辑错误。</p><p>​正常来说，当程序出现异常时，会立即终止，不会执行后面的代码，但是这样会导致因为一点小错误而耽误整个程序的执行。为了避免这种事情发生，引入异常处理机制进行异常处理，那么即使出现了异常，程序也可以继续执行。</p><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><ol><li>Error：JVM无法解决的严重问题。如：JVM系统内部错误，资源耗尽等严重情况。StackOverflowError、OutOfMemoryError等。Error属于严重错误，程序会崩溃。</li><li>Exception：其他外在因素导致的一般性问题，可以使用<code>try-catch</code>语句跳过避免程序崩溃。比如NullPointerException，ArithmeticException等。Exception分为<strong>运行时异常</strong>和<strong>编译时异常</strong>。</li></ol><h3 id="try-catch用法及注意事项"><a href="#try-catch用法及注意事项" class="headerlink" title="try-catch用法及注意事项"></a>try-catch用法及注意事项</h3><p><code>try-catch</code>类似于Python的<code>try-except</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>, num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> num1 / num2; <span class="comment">// 除0异常</span></span><br><span class="line">        <span class="comment">// 之后的代码不执行，直接进入到catch</span></span><br><span class="line">        <span class="comment">// 若try中没有异常，则不进入catch块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">System.out.println(e.getMessage());  <span class="comment">// 输出异常信息</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;  <span class="comment">// catch语句可以有多个,子类异常在前，父类在后</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">// finally可加可不加</span></span><br><span class="line">        <span class="comment">// 如果加了意味无论try是否有异常，catch是否捕获了异常，都一定会执行finally中的语句</span></span><br><span class="line">        <span class="comment">// 通常将关闭资源的代码放在finally中</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="throws用法"><a href="#throws用法" class="headerlink" title="throws用法"></a>throws用法</h3><p>​如果一个方法中可能产生某种异常，但是不能确定如何处理这种异常，则可以显示地声明抛出异常，表示由该方法的<u>调用者</u>负责处理。</p><p>​throws可以声明抛出的异常列表，可以是异常类型或者异常的父类类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, Exception&#123;</span><br><span class="line">        FileInputStream fis;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d://aa.txt&quot;</span>);<span class="comment">// 不存在此文件会产生FileNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>对于编译异常，程序必须处理。对于运行异常，若程序不处理，默认使用throws向上抛出，直到抛到JVM处终止程序。</li><li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，抛出的异常要么和父类的异常一致，要么为父类抛出异常的子类。</li><li>如果有try-catch语句，就不必用throws</li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义一个异常，用于规定程序必须按照某个指定的逻辑来编写或运行。</p><h4 id="用法及注意事项"><a href="#用法及注意事项" class="headerlink" title="用法及注意事项"></a>用法及注意事项</h4><p>一般情况下，继承<code>RuntimeException</code>类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">50</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumException</span>(<span class="string">&quot;num is too big&quot;</span>);<span class="comment">// 抛出一个自定义异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throws与throw"><a href="#throws与throw" class="headerlink" title="throws与throw"></a>throws与throw</h2><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面接</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（二）</title>
      <link href="/inori/df2b4331.html"/>
      <url>/inori/df2b4331.html</url>
      
        <content type="html"><![CDATA[<h2 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h2><p>在类中定义的变量，加上<code>static</code>称为类变量，否则称为实例变量&#x2F;普通变量。</p><p>性质：</p><ol><li>类中使用<code>static</code>修饰的变量将会被所有同类共享。</li><li><code>static</code>类变量，在类加载时就生成了，不需要创建对象实例就可以访问（以该变量不是<code>private</code>修饰为前提）。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>什么时候需要使用类变量？</li></ol><p>  当我们需要让某个类的所有对象对共享一个变量时可以使用。</p><ol start="2"><li>类变量与实例变量的区别：</li></ol><p>  类变量是该类的所有对象共享的，而实例变量时每个对象独享的。</p><ol start="3"><li>类变量的生命周期随着类加载开始，随着类消亡而被销毁。</li></ol><h2 id="类方法（静态方法）"><a href="#类方法（静态方法）" class="headerlink" title="类方法（静态方法）"></a>类方法（静态方法）</h2><p>类似于类变量，就是在类中定义的方法前使用<code>static</code>修饰。</p><p>使用时不需要将类实例化，直接用类名.方法使用。</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>类方法和普通方法一样，随着类加载而加载，将结构信息存在方法区</li><li>类方法中无<code>this</code>参数，不能使用与对象有关的关键字，如<code>this</code>和<code>super</code>。</li><li>类方法只能访问静态变量和静态方法。</li><li>普通成员方法可以访问静态方法和普通方法。</li></ol><h2 id="理解main方法"><a href="#理解main方法" class="headerlink" title="理解main方法"></a>理解main方法</h2><blockquote><p>public static void main(String[] args){}</p></blockquote><ol><li>main方法由JVM调用</li><li>JVM需要调用类的main()方法，所以该方法的访问权限必须是public</li><li>JVM在执行main()方法时不需要创建对象，所以该方法必须是static</li><li>main方法会接受String类型的数组参数args，该数组中保存着执行java命令时传递给所运行的类的参数</li><li>main方法中想要访问非静态的变量和方法需要先实例化再用。</li></ol><h2 id="代码块的使用"><a href="#代码块的使用" class="headerlink" title="代码块的使用"></a>代码块的使用</h2><p>没有方法名的方法。使用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>或者什么都不写 &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  相当于另外一种形式的构造器，可以做初始化操作，在使用构造器之前会调 用代码块，也就是说优先级高于构造器内的代码。可以将多次出现的重复代码放到代码块中。</p><p>注：如果使用static修饰代码块，则总共只会调用一次。如果是普通代码块，则每创建一次这个类都会执行一次。</p><p>创建对象时，在类中的调用顺序：</p><ol><li>调用静态代码块和静态属性初始化</li><li>调用普通代码块和普通属性初始化</li><li>调用构造方法</li></ol><p>当创建一个子类对象时（继承父类），调用顺序为：</p><ol><li>父类的静态代码块和静态属性</li><li>子类的静态代码块和静态属性</li><li>父类的普通代码块和普通属性</li><li>父类的构造方法</li><li>子类的普通..</li><li>子类的构造方法</li></ol><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final可以修饰类、属性、方法和局部变量，final修饰的属性又叫做常量。</p><p>用法：</p><ol><li>当不希望类被继承时。</li><li>当不希望父类的某个方法被子类覆盖或重写时。</li><li>当不希望类的某个属性的值被修改时。</li><li>当不希望某个局部变量被修改时。</li></ol><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>final修饰的属性一般用XX_XX_XX命名（大写，字母间使用下划线隔开）</p></li><li><p>final属性在定义时必须赋初值，赋值的位置可以在：</p><ul><li><p>定义时直接赋值</p></li><li><p>在构造器中赋值（仅限非static）</p></li><li><p>在代码块中赋值（static时使用静态代码块）</p></li></ul></li><li><p>如果一个类已经是final类了，其中的属性和方法就不要用final修饰了</p></li><li><p>final不能修饰构造器</p></li><li><p>final往往与static一起使用，效率更高，不会导致类加载</p></li><li><p>包装类（Integer、Double、Float、Boolean等）都是使用final修饰的，不可被继承</p></li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>​当在父类中声明了一个方法，但是不知道该如何实现时，就可以不实现，而是把该方法声明为一个抽象方法，同时该类变成一个抽象类。</p><ol><li>用abstract关键字来修饰一个类&#x2F;方法时，这个类就叫做抽象类&#x2F;方法</li><li>抽象类的价值更多作用在于设计，是设计者设计好后，让子类继承并实现抽象类</li><li>抽象类不能被实例化</li><li>抽象方法一定在抽象类中，但是抽象类不一定有抽象方法</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也是抽象类</li><li>抽象方法不能使用private、final和static修饰，因为这三个关键字都与重写相违背（用这三个关键字修饰方法不许被修改）</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  <span class="comment">//抽象类不能有主体&quot;&#123;&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是给出一些没有实现的方法，封装到一起，当某个类要用时，根据具体情况把接口中的方法写出来。</p><p>java8之后，接口中可以有方法的具体实现，但是非静态方法需要使用<code>default</code>修饰。</p><p><strong>接口中的方法都默认使用<code>public abstract</code>修饰，属性默认使用<code>public static final</code>修饰。</strong></p><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">XXX</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">XXXX</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要用到接口时</span></span><br><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>接口不能被实例化（同抽象类）</li><li>一个类可以同时实现多个接口</li></ol><blockquote><p>class X implements Y, Z {}</p></blockquote><ol start="3"><li>接口不能继承类，但是可以继承其他接口(接口与接口之间是继承关系，接口与类之间是实现关系)</li></ol><blockquote><p>interface A extends B, C {}</p></blockquote><ol start="4"><li>接口的修饰符只能是public和默认</li></ol><h4 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h4><p>​当子类继承父类时，自动拥有父类的功能。但因为一个子类只能继承一个父类，如果子类需要扩展功能，就可以通过实现接口的方式扩展。<u>可以理解为实现接口是对java单继承机制的扩展。</u></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类的内部又完整的嵌套了另一个类，被嵌套的类叫做内部类。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类定义在外部类的局部位置，通常在方法或代码块中，有类名。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>可以直接访问外部类的全部成员，包括私有</li><li>不能添加访问修饰符，因为局部内部类的地位相当于一个局部变量。但是可以用final修饰</li><li>作用域：在定义它的方法或代码块中</li><li>外部类想访问局部内部类的成员需要先new一个再访问</li><li>如果外部类中成员和局部内部类中成员重名，访问时使用就近原则，如果想访问外部类，可以使用<code>外部类.this.成员</code>访问</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>​匿名内部类没有类名（但是底层实现的时候有名字），不仅是一个类，还是一个对象，所有它同时拥有类和对象的特性，可以当做实参直接传递。</p><p>特点与局部内部类类似。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类或接口 变量名 = <span class="keyword">new</span> 类或接口(参数)&#123;</span><br><span class="line"><span class="comment">// 类体</span></span><br><span class="line">&#125;;</span><br><span class="line">变量名.方法名();</span><br><span class="line"><span class="comment">// -----------或者--------------</span></span><br><span class="line"><span class="keyword">new</span> 类或接口(参数)&#123;</span><br><span class="line">    <span class="comment">// 类体</span></span><br><span class="line">&#125;.方法名();</span><br></pre></td></tr></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类定义在外部类的成员位置，没有static修饰。其定位是一个类成员，可以添加任意修饰符。并且作用域为整个外部类体。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>假设<code>Outer</code>类中有一个名为<code>Inner</code>的成员内部类，当外部其他类想使用成员内部时：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inn</span> <span class="operator">=</span> out.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：在Outer类中声明一个方法，可以返回Inner对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    .....;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inn</span> <span class="operator">=</span> out.getInnerInstance();</span><br></pre></td></tr></table></figure><p>其他使用方式跟其他内部类相同。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是在成员内部类的基础上，有static修饰，有内部类和静态方法的全部特性。</p><p>当外部其他类想访问静态内部类时,因为是静态的，所以不需要实例化，通过类名直接访问：</p><blockquote><p>Inner inn &#x3D; new Outer.Inner();</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（一）</title>
      <link href="/inori/ef3dafe9.html"/>
      <url>/inori/ef3dafe9.html</url>
      
        <content type="html"><![CDATA[<h2 id="idea常用快捷键"><a href="#idea常用快捷键" class="headerlink" title="idea常用快捷键"></a>idea常用快捷键</h2><ol><li><p>Ctrl + Alt + L  格式化</p></li><li><p>Shift + F10  编译运行</p></li><li><p>Alt + Insert  插入构造器</p></li><li><p>Ctrl + H  显示继承关系</p></li><li><p>Alt+Enter  new完对象后可以直接分配变量名</p></li></ol><h2 id="idea-断点调试"><a href="#idea-断点调试" class="headerlink" title="idea 断点调试"></a>idea 断点调试</h2><ol><li>跳入（F7): 跳入方法内（可以查看JDK原码）</li><li>跳过（F8): 逐行执行代码</li><li>跳出（shift+F8)：跳出方法</li><li>继续（F9)：跳到下一个断点</li></ol><h2 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h2><p>包本质就是文件夹，创建不同的文件夹&#x2F;目录来保存类文件。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>区分相同名字的类</li><li>更好的管理类</li><li>控制访问范围</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>package 文件夹名.文件夹名…</p></blockquote><p>在import上面写，使用idea时会自动添加。</p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table><thead><tr><th align="center">访问级别</th><th align="center">访问控制修饰符</th><th align="center">同类</th><th align="center">同包</th><th align="center">子类</th><th align="center">不同包</th></tr></thead><tbody><tr><td align="center">公开</td><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">受保护</td><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">默认</td><td align="center">无修饰符</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">私有</td><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>封装、继承、多态</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>​封装（encapsulation）就是把抽象出的属性和方法封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作[方法]，才能对数据进行操作。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li><p>将属性私有化</p></li><li><p>提供一个public的类set方法，用于对属性判断并赋值</p></li><li><p>提供一个public的类get方法，用于获取属性的值</p></li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>​当两个类的属性和方法有很多相同部分时，需要继承。即当多个类存在相同的属性和方法时，可以抽象出父类，在父类中定义这些相同的属性和方法，子类不需要重新定义这些属性和方法，只需要通过<code>extends</code>来声明继承。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>提高代码复用性</li><li>提高代码扩展性和可维护性</li></ol><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 子类 extends 父类&#123;</span><br><span class="line"><span class="comment">// 类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>子类自动拥有父类定义的属性和方法</li><li>父类又叫超类，基类</li><li>子类又叫派生类</li><li>一个子类只能有一个直接父类（只能继承一个类），但是可以有很多祖宗类（父类又继承了一个超类，那个超类又继承了一个超类……)</li><li>子类必须调用父类的构造器， 完成父类的初始化</li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器。如果父类没有提供无参构造器，则必须在子类的构造器中用<code>super</code>去指定使用父类的哪个构造器完成对父类的初始化工作</li><li><code>super</code>和<code>this</code>都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>java所有类都是<code>Object</code>类的子类,<code>Object</code>是所有类的基类</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态,多态是建立在封装和继承基础之上的。</p><h4 id="具体体现"><a href="#具体体现" class="headerlink" title="具体体现"></a>具体体现</h4><ol><li>方法的多态（重载和重写等）</li><li>对象的多态<ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时即确定，运行类型可以变化。</li></ul></li></ol><h4 id="对象的向上转型"><a href="#对象的向上转型" class="headerlink" title="对象的向上转型"></a>对象的向上转型</h4><p>父类的引用指向子类的对象</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li><p>可以调用父类中所有成员（遵守访问权限）</p></li><li><p>不能调用子类特有的方法（编译阶段能调用哪些成员，由编译类型决定）</p></li><li><p>最终运行效果看子类(运行类型)的具体实现，即调用方法时，按照从子类（运行类型）开始查找方法。</p></li></ol><h4 id="对象的向下转型"><a href="#对象的向下转型" class="headerlink" title="对象的向下转型"></a>对象的向下转型</h4><p>父类对象转换成子类对象。与向上转型不同，向下转型是不安全的</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">// 编译类型是A，运行类型是B</span></span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">C</span>(); <span class="comment">// 编译类型是A，运行类型是C</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B)a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><ol><li><p>当调用对象方法时，该方法会和该对象的内存地址（运行类型）绑定</p></li><li><p>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用。</p></li></ol><p>补充：<code>instanceOf</code>是比较操作符，用于判断对象的运行类型是否为某类型或某类型的子类型。</p><h2 id="类的五大成员"><a href="#类的五大成员" class="headerlink" title="类的五大成员"></a>类的五大成员</h2><p><strong>属性、方法、构造器、代码块、内部类</strong></p><h3 id="属性-成员变量-字段"><a href="#属性-成员变量-字段" class="headerlink" title="属性&#x2F;成员变量&#x2F;字段"></a>属性&#x2F;成员变量&#x2F;字段</h3><p>就是类中定义的变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>属性的定义方法用变量：<code>访问修饰符 属性类型 属性名</code></li><li>属性如果不赋值会使用默认值。<code>byte、short、int、long</code>赋0，<code>float、double</code>赋0.0，<code>char</code>赋\u0000，<code>boolean</code>赋false，<code>String</code>赋null。</li></ol><h3 id="方法-成员方法"><a href="#方法-成员方法" class="headerlink" title="方法&#x2F;成员方法"></a>方法&#x2F;成员方法</h3><p>就是类中定义的函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSalary</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载(overload)"></a>方法重载(overload)</h4><p>java中允许同一个类中，多个同名方法的存在，但要求形参不一致(变量类型或者变量数量)</p><ol><li>减轻了起名的麻烦</li><li>减轻了记名的麻烦</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalculator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">double</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculator</span><span class="params">(<span class="type">double</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2,<span class="type">int</span> n3)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2 + n3;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重写-override"><a href="#方法重写-override" class="headerlink" title="方法重写(override)"></a>方法重写(override)</h4><ol><li><p>即在子类中重新写一遍父类中的方法，需要和父类方法的参数，名称完全一样</p></li><li><p>返回类型要么一样，要么是父类返回类型的子类，比如<code>Object -&gt; String</code></p></li><li><p>子类方法的访问权限必须大于等于父类方法</p></li></ol><h4 id="方法重载与重写的区别"><a href="#方法重载与重写的区别" class="headerlink" title="方法重载与重写的区别"></a>方法重载与重写的区别</h4><table><thead><tr><th align="center">名称访问</th><th align="center">范围</th><th align="center">方法名</th><th align="center">形参</th><th align="center">返回类型</th><th align="center">修饰符</th></tr></thead><tbody><tr><td align="center">重载</td><td align="center">本类</td><td align="center">相同</td><td align="center">类型、个数或者顺序至少有一个不同</td><td align="center">随意</td><td align="center">随意</td></tr><tr><td align="center">重写</td><td align="center">protected</td><td align="center">相同</td><td align="center">相同</td><td align="center">一致或子类</td><td align="center">大于等于父类</td></tr></tbody></table><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>构造器是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</li><li>如果一个类不写构造器，则默认会有一个无参构造器</li><li>构造器的调用自动完成</li></ol><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问修饰符] 方法名(形参列表)&#123; </span><br><span class="line">     方法体;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>接下来见<a href="/inori/df2b4331">java基础入门（二）</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题第二天</title>
      <link href="/inori/3b25fa04.html"/>
      <url>/inori/3b25fa04.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode每日一题"><a href="#LeetCode每日一题" class="headerlink" title="LeetCode每日一题"></a>LeetCode每日一题</h1><p>​今天的每日一题是<a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a>，简单题，直接做。</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出：false</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出：false</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出：true</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>把字符串中每一个字符映射到哈希表上，统计数字，如果ransomNote中的对应字母数量小于magazine就可以返回true。</p><p>优化点：如果ransomNote长度大于magazine了，则直接返回false。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.length() &gt; magazine.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">            map1.put(c, map1.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">            map2.put(c, map2.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> key : map1.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map2.containsKey(key) || map2.get(key) &lt; map1.get(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ransomNote) &gt; <span class="built_in">len</span>(magazine):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tab1, tab2 = Counter(ransomNote), Counter(magazine)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> tab1:</span><br><span class="line">            <span class="keyword">if</span> tab2[key] &lt; tab1[key]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(m+n)，n和m是两个字符串的长度。</li><li>空间复杂度：O(s)，s为字符数量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第379场周赛</title>
      <link href="/inori/d63cc9f2.html"/>
      <url>/inori/d63cc9f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode第379场周赛"><a href="#LeetCode第379场周赛" class="headerlink" title="LeetCode第379场周赛"></a>LeetCode第379场周赛</h1><p>​这场比赛感觉来恶心人的，一堆边界条件，又让我疯狂WA，简单题也WA，受不了了。</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>dimensions</code>。</p><p>对于所有下标 <code>i</code>（<code>0 &lt;= i &lt; dimensions.length</code>），<code>dimensions[i][0]</code> 表示矩形 <code>i</code> 的长度，而 <code>dimensions[i][1]</code> 表示矩形<code>i</code>的宽度。</p><p>返回对角线最<strong>长</strong>的矩形的<strong>面积</strong>。如果存在多个对角线长度相同的矩形，返回面积最<strong>大</strong>的矩形的面积。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：dimensions &#x3D; [[9,3],[8,6]]<br>输出：48<br>解释：<br>下标 &#x3D; 0，长度 &#x3D; 9，宽度 &#x3D; 3。对角线长度 &#x3D; sqrt(9 * 9 + 3 * 3) &#x3D; sqrt(90) ≈ 9.487。<br>下标 &#x3D; 1，长度 &#x3D; 8，宽度 &#x3D; 6。对角线长度 &#x3D; sqrt(8 * 8 + 6 * 6) &#x3D; sqrt(100) &#x3D; 10。<br>因此，下标为 1 的矩形对角线更长，所以返回面积 &#x3D; 8 * 6 &#x3D; 48。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：dimensions &#x3D; [[3,4],[4,3]]<br>输出：12<br>解释：两个矩形的对角线长度相同，为 5，所以最大面积 &#x3D; 12。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= dimensions.length &lt;= 100</code></li><li><code>dimensions[i].length == 2</code></li><li><code>1 &lt;= dimensions[i][0], dimensions[i][1] &lt;= 100</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>又是阅读理解题。</p><p>注意最后一句：如果存在多个对角线长度相同的矩形，返回面积最<strong>大</strong>的矩形的面积。这就需要特判一下了，如果对角线等于当前最大值就更新矩形面积。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">areaOfMaxDiagonal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dimensions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> nums: dimensions)&#123;</span><br><span class="line">            <span class="type">int</span> a = nums[<span class="number">0</span>], b = nums[<span class="number">1</span>];</span><br><span class="line">            <span class="type">double</span> tmp = <span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; s)&#123;<span class="comment">// 当对角线大时直接更新ans</span></span><br><span class="line">                s = tmp;</span><br><span class="line">                ans = a * b;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp == s)&#123;<span class="comment">// 相等时再判断最值</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, a * b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">areaOfMaxDiagonal</span><span class="params">(<span class="type">int</span>[][] dimensions)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] nums: dimensions)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> nums[<span class="number">0</span>], b = nums[<span class="number">1</span>];</span><br><span class="line">            <span class="type">double</span> <span class="variable">tmp</span> <span class="operator">=</span> Math.sqrt(a * a + b * b);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; s)&#123;<span class="comment">// 当对角线大时直接更新ans</span></span><br><span class="line">                s = Math.sqrt(a * a + b * b);</span><br><span class="line">                ans = a * b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp == s)&#123;<span class="comment">// 相等时再判断最值</span></span><br><span class="line">                ans = Math.max(ans, a * b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">areaOfMaxDiagonal</span>(<span class="params">self, dimensions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> dimensions:</span><br><span class="line">            tmp = sqrt(a * a + b * b)</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; s:</span><br><span class="line">                s = tmp</span><br><span class="line">                ans = a * b</span><br><span class="line">            <span class="keyword">elif</span> tmp == s:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, a * b)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)，n为数组长度。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>现有一个下标从 <strong>0</strong> 开始的 <code>8 x 8</code> 棋盘，上面有 <code>3</code> 枚棋子。</p><p>给你 <code>6</code> 个整数 <code>a</code> 、<code>b</code> 、<code>c</code> 、<code>d</code> 、<code>e</code> 和 <code>f</code> ，其中：</p><ul><li><code>(a, b)</code> 表示白色车的位置。</li><li><code>(c, d)</code> 表示白色象的位置。</li><li><code>(e, f)</code> 表示黑皇后的位置。</li></ul><p>假定你只能移动白色棋子，返回捕获黑皇后所需的<strong>最少</strong>移动次数。</p><p><strong>请注意</strong>：</p><ul><li>车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。</li><li>象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。</li><li>如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。</li><li>皇后不能移动。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/12/21/ex1.png" alt="img"></p><blockquote><p>输入：a &#x3D; 1, b &#x3D; 1, c &#x3D; 8, d &#x3D; 8, e &#x3D; 2, f &#x3D; 3<br>输出：2<br>解释：将白色车先移动到 (1, 3) ，然后移动到 (2, 3) 来捕获黑皇后，共需移动 2 次。<br>由于起始时没有任何棋子正在攻击黑皇后，要想捕获黑皇后，移动次数不可能少于 2 次。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/12/21/ex2.png" alt="img"></p><blockquote><p>输入：a &#x3D; 5, b &#x3D; 3, c &#x3D; 3, d &#x3D; 4, e &#x3D; 5, f &#x3D; 2<br>输出：1<br>解释：可以通过以下任一方式移动 1 次捕获黑皇后：</p><ul><li>将白色车移动到 (5, 2) 。</li><li>将白色象移动到 (5, 2) 。</li></ul></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a, b, c, d, e, f &lt;= 8</code></li><li>两枚棋子不会同时出现在同一个格子上。</li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>恶心人的题，分类讨论。</p><ol><li><p>如果车能直接攻击到皇后，或者象能直接攻击到皇后，那么返回1。</p></li><li><p>如果车被象挡住，那么移走象，车就可以攻击到皇后，返回2。</p></li><li><p>如果象被车挡住，那么移走车，象就可以攻击到皇后，返回2。</p></li><li><p>如果车不能直接攻击到皇后，那么车可以水平移动或者垂直移动，其中一个位置必定不会被象挡住，可以攻击到皇后，返回2。</p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMovesToCaptureTheQueen</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span>, c: <span class="built_in">int</span>, d: <span class="built_in">int</span>, e: <span class="built_in">int</span>, f: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="number">9</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="number">9</span> <span class="keyword">and</span> j &lt; <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a == e <span class="keyword">and</span> a != c): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(b == f <span class="keyword">and</span> b != d): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(a == c <span class="keyword">and</span> a == e <span class="keyword">and</span> <span class="built_in">abs</span>(b - f) != <span class="built_in">abs</span>(b - d) + <span class="built_in">abs</span>(d - f)): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(b == d <span class="keyword">and</span> b == f <span class="keyword">and</span> <span class="built_in">abs</span>(a - e) != <span class="built_in">abs</span>(a - c) + <span class="built_in">abs</span>(c - e)): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：<code>O(9 * 4) = O(1)</code>。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们的长度都是偶数<code> n</code> 。</p><p>你必须从 <code>nums1</code> 中移除 <code>n / 2</code> 个元素，同时从 <code>nums2</code> 中也移除 <code>n / 2</code> 个元素。移除之后，你将 <code>nums1</code> 和 <code>nums2</code> 中剩下的元素插入到集合 <code>s</code> 中。</p><p>返回集合 <code>s</code>可能的 <strong>最多</strong> 包含多少元素。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,2,1,2], nums2 &#x3D; [1,1,1,1]<br>输出：2<br>解释：从 nums1 和 nums2 中移除两个 1 。移除后，数组变为 nums1 &#x3D; [2,2] 和 nums2 &#x3D; [1,1] 。因此，s &#x3D; {1,2} 。<br>可以证明，在移除之后，集合 s 最多可以包含 2 个元素。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [2,3,2,3,2,3]<br>输出：5<br>解释：从 nums1 中移除 2、3 和 6 ，同时从 nums2 中移除两个 3 和一个 2 。移除后，数组变为 nums1 &#x3D; [1,4,5] 和 nums2 &#x3D; [2,3,2] 。因此，s &#x3D; {1,2,3,4,5} 。<br>可以证明，在移除之后，集合 s 最多可以包含 5 个元素。 </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,1,2,2,3,3], nums2 &#x3D; [4,4,5,5,6,6]<br>输出：6<br>解释：从 nums1 中移除 1、2 和 3 ，同时从 nums2 中移除 4、5 和 6 。移除后，数组变为 nums1 &#x3D; [1,2,3] 和 nums2 &#x3D; [4,5,6] 。因此，s &#x3D; {1,2,3,4,5,6} 。<br>可以证明，在移除之后，集合 s 最多可以包含 6 个元素。 </p></blockquote><p><strong>提示：</strong></p><ul><li><code>n == nums1.length == nums2.length</code></li><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li><li><code>n</code>是偶数。</li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^9</code></li></ul><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>这题一看，好像很难，但其实就是简单的求交集，数学找规律求方程即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSetSize</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums1)&#123;</span><br><span class="line">            set1.add(i);    <span class="comment">// nums1的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums2)&#123;</span><br><span class="line">            set2.add(i);    <span class="comment">// nums2的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(set1);</span><br><span class="line">        set.addAll(set2);   <span class="comment">// set1和set2的并集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, set1.size() - n / <span class="number">2</span>), x2 = Math.max(<span class="number">0</span>, set2.size() - n / <span class="number">2</span>);   <span class="comment">// nums1和nums2仍需要删除的数的数量</span></span><br><span class="line">        <span class="keyword">if</span>(x1 == <span class="number">0</span> &amp;&amp; x2 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> set.size();  <span class="comment">// 如果不需要删除了，就直接返回两者的并集的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(set1);</span><br><span class="line">        s.retainAll(set2);  <span class="comment">// 两者的交集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Math.min(<span class="number">0</span>, s.size() - x1 - x2);    <span class="comment">// 通过统计找到的规律，先从两者交集中移除元素，如果够用了x=0，不够的话x&lt;0,然后再从两者的并集中移除元素。</span></span><br><span class="line">        <span class="keyword">return</span> set.size() + x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumSetSize</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums1)</span><br><span class="line">        s1, s2 = <span class="built_in">set</span>(nums1), <span class="built_in">set</span>(nums2)</span><br><span class="line">        x1, x2 = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1) - n // <span class="number">2</span>), <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">len</span>(s2) - n // <span class="number">2</span>) <span class="comment"># nums1和nums2仍需要删除的数的数量</span></span><br><span class="line">        <span class="keyword">if</span> (x1 == <span class="number">0</span> <span class="keyword">and</span> x2 == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(s1 | s2)<span class="comment"># 如果不需要删除了，就直接返回两者的并集的长度</span></span><br><span class="line">        </span><br><span class="line">        s = s1 &amp; s2</span><br><span class="line">        x = <span class="built_in">min</span>(<span class="built_in">len</span>(s) - x1 - x2, <span class="number">0</span>) <span class="comment"># 通过统计找到的规律，先从两者交集中移除元素，如果够用了x=0，不够的话x&lt;0,然后再从两者的并集中移除元素。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s1 | s2) + x</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：<code>O(n * 4) = O(n)</code>，定义了4个哈希集合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第121场双周赛</title>
      <link href="/inori/6b6c0081.html"/>
      <url>/inori/6b6c0081.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode第121场双周赛"><a href="#LeetCode第121场双周赛" class="headerlink" title="LeetCode第121场双周赛"></a>LeetCode第121场双周赛</h1><p>​每次这么晚打比赛脑子都要抽风，这次周赛疯狂WA，第一道简单题更是WA了4次，受不了了。每次打比赛我都是能AC三题就是胜利，第四题看一眼题干，能看懂就做，看不懂就不做了，这次确实是A掉三题，只不过罚时了很久就是了…</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>如果一个前缀 <code>nums[0..i]</code> 满足对于 <code>1 &lt;= j &lt;= i</code> 的所有元素都有 <code>nums[j] = nums[j - 1] + 1</code> ，那么我们称这个前缀是一个 <strong>顺序前缀</strong> 。特殊情况是，只包含 <code>nums[0]</code> 的前缀也是一个 <strong>顺序前缀</strong> 。</p><p>请你返回 <code>nums</code> 中没有出现过的 <strong>最小</strong> 整数 <code>x</code> ，满足 <code>x</code> 大于等于 <strong>最长</strong> 顺序前缀的和。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [1,2,3,2,5]<br>输出：6<br>解释：nums 的最长顺序前缀是 [1,2,3] ，和为 6 ，6 不在数组中，所以 6 是大于等于最长顺序前缀和的最小整数。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums &#x3D; [3,4,5,1,12,14,13]<br>输出：15<br>解释：nums 的最长顺序前缀是 [3,4,5] ，和为 12 ，12、13 和 14 都在数组中，但 15 不在，所以 15 是大于等于最长顺序前缀和的最小整数。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= 50</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>纯纯阅读理解题，我就是因为没理解到位WA了三次。</p><ol><li><p>必须<code>1 &lt;= j &lt;= i</code>之间的所有元素全都满足才算一个顺序前缀。并且**nums[0]**也算一个顺序前缀。</p></li><li><p>需要返回的是最长顺序前缀的和，并且这个和在数组中没出现过，如果出现过，就一直+1直到满足条件。</p></li></ol><p>明白了以上几点，再看数据范围：50，啥都不用想了，直接<code>n^2</code>暴力解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingInteger</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, s = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; hashSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            hashSet.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">1</span>, ts = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    tmp ++;</span><br><span class="line">                    ts += nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">// 如果不满足条件直接break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmp);</span><br><span class="line">            <span class="keyword">if</span>(ans == tmp)&#123;<span class="comment">// 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">                s = <span class="built_in">max</span>(s, ts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">50</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s; i &lt;= <span class="number">51</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.<span class="built_in">find</span>(i) == hashSet.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingInteger</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>, ts = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    tmp ++;</span><br><span class="line">                    ts += nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">// 如果不满足条件直接break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, tmp);</span><br><span class="line">            <span class="keyword">if</span>(ans == tmp) s = Math.max(s, ts);<span class="comment">// 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">50</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s; i &lt;= <span class="number">51</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingInteger</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, ans, s = <span class="built_in">len</span>(nums), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        hashSet = <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tmp, ts = <span class="number">1</span>, nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>:</span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">                    ts += nums[j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmp)</span><br><span class="line">            <span class="keyword">if</span> ans == tmp:<span class="comment"># 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">                s = <span class="built_in">max</span>(s, ts)</span><br><span class="line">        <span class="keyword">if</span> s &gt; <span class="number">50</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s, <span class="number">52</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hashSet:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n^2)，n为数组长度。</li><li>空间复杂度：O(n)，定义了一个哈希集合，最坏情况下有n个数。</li></ul><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p><p>你可以对数组执行以下操作 <strong>任意次</strong> ：</p><ul><li>选择数组里的 <strong>任意</strong> 一个元素，并将它的 <strong>二进制</strong> 表示 <strong>翻转</strong> 一个数位，翻转数位表示将 <code>0</code> 变成 <code>1</code> 或者将 <code>1</code> 变成 <code>0</code> 。</li></ul><p>你的目标是让数组里 <strong>所有</strong> 元素的按位异或和得到 <code>k</code> ，请你返回达成这一目标的 <strong>最少</strong> 操作次数。</p><p><strong>注意</strong>，你也可以将一个数的前导 0 翻转。比方说，数字 <code>(101)2</code> 翻转第四个数位，得到 <code>(1101)2</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [2,1,3,4], k &#x3D; 1<br>输出：2<br>解释：我们可以执行以下操作：</p><ul><li>选择下标为 2 的元素，也就是 3 &#x3D;&#x3D; (011)2 ，我们翻转第一个数位得到 (010)2 &#x3D;&#x3D; 2 。数组变为 [2,1,2,4] 。</li><li>选择下标为 0 的元素，也就是 2 &#x3D;&#x3D; (010)2 ，我们翻转第三个数位得到 (110)2 &#x3D;&#x3D; 6 。数组变为 [6,1,2,4] 。<br>最终数组的所有元素异或和为 (6 XOR 1 XOR 2 XOR 4) &#x3D;&#x3D; 1 &#x3D;&#x3D; k 。<br>无法用少于 2 次操作得到异或和等于 k 。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums &#x3D; [2,0,2,0], k &#x3D; 0<br>输出：0<br>解释：数组所有元素的异或和为 (2 XOR 0 XOR 2 XOR 0) &#x3D;&#x3D; 0 &#x3D;&#x3D; k 。所以不需要进行任何操作。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^6</code></li><li><code>0 &lt;= k &lt;= 10^6</code></li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>这道题看似很唬人，其实是纸老虎。</p><p>设nums的异或和为s。</p><p>令<code>s=k</code>就等于<code>s⊕k=0</code>。也就是把数组中所有数全部异或，令其为x，只需要比较x和k有多少位不一样即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            s ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        s ^= k;<span class="comment">// 想知道s和k有几位数不一样只需要异或一次后数1的个数即可</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s)&#123;</span><br><span class="line">            ans += s &amp; <span class="number">1</span>;</span><br><span class="line">            s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            s ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(s ^ k);<span class="comment">// 想知道s和k有几位数不一样只需要异或一次后数1的个数即可,bitCount方法可以直接获取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            s ^= i</span><br><span class="line">        <span class="keyword">return</span> (s ^ k).bit_count()</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)，n为数组长度。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>给你两个正整数 <code>x</code> 和 <code>y</code> 。</p><p>一次操作中，你可以执行以下四种操作之一：</p><ol><li>如果 <code>x</code> 是 <code>11</code> 的倍数，将 <code>x</code> 除以 <code>11</code> 。</li><li>如果 <code>x</code> 是 <code>5</code> 的倍数，将 <code>x</code> 除以 <code>5</code> 。</li><li>将 <code>x</code> 减 <code>1</code> 。</li><li>将 <code>x</code> 加 <code>1</code> 。</li></ol><p>请你返回让 <code>x</code> 和 <code>y</code> 相等的 <strong>最少</strong> 操作次数。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：x &#x3D; 26, y &#x3D; 1<br>输出：3<br>解释：我们可以通过以下操作将 26 变为 1 ：</p><ol><li>将 x 减 1</li><li>将 x 除以 5</li><li>将 x 除以 5<br>将 26 变为 1 最少需要 3 次操作。</li></ol></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：x &#x3D; 54, y &#x3D; 2<br>输出：4<br>解释：我们可以通过以下操作将 54 变为 2 ：</p><ol><li>将 x 加 1</li><li>将 x 除以 11</li><li>将 x 除以 5</li><li>将 x 加 1<br>将 54 变为 2 最少需要 4 次操作。</li></ol></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：x &#x3D; 25, y &#x3D; 30<br>输出：5<br>解释：我们可以通过以下操作将 25 变为 30 ：</p><ol><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1<br>将 25 变为 30 最少需要 5 次操作。</li></ol></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x, y &lt;= 10^4</code></li></ul><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>这题我第一眼看以为是模拟，仔细看了一下样例发现没有这么复杂，可以抽象成最短路问题，直接BFS即可。</p><p>这里有一点可以优化的方法：注意x想要增加只有+1这种方法，所有如果<code>y &gt;= x</code>时，直接返回<code>y - x</code>即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperationsToMakeEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        deque&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(x, <span class="number">0</span>));</span><br><span class="line">        visited.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="type">int</span> tmp = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(now);</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(now);</span><br><span class="line">            <span class="keyword">if</span> (tmp == y)&#123;</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">11</span> == <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp / <span class="number">11</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp / <span class="number">11</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp / <span class="number">11</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp / <span class="number">5</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp / <span class="number">5</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp / <span class="number">5</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp - <span class="number">1</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp - <span class="number">1</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp - <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">find</span>(tmp + <span class="number">1</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp + <span class="number">1</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp + <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperationsToMakeEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        ArrayDeque&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, <span class="number">0</span>&#125;);</span><br><span class="line">        set.add(x);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] now = q.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> now[<span class="number">0</span>], cnt = now[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmp == y) <span class="keyword">return</span> cnt;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">11</span> == <span class="number">0</span> &amp;&amp; !set.contains(tmp / <span class="number">11</span>))&#123;</span><br><span class="line">                set.add(tmp / <span class="number">11</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp / <span class="number">11</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; !set.contains(tmp / <span class="number">5</span>))&#123;</span><br><span class="line">                set.add(tmp / <span class="number">5</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp / <span class="number">5</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span> &amp;&amp; !set.contains(tmp - <span class="number">1</span>))&#123;</span><br><span class="line">                set.add(tmp - <span class="number">1</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp - <span class="number">1</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(tmp + <span class="number">1</span>))&#123;</span><br><span class="line">                set.add(tmp + <span class="number">1</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp + <span class="number">1</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumOperationsToMakeEqual</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> y &gt;= x:</span><br><span class="line">            <span class="keyword">return</span> y - x</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        q.append((x, <span class="number">0</span>))</span><br><span class="line">        visited.add(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp, cnt = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> tmp == y:</span><br><span class="line">                <span class="keyword">return</span> cnt</span><br><span class="line">            <span class="keyword">if</span> tmp % <span class="number">11</span> == <span class="number">0</span> <span class="keyword">and</span> tmp // <span class="number">11</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp // <span class="number">11</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp // <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp % <span class="number">5</span> == <span class="number">0</span> <span class="keyword">and</span> tmp // <span class="number">5</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp // <span class="number">5</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp // <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span> <span class="keyword">and</span> tmp - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp - <span class="number">1</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp + <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp + <span class="number">1</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(x)。</li><li>空间复杂度：O(x)，定义了一个哈希集合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题.1</title>
      <link href="/inori/7752405a.html"/>
      <url>/inori/7752405a.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode每日一题"><a href="#LeetCode每日一题" class="headerlink" title="LeetCode每日一题"></a>LeetCode每日一题</h1><p>​今天的每日一题是<a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/">2807. 在链表中插入最大公约数</a>，难度标的中等，不过我认为应该是简单题</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你一个链表的头 <code>head</code> ，每个结点包含一个整数值。</p><p>在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 <strong>最大公约数</strong> 。</p><p>请你返回插入之后的链表。</p><p>两个数的 <strong>最大公约数</strong> 是可以被两个数字整除的最大正整数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/07/18/ex1_copy.png" alt="img"></p><blockquote><p>输入：head &#x3D; [18,6,10,3]<br>输出：[18,6,6,2,10,1,3]<br>解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。</p><ul><li>18 和 6 的最大公约数为 6 ，插入第一和第二个结点之间。</li><li>6 和 10 的最大公约数为 2 ，插入第二和第三个结点之间。</li><li>10 和 3 的最大公约数为 1 ，插入第三和第四个结点之间。<br>所有相邻结点之间都插入完毕，返回链表。</li></ul></blockquote><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/07/18/ex2_copy1.png" alt="img"></p><blockquote><p>输入：head &#x3D; [7]<br>输出：[7]<br>解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。<br>没有相邻结点，所以返回初始链表。</p></blockquote><p><strong>提示：</strong></p><ul><li>链表中结点数目在 <code>[1, 5000]</code> 之间。</li><li><code>1 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>​这道题很直观，明显是考差欧几里得算法(辗转相除法)<code>gcd(a,b) = gcd(b,a mod b)</code>原理为：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。</p><p>​明白了考察的知识点，这道题就非常简单了，直接遍历链表，在每两个节点直接插入这两个节点的值的最大公约数<code>gcd(node1.val, node2.val)</code>即可，计算gcd的方法可以是 <code>Math.gcd</code>或者自定义方法。</p><p>​有一点需要注意，只有节点数大于1时才需要插入，否则直接返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">insertGreatestCommonDivisors</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = head, *ne = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(ne)&#123;</span><br><span class="line">            ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="built_in">gcd</span>(pre-&gt;val, ne-&gt;val), ne);</span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">            pre = ne;</span><br><span class="line">            ne = ne-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">insertGreatestCommonDivisors</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, ne = head.next;</span><br><span class="line">        <span class="keyword">while</span>(ne != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> gcd(pre.val, ne.val);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(g, ne);</span><br><span class="line">            pre.next = newNode;</span><br><span class="line">            pre = ne;</span><br><span class="line">            ne = ne.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertGreatestCommonDivisors</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">            <span class="keyword">return</span> a <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        pre, ne = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> ne:</span><br><span class="line">            node = ListNode(gcd(pre.val, ne.val), ne)</span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">            pre = ne</span><br><span class="line">            ne = ne.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(nlog⁡M)，其中n为链表长度，M是节点最大可能的值，每次计算要O(logM)的时间。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些碎碎念</title>
      <link href="/inori/303572a2.html"/>
      <url>/inori/303572a2.html</url>
      
        <content type="html"><![CDATA[<h3 id="2024-1-1"><a href="#2024-1-1" class="headerlink" title="2024.1.1"></a>2024.1.1</h3><p>​很久以前就想着搭一个个人博客，但是一直拖着没搞，昨天晚上闲来无事，突然想到这件事，一口气搞出来了。说是个人博客，主要是当我的笔记本用吧，博客里面很多东西都没弄懂，也没弄好。</p><p>​目标是缓慢且持续的更新，学啥更啥…</p><h3 id="2024-1-26"><a href="#2024-1-26" class="headerlink" title="2024.1.26"></a>2024.1.26</h3><p>​终于把期末考试的事搞完了，我认为研究生上的课，不对，应该是本科和研究生上的课不能说是毫无用处，只能说是屁用没有，占用自学的时间，在那坐着浪费时间，老师在课上讲一些已经与当前正在应用的技术脱节很久的老知识，关键是课程报告和结课论文还需要用这些东西，学这些东西以后又用不上，又要浪费一大段时间。唉</p><h3 id="2024-2-1"><a href="#2024-2-1" class="headerlink" title="2024.2.1"></a>2024.2.1</h3><p>​放寒假了，实验室布置了一堆任务，但是我自己还想要自学很多东西，好像放假比不放假还难受。现在开始继续学习并且更新博客了。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/inori/4a17b156.html"/>
      <url>/inori/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>费了不少劲！终于把我的博客搭好了！</p><h3 id="所用技术"><a href="#所用技术" class="headerlink" title="所用技术"></a>所用技术</h3><p>​本网站使用GitHub后端+Hexo框架+Butterfly渲染，并在基础上做出了一小部分魔改，加了些花里胡哨的东西，域名在阿里云选购。</p><hr><p>​就说这么多吧，后续我争取做到把每日学到的东西做一个总结，更新在这里，希望可以用这种方法来加深我对知识的理解与记忆。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
