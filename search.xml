<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL基础篇</title>
      <link href="/inori/337fcc87.html"/>
      <url>/inori/337fcc87.html</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h2><table><thead><tr><th align="center">名称</th><th align="center">解释</th><th align="center">简称</th></tr></thead><tbody><tr><td align="center">数据库</td><td align="center">将数据有组织的存储的仓库</td><td align="center">DataBase(DB)</td></tr><tr><td align="center">数据库管理系统</td><td align="center">操纵和管理数据库的大型软件</td><td align="center">DBMS</td></tr><tr><td align="center">SQL</td><td align="center">操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准</td><td align="center">Structured Query Language</td></tr></tbody></table><p>工程师通过SQL操作DBMS，间接管理数据库中的数据</p><p>Oracle、MySQL等系统是关系型数据库管理系统，支持使用SQL语言进行数据库操作。</p><p>关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</p><h3 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h3><p>安装：这里推荐安装Mysql8版本，可以参考<a href="https://zhuanlan.zhihu.com/p/645347983?utm_id=0">这篇文章</a>安装MySQL</p><p>启动与停止：</p><blockquote><p>net start mysql80</p><p>net stop mysql80</p></blockquote><p>客户端连接：<code>mysql [-h 127.0.0.1] [-P 3306] -u root -p</code></p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul><li>SQL语句可以单行或多行书写，以分号结尾</li><li>MySQL中的SQL语句不区分大小写，但是关键字推荐使用大写</li><li>注释：<ul><li>单行注释：<code>-- 注释内容</code>或<code># 注释内容</code>(MySQL特有)</li><li>多行注释：<code>/*注释内容*/</code></li></ul></li></ul><h3 id="SQL数值类型"><a href="#SQL数值类型" class="headerlink" title="SQL数值类型"></a>SQL数值类型</h3><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p><img src="D:\Blog\source\img\mysql_intDataType.png" alt="mysql_datatype"></p><p>无符号数<code>TINYINT UNSIGNED</code>，DECIMAL类型<code>DECIMAL(x,y)</code>，x代表数字的整体长度&#x3D;整数长度+小数长度，y代表小数的长度</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p><img src="D:\Blog\source\img\mysql_charDataType.png" alt="mysql_datatype"></p><p>​CHAR为定长字符串，开多少空间就占用多少空间，VARCHAR为变长字符串，根据存储的数据动态计算空间。</p><p>​长文本数据分为<u>BLOB</u>和<u>TEXT</u>类型，BLOB表示二进制数据，可以是音频、视频、图像等数据，可以将其存储在数据库中，但是在开发时很少这么做，一般采用专门的文件服务器进行存储。</p><h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><p><img src="D:\Blog\source\img\mysql_timeDataType.png" alt="mysql_timeDataType"></p><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><table><thead><tr><th align="center">分类</th><th align="center">全称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DDL</td><td align="center">Data Definition Language</td><td align="center">数据定义语言，定义数据库对象（数据库，表，字段）</td></tr><tr><td align="center">DML</td><td align="center">Data Manipulation Language</td><td align="center">数据操作语言，对数据库表中的数据进行增删改</td></tr><tr><td align="center">DQL</td><td align="center">Data Query Language</td><td align="center">数据查询语言，查询表中的记录</td></tr><tr><td align="center">DCL</td><td align="center">Data Control Language</td><td align="center">数据控制语言，创建数据库用户、控制访问权限</td></tr></tbody></table><h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><p><code>[...]</code>部分为可选参数</p><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><ul><li>查询所有数据库：<code>SHOW DATABASES;</code></li><li>查询当前数据库：<code>SELECT DATABASE();</code></li><li>创建：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; </code></li><li>删除：<code>DROP DATABASE [IF EXISTS] 数据库名;</code></li><li>使用：<code>USE 数据库名;</code></li></ul><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><ul><li>查询数据库所有表：<code>SHOW TABLES;</code></li><li>查询表结构：<code>DESE 表名;</code></li><li>查询指定表的建表语句：<code>SHOW CREATE TABLE 表名;</code></li><li>创建表：</li></ul><blockquote><p>CREATE TABLE 表名(</p><p>​字段1 字段1类型[COMMENT 字段1注释],</p><p>​字段2 字段2类型[COMMENT 字段2注释],</p><p>​…..,</p><p>​字段n 字段n类型[COMMENT 字段n注释]</p><p>)[COMMENT 表注释];</p></blockquote><ul><li>添加字段：<code>ALTER TABLE 表名 ADD 字段名 类型 [comment] [约束];</code></li><li>修改数据类型：<code>ALTER TABLE 表名 MODIFY 字段名 新类型;</code></li><li>修改字段名和类型：<code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 [comment] [约束];</code></li><li>修改表名：<code>ALTER TABLE 表名 RENAME TO 新表名;</code></li><li>删除字段：<code>ALTER TABLE 表名 DROP 字段名;</code></li><li>删除表：<code>DROP TABLE [IF EXISTS] 表名;</code></li><li>删除指定表并重新创建（格式化该表）：<code>TRUNCATE TABLE 表名;</code></li></ul><h3 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h3><ul><li>给指定字段添加数据：<code>INSERT INTO 表名（字段1，字段2...） VALUES（值1，值2...）;</code></li><li>给全部字段添加数据：<code>INSERT INTO 表名 VALUES（值1，值2...）;</code></li><li>批量添加数据：</li></ul><blockquote><p>INSERT INTO 表名（字段1，字段2…） VALUES（值1，值2…）,（值1，值2…）…;</p><p>INSERT INTO 表名 VALUES（值1，值2…）,（值1，值2…）…;</p></blockquote><ul><li>修改数据：<code>UPDATE 表名 SET 字段1=值1, 字段2=值2...[WHERE 条件];</code></li><li>删除数据：<code>DELETE FROM 表名 [WHERE 条件];</code></li></ul><h3 id="DQL语句"><a href="#DQL语句" class="headerlink" title="DQL语句"></a>DQL语句</h3><ul><li><p>查询多个字段：<code>SELECT 字段1,字段2,... FROM 表名;</code></p></li><li><p>查询全部字段：<code>SELECT * FROM 表名;</code></p></li><li><p>设置别名：<code>SELECT 字段1 AS 别名1,字段2 AS 别名2,... FROM 表名;</code></p></li><li><p>去重：<code>SELECT DISTINCT 字段列表 FROM 表名;</code></p></li><li><p>条件查询：<code>SELECT 字段列表 FROM WHERE 条件列表;</code></p><p><u>此处的条件列表与其他编程语言的条件判断基本一致</u>，个别不一样的中常用的有<code>LIKE 占位符</code>表示模糊匹配（_匹配单个字符，%匹配任意字符）</p></li><li><p>使用聚合函数查询：<code>SELECT 聚合函数(字段列表) FROM 表名;</code></p></li></ul><p>​常用的聚合函数有：<u>count(),max(),min(),avg(),sum()</u>,按列进行计算</p><ul><li><p>分组查询：<code>SELECT 字段列表 FROM 表名 [WHERE 分组前过滤条件] GROUP BY 分组字段名 [HAVING 分组后的过滤条件];</code>（其中having中可以使用聚合函数过滤，where中不可以，并且分组之后查询的字段一般为分组字段和聚合函数）</p></li><li><p>排序查询：<code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;</code></p><p><u>排序方式有两种：ASC：升序（默认），DESC：降序。</u>如果是多字段排序，当且仅当第一个字段相同时按照第二个排。</p></li><li><p>分页查询：<code>SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</code></p><ul><li>索引从0开始编号，起始索引&#x3D;（查询页面-1）*每页的记录数</li><li>分页查询时数据库的方言，不同的数据库中实现语句不同，MySQL中是LIMIT</li><li>如果查的是第一页的数据，起始索引可以省略</li></ul></li></ul><h4 id="DQL语句编写顺序与执行顺序"><a href="#DQL语句编写顺序与执行顺序" class="headerlink" title="DQL语句编写顺序与执行顺序"></a>DQL语句编写顺序与执行顺序</h4><p><img src="D:\Blog\source\img\mysql_DQLSequence.png" alt="mysql_DQLSequence"></p><h3 id="DCL语句"><a href="#DCL语句" class="headerlink" title="DCL语句"></a>DCL语句</h3><ul><li>查询用户：<code>SELECT * FROM user;</code></li><li>创建用户：<code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></li><li>修改用户密码：<code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password &#39;新密码&#39;;</code></li><li>删除用户：<code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>查询用户权限：<code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>授予权限：<code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>撤销权限：<code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></li></ul><h4 id="常用的权限"><a href="#常用的权限" class="headerlink" title="常用的权限"></a>常用的权限</h4><table><thead><tr><th align="center">权限</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">all&#x2F;all privileges</td><td align="center">所有权限</td></tr><tr><td align="center">select</td><td align="center">查询数据</td></tr><tr><td align="center">insert</td><td align="center">插入数据</td></tr><tr><td align="center">update</td><td align="center">修改数据</td></tr><tr><td align="center">delete</td><td align="center">删除数据</td></tr><tr><td align="center">alter</td><td align="center">修改表</td></tr><tr><td align="center">drop</td><td align="center">删除数据库、表、视图</td></tr><tr><td align="center">create</td><td align="center">创建数据库、表</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在数据库中，函数指的是可以直接被另一段程序调用的程序或代码。</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CONCAT(S1,S2,…,Sn)</td><td align="center">字符串拼接，将给定的字符串拼成一个</td></tr><tr><td align="center">LOWER(str)</td><td align="center">str全部字符转成小写</td></tr><tr><td align="center">UPPER(str)</td><td align="center">str全部字符转成大写</td></tr><tr><td align="center">LPAD(str,n,pad)</td><td align="center">左填充，用字符串pad对str的左边进行填充直到长度到达n</td></tr><tr><td align="center">RPAD(str,n,pad)</td><td align="center">右填充，用字符串pad对str的右边进行填充直到长度到达n</td></tr><tr><td align="center">TRIM(str)</td><td align="center">去掉收尾空格</td></tr><tr><td align="center">SUBSTRING(str,start,len)</td><td align="center">返回字符串str从start开始len长度的字符串，索引从1开始</td></tr><tr><td align="center">LENGTH(str)</td><td align="center">返回字符串长度</td></tr></tbody></table><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CEIL(x)</td><td align="center">上取整</td></tr><tr><td align="center">FLOOR(x)</td><td align="center">下取整</td></tr><tr><td align="center">MOD(x,y)</td><td align="center">返回x&#x2F;y的模</td></tr><tr><td align="center">RAND()</td><td align="center">返回0~1的随机数</td></tr><tr><td align="center">ROUND(x,y)</td><td align="center">求x的四舍五入，保留y位小数</td></tr></tbody></table><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CURDATE()</td><td align="center">返回当前日期</td></tr><tr><td align="center">CURTIME()</td><td align="center">获取当前时间</td></tr><tr><td align="center">NOW()</td><td align="center">获取当前日期和时间</td></tr><tr><td align="center">YEAR(date)</td><td align="center">返回指定date的年份</td></tr><tr><td align="center">MONTH(date)</td><td align="center">返回指定date的月份</td></tr><tr><td align="center">DAY(date)</td><td align="center">返回指定date的日</td></tr><tr><td align="center">DATE_ADD(date,INTERVAL expr type)</td><td align="center">返回一个日期&#x2F;时间加上一个时间间隔expr后的时间</td></tr><tr><td align="center">DATEDIFF(date1,date2)</td><td align="center">返回date1和date2之间间隔的天数，date1-date2</td></tr></tbody></table><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">IF(value,t,f)</td><td align="center">如果value为true，返回t，否则返回f</td></tr><tr><td align="center">IFNULL(value1,value2)</td><td align="center">如果value1不为空，返回value1，否则返回value2</td></tr><tr><td align="center">CASE WHEN [val1] THEN [res1]…ELSE[default]END</td><td align="center">如果val1为true，返回res1,…否则返回默认值</td></tr><tr><td align="center">CASE [expr] WHEN [val1] THEN [res1]…ELSE[default]END</td><td align="center">如果expr的值等于val1，返回res1,…否则返回默认值</td></tr></tbody></table><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>​约束是作用于表中字段上的规则，在创建表或修改表的时候添加约束，用于限制存储在表中的数据。可以保证数据的正确，有效性和完整性。</p><h3 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h3><p><img src="D:\Blog\source\img\mysql_limitTyoe.png" alt="mysql_limitTyoe"></p><p>添加约束时只需要在后面直接添加关键字即可，不同约束使用空格隔开</p><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>​外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性，具有外键的称为子表&#x2F;从表，外键所关联的表称为父表&#x2F;主表。</p><ul><li>建立外键关联</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可以在创建表时直接指明外键</span><br><span class="line">CREATE TABLE name(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">    ...,</span><br><span class="line">    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 或者建表之后额外添加</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表(主表字段);</span><br></pre></td></tr></table></figure><ul><li>删除外键：<code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></li></ul><h3 id="外键约束-1"><a href="#外键约束-1" class="headerlink" title="外键约束"></a>外键约束</h3><p><img src="D:\Blog\source\img\mysql_fkType.png" alt="mysql_fkType"></p><p>使用时在外键命令后面添加<code>ON UPDATE 行为 ON DELETE 行为</code></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表查询即从多张表中查询数据。可以分为<u>连接查询</u>和<u>子查询</u></p><ul><li><p>连接查询</p><ul><li><p>内连接</p></li><li><p>外连接</p><ul><li><p>左外连接</p></li><li><p>右外连接</p></li></ul></li><li><p>自连接</p></li></ul></li><li><p>子查询</p></li></ul><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li><p>一对一：</p><ul><li>案例：个人与个人信息</li><li>关系：每个人有每个人自己的个人信息</li><li>实现：将基础字段放在一张表中，详情信息放在另一张表中，在任意一方加入外键，关联另一方的主键，并设置外键为UNIQUE</li></ul></li><li><p>一对多&#x2F;多对一：</p><ul><li>案例：部门与员工</li><li>关系：一个部门对应多个员工，一个员工对应一个部门</li><li>实现：在多的一方建立外键，指向一的一方的主键</li></ul></li><li><p>多对多：</p><ul><li>案例：学生与课程</li><li>关系：一个学生可以选修多门课程，一门课程可以有多个学生选择</li><li>实现：建立一张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul></li></ul><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>查询A、B交集部分的数据</p><ul><li>隐式内连接：<code>SELECT 字段列表 FROM 表1,表2 WHERE 条件;</code></li><li>显示内连接：<code>SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件;</code></li></ul><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>查询左表所有数据，以及两张表交集部分的数据</p><p><code>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件; </code></p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>查询右表所有数据，以及两张表交集部分的数据</p><p><code>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件; </code></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>当前表与自身的连接查询，自连接必须使用表别名。自连接可以是内连接查询，也可以是外连接查询</p><p><code>SELECT 字段列表 FROM 表1 别名1 JOIN 表2 别名2 ON 条件; </code></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套SELECT语句称为嵌套查询，也叫子查询，子查询外部的语句可以是增删改查任意一个</p><p>例如：<code>SELECT 字段列表 FROM 表1 WHERE 字段1=(SELECT 字段1 FROM 表2); </code></p><p>根据子查询结果不同，分为：</p><ul><li><p>标量子查询（子查询结果为单个值）：直接嵌套查询即可</p></li><li><p>列子查询：</p><p>常用的操作符：IN(指定范围内),NOT IN(不在指定范围内),ANY(返回列表中任意一个满足条件即可),SOME(同ANY),ALL(条件必须全部满足)</p></li><li><p>行子查询:</p><p>常用的操作符：&#x3D;,&lt;&gt;,IN,NOT IN</p></li><li><p>表子查询（多行多列）:</p><p>常用的操作符：IN</p></li></ul><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询使用union(合并后去重)，union all(合并)命令，可以把多次查询的结果合并起来，形成一个新的查询结果集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 ...</span><br><span class="line">UNION[ALL]</span><br><span class="line">SELECT 字段列表 FROM 表1 ...;</span><br></pre></td></tr></table></figure><p>联合查询中多张表的列数必须保持一致，字段类型也要一致。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>​事务是一组操作的集合，是不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求。</p><p>​默认MySQL的事务是自动提交的，即执行DML语句时，MySQL会立即隐式的提交事务。</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>操作事务有两种方式：1.关闭事务的自动提交 2.通过指令显式开启事务</p><ul><li>查看事务提交方式：<code>SELECT @@autocommit;</code></li><li>设置事务提交方式(1为自动提交，0为手动提交）：<code>SET @@autocommit=0;</code> </li><li>开启事务：<code>START TRANSACTION;</code></li><li>提交事务：<code>COMMIT;</code></li><li>回滚事务：<code>ROLLBACK;</code></li></ul><h3 id="事务四大特性"><a href="#事务四大特性" class="headerlink" title="事务四大特性"></a>事务四大特性</h3><ul><li>原子性A：事务不可分割，事务中的操作要么同时成功，要么同时失败。</li><li>一致性C：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性I：数据库系统提供的隔离机制，保证事务在不收外部并发操作影响的独立环境下运行</li><li>持久性D：事务一旦提交或回滚，对数据的改变就是永久的</li></ul><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p>多个并发事务在执行过程当中所出现的问题</p><table><thead><tr><th align="center">问题</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">脏读</td><td align="center">一个事务读取到另一个事务还没有提交的数据</td></tr><tr><td align="center">不可重复读</td><td align="center">一个事物先后读取到同一条数据，但两次读取的数据不同</td></tr><tr><td align="center">幻读</td><td align="center">一个事物按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>√表示该隔离级别会出现对应问题，从上到下隔离级别由低到高，性能由高到低</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read committed</td><td align="center">x</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable Read</td><td align="center">x</td><td align="center">x</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><p>MySQL中的默认隔离级别是<u>Repeatable Read</u>，Oracle是<u>Read committed</u></p><ul><li>查看事务隔离级别：<code>SELECT @@transaction_isolation;</code></li><li>设置事务隔离级别：<code>SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;隔离级别&#125;;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射</title>
      <link href="/inori/e29c8e30.html"/>
      <url>/inori/e29c8e30.html</url>
      
        <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>利用反射机制，可以通过外部文件配置，在不修改源码的情况下控制程序，符合设计模型中OCP原则</p><ol><li>反射机制允许程序在执行期间借助于<code>Reflection</code>API取得任何类的内部信息（成员变量、构造器、成员方法等），并能操作对象的属性及方法。</li><li>加载类之后，在堆中产生了一个<code>Class</code>类型的对象，这个对象包括了类的完整结构信息。这个对象就像一面镜子，通过这个镜子看到类的结构，所以称之为：反射</li><li>反射可以做到的事：<ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ul></li><li>使用反射后，程序的执行速度会受到影响</li></ol><h2 id="反射相关的类"><a href="#反射相关的类" class="headerlink" title="反射相关的类"></a>反射相关的类</h2><p>常用的反射相关的类都在<code>java.lang</code>包中</p><ol><li>Class:代表一个类，表示某个类加载后在堆中的对象</li><li>reflect.Method:类的方法</li><li>reflect.Field:类的成员变量，<u>不能得到private属性</u></li><li>reflect.Constructor:构造器</li></ol><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ol><li>Class类也是继承Object的类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class对象，在内存中只有一份，因为类只加载一次（比如在使用反射加载类对象之前已经实例化过一次该类，就不会再调用loadClass方法）</li><li>Class对象存放在堆中</li><li>类的字节码二进制数据存放在方法区，称为类的元数据</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">static Class forName（）</td><td align="center">返回指定类名的Class对象</td></tr><tr><td align="center">Object newInstance()</td><td align="center">返回Class对象的一个实例</td></tr><tr><td align="center">String gatName()</td><td align="center">返回Class对象所表示的实体（类，接口，基本类型等）的名称</td></tr><tr><td align="center">Class getSuperClass()</td><td align="center">返回其父类</td></tr><tr><td align="center">Constructor[] getConstructors()</td><td align="center">返回本类的构造器</td></tr><tr><td align="center">ClassLoader getClassLoader()</td><td align="center">返回类的加载器</td></tr><tr><td align="center">Field[] getFields()</td><td align="center">返回所有public修饰的属性，包括本类及父类</td></tr><tr><td align="center">Field[] getDeclaredFields()</td><td align="center">返回本类所有属性</td></tr><tr><td align="center">Method[] getMethods()</td><td align="center">返回所有public修饰的方法，包括本类及父类</td></tr><tr><td align="center">Method[] getDeclaredMethods()</td><td align="center">返回本类所有方法</td></tr></tbody></table><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><ol><li>若已知一个类的完整路径“包名.类名”，可以通过Class类的<code>forName()</code>获取。<u>应用场景</u>：配置文件，读取类全路径，加载类</li><li>若已知具体的类，可以通过<code>类.class</code>获取，该方式也可以获取基本数据类型的Class对象。<u>应用场景</u>：用于参数传递，如通过反射的对应构造器对象。</li><li>如果已经有该类的实例，可以通过<code>对象.getClass()</code>获取Class对象</li><li>通过类加载器获取：</li></ol><blockquote><p>ClassLoader classLoader &#x3D; test.getClass().getClassLoader();</p><p>Class cls &#x3D; classLoader.loadClass(classAllPath);&#x2F;&#x2F; classAllPath为类的完整路径</p></blockquote><ol start="5"><li>基本数据类型的包装类（Integer，Boolean等）可以通过<code>.TYPE</code>获取Class对象</li></ol><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p>类加载分为<u>静态加载</u>和<u>动态加载</u>。</p><p>静态加载：编译时加载相关的类，如果没有则报错，哪怕不一定会用到这个类，也会加载</p><p>动态加载：运行时加载需要的类，如果运行时不用该类就不会报错，反射使用的就是动态加载方案</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanf.nextInt();</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">// 静态加载，哪怕可能不会使用到这个类也会加载，会直接报错</span></span><br><span class="line">                dog.method();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Dog&quot;</span>);<span class="comment">// 动态加载，当使用到的时候才会报错</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">                m.invoke();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h5><p>大体流程如下图所示。</p><p><img src="D:\Blog\source\img\ClassLoad.png"></p><p>​首先对源码进行编译，生成字节码文件，在运行时进入类加载，由类加载器将类的class文件读入内存，并创建一个Class对象。</p><p>然后进入连接阶段，把二进制数据合并到JRE中，<u>验证：</u>对文件安全性进行验证，<u>准备：</u>对静态变量进行默认初始化并分配空间，解析：把符号引用转成直接引用（地址引用）。最后进行初始化，由JVM负责，执行<code>&lt;clinit&gt;()</code>方法。</p><p>​<code>&lt;clinit&gt;()</code>方法是由编译器按照语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值动作和静态代码块中的语句，并进行合并。虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁，同步。如果多个线程同时去初始化一个类，同一时间内只允许一个线程执行此方法。</p><h3 id="Field类常用方法"><a href="#Field类常用方法" class="headerlink" title="Field类常用方法"></a>Field类常用方法</h3><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">getModifiers()</td><td align="center">以int形式返回修饰符</td></tr><tr><td align="center">getType()</td><td align="center">以Class形式获取返回类型</td></tr><tr><td align="center">getName()</td><td align="center">返回属性名</td></tr><tr><td align="center">getParameterTypes()</td><td align="center">以Class[] 返回参数类型数组</td></tr></tbody></table><p>注：在<code>getModifiers()</code>方法中，返回的int形式为：默认是0，public是1，private是2，protected是4，static是8，final是16。如果有多个修饰符就代数相加。</p><h2 id="反射暴破"><a href="#反射暴破" class="headerlink" title="反射暴破"></a>反射暴破</h2><p>使用反射机制访问private属性、方法、构造器，称为暴破（暴力破解），可以破坏封装特性。  </p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取person类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; person = Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> person.getDeclaredConstructor().newInstance();  <span class="comment">// 创建无参实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建private有参实例</span></span><br><span class="line">        Constructor&lt;?&gt; privateConstructor = person.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        privateConstructor.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴破</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> privateConstructor.newInstance(<span class="string">&quot;Mary&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> person.getDeclaredField(<span class="string">&quot;name&quot;</span>);   <span class="comment">// 获取name属性</span></span><br><span class="line">        name.set(o, <span class="string">&quot;Jack&quot;</span>);    <span class="comment">// 修改name</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">toString</span> <span class="operator">=</span> person.getMethod(<span class="string">&quot;toString&quot;</span>);     <span class="comment">// 获取toString方法</span></span><br><span class="line">        <span class="comment">// 如果方法有返回值，统一返回Object，但是运行类型和方法定义的返回类型一致</span></span><br><span class="line">        System.out.println(toString.invoke(o));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取private属性age</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> person.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.setAccessible(<span class="literal">true</span>);    <span class="comment">// 暴破</span></span><br><span class="line">        age.set(o, <span class="number">23</span>); <span class="comment">// 修改age</span></span><br><span class="line">        System.out.println(age.get(o)); <span class="comment">// 获取age的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取private方法say，如果方法中要求传参，则需要在后面输入参数对应的Class类</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">say</span> <span class="operator">=</span> person.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">        say.setAccessible(<span class="literal">true</span>);    <span class="comment">// 暴破</span></span><br><span class="line">        say.invoke(o1, <span class="string">&quot;success&quot;</span>, <span class="number">1</span>);  <span class="comment">// 激活方法并传入参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String word, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用say方法：&quot;</span> + word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java网络编程基础</title>
      <link href="/inori/bc47619b.html"/>
      <url>/inori/bc47619b.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p> 大都是计算机网络的基础知识，这里仅复习一下重点概念。</p><ol><li>IP地址&#x3D;网络地址+主机地址</li><li>IPv4最大的问题在于网络地址资源有限，制约了互联网的应用与发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</li><li>端口号用于标识计算机上某个特定的网络程序，范围是<strong>0~65535</strong>，其中<strong>0~1024</strong>已经被占用，当浏览器或程序要请求特定IP的某些服务时，需要使用IP地址+端口号的形式访问</li><li>常见的端口号：</li></ol><blockquote><p>ssh:22 ftp:21 smtp:25 http: 80</p><p>tomcat: 8080 mysql:3306 oracle:1521 sqlserver:1433</p></blockquote><ol start="5"><li>OSI七层模型是理论上的，并没有实际使用。主要使用的是TCP&#x2F;IP模型四层模型，分为：应用层、传输层、网际层、网络接口层</li><li>TCP协议：<ul><li>使用TCP前需要“三次握手”建立连接，形成传输数据通道，进行可靠传输</li><li>TCP协议进行通信的两个应用进程：客户端、服务端</li><li>在连接中可进行大数据量的传输</li><li>传输完毕需要释放已建立的连接，效率较低</li></ul></li><li>UDP协议：<ul><li>将数据、源、目的地封装成数据包，不需要建立连接，不可靠传输</li><li>每个数据包大小限制64KB</li><li>传输效率高</li></ul></li></ol><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><p>一般使用java.net包进行网络编程</p><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><ol><li>getLocalHost:获取本机的InetAddress对象</li><li>getByName:根据指定的主机名&#x2F;域名获取IP地址对象</li><li>getHostName:获取InetAddress对象的主机名</li><li>getHostAddress:获取InetAddress对象的IP地址</li></ol><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket（套接字）已经成为开发网络应用程序的标准，两台机器进行网络通信时，两端都要有Socket，作为两台机器间通信的端点，网络通信本质上就是Socket间的通信。</p><p>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输，一般主动发起通信的应用程序为客服端，等待通信请求的是服务端。</p><h4 id="Socket-TCP通信"><a href="#Socket-TCP通信" class="headerlink" title="Socket-TCP通信"></a>Socket-TCP通信</h4><p>当需要TCP进行通讯时，使用<code>socket.getOutputStream()和socket.getInputStream()</code>，当客户端连接到服务端时，客户端会由TCP&#x2F;IP协议分配一个端口与服务端进行通信。</p><p>服务器端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端正在侦听&quot;</span> + port + <span class="string">&quot;端口&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();  <span class="comment">// 没侦听到程序就会阻塞在这，如果侦听到了就会返回Socket对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> readLen;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>((readLen = inputStream.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            str += <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用完毕后要关闭连接</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLoaclHost(), <span class="number">9999</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;Hello,Server&quot;</span>.getBytes());</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Socket-UDP通信"><a href="#Socket-UDP通信" class="headerlink" title="Socket-UDP通信"></a>Socket-UDP通信</h4><ol><li>类<strong>DategramSocket</strong>和<strong>DatagramPacket</strong>实现了基于UDP协议的网络通信</li><li>没有明确的服务端和客户端，只有数据的发送端与接收端，并且两者身份可互换</li><li>接收数据和发送数据是通过<strong>DatagramSocket</strong>对象完成</li><li>将数据封装到<strong>DatagramPacket</strong>对象中装包</li><li>当接收到<strong>DatagramPacket</strong>对象时需要进行拆包，取出数据</li></ol><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>端口1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Port1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">        ds.receive(res);<span class="comment">// 开一个缓冲区，从其他端口处接收消息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> res.getLength();</span><br><span class="line">        <span class="type">byte</span>[] data = res.getData();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        ds.close();<span class="comment">// 最后要关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>端口2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Port2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你想说什么？&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanf.next();</span><br><span class="line">        <span class="type">byte</span>[] buf = s.getBytes();</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">sen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, InetAddress.getLocalHost(), <span class="number">9999</span>);<span class="comment">// 发送数据到指定端口</span></span><br><span class="line">        ds.send(sen);</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaIO流</title>
      <link href="/inori/47e3b155.html"/>
      <url>/inori/47e3b155.html</url>
      
        <content type="html"><![CDATA[<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>​文件在程序中是以流的形式来操作的，文件保存在硬盘中，通过输入流被java程序读取，程序再通过输出流输出进文件中。流是数据在数据源和程序之间经历的路径，输入流是数据从数据源到程序的路径，输出流是程序到数据源的路径。</p><p>​java.io包中提供了各种流类和接口，以获取不同种类的数据，并通过方法输入或输出数据。</p><h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ul><li>按照数据单位可以分为：字节流（8bit）、字符流</li><li>按照数据流向分为：输入流、输出流</li><li>按照流的角色不同分为：节点流、处理流&#x2F;包装流</li></ul><h2 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a>常用的文件操作</h2><ol><li><p>创建文件对象相关构造器和方法</p><ul><li><code>new File(String pathname)</code>：根据路径创建文件对象</li><li><code>new File(File parent, String child)</code>：根据父目录文件+子路径构建</li><li><code>new File(String parent, String child)</code>：同上</li></ul></li><li><p>获取文件相关信息</p><ul><li><code>getName</code>：获取文件名</li><li><code>getAbsolutePath</code>：获取绝对路径</li><li><code>getParent</code>：获取文件父目录</li><li><code>length</code>：获取文件占用字节</li><li><code>exists</code>：文件是否存在</li><li><code>isFile</code>：是否为文件</li><li><code>isDirectory</code>：是否为文件夹</li><li><code>delete</code>：删除文件</li><li><code>mkdir/mkdirs</code>创建目录&#x2F;多级目录</li></ul></li></ol><h2 id="常用IO类"><a href="#常用IO类" class="headerlink" title="常用IO类"></a>常用IO类</h2><ol><li><p>InputStream&#x2F;OutputStream：从文件中读取字节的类，有基本的字节输入输出功能，常使用byte数组进行接收和写入</p><ul><li>使用<code>getBytes</code>将字符串转成Byte数组，从而对文件进行写入</li><li>使用完输出输入流之后一定要关闭流，可以使用<code>try-with-resources</code>语句来确保资源的正确关闭。</li></ul></li></ol><p>综合使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="string">&quot;/source.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destinationFilePath</span> <span class="operator">=</span> <span class="string">&quot;/destination.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try-with-resources语法：在try语句中初始化流类</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFilePath));</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destinationFilePath))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取并写入文件</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;File copied successfully.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Reader&#x2F;Writer：从文件中读取字符的类，主要用于处理字符数据。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="string">&quot;/source.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destinationFilePath</span> <span class="operator">=</span> <span class="string">&quot;/destination.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try-with-resources语法：在try语句中初始化流类</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(sourceFilePath);</span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destinationFilePath)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取并写入文件</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;File copied successfully.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>节点流可以从一个特定的数据源读写数据，如上面使用的FileReader、FileWriter。节点流是底层流，直接与数据源相接。</p></li><li><p>处理流（包装流）是连接已存在的流，以增加缓冲的方式来提高输入输出的效率，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWritter。处理流既可以消除不同节点流的实现差异，也可以提供方便的方法来完成输入输出。处理流使用了修改器设计模式，不会与数据直接相连。</p></li><li><p>对象流ObjectInputStream&#x2F;ObjectOutputStream是用于对象序列化和反序列化的类。它们可以将对象转换为字节流，以便在网络上传输或保存到文件中。</p><ul><li><p>序列化就是在保存数据时，保存数据的值和数据类型</p></li><li><p>反序列就是在恢复数据时，恢复数据的值和数据类型</p></li><li><p>如果想让某个对象支持序列化，则其类必须实现<strong>Serializable</strong>(推荐，该类为标记接口，不需要实现方法）和<strong>Externalizable</strong>两个接口<u>其中之一</u></p></li><li><p>反序列化时，读取的顺序需要和序列化的顺序一致，并且返回的是Object类型，需要向下转型</p></li><li><p>序列化的类中建议添加<code>SerialVersionUID</code>，为了提高版本兼容性</p></li><li><p>序列化对象时，默认里面所有属性都会序列化（所以要求该类中所有的属性必须可序列化），除了<code>static</code>或<code>transient</code>修饰的成员</p></li><li><p>序列化可继承，父类实现了序列化，则其所有子类都可以序列化</p></li></ul></li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">testPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\test.dat&quot;</span>;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(testPath));</span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(testPath));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person_</span> <span class="operator">=</span> (Person)ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;<span class="comment">// 测试用的序列化类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String likedColor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String likedColor)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.likedColor = likedColor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, likedColor=&#x27;&quot;</span> + likedColor + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>标准输入输出流<code>System.in/System.out</code>：</p><ul><li><p><code>System.in</code>编译类型为InputStream，运行类型为BufferedInputStream，输入对象为键盘</p></li><li><p><code>System.out</code>编译类型和运行类型均为PrintStream，输出对象为显示器</p></li></ul></li><li><p>转换流<code>InputStreamReader/OutputStreamWriter</code>：</p><ul><li><code>InputStreamReader</code>：可以将<code>InputStream</code>包装成<code>Reader</code></li><li><code>OutputStreamWriter</code>：可以将<code>OutputStream</code>包装成<code>Writer</code></li><li>可以在使用时指定编码格式</li></ul></li></ol><p><img src="D:\Blog\source\img\IOType.png"></p><h2 id="Properties读写文件"><a href="#Properties读写文件" class="headerlink" title="Properties读写文件"></a>Properties读写文件</h2><p>​在java集合类中介绍过，Properties类是一种专门用于读写配置文件的集合类。在项目过程中经常要从数据库中读文件，读取的文件类型经常是.properties文件。在Properties文件中配置文件的格式为：<code>key=value</code>，默认格式为String。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol><li>load：加载配置文件的键值对到Properties对象</li><li>store：将Properties中的键值对存储到配置文件，在IDEA中，保存时如果有中文，会存储为unicode码</li><li>list：将数据显示到指定设备&#x2F;流对象</li><li><code>getProperty(key)</code>：根据键获取值</li><li><code>setProperty(key, value)</code>：设置键值对到Properties对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pro.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">// 把键值对显示到控制台</span></span><br><span class="line">        pro.list(System.out);</span><br><span class="line">        <span class="comment">// 根据键获取值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="comment">// 存储键值对到Properties文件中</span></span><br><span class="line">        pro.setProperty(<span class="string">&quot;user2&quot;</span>, <span class="string">&quot;inori&quot;</span>);</span><br><span class="line">        pro.setProperty(<span class="string">&quot;pwd2&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        pro.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/mysql2.properties&quot;</span>), <span class="literal">null</span>); <span class="comment">// 想要写入必须保存，第二个参数为想要写入的注释，如果不为null的话会写在文件的第一行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程基础部分</title>
      <link href="/inori/9da8abfe.html"/>
      <url>/inori/9da8abfe.html</url>
      
        <content type="html"><![CDATA[<h1 id="待更新（等学完JUC一起更）"><a href="#待更新（等学完JUC一起更）" class="headerlink" title="待更新（等学完JUC一起更）"></a>待更新（等学完JUC一起更）</h1>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合</title>
      <link href="/inori/4b0d9081.html"/>
      <url>/inori/4b0d9081.html</url>
      
        <content type="html"><![CDATA[<h2 id="集合的好处"><a href="#集合的好处" class="headerlink" title="集合的好处"></a>集合的好处</h2><p>之前保存多个数据的时候一直都是用的数组，但是数组</p><ol><li>长度开始时必须指定，而且一旦指定，不能更改</li><li>保存的必须为同一类型的元素</li><li>使用数组进行增加&#x2F;删除元素时比较麻烦</li></ol><p>但是集合避免了这些缺点，可以动态保存任意多个对象。</p><p>常用的集合主要可以分为两类</p><ol><li>单列集合Collection<ul><li>List：ArrayList、LinkedList、Vector</li><li>Set：HashSet、TreeSet</li></ul></li><li>双列集合Map：HashMap、TreeMap、Hashtable、Properties</li></ol><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection是一个接口，不可以实例化。该类提供了一些通用方法，供实现该接口的类使用。</p><ol><li>size：集合中元素个数</li><li>isEmpty：检查集合是否为空</li><li>clear：清空集合</li></ol><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List实现了Collection接口，除了通用方法外，还含有：</p><ol><li>add（i,b)：把b元素添加到集合的i位置</li><li>addAll(i,b)：从i位置开始，把b中所有元素添加进来</li><li>get(i)：得到i位置上的元素</li><li>indexOf(a)&#x2F;lastIndexOf(a)：返回a在List中第一次&#x2F;最后一次出现的位置</li><li>remove(i)：移除并返回i位置上的元素</li><li>set(i,a)：将位置i上的元素替换成a</li><li>subList(i,j)：返回集合下标[i,j)的子集</li></ol><p><strong>ArrayList的扩容机制</strong>：当实例化对象时，可以指定大小。如果使用的无参构造器，则初始化大小为0，添加元素时，扩容为10。无论是否指定了初始大小，如果需要再次扩容，则每次扩充为原大小的1.5倍。</p><p><strong>Vector的扩容机制</strong>：当实例化对象时，可以指定大小。如果使用无参构造器，则初始化大小为10。如果需要扩容则按照两倍扩容。</p><p>Vector相比于ArrayList效率较低，但是Vector在源码中添加了<code>synchronized</code>修饰，保证了线程安全，因此在开发中，需要线程同步安全时，要考虑Vector。</p><p><strong>LinkedList</strong>：本质是双向链表，具有双向链表的一切特性，头尾部增删很快，改查很慢，不适合改查操作多的环境。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合内元素唯一，且不能通过索引查找，遍历顺序不能保证与插入顺序一致。可以使用<code>add</code>、<code>remove</code>方法。</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li>HashSet的底层是HashMap</li><li>添加一个元素时，先得到hash值，使用hash值转化成索引值</li><li>找到存储数据表table，看这个索引位置是否有已经存放的元素，如果没有就加入，如果有并且元素不同（使用equals比较），就添加到最后</li><li>在jdk8中，如果一条链表长度超过<code>TREEIFY_THRESHOLD</code>（默认是8），并且table大小≥<code>MIN_TREEIFY_CAPACITY</code>（默认是64），就会变成红黑树。</li><li>第一次添加元素时，table数组扩容到16，<code>临界值=threShold*loadFactor=最大长度*0.75=16*0.75=12</code></li><li>如果数组长度到了临界值，就会再次进行扩容，<code>容量=当前最大长度*2</code>，直到达到了树化条件，<code>新的临界值=最大长度*0.75</code></li><li>如果想保证元素的遍历顺序等于插入顺序，可以使用<strong>LinkedHashSet</strong>。</li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet是即有序集合，底层基于红黑树，能够确保集合元素按照升序或降序排列。</p><p>相比于HashSet新增的方法有：</p><ol><li>firse&#x2F;last：获取第一个&#x2F;最后一个元素</li><li>floor(a)&#x2F;ceiling(a)：获取小于等于&#x2F;大于等于a的最大&#x2F;最小元素</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map与Collection并列存在，用于保存具有映射关系的数据：键值对。Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中。</p><p>Map接口常用方法：</p><ol><li><code>put(key, value)</code>：添加键值对</li><li><code>remove()</code>：根据键删除映射关系</li><li><code>get(key)</code>：根据键获取值</li><li>size：获取元素个数</li><li>isEmpty：判断Map是否为空</li><li>clear：清空</li><li>containsKey：查找键是否存在</li><li>keySet：返回所有键的集合</li></ol><p>HashMap键值对的两种遍历方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.遍历键，找到值</span></span><br><span class="line">        <span class="keyword">for</span> (String key: hashMap.keySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> hashMap.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.使用entrySet获取键值对</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap没有实现同步，不保证线程安全。</p><p>HashTable与HashMap使用的方法基本一致，区别在于：</p><ol><li>HashTable的键和值都不能为null，否则会报空指针异常</li><li>HashTable是线程安全的，多个线程不能同时修改HashTable中的内容</li><li>HashTable在性能上比HashMap略差</li></ol><p>Properties类是用于处理属性文件的类，继承自HashTable类，并实现了Map接口，特点与HashTable类似。Properties主要用于从properties文件中加载数据到Properties类对象，并进行读取和修改。</p><p>方法：</p><ol><li><code>setProperty(key, value)</code>：添加属性</li><li><code>getProperty(key)</code>：获取属性</li><li>load：加载属性文件</li><li>store：保存属性文件</li></ol><p>TreeMap即有序键值对，可以保证插入的键有序排列，方法与HashMap大致相同，但是TreeMap不允许键为null，只允许值接null。</p><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>Collections是一个操作Set、List、Map等集合的工具类，其中提供了一系列的static方法对元素进行排序、查询和修改等操作。</p><p>主要方法：</p><ol><li>sort：对List进行升序排序，其中可以编写比较器对List指定排序方法</li><li>shuffle：打乱List中元素的顺序</li><li>reverse：对List进行翻转</li><li>swap：交换List中两个元素的位置</li><li>max&#x2F;min：返回集合中最大&#x2F;最小的元素</li><li><code>frequency(Collection, Object)</code>：返回Collection集合中Object的出现次数</li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java常用类及其方法</title>
      <link href="/inori/12697782.html"/>
      <url>/inori/12697782.html</url>
      
        <content type="html"><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>针对八种基本数据类型相应的引用类型，有了类的特点，就能调用类中的方法。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>​这两个过程的主要用途在于使得在需要使用对象的场景中能够使用基本数据类型，以及在需要使用基本数据类型的场景中能够使用对象。例如，在集合类中，只能存储对象而不能存储基本数据类型，因此需要通过装箱将基本数据类型转换为对应的包装类对象。</p><p>​在jdk5之前，需要手动装箱与拆箱，jdk5及之后使用自动装箱与拆箱。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 手动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(num);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> Integer.valueOf(num);</span><br><span class="line">        <span class="comment">// 手动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自动装箱和拆箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ol><li>字符串的字符使用Unicode字符编码，无论字母还是汉字都占2字节</li><li>String类有很多构造器和构造器的重载，常用的有：</li></ol><blockquote><p>String s1 &#x3D; new String();</p><p>String s2 &#x3D; new String(String original);</p><p>String s3 &#x3D; new String(char[] a);</p><p>String s4 &#x3D; new String(char[] a, int startIndex, int count);</p><p>String s5 &#x3D; new String(byte[] b);</p></blockquote><ol start="3"><li>String类实现了接口Serializable（串行化：可以在网络传输）和接口Comparable（比较大小）</li><li>String是final类，不能被继承</li><li>String有属性private final char value[]，用于存放字符串内容</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li>equals：区分大小写，判断内容是否相等</li><li>equalsIgnoreCase：忽略大小写，判断内容是否相等</li><li>length：返回字符串长度</li><li>substring：截取指定范围的子串，前闭后开区间</li><li>trim：去掉前后空格</li><li>charAt：获取索引处字符</li><li>toUpperCase：把字符串全部转换成大写</li><li>toLowerCase：把字符串全部转换成小写</li><li>replace：<code>str.replace(a,b)</code>将str中所有的a替换成b</li><li>split：字符串分割，类似于Python的split，需要用列表接收</li><li>toCharArray：将字符串转化成字符数组<code>char[]</code></li><li>format：用法类似于c的printf</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14159265</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(<span class="string">&quot;a=%d,b=%s,c=%c,d=%.2f&quot;</span>, a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>​StringBuffer是一个容器，因为是线程安全的(方法添加了synchronized修饰)，所以一般用于多线程，代表可变的字符序列，可以对字符串内容进行增删，方法与String大体相同。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><blockquote><p>StringBuffer()：构造一个不带字符的缓冲区，大小为16</p><p>StringBuffer(int capacity)：构造一个不带字符，容量为capacity的缓冲区</p><p>StringBuffer(String str)：构造一个内容为str，大小为str.length()+16的缓冲区</p></blockquote><h4 id="转换机制"><a href="#转换机制" class="headerlink" title="转换机制"></a>转换机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String -&gt; StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer -&gt; String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li>append：向后面添加字符串</li><li>delete：<code>delete(a,b)</code>删除指定范围的字符，左闭右开，即删除[a,b)内的字符</li><li>replace：<code>replace(a,b)</code>用法同delete，删除改为替换</li><li>indexOf：查找指定子串在字符串中第一次出现的位置，没找到返回-1</li><li>insert：<code>insert(a,b)</code>在a位置插入字符串b</li></ol><h3 id="StringBulider类"><a href="#StringBulider类" class="headerlink" title="StringBulider类"></a>StringBulider类</h3><p>​StringBulider和StringBuffer类均代表可变的字符序列，但是StringBulider效率更高，两者方法相同，所以使用和StringBuffer一样，但是StringBulider一般用于单线程。</p><p>效率：StringBulider &gt; StringBuffer &gt; String</p><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>包含用于执行基本数学运算的方法。</p><ol><li>abs：绝对值</li><li>pow：幂运算，<code>pow(a,b)</code>指求a的b次方</li><li>ceil：向上取整</li><li>floor：向下取整</li><li>sqrt：开方</li><li>random：返回一个[0,1)之间的double类型的随机数</li><li>max&#x2F;min：求最值</li></ol><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays用于管理或操作数组。</p><ol><li>toString：将数组内容变成字符串，便于输出查看内容</li><li>sort：将数组排序，可以使用匿名内部类改变排序方法</li><li>binarySearch：通过二分查找有序数组的某一个数，如果存在返回索引。不存在返回<code>-(本应该在的位置+1)</code></li><li>fill：<code>fill(arr, num)</code>将arr数组内容全部变成num</li><li>asList：将一组值转换成list</li></ol><h2 id="大数处理方案"><a href="#大数处理方案" class="headerlink" title="大数处理方案"></a>大数处理方案</h2><p><strong>BigInteger</strong>适合保存超出<code>long</code>表示范围的整数。<strong>BigDecimal</strong>适合保存超出<code>double</code>表示范围的浮点型。</p><p>加减乘除不能使用正常的数学符号，必须使用类给定的方法。</p><p>用法（以BigInteger为例，BigDecimal与之相同）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;9999999999999999999999999999999999&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">add</span> <span class="operator">=</span> num1.add(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">sub</span> <span class="operator">=</span> num1.subtract(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">mul</span> <span class="operator">=</span> num1.multiply(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">div</span> <span class="operator">=</span> num1.divide(num2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意，BigDecimal的除法可能与BigInteger不同</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10.999999999999999999999999999999999991&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果除数除不尽的话会报异常，解决办法：</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">div2</span> <span class="operator">=</span> num3.divide(num4, BigDecimal.ROUND_CEILING); <span class="comment">// 保留与被除数相同的精度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p>用于获得系统时间。</p><ol><li>Date：<code>new Date()</code>获取当前系统时间。</li><li>SimpleDateFormat：将日期转换成指定格式的字符串<code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;)</code>E表示星期</li></ol><h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p>指Calendar类，Calendar是一个抽象类，构造器使用private修饰。可以通过getInstance()获取实例。Calendar没有专门的格式化方法，需要自己组合显示。</p><ol><li><code>Calendar c = Calendar.getInstance()</code>创建日历类对象，包含Calendar字段</li><li>获取日历：</li></ol><blockquote><p>c.get(Calendar.YEAR)</p><p>c.get(Calendar.MONTH) + 1 &#x2F;&#x2F; 月默认从0开始</p><p>c.get(Calendar.DAY_OF_MONTH)</p><p>c.get(Calendar.HOUR)</p><p>c.get(Calendar.MINUTE)</p><p>c.get(Calendar.SECOND)</p></blockquote><h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>为了改善前两代日期类的不足，在jdk8中推出了第三代日期类</p><ol><li>LocalDate：年月日</li><li>LocalTime：时分秒</li><li>LocalDateTime：日期+时间</li></ol><blockquote><p>LocalDateTime ldt &#x3D; LoaclDateTime.now()</p><p>ldt.getYear()</p><p>ldt.getMonthValue()</p><p>ldt.getDayOfMonth()</p><p>ldt.getHour()</p><p>ldt.getMinute()</p><p>ldt.getSecond()</p></blockquote><ol start="4"><li>SimpleDateFormat：格式日期类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LoaclDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format();</span><br></pre></td></tr></table></figure><ol start="5"><li>plus系列方法：<code>plusDay</code>、<code>plusMinutes</code>等方法，可以查看多少天&#x2F;分钟后的日期是什么</li><li>minus系列方法：可以查看给定时间之前的日期是什么</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>​泛型是一种在设计和使用类、接口和方法时，允许更广泛地操作各种数据类型的机制。泛型提供了一种在代码中使用一般类型而不是具体类型的方式，在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值类型、参数类型，这样可以提高代码的重用性、可读性和类型安全性，使用任何字母都可以，通常使用<code>&lt;E&gt;</code>、<code>&lt;T&gt;</code>、<code>&lt;K&gt;</code>表示。Java的源码中使用了大量泛型以提高代码复用性。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Test&lt;Integer&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(<span class="number">1</span>);<span class="comment">// 使用Integer代替E</span></span><br><span class="line">        System.out.println(test.function()); <span class="comment">// 返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt;&#123;</span><br><span class="line">T s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(T s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t, R r)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>给泛型指定数据类型时，只能使用引用类型，不能是基本数据类型</li><li>在给泛型指定具体类型时，可以传入该类型或者该类型的子类型</li><li>使用泛型的数组不能初始化（因为不知道这里要用什么样的类型，不知道要开多大空间）</li><li>静态属性和静态方法中不能使用泛型（因为静态是和类相关的，在类加载时，对象还没有创建，如果静态属性和静态方法使用了泛型，JVM就无法完成初始化）</li><li>泛型方法可以在普通类中，也可以在泛型类中</li><li>如果创建类时没有指定类型，默认为Object</li><li>若在接口类中使用泛型，类型在继承接口或者实现接口时确定</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IUsb</span>&lt;U, R&gt;&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    R <span class="title function_">get</span><span class="params">(U u)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(R r)</span>;</span><br><span class="line">    <span class="keyword">default</span> R <span class="title function_">method</span><span class="params">(U u)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> <span class="keyword">extends</span> <span class="title class_">IUsb</span>&lt;String, Double&gt; &#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">implements</span> <span class="title class_">IUsb</span>&lt;String, Double&gt; &#123;......&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>泛型的通配符：<ul><li><code>&lt;?&gt;</code>代表支持任意泛型类型</li><li><code>&lt;? extends A&gt;</code>代表支持A类以及A的子类，规定了泛型类型的上限</li><li><code>&lt;? super A&gt;</code>代表支持A类以及A的父类，规定了泛型类型的下限</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（三）</title>
      <link href="/inori/9235e063.html"/>
      <url>/inori/9235e063.html</url>
      
        <content type="html"><![CDATA[<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li>使用关键字enum代替class，默认会继承Enum类</li><li><code>public static final 类名 = new 类名(参数)</code>直接使用<code>类名(参数)</code>代替，这种语法会默认调用该类的构造器，如果有无参构造器可以不填参数</li><li>如果有多个常量对象，使用<code>,</code>间隔</li><li>创建的对象放在枚举类的行首</li><li>Enum类不可在外部创建对象，因为其构造器为私有</li></ol><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th align="center">方法名</th><th align="left">详细描述</th></tr></thead><tbody><tr><td align="center">valueOf</td><td align="left">通过字符串找到叫该名字的枚举对象，如果没找到会报异常</td></tr><tr><td align="center">toString</td><td align="left">返回枚举对象的名称，通常会在枚举类中重写该方法</td></tr><tr><td align="center">values</td><td align="left">隐藏在枚举类中的方法，返回一个数组，含有全部定义的枚举对象</td></tr><tr><td align="center">ordinal</td><td align="left">输出该枚举对象的定义次序，从0开始编号</td></tr><tr><td align="center">compareTo</td><td align="left">比较两个枚举对象，按照定义次序比较，返回前面的枚举常量编号减去后面的枚举常量编号</td></tr></tbody></table><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>使用enum关键字后不能继承其他类（enum会隐式的继承Enum类）</li><li>枚举类的普通类一样可以实现接口</li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解(Annotation)也叫做元数据(Metadata)，用于解释包、类、方法、属性、构造器、局部变量等数据信息。注解不影响程序逻辑，但是可以被编译，相当于嵌入在代码中的补充信息。</p><h3 id="常用的注解符号"><a href="#常用的注解符号" class="headerlink" title="常用的注解符号"></a>常用的注解符号</h3><ol><li><p><code>@Override</code>重写某个父类方法，该注解只能用于方法</p></li><li><p><code>@Deprecated</code>表示某个程序元素已过时，即不推荐使用</p></li><li><p><code>@SuppressWarnings</code>抑制编译器警告，一般使用all，语法<code>@SuppressWarnings(&#123;&quot;all&quot;&#125;)</code></p></li><li><p><code>@interface</code>用于定义了注解类，之后用到再细说</p></li><li><p>元注解</p><ul><li><code>@Retention</code>指定注解的作用范围，有三种类型：<code>SOURCE</code>源码时，<code>CLASS</code>类中，<code>RUNTIME</code>运行时</li><li><code>@Target</code>指定注解可以在哪些地方使用</li><li><code>@Documented</code>指定该注解是否会在javadoc体现</li><li><code>@Inherited</code>子类继承父类的注解</li></ul></li></ol><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>​在程序执行中发生的不正常行为称为异常，异常不是语法或逻辑错误。</p><p>​正常来说，当程序出现异常时，会立即终止，不会执行后面的代码，但是这样会导致因为一点小错误而耽误整个程序的执行。为了避免这种事情发生，引入异常处理机制进行异常处理，那么即使出现了异常，程序也可以继续执行。</p><h3 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h3><ol><li>Error：JVM无法解决的严重问题。如：JVM系统内部错误，资源耗尽等严重情况。StackOverflowError、OutOfMemoryError等。Error属于严重错误，程序会崩溃。</li><li>Exception：其他外在因素导致的一般性问题，可以使用<code>try-catch</code>语句跳过避免程序崩溃。比如NullPointerException，ArithmeticException等。Exception分为<strong>运行时异常</strong>和<strong>编译时异常</strong>。</li></ol><h3 id="try-catch用法及注意事项"><a href="#try-catch用法及注意事项" class="headerlink" title="try-catch用法及注意事项"></a>try-catch用法及注意事项</h3><p><code>try-catch</code>类似于Python的<code>try-except</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>, num2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> num1 / num2; <span class="comment">// 除0异常</span></span><br><span class="line">        <span class="comment">// 之后的代码不执行，直接进入到catch</span></span><br><span class="line">        <span class="comment">// 若try中没有异常，则不进入catch块</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">System.out.println(e.getMessage());  <span class="comment">// 输出异常信息</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;  <span class="comment">// catch语句可以有多个,子类异常在前，父类在后</span></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;<span class="comment">// finally可加可不加</span></span><br><span class="line">        <span class="comment">// 如果加了意味无论try是否有异常，catch是否捕获了异常，都一定会执行finally中的语句</span></span><br><span class="line">        <span class="comment">// 通常将关闭资源的代码放在finally中</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="throws用法"><a href="#throws用法" class="headerlink" title="throws用法"></a>throws用法</h3><p>​如果一个方法中可能产生某种异常，但是不能确定如何处理这种异常，则可以显示地声明抛出异常，表示由该方法的<u>调用者</u>负责处理。</p><p>​throws可以声明抛出的异常列表，可以是异常类型或者异常的父类类型。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, Exception&#123;</span><br><span class="line">        FileInputStream fis;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;d://aa.txt&quot;</span>);<span class="comment">// 不存在此文件会产生FileNotFoundException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>对于编译异常，程序必须处理。对于运行异常，若程序不处理，默认使用throws向上抛出，直到抛到JVM处终止程序。</li><li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，抛出的异常要么和父类的异常一致，要么为父类抛出异常的子类。</li><li>如果有try-catch语句，就不必用throws</li></ol><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>自定义一个异常，用于规定程序必须按照某个指定的逻辑来编写或运行。</p><h4 id="用法及注意事项"><a href="#用法及注意事项" class="headerlink" title="用法及注意事项"></a>用法及注意事项</h4><p>一般情况下，继承<code>RuntimeException</code>类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">50</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NumException</span>(<span class="string">&quot;num is too big&quot;</span>);<span class="comment">// 抛出一个自定义异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="throws与throw"><a href="#throws与throw" class="headerlink" title="throws与throw"></a>throws与throw</h2><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面接</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（二）</title>
      <link href="/inori/df2b4331.html"/>
      <url>/inori/df2b4331.html</url>
      
        <content type="html"><![CDATA[<h2 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h2><p>在类中定义的变量，加上<code>static</code>称为类变量，否则称为实例变量&#x2F;普通变量。</p><p>性质：</p><ol><li>类中使用<code>static</code>修饰的变量将会被所有同类共享。</li><li><code>static</code>类变量，在类加载时就生成了，不需要创建对象实例就可以访问（以该变量不是<code>private</code>修饰为前提）。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>什么时候需要使用类变量？</li></ol><p>  当我们需要让某个类的所有对象对共享一个变量时可以使用。</p><ol start="2"><li>类变量与实例变量的区别：</li></ol><p>  类变量是该类的所有对象共享的，而实例变量时每个对象独享的。</p><ol start="3"><li>类变量的生命周期随着类加载开始，随着类消亡而被销毁。</li></ol><h2 id="类方法（静态方法）"><a href="#类方法（静态方法）" class="headerlink" title="类方法（静态方法）"></a>类方法（静态方法）</h2><p>类似于类变量，就是在类中定义的方法前使用<code>static</code>修饰。</p><p>使用时不需要将类实例化，直接用类名.方法使用。</p><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>类方法和普通方法一样，随着类加载而加载，将结构信息存在方法区</li><li>类方法中无<code>this</code>参数，不能使用与对象有关的关键字，如<code>this</code>和<code>super</code>。</li><li>类方法只能访问静态变量和静态方法。</li><li>普通成员方法可以访问静态方法和普通方法。</li></ol><h2 id="理解main方法"><a href="#理解main方法" class="headerlink" title="理解main方法"></a>理解main方法</h2><blockquote><p>public static void main(String[] args){}</p></blockquote><ol><li>main方法由JVM调用</li><li>JVM需要调用类的main()方法，所以该方法的访问权限必须是public</li><li>JVM在执行main()方法时不需要创建对象，所以该方法必须是static</li><li>main方法会接受String类型的数组参数args，该数组中保存着执行java命令时传递给所运行的类的参数</li><li>main方法中想要访问非静态的变量和方法需要先实例化再用。</li></ol><h2 id="代码块的使用"><a href="#代码块的使用" class="headerlink" title="代码块的使用"></a>代码块的使用</h2><p>没有方法名的方法。使用格式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>或者什么都不写 &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  相当于另外一种形式的构造器，可以做初始化操作，在使用构造器之前会调 用代码块，也就是说优先级高于构造器内的代码。可以将多次出现的重复代码放到代码块中。</p><p>注：如果使用static修饰代码块，则总共只会调用一次。如果是普通代码块，则每创建一次这个类都会执行一次。</p><p>创建对象时，在类中的调用顺序：</p><ol><li>调用静态代码块和静态属性初始化</li><li>调用普通代码块和普通属性初始化</li><li>调用构造方法</li></ol><p>当创建一个子类对象时（继承父类），调用顺序为：</p><ol><li>父类的静态代码块和静态属性</li><li>子类的静态代码块和静态属性</li><li>父类的普通代码块和普通属性</li><li>父类的构造方法</li><li>子类的普通..</li><li>子类的构造方法</li></ol><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>final可以修饰类、属性、方法和局部变量，final修饰的属性又叫做常量。</p><p>用法：</p><ol><li>当不希望类被继承时。</li><li>当不希望父类的某个方法被子类覆盖或重写时。</li><li>当不希望类的某个属性的值被修改时。</li><li>当不希望某个局部变量被修改时。</li></ol><h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><p>final修饰的属性一般用XX_XX_XX命名（大写，字母间使用下划线隔开）</p></li><li><p>final属性在定义时必须赋初值，赋值的位置可以在：</p><ul><li><p>定义时直接赋值</p></li><li><p>在构造器中赋值（仅限非static）</p></li><li><p>在代码块中赋值（static时使用静态代码块）</p></li></ul></li><li><p>如果一个类已经是final类了，其中的属性和方法就不要用final修饰了</p></li><li><p>final不能修饰构造器</p></li><li><p>final往往与static一起使用，效率更高，不会导致类加载</p></li><li><p>包装类（Integer、Double、Float、Boolean等）都是使用final修饰的，不可被继承</p></li></ol><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>​当在父类中声明了一个方法，但是不知道该如何实现时，就可以不实现，而是把该方法声明为一个抽象方法，同时该类变成一个抽象类。</p><ol><li>用abstract关键字来修饰一个类&#x2F;方法时，这个类就叫做抽象类&#x2F;方法</li><li>抽象类的价值更多作用在于设计，是设计者设计好后，让子类继承并实现抽象类</li><li>抽象类不能被实例化</li><li>抽象方法一定在抽象类中，但是抽象类不一定有抽象方法</li><li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也是抽象类</li><li>抽象方法不能使用private、final和static修饰，因为这三个关键字都与重写相违背（用这三个关键字修饰方法不许被修改）</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  <span class="comment">//抽象类不能有主体&quot;&#123;&#125;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是给出一些没有实现的方法，封装到一起，当某个类要用时，根据具体情况把接口中的方法写出来。</p><p>java8之后，接口中可以有方法的具体实现，但是非静态方法需要使用<code>default</code>修饰。</p><p><strong>接口中的方法都默认使用<code>public abstract</code>修饰，属性默认使用<code>public static final</code>修饰。</strong></p><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">XXX</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">XXXX</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要用到接口时</span></span><br><span class="line">class 类名 implements 接口&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>接口不能被实例化（同抽象类）</li><li>一个类可以同时实现多个接口</li></ol><blockquote><p>class X implements Y, Z {}</p></blockquote><ol start="3"><li>接口不能继承类，但是可以继承其他接口(接口与接口之间是继承关系，接口与类之间是实现关系)</li></ol><blockquote><p>interface A extends B, C {}</p></blockquote><ol start="4"><li>接口的修饰符只能是public和默认</li></ol><h4 id="接口与继承"><a href="#接口与继承" class="headerlink" title="接口与继承"></a>接口与继承</h4><p>​当子类继承父类时，自动拥有父类的功能。但因为一个子类只能继承一个父类，如果子类需要扩展功能，就可以通过实现接口的方式扩展。<u>可以理解为实现接口是对java单继承机制的扩展。</u></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>一个类的内部又完整的嵌套了另一个类，被嵌套的类叫做内部类。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类定义在外部类的局部位置，通常在方法或代码块中，有类名。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol><li>可以直接访问外部类的全部成员，包括私有</li><li>不能添加访问修饰符，因为局部内部类的地位相当于一个局部变量。但是可以用final修饰</li><li>作用域：在定义它的方法或代码块中</li><li>外部类想访问局部内部类的成员需要先new一个再访问</li><li>如果外部类中成员和局部内部类中成员重名，访问时使用就近原则，如果想访问外部类，可以使用<code>外部类.this.成员</code>访问</li></ol><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>​匿名内部类没有类名（但是底层实现的时候有名字），不仅是一个类，还是一个对象，所有它同时拥有类和对象的特性，可以当做实参直接传递。</p><p>特点与局部内部类类似。</p><p>语法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类或接口 变量名 = <span class="keyword">new</span> 类或接口(参数)&#123;</span><br><span class="line"><span class="comment">// 类体</span></span><br><span class="line">&#125;;</span><br><span class="line">变量名.方法名();</span><br><span class="line"><span class="comment">// -----------或者--------------</span></span><br><span class="line"><span class="keyword">new</span> 类或接口(参数)&#123;</span><br><span class="line">    <span class="comment">// 类体</span></span><br><span class="line">&#125;.方法名();</span><br></pre></td></tr></table></figure><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类定义在外部类的成员位置，没有static修饰。其定位是一个类成员，可以添加任意修饰符。并且作用域为整个外部类体。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>假设<code>Outer</code>类中有一个名为<code>Inner</code>的成员内部类，当外部其他类想使用成员内部时：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Outer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inn</span> <span class="operator">=</span> out.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：在Outer类中声明一个方法，可以返回Inner对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    .....;</span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inn</span> <span class="operator">=</span> out.getInnerInstance();</span><br></pre></td></tr></table></figure><p>其他使用方式跟其他内部类相同。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类是在成员内部类的基础上，有static修饰，有内部类和静态方法的全部特性。</p><p>当外部其他类想访问静态内部类时,因为是静态的，所以不需要实例化，通过类名直接访问：</p><blockquote><p>Inner inn &#x3D; new Outer.Inner();</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础入门（一）</title>
      <link href="/inori/ef3dafe9.html"/>
      <url>/inori/ef3dafe9.html</url>
      
        <content type="html"><![CDATA[<h2 id="idea常用快捷键"><a href="#idea常用快捷键" class="headerlink" title="idea常用快捷键"></a>idea常用快捷键</h2><ol><li><p>Ctrl + Alt + L  格式化</p></li><li><p>Shift + F10  编译运行</p></li><li><p>Alt + Insert  插入构造器</p></li><li><p>Ctrl + H  显示继承关系</p></li><li><p>Alt+Enter  new完对象后可以直接分配变量名</p></li></ol><h2 id="idea-断点调试"><a href="#idea-断点调试" class="headerlink" title="idea 断点调试"></a>idea 断点调试</h2><ol><li>跳入（F7): 跳入方法内（可以查看JDK原码）</li><li>跳过（F8): 逐行执行代码</li><li>跳出（shift+F8)：跳出方法</li><li>继续（F9)：跳到下一个断点</li></ol><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>JUnit是一个Java语言的单元测试框架，多数Java的开发环境已经继承了JUnit作为单元测试工具。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>​如果在编写主方法时添加了很多非静态的方法，则在逐个测试方法时需要在main()函数中挨个new出来，再逐个测试。这样做非常的麻烦，可以点击<code>Alt + Enter</code>安装JUnit框架，在需要测试的方法上加<code>@Test</code>标识，则该方法前面会出现绿色的运行按钮，这样不需要在main()函数中声明也可以快速执行方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// new Test().m1();</span></span><br><span class="line">        <span class="comment">// new Test().m2();</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 is Testing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;m1 is Testing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h2><p>包本质就是文件夹，创建不同的文件夹&#x2F;目录来保存类文件。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>区分相同名字的类</li><li>更好的管理类</li><li>控制访问范围</li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>package 文件夹名.文件夹名…</p></blockquote><p>在import上面写，使用idea时会自动添加。</p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><table><thead><tr><th align="center">访问级别</th><th align="center">访问控制修饰符</th><th align="center">同类</th><th align="center">同包</th><th align="center">子类</th><th align="center">不同包</th></tr></thead><tbody><tr><td align="center">公开</td><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">受保护</td><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">默认</td><td align="center">无修饰符</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">私有</td><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>封装、继承、多态</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>​封装（encapsulation）就是把抽象出的属性和方法封装在一起，数据被保护在内部，程序的其它部分只有通过被授权的操作[方法]，才能对数据进行操作。</p><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol><li><p>将属性私有化</p></li><li><p>提供一个public的类set方法，用于对属性判断并赋值</p></li><li><p>提供一个public的类get方法，用于获取属性的值</p></li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>​当两个类的属性和方法有很多相同部分时，需要继承。即当多个类存在相同的属性和方法时，可以抽象出父类，在父类中定义这些相同的属性和方法，子类不需要重新定义这些属性和方法，只需要通过<code>extends</code>来声明继承。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>提高代码复用性</li><li>提高代码扩展性和可维护性</li></ol><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 子类 extends 父类&#123;</span><br><span class="line"><span class="comment">// 类体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ol><li>子类自动拥有父类定义的属性和方法</li><li>父类又叫超类，基类</li><li>子类又叫派生类</li><li>一个子类只能有一个直接父类（只能继承一个类），但是可以有很多祖宗类（父类又继承了一个超类，那个超类又继承了一个超类……)</li><li>子类必须调用父类的构造器， 完成父类的初始化</li><li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器。如果父类没有提供无参构造器，则必须在子类的构造器中用<code>super</code>去指定使用父类的哪个构造器完成对父类的初始化工作</li><li><code>super</code>和<code>this</code>都只能放在构造器第一行，因此这两个方法不能共存在一个构造器</li><li>java所有类都是<code>Object</code>类的子类,<code>Object</code>是所有类的基类</li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态,多态是建立在封装和继承基础之上的。</p><h4 id="具体体现"><a href="#具体体现" class="headerlink" title="具体体现"></a>具体体现</h4><ol><li>方法的多态（重载和重写等）</li><li>对象的多态<ul><li>一个对象的编译类型和运行类型可以不一致</li><li>编译类型在定义对象时即确定，运行类型可以变化。</li></ul></li></ol><h4 id="对象的向上转型"><a href="#对象的向上转型" class="headerlink" title="对象的向上转型"></a>对象的向上转型</h4><p>父类的引用指向子类的对象</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li><p>可以调用父类中所有成员（遵守访问权限）</p></li><li><p>不能调用子类特有的方法（编译阶段能调用哪些成员，由编译类型决定）</p></li><li><p>最终运行效果看子类(运行类型)的具体实现，即调用方法时，按照从子类（运行类型）开始查找方法。</p></li></ol><h4 id="对象的向下转型"><a href="#对象的向下转型" class="headerlink" title="对象的向下转型"></a>对象的向下转型</h4><p>父类对象转换成子类对象。与向上转型不同，向下转型是不安全的</p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 向上转型</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">// 编译类型是A，运行类型是B</span></span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">C</span>(); <span class="comment">// 编译类型是A，运行类型是C</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 向下转型</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B)a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><ol><li><p>当调用对象方法时，该方法会和该对象的内存地址（运行类型）绑定</p></li><li><p>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用。</p></li></ol><p>补充：<code>instanceOf</code>是比较操作符，用于判断对象的运行类型是否为某类型或某类型的子类型。</p><h2 id="类的五大成员"><a href="#类的五大成员" class="headerlink" title="类的五大成员"></a>类的五大成员</h2><p><strong>属性、方法、构造器、代码块、内部类</strong></p><h3 id="属性-成员变量-字段"><a href="#属性-成员变量-字段" class="headerlink" title="属性&#x2F;成员变量&#x2F;字段"></a>属性&#x2F;成员变量&#x2F;字段</h3><p>就是类中定义的变量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>属性的定义方法用变量：<code>访问修饰符 属性类型 属性名</code></li><li>属性如果不赋值会使用默认值。<code>byte、short、int、long</code>赋0，<code>float、double</code>赋0.0，<code>char</code>赋\u0000，<code>boolean</code>赋false，<code>String</code>赋null。</li></ol><h3 id="方法-成员方法"><a href="#方法-成员方法" class="headerlink" title="方法&#x2F;成员方法"></a>方法&#x2F;成员方法</h3><p>就是类中定义的函数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getSalary</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重载-overload"><a href="#方法重载-overload" class="headerlink" title="方法重载(overload)"></a>方法重载(overload)</h4><p>java中允许同一个类中，多个同名方法的存在，但要求形参不一致(变量类型或者变量数量)</p><ol><li>减轻了起名的麻烦</li><li>减轻了记名的麻烦</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalculator</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">double</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calculator</span><span class="params">(<span class="type">double</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculator</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2,<span class="type">int</span> n3)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n1 + n2 + n3;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法重写-override"><a href="#方法重写-override" class="headerlink" title="方法重写(override)"></a>方法重写(override)</h4><ol><li><p>即在子类中重新写一遍父类中的方法，需要和父类方法的参数，名称完全一样</p></li><li><p>返回类型要么一样，要么是父类返回类型的子类，比如<code>Object -&gt; String</code></p></li><li><p>子类方法的访问权限必须大于等于父类方法</p></li></ol><h4 id="方法重载与重写的区别"><a href="#方法重载与重写的区别" class="headerlink" title="方法重载与重写的区别"></a>方法重载与重写的区别</h4><table><thead><tr><th align="center">名称访问</th><th align="center">范围</th><th align="center">方法名</th><th align="center">形参</th><th align="center">返回类型</th><th align="center">修饰符</th></tr></thead><tbody><tr><td align="center">重载</td><td align="center">本类</td><td align="center">相同</td><td align="center">类型、个数或者顺序至少有一个不同</td><td align="center">随意</td><td align="center">随意</td></tr><tr><td align="center">重写</td><td align="center">protected</td><td align="center">相同</td><td align="center">相同</td><td align="center">一致或子类</td><td align="center">大于等于父类</td></tr></tbody></table><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>构造器是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。</p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化</li><li>如果一个类不写构造器，则默认会有一个无参构造器</li><li>构造器的调用自动完成</li></ol><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[访问修饰符] 方法名(形参列表)&#123; </span><br><span class="line">     方法体;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>接下来见<a href="/inori/df2b4331">java基础入门（二）</a></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题.2</title>
      <link href="/inori/3b25fa04.html"/>
      <url>/inori/3b25fa04.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode每日一题"><a href="#LeetCode每日一题" class="headerlink" title="LeetCode每日一题"></a>LeetCode每日一题</h1><p>​今天的每日一题是<a href="https://leetcode.cn/problems/ransom-note/">383. 赎金信</a>，简单题，直接做。</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p><p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p><p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：ransomNote &#x3D; “a”, magazine &#x3D; “b”<br>输出：false</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “ab”<br>输出：false</p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：ransomNote &#x3D; “aa”, magazine &#x3D; “aab”<br>输出：true</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= ransomNote.length, magazine.length &lt;= 105</code></li><li><code>ransomNote</code> 和 <code>magazine</code> 由小写英文字母组成</li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>把字符串中每一个字符映射到哈希表上，统计数字，如果ransomNote中的对应字母数量小于magazine就可以返回true。</p><p>优化点：如果ransomNote长度大于magazine了，则直接返回false。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ransomNote.length() &gt; magazine.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ransomNote.toCharArray()) &#123;</span><br><span class="line">            map1.put(c, map1.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : magazine.toCharArray()) &#123;</span><br><span class="line">            map2.put(c, map2.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> key : map1.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map2.containsKey(key) || map2.get(key) &lt; map1.get(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canConstruct</span>(<span class="params">self, ransomNote: <span class="built_in">str</span>, magazine: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(ransomNote) &gt; <span class="built_in">len</span>(magazine):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tab1, tab2 = Counter(ransomNote), Counter(magazine)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> tab1:</span><br><span class="line">            <span class="keyword">if</span> tab2[key] &lt; tab1[key]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(m+n)，n和m是两个字符串的长度。</li><li>空间复杂度：O(s)，s为字符数量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第379场周赛</title>
      <link href="/inori/d63cc9f2.html"/>
      <url>/inori/d63cc9f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode第379场周赛"><a href="#LeetCode第379场周赛" class="headerlink" title="LeetCode第379场周赛"></a>LeetCode第379场周赛</h1><p>​这场比赛感觉来恶心人的，一堆边界条件，又让我疯狂WA，简单题也WA，受不了了。</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>dimensions</code>。</p><p>对于所有下标 <code>i</code>（<code>0 &lt;= i &lt; dimensions.length</code>），<code>dimensions[i][0]</code> 表示矩形 <code>i</code> 的长度，而 <code>dimensions[i][1]</code> 表示矩形<code>i</code>的宽度。</p><p>返回对角线最<strong>长</strong>的矩形的<strong>面积</strong>。如果存在多个对角线长度相同的矩形，返回面积最<strong>大</strong>的矩形的面积。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：dimensions &#x3D; [[9,3],[8,6]]<br>输出：48<br>解释：<br>下标 &#x3D; 0，长度 &#x3D; 9，宽度 &#x3D; 3。对角线长度 &#x3D; sqrt(9 * 9 + 3 * 3) &#x3D; sqrt(90) ≈ 9.487。<br>下标 &#x3D; 1，长度 &#x3D; 8，宽度 &#x3D; 6。对角线长度 &#x3D; sqrt(8 * 8 + 6 * 6) &#x3D; sqrt(100) &#x3D; 10。<br>因此，下标为 1 的矩形对角线更长，所以返回面积 &#x3D; 8 * 6 &#x3D; 48。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：dimensions &#x3D; [[3,4],[4,3]]<br>输出：12<br>解释：两个矩形的对角线长度相同，为 5，所以最大面积 &#x3D; 12。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= dimensions.length &lt;= 100</code></li><li><code>dimensions[i].length == 2</code></li><li><code>1 &lt;= dimensions[i][0], dimensions[i][1] &lt;= 100</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>又是阅读理解题。</p><p>注意最后一句：如果存在多个对角线长度相同的矩形，返回面积最<strong>大</strong>的矩形的面积。这就需要特判一下了，如果对角线等于当前最大值就更新矩形面积。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">areaOfMaxDiagonal</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; dimensions)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> nums: dimensions)&#123;</span><br><span class="line">            <span class="type">int</span> a = nums[<span class="number">0</span>], b = nums[<span class="number">1</span>];</span><br><span class="line">            <span class="type">double</span> tmp = <span class="built_in">sqrt</span>(a * a + b * b);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; s)&#123;<span class="comment">// 当对角线大时直接更新ans</span></span><br><span class="line">                s = tmp;</span><br><span class="line">                ans = a * b;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tmp == s)&#123;<span class="comment">// 相等时再判断最值</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans, a * b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">areaOfMaxDiagonal</span><span class="params">(<span class="type">int</span>[][] dimensions)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] nums: dimensions)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> nums[<span class="number">0</span>], b = nums[<span class="number">1</span>];</span><br><span class="line">            <span class="type">double</span> <span class="variable">tmp</span> <span class="operator">=</span> Math.sqrt(a * a + b * b);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; s)&#123;<span class="comment">// 当对角线大时直接更新ans</span></span><br><span class="line">                s = Math.sqrt(a * a + b * b);</span><br><span class="line">                ans = a * b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(tmp == s)&#123;<span class="comment">// 相等时再判断最值</span></span><br><span class="line">                ans = Math.max(ans, a * b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">areaOfMaxDiagonal</span>(<span class="params">self, dimensions: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> dimensions:</span><br><span class="line">            tmp = sqrt(a * a + b * b)</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; s:</span><br><span class="line">                s = tmp</span><br><span class="line">                ans = a * b</span><br><span class="line">            <span class="keyword">elif</span> tmp == s:</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, a * b)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)，n为数组长度。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>现有一个下标从 <strong>0</strong> 开始的 <code>8 x 8</code> 棋盘，上面有 <code>3</code> 枚棋子。</p><p>给你 <code>6</code> 个整数 <code>a</code> 、<code>b</code> 、<code>c</code> 、<code>d</code> 、<code>e</code> 和 <code>f</code> ，其中：</p><ul><li><code>(a, b)</code> 表示白色车的位置。</li><li><code>(c, d)</code> 表示白色象的位置。</li><li><code>(e, f)</code> 表示黑皇后的位置。</li></ul><p>假定你只能移动白色棋子，返回捕获黑皇后所需的<strong>最少</strong>移动次数。</p><p><strong>请注意</strong>：</p><ul><li>车可以向垂直或水平方向移动任意数量的格子，但不能跳过其他棋子。</li><li>象可以沿对角线方向移动任意数量的格子，但不能跳过其他棋子。</li><li>如果车或象能移向皇后所在的格子，则认为它们可以捕获皇后。</li><li>皇后不能移动。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/12/21/ex1.png" alt="img"></p><blockquote><p>输入：a &#x3D; 1, b &#x3D; 1, c &#x3D; 8, d &#x3D; 8, e &#x3D; 2, f &#x3D; 3<br>输出：2<br>解释：将白色车先移动到 (1, 3) ，然后移动到 (2, 3) 来捕获黑皇后，共需移动 2 次。<br>由于起始时没有任何棋子正在攻击黑皇后，要想捕获黑皇后，移动次数不可能少于 2 次。</p></blockquote><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/12/21/ex2.png" alt="img"></p><blockquote><p>输入：a &#x3D; 5, b &#x3D; 3, c &#x3D; 3, d &#x3D; 4, e &#x3D; 5, f &#x3D; 2<br>输出：1<br>解释：可以通过以下任一方式移动 1 次捕获黑皇后：</p><ul><li>将白色车移动到 (5, 2) 。</li><li>将白色象移动到 (5, 2) 。</li></ul></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a, b, c, d, e, f &lt;= 8</code></li><li>两枚棋子不会同时出现在同一个格子上。</li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>恶心人的题，分类讨论。</p><ol><li><p>如果车能直接攻击到皇后，或者象能直接攻击到皇后，那么返回1。</p></li><li><p>如果车被象挡住，那么移走象，车就可以攻击到皇后，返回2。</p></li><li><p>如果象被车挡住，那么移走车，象就可以攻击到皇后，返回2。</p></li><li><p>如果车不能直接攻击到皇后，那么车可以水平移动或者垂直移动，其中一个位置必定不会被象挡住，可以攻击到皇后，返回2。</p></li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minMovesToCaptureTheQueen</span>(<span class="params">self, a: <span class="built_in">int</span>, b: <span class="built_in">int</span>, c: <span class="built_in">int</span>, d: <span class="built_in">int</span>, e: <span class="built_in">int</span>, f: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="number">9</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        i = c</span><br><span class="line">        j = d</span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="number">9</span> <span class="keyword">and</span> j &lt; <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">if</span> i == e <span class="keyword">and</span> j == f: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i == a <span class="keyword">and</span> j == b: <span class="keyword">break</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a == e <span class="keyword">and</span> a != c): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(b == f <span class="keyword">and</span> b != d): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(a == c <span class="keyword">and</span> a == e <span class="keyword">and</span> <span class="built_in">abs</span>(b - f) != <span class="built_in">abs</span>(b - d) + <span class="built_in">abs</span>(d - f)): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span>(b == d <span class="keyword">and</span> b == f <span class="keyword">and</span> <span class="built_in">abs</span>(a - e) != <span class="built_in">abs</span>(a - c) + <span class="built_in">abs</span>(c - e)): <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：<code>O(9 * 4) = O(1)</code>。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>给你两个下标从 <code>0</code> 开始的整数数组 <code>nums1</code> 和 <code>nums2</code> ，它们的长度都是偶数<code> n</code> 。</p><p>你必须从 <code>nums1</code> 中移除 <code>n / 2</code> 个元素，同时从 <code>nums2</code> 中也移除 <code>n / 2</code> 个元素。移除之后，你将 <code>nums1</code> 和 <code>nums2</code> 中剩下的元素插入到集合 <code>s</code> 中。</p><p>返回集合 <code>s</code>可能的 <strong>最多</strong> 包含多少元素。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,2,1,2], nums2 &#x3D; [1,1,1,1]<br>输出：2<br>解释：从 nums1 和 nums2 中移除两个 1 。移除后，数组变为 nums1 &#x3D; [2,2] 和 nums2 &#x3D; [1,1] 。因此，s &#x3D; {1,2} 。<br>可以证明，在移除之后，集合 s 最多可以包含 2 个元素。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,2,3,4,5,6], nums2 &#x3D; [2,3,2,3,2,3]<br>输出：5<br>解释：从 nums1 中移除 2、3 和 6 ，同时从 nums2 中移除两个 3 和一个 2 。移除后，数组变为 nums1 &#x3D; [1,4,5] 和 nums2 &#x3D; [2,3,2] 。因此，s &#x3D; {1,2,3,4,5} 。<br>可以证明，在移除之后，集合 s 最多可以包含 5 个元素。 </p></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：nums1 &#x3D; [1,1,2,2,3,3], nums2 &#x3D; [4,4,5,5,6,6]<br>输出：6<br>解释：从 nums1 中移除 1、2 和 3 ，同时从 nums2 中移除 4、5 和 6 。移除后，数组变为 nums1 &#x3D; [1,2,3] 和 nums2 &#x3D; [4,5,6] 。因此，s &#x3D; {1,2,3,4,5,6} 。<br>可以证明，在移除之后，集合 s 最多可以包含 6 个元素。 </p></blockquote><p><strong>提示：</strong></p><ul><li><code>n == nums1.length == nums2.length</code></li><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li><li><code>n</code>是偶数。</li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^9</code></li></ul><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>这题一看，好像很难，但其实就是简单的求交集，数学找规律求方程即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumSetSize</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        HashSet&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums1)&#123;</span><br><span class="line">            set1.add(i);    <span class="comment">// nums1的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums2)&#123;</span><br><span class="line">            set2.add(i);    <span class="comment">// nums2的集合</span></span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(set1);</span><br><span class="line">        set.addAll(set2);   <span class="comment">// set1和set2的并集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, set1.size() - n / <span class="number">2</span>), x2 = Math.max(<span class="number">0</span>, set2.size() - n / <span class="number">2</span>);   <span class="comment">// nums1和nums2仍需要删除的数的数量</span></span><br><span class="line">        <span class="keyword">if</span>(x1 == <span class="number">0</span> &amp;&amp; x2 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> set.size();  <span class="comment">// 如果不需要删除了，就直接返回两者的并集的长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(set1);</span><br><span class="line">        s.retainAll(set2);  <span class="comment">// 两者的交集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Math.min(<span class="number">0</span>, s.size() - x1 - x2);    <span class="comment">// 通过统计找到的规律，先从两者交集中移除元素，如果够用了x=0，不够的话x&lt;0,然后再从两者的并集中移除元素。</span></span><br><span class="line">        <span class="keyword">return</span> set.size() + x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumSetSize</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums1)</span><br><span class="line">        s1, s2 = <span class="built_in">set</span>(nums1), <span class="built_in">set</span>(nums2)</span><br><span class="line">        x1, x2 = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">len</span>(s1) - n // <span class="number">2</span>), <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">len</span>(s2) - n // <span class="number">2</span>) <span class="comment"># nums1和nums2仍需要删除的数的数量</span></span><br><span class="line">        <span class="keyword">if</span> (x1 == <span class="number">0</span> <span class="keyword">and</span> x2 == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">len</span>(s1 | s2)<span class="comment"># 如果不需要删除了，就直接返回两者的并集的长度</span></span><br><span class="line">        </span><br><span class="line">        s = s1 &amp; s2</span><br><span class="line">        x = <span class="built_in">min</span>(<span class="built_in">len</span>(s) - x1 - x2, <span class="number">0</span>) <span class="comment"># 通过统计找到的规律，先从两者交集中移除元素，如果够用了x=0，不够的话x&lt;0,然后再从两者的并集中移除元素。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s1 | s2) + x</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)。</li><li>空间复杂度：<code>O(n * 4) = O(n)</code>，定义了4个哈希集合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第121场双周赛</title>
      <link href="/inori/6b6c0081.html"/>
      <url>/inori/6b6c0081.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode第121场双周赛"><a href="#LeetCode第121场双周赛" class="headerlink" title="LeetCode第121场双周赛"></a>LeetCode第121场双周赛</h1><p>​每次这么晚打比赛脑子都要抽风，这次周赛疯狂WA，第一道简单题更是WA了4次，受不了了。每次打比赛我都是能AC三题就是胜利，第四题看一眼题干，能看懂就做，看不懂就不做了，这次确实是A掉三题，只不过罚时了很久就是了…</p><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 。</p><p>如果一个前缀 <code>nums[0..i]</code> 满足对于 <code>1 &lt;= j &lt;= i</code> 的所有元素都有 <code>nums[j] = nums[j - 1] + 1</code> ，那么我们称这个前缀是一个 <strong>顺序前缀</strong> 。特殊情况是，只包含 <code>nums[0]</code> 的前缀也是一个 <strong>顺序前缀</strong> 。</p><p>请你返回 <code>nums</code> 中没有出现过的 <strong>最小</strong> 整数 <code>x</code> ，满足 <code>x</code> 大于等于 <strong>最长</strong> 顺序前缀的和。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [1,2,3,2,5]<br>输出：6<br>解释：nums 的最长顺序前缀是 [1,2,3] ，和为 6 ，6 不在数组中，所以 6 是大于等于最长顺序前缀和的最小整数。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums &#x3D; [3,4,5,1,12,14,13]<br>输出：15<br>解释：nums 的最长顺序前缀是 [3,4,5] ，和为 12 ，12、13 和 14 都在数组中，但 15 不在，所以 15 是大于等于最长顺序前缀和的最小整数。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= 50</code></li></ul><h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p>纯纯阅读理解题，我就是因为没理解到位WA了三次。</p><ol><li><p>必须<code>1 &lt;= j &lt;= i</code>之间的所有元素全都满足才算一个顺序前缀。并且**nums[0]**也算一个顺序前缀。</p></li><li><p>需要返回的是最长顺序前缀的和，并且这个和在数组中没出现过，如果出现过，就一直+1直到满足条件。</p></li></ol><p>明白了以上几点，再看数据范围：50，啥都不用想了，直接<code>n^2</code>暴力解。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingInteger</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, s = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; hashSet;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums)&#123;</span><br><span class="line">            hashSet.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> tmp = <span class="number">1</span>, ts = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    tmp ++;</span><br><span class="line">                    ts += nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">// 如果不满足条件直接break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmp);</span><br><span class="line">            <span class="keyword">if</span>(ans == tmp)&#123;<span class="comment">// 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">                s = <span class="built_in">max</span>(s, ts);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">50</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s; i &lt;= <span class="number">51</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (hashSet.<span class="built_in">find</span>(i) == hashSet.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingInteger</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">1</span>, ts = nums[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>)&#123;</span><br><span class="line">                    tmp ++;</span><br><span class="line">                    ts += nums[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">// 如果不满足条件直接break</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, tmp);</span><br><span class="line">            <span class="keyword">if</span>(ans == tmp) s = Math.max(s, ts);<span class="comment">// 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">50</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s; i &lt;= <span class="number">51</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i)) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingInteger</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n, ans, s = <span class="built_in">len</span>(nums), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        hashSet = <span class="built_in">set</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            tmp, ts = <span class="number">1</span>, nums[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[j] == nums[j - <span class="number">1</span>] + <span class="number">1</span>:</span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">                    ts += nums[j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, tmp)</span><br><span class="line">            <span class="keyword">if</span> ans == tmp:<span class="comment"># 只有确定这次是最长前缀的时候才更新s，避免s大但是ans小的情况</span></span><br><span class="line">                s = <span class="built_in">max</span>(s, ts)</span><br><span class="line">        <span class="keyword">if</span> s &gt; <span class="number">50</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(s, <span class="number">52</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> hashSet:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n^2)，n为数组长度。</li><li>空间复杂度：O(n)，定义了一个哈希集合，最坏情况下有n个数。</li></ul><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p>给你一个下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个正整数 <code>k</code> 。</p><p>你可以对数组执行以下操作 <strong>任意次</strong> ：</p><ul><li>选择数组里的 <strong>任意</strong> 一个元素，并将它的 <strong>二进制</strong> 表示 <strong>翻转</strong> 一个数位，翻转数位表示将 <code>0</code> 变成 <code>1</code> 或者将 <code>1</code> 变成 <code>0</code> 。</li></ul><p>你的目标是让数组里 <strong>所有</strong> 元素的按位异或和得到 <code>k</code> ，请你返回达成这一目标的 <strong>最少</strong> 操作次数。</p><p><strong>注意</strong>，你也可以将一个数的前导 0 翻转。比方说，数字 <code>(101)2</code> 翻转第四个数位，得到 <code>(1101)2</code> 。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：nums &#x3D; [2,1,3,4], k &#x3D; 1<br>输出：2<br>解释：我们可以执行以下操作：</p><ul><li>选择下标为 2 的元素，也就是 3 &#x3D;&#x3D; (011)2 ，我们翻转第一个数位得到 (010)2 &#x3D;&#x3D; 2 。数组变为 [2,1,2,4] 。</li><li>选择下标为 0 的元素，也就是 2 &#x3D;&#x3D; (010)2 ，我们翻转第三个数位得到 (110)2 &#x3D;&#x3D; 6 。数组变为 [6,1,2,4] 。<br>最终数组的所有元素异或和为 (6 XOR 1 XOR 2 XOR 4) &#x3D;&#x3D; 1 &#x3D;&#x3D; k 。<br>无法用少于 2 次操作得到异或和等于 k 。</li></ul></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：nums &#x3D; [2,0,2,0], k &#x3D; 0<br>输出：0<br>解释：数组所有元素的异或和为 (2 XOR 0 XOR 2 XOR 0) &#x3D;&#x3D; 0 &#x3D;&#x3D; k 。所以不需要进行任何操作。</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>0 &lt;= nums[i] &lt;= 10^6</code></li><li><code>0 &lt;= k &lt;= 10^6</code></li></ul><h3 id="思路分析-1"><a href="#思路分析-1" class="headerlink" title="思路分析"></a>思路分析</h3><p>这道题看似很唬人，其实是纸老虎。</p><p>设nums的异或和为s。</p><p>令<code>s=k</code>就等于<code>s⊕k=0</code>。也就是把数组中所有数全部异或，令其为x，只需要比较x和k有多少位不一样即可。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minOperations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            s ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        s ^= k;<span class="comment">// 想知道s和k有几位数不一样只需要异或一次后数1的个数即可</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s)&#123;</span><br><span class="line">            ans += s &amp; <span class="number">1</span>;</span><br><span class="line">            s &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i: nums)&#123;</span><br><span class="line">            s ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(s ^ k);<span class="comment">// 想知道s和k有几位数不一样只需要异或一次后数1的个数即可,bitCount方法可以直接获取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minOperations</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            s ^= i</span><br><span class="line">        <span class="keyword">return</span> (s ^ k).bit_count()</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)，n为数组长度。</li><li>空间复杂度：O(1)。</li></ul><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>给你两个正整数 <code>x</code> 和 <code>y</code> 。</p><p>一次操作中，你可以执行以下四种操作之一：</p><ol><li>如果 <code>x</code> 是 <code>11</code> 的倍数，将 <code>x</code> 除以 <code>11</code> 。</li><li>如果 <code>x</code> 是 <code>5</code> 的倍数，将 <code>x</code> 除以 <code>5</code> 。</li><li>将 <code>x</code> 减 <code>1</code> 。</li><li>将 <code>x</code> 加 <code>1</code> 。</li></ol><p>请你返回让 <code>x</code> 和 <code>y</code> 相等的 <strong>最少</strong> 操作次数。</p><p><strong>示例 1：</strong></p><blockquote><p>输入：x &#x3D; 26, y &#x3D; 1<br>输出：3<br>解释：我们可以通过以下操作将 26 变为 1 ：</p><ol><li>将 x 减 1</li><li>将 x 除以 5</li><li>将 x 除以 5<br>将 26 变为 1 最少需要 3 次操作。</li></ol></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：x &#x3D; 54, y &#x3D; 2<br>输出：4<br>解释：我们可以通过以下操作将 54 变为 2 ：</p><ol><li>将 x 加 1</li><li>将 x 除以 11</li><li>将 x 除以 5</li><li>将 x 加 1<br>将 54 变为 2 最少需要 4 次操作。</li></ol></blockquote><p><strong>示例 3：</strong></p><blockquote><p>输入：x &#x3D; 25, y &#x3D; 30<br>输出：5<br>解释：我们可以通过以下操作将 25 变为 30 ：</p><ol><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1</li><li>将 x 加 1<br>将 25 变为 30 最少需要 5 次操作。</li></ol></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= x, y &lt;= 10^4</code></li></ul><h3 id="思路分析-2"><a href="#思路分析-2" class="headerlink" title="思路分析"></a>思路分析</h3><p>这题我第一眼看以为是模拟，仔细看了一下样例发现没有这么复杂，可以抽象成最短路问题，直接BFS即可。</p><p>这里有一点可以优化的方法：注意x想要增加只有+1这种方法，所有如果<code>y &gt;= x</code>时，直接返回<code>y - x</code>即可。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumOperationsToMakeEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        deque&lt;tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        set&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">        q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(x, <span class="number">0</span>));</span><br><span class="line">        visited.<span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            tuple&lt;<span class="type">int</span>, <span class="type">int</span>&gt; now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="type">int</span> tmp = <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(now);</span><br><span class="line">            <span class="type">int</span> cnt = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(now);</span><br><span class="line">            <span class="keyword">if</span> (tmp == y)&#123;</span><br><span class="line">                <span class="keyword">return</span> cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">11</span> == <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp / <span class="number">11</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp / <span class="number">11</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp / <span class="number">11</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp / <span class="number">5</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp / <span class="number">5</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp / <span class="number">5</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span> &amp;&amp; visited.<span class="built_in">find</span>(tmp - <span class="number">1</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp - <span class="number">1</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp - <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(visited.<span class="built_in">find</span>(tmp + <span class="number">1</span>) == visited.<span class="built_in">end</span>())&#123;</span><br><span class="line">                visited.<span class="built_in">insert</span>(tmp + <span class="number">1</span>);</span><br><span class="line">                q.<span class="built_in">push_back</span>(<span class="built_in">make_tuple</span>(tmp + <span class="number">1</span>, cnt + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumOperationsToMakeEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        ArrayDeque&lt;<span class="type">int</span>[]&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, <span class="number">0</span>&#125;);</span><br><span class="line">        set.add(x);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] now = q.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> now[<span class="number">0</span>], cnt = now[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tmp == y) <span class="keyword">return</span> cnt;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">11</span> == <span class="number">0</span> &amp;&amp; !set.contains(tmp / <span class="number">11</span>))&#123;</span><br><span class="line">                set.add(tmp / <span class="number">11</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp / <span class="number">11</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; !set.contains(tmp / <span class="number">5</span>))&#123;</span><br><span class="line">                set.add(tmp / <span class="number">5</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp / <span class="number">5</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; <span class="number">0</span> &amp;&amp; !set.contains(tmp - <span class="number">1</span>))&#123;</span><br><span class="line">                set.add(tmp - <span class="number">1</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp - <span class="number">1</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(tmp + <span class="number">1</span>))&#123;</span><br><span class="line">                set.add(tmp + <span class="number">1</span>);</span><br><span class="line">                q.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;tmp + <span class="number">1</span>, cnt + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumOperationsToMakeEqual</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> y &gt;= x:</span><br><span class="line">            <span class="keyword">return</span> y - x</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        q.append((x, <span class="number">0</span>))</span><br><span class="line">        visited.add(x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp, cnt = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> tmp == y:</span><br><span class="line">                <span class="keyword">return</span> cnt</span><br><span class="line">            <span class="keyword">if</span> tmp % <span class="number">11</span> == <span class="number">0</span> <span class="keyword">and</span> tmp // <span class="number">11</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp // <span class="number">11</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp // <span class="number">11</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp % <span class="number">5</span> == <span class="number">0</span> <span class="keyword">and</span> tmp // <span class="number">5</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp // <span class="number">5</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp // <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp &gt; <span class="number">0</span> <span class="keyword">and</span> tmp - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp - <span class="number">1</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> tmp + <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                q.append((tmp + <span class="number">1</span>, cnt + <span class="number">1</span>))</span><br><span class="line">                visited.add(tmp + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(x)。</li><li>空间复杂度：O(x)，定义了一个哈希集合。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode每日一题.1</title>
      <link href="/inori/7752405a.html"/>
      <url>/inori/7752405a.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode每日一题"><a href="#LeetCode每日一题" class="headerlink" title="LeetCode每日一题"></a>LeetCode每日一题</h1><p>​今天的每日一题是<a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/">2807. 在链表中插入最大公约数</a>，难度标的中等，不过我认为应该是简单题</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你一个链表的头 <code>head</code> ，每个结点包含一个整数值。</p><p>在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 <strong>最大公约数</strong> 。</p><p>请你返回插入之后的链表。</p><p>两个数的 <strong>最大公约数</strong> 是可以被两个数字整除的最大正整数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/07/18/ex1_copy.png" alt="img"></p><blockquote><p>输入：head &#x3D; [18,6,10,3]<br>输出：[18,6,6,2,10,1,3]<br>解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。</p><ul><li>18 和 6 的最大公约数为 6 ，插入第一和第二个结点之间。</li><li>6 和 10 的最大公约数为 2 ，插入第二和第三个结点之间。</li><li>10 和 3 的最大公约数为 1 ，插入第三和第四个结点之间。<br>所有相邻结点之间都插入完毕，返回链表。</li></ul></blockquote><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/07/18/ex2_copy1.png" alt="img"></p><blockquote><p>输入：head &#x3D; [7]<br>输出：[7]<br>解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。<br>没有相邻结点，所以返回初始链表。</p></blockquote><p><strong>提示：</strong></p><ul><li>链表中结点数目在 <code>[1, 5000]</code> 之间。</li><li><code>1 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>​这道题很直观，明显是考差欧几里得算法(辗转相除法)<code>gcd(a,b) = gcd(b,a mod b)</code>原理为：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。</p><p>​明白了考察的知识点，这道题就非常简单了，直接遍历链表，在每两个节点直接插入这两个节点的值的最大公约数<code>gcd(node1.val, node2.val)</code>即可，计算gcd的方法可以是 <code>Math.gcd</code>或者自定义方法。</p><p>​有一点需要注意，只有节点数大于1时才需要插入，否则直接返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">insertGreatestCommonDivisors</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = head, *ne = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(ne)&#123;</span><br><span class="line">            ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="built_in">gcd</span>(pre-&gt;val, ne-&gt;val), ne);</span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">            pre = ne;</span><br><span class="line">            ne = ne-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">insertGreatestCommonDivisors</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, ne = head.next;</span><br><span class="line">        <span class="keyword">while</span>(ne != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> gcd(pre.val, ne.val);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(g, ne);</span><br><span class="line">            pre.next = newNode;</span><br><span class="line">            pre = ne;</span><br><span class="line">            ne = ne.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertGreatestCommonDivisors</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">            <span class="keyword">return</span> a <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        pre, ne = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> ne:</span><br><span class="line">            node = ListNode(gcd(pre.val, ne.val), ne)</span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">            pre = ne</span><br><span class="line">            ne = ne.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(nlog⁡M)，其中n为链表长度，M是节点最大可能的值，每次计算要O(logM)的时间。</li><li>空间复杂度：O(1)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些碎碎念</title>
      <link href="/inori/303572a2.html"/>
      <url>/inori/303572a2.html</url>
      
        <content type="html"><![CDATA[<h3 id="2024-1-1"><a href="#2024-1-1" class="headerlink" title="2024.1.1"></a>2024.1.1</h3><p>​很久以前就想着搭一个个人博客，但是一直拖着没搞，昨天晚上闲来无事，突然想到这件事，一口气搞出来了。说是个人博客，主要是当我的笔记本用吧，博客里面很多东西都没弄懂，也没弄好。</p><p>​目标是缓慢且持续的更新，学啥更啥…</p><h3 id="2024-1-26"><a href="#2024-1-26" class="headerlink" title="2024.1.26"></a>2024.1.26</h3><p>​终于把期末考试的事搞完了，我认为研究生上的课，不对，应该是本科和研究生上的课不能说是毫无用处，只能说是屁用没有，占用自学的时间，在那坐着浪费时间，老师在课上讲一些已经与当前正在应用的技术脱节很久的老知识，关键是课程报告和结课论文还需要用这些东西，学这些东西以后又用不上，又要浪费一大段时间。唉</p><h3 id="2024-2-1"><a href="#2024-2-1" class="headerlink" title="2024.2.1"></a>2024.2.1</h3><p>​放寒假了，实验室布置了一堆任务，但是我自己还想要自学很多东西，好像放假比不放假还难受。现在开始继续学习并且更新博客了。</p><h3 id="2024-2-9"><a href="#2024-2-9" class="headerlink" title="2024.2.9"></a>2024.2.9</h3><p>​今天除夕，我依旧在学习，得完成自己给自己下定的目标才行，已经拖了好几天了，这两天把它非得干掉。但是在家学不下去啊，学几分钟就想玩，一玩一小时就过去了…太浮躁了，不知道怎么改正，只能是硬学了。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/inori/4a17b156.html"/>
      <url>/inori/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>费了不少劲！终于把我的博客搭好了！</p><h3 id="所用技术"><a href="#所用技术" class="headerlink" title="所用技术"></a>所用技术</h3><p>​本网站使用GitHub后端+Hexo框架+Butterfly渲染，并在基础上做出了一小部分魔改，加了些花里胡哨的东西，域名在阿里云选购。</p><hr><p>​就说这么多吧，后续我争取做到把每日学到的东西做一个总结，更新在这里，希望可以用这种方法来加深我对知识的理解与记忆。</p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 碎碎念 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
