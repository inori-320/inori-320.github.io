<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>楪祈のBlog</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>星座になれたら。</description>
    <pubDate>Wed, 24 Apr 2024 07:59:59 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Docker的基本使用</title>
      <link>http://example.com/inori/ca4a993b.html</link>
      <guid>http://example.com/inori/ca4a993b.html</guid>
      <pubDate>Wed, 24 Apr 2024 03:47:21 GMT</pubDate>
      
      <description>Docker常用命令</description>
      
      
      
      <content:encoded><![CDATA[<p>Docker使用Google推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><p>Docker在容器的基础上进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得Docker技术比虚拟机技术更为轻便、快捷。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像：一个特殊的文件系统"><a href="#镜像：一个特殊的文件系统" class="headerlink" title="镜像：一个特殊的文件系统"></a><strong>镜像：一个特殊的文件系统</strong></h3><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。</p><p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker设计时，就将其设计为分层存储的架构，镜像实际是由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p><p>在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><p>因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h3 id="容器：镜像运行时的实体"><a href="#容器：镜像运行时的实体" class="headerlink" title="容器：镜像运行时的实体"></a><strong>容器：镜像运行时的实体</strong></h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。</p><p>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新start，数据不会丢失。</p><h3 id="仓库：集中存放镜像文件的地方"><a href="#仓库：集中存放镜像文件的地方" class="headerlink" title="仓库：集中存放镜像文件的地方"></a><strong>仓库：集中存放镜像文件的地方</strong></h3><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</p><p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。</p><p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><p>这里补充一下 Docker Registry 公开服务和私有 Docker Registry 的概念：</p><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。</p><p>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的<a href="https://hub.docker.com/">Docker Hub</a>，这也是默认的Registry，并拥有大量的高质量的镜像。</p><p>在国内访问可能会比较慢，国内也有一些云服务商提供类似于Docker Hub的公开服务。</p><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 Docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><p><img src="D:\Blog\source\img\img_con.png" alt="img_con"></p><h2 id="初步配置Docker"><a href="#初步配置Docker" class="headerlink" title="初步配置Docker"></a>初步配置Docker</h2><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker容器开机自启</span></span><br><span class="line">docker update <span class="literal">--restart</span>=always [容器名/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p>给常用Docker命令起别名，方便访问：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br></pre></td></tr></table></figure><p>执行命令使修改生效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p><img src="D:\Blog\source\img\docker_control.png" alt="docker_control"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    <span class="number">605</span>c77e624dd   <span class="number">16</span> months ago   <span class="number">141</span>MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步，创建并允许Nginx容器</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第5步，查看运行中容器</span></span><br><span class="line">docker <span class="built_in">ps</span></span><br><span class="line"><span class="comment"># 也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第8步，查看所有容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第9步，再次启动nginx容器</span></span><br><span class="line">docker <span class="built_in">start</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第10步，再次查看容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br><span class="line"><span class="comment"># 或者，可以进入MySQL</span></span><br><span class="line">docker exec <span class="literal">-it</span> mysql mysql <span class="literal">-uroot</span> <span class="literal">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第13步，删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br><span class="line"><span class="comment"># 发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> nginx</span><br></pre></td></tr></table></figure><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷（volume）是一个虚拟目录，是<strong>容器内</strong>目录与<strong>宿主机</strong>目录之间映射的桥梁。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     <span class="number">29524</span>ff09715htrhfhthfhta2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-04-24T09:50:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html</span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br></pre></td></tr></table></figure><h3 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h3><p>数据卷的目录结构较深，去操作数据卷目录会不太方便。在很多情况下会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><p>本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>如果想要部署我们自己的项目，需要将其打包为一个镜像。</p><p>打包镜像分成如下步骤：</p><ul><li>准备Linux运行环境</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。记录镜像结构的文件就称为<a href="https://docs.docker.com/engine/reference/builder/"><strong>Dockerfile</strong></a></p><h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>通常在其他人提供好的基础镜像之上制作镜像</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像</p><p>首先将本地打包好的jar包和Dockerfile传入linux服务器，然后执行命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/image</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><p><code>docker build </code>: 构建一个docker镜像</p></li><li><p><code>-t demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</p></li><li><p><code>.</code> : 指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接指定Dockerfile目录</span></span><br><span class="line">docker build -t docker-demo:1.0 /root/image</span><br></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>项目往往需要访问其它各种中间件，例如MySQL、Redis等。但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p><p>所以，我们必须借助于<a href="https://docs.docker.com/engine/reference/commandline/network/">docker的网络功能</a>来解决这个问题</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   demo      bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了demo以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect demo mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect demo <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>只是部署一个简单的java项目，会包含以下3个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了</p><p>DockerCompose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的docker-compose.yml模板文件（YAML格式）来定义一组相关联的应用容器。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">docker-compose.yml文件的基本语法</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数很相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network demo</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th align="left"><strong>docker run 参数</strong></th><th align="left"><strong>docker compose 指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">–name</td><td align="left">container_name</td><td align="left">容器名称</td></tr><tr><td align="left">-p</td><td align="left">ports</td><td align="left">端口映射</td></tr><tr><td align="left">-e</td><td align="left">environment</td><td align="left">环境变量</td></tr><tr><td align="left">-v</td><td align="left">volumes</td><td align="left">数据卷配置</td></tr><tr><td align="left">–network</td><td align="left">networks</td><td align="left">网络</td></tr></tbody></table><h3 id="项目部署示例"><a href="#项目部署示例" class="headerlink" title="项目部署示例"></a>项目部署示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">project:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">demo:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">net</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以<a href="https://docs.docker.com/compose/reference/">部署项目</a>了</p><p>基本语法：<code>docker compose [OPTIONS] [COMMAND]</code></p><p>OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td><td align="left"></td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left">down</td><td align="left">停止并移除所有容器、网络</td><td align="left"></td></tr><tr><td align="left">ps</td><td align="left">列出所有启动的容器</td><td align="left"></td></tr><tr><td align="left">logs</td><td align="left">查看指定容器的日志</td><td align="left"></td></tr><tr><td align="left">stop</td><td align="left">停止容器</td><td align="left"></td></tr><tr><td align="left">start</td><td align="left">启动容器</td><td align="left"></td></tr><tr><td align="left">restart</td><td align="left">重启容器</td><td align="left"></td></tr><tr><td align="left">top</td><td align="left">查看运行的进程</td><td align="left"></td></tr><tr><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td><td align="left"></td></tr></tbody></table><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除镜像</span></span><br><span class="line">docker rmi demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY demo-service.jar /app.jar                                         0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root                                                 0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network net      Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container demo   Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/docker/">docker</category>
      
      
      <category domain="http://example.com/tags/docker/">docker</category>
      
      
      <comments>http://example.com/inori/ca4a993b.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis进阶篇</title>
      <link>http://example.com/inori/a9e82450.html</link>
      <guid>http://example.com/inori/a9e82450.html</guid>
      <pubDate>Tue, 16 Apr 2024 12:16:39 GMT</pubDate>
      
      <description>redis入门</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便继续使用缓存</p><p><strong>主动更新：</strong>手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="D:\Blog\source\img\redis_cacheUpdate.png" alt="redis_cacheUpdate"></p><h3 id="数据库缓存不一致解决方案"><a href="#数据库缓存不一致解决方案" class="headerlink" title="数据库缓存不一致解决方案"></a>数据库缓存不一致解决方案</h3><p>由于缓存的数据源来自于数据库,而数据库的数据是会发生变化的,因此,如果当数据库中数据发生变化,而缓存却没有同步,此时就会有一致性问题存在,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern: 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><h3 id="缓存穿透问题的解决思路"><a href="#缓存穿透问题的解决思路" class="headerlink" title="缓存穿透问题的解决思路"></a>缓存穿透问题的解决思路</h3><p><strong>缓存穿透</strong>：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器使用的是哈希思想，而哈希思想可能存在哈希冲突</p><h3 id="缓存雪崩问题及解决思路"><a href="#缓存雪崩问题及解决思路" class="headerlink" title="缓存雪崩问题及解决思路"></a>缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h3 id="缓存击穿问题及解决思路"><a href="#缓存击穿问题及解决思路" class="headerlink" title="缓存击穿问题及解决思路"></a>缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="D:\Blog\source\img\redisThrough.png" alt="redisThrough"></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><h3 id="分布式锁应该满足的条件"><a href="#分布式锁应该满足的条件" class="headerlink" title="分布式锁应该满足的条件"></a>分布式锁应该满足的条件</h3><ul><li>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li><li>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</li><li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li><li>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全也是程序中必不可少的一环</li></ul><h3 id="常见的分布式锁"><a href="#常见的分布式锁" class="headerlink" title="常见的分布式锁"></a>常见的分布式锁</h3><p><img src="D:\Blog\source\img\common_lock.png" alt="common_lock"></p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><h4 id="Redisson简介"><a href="#Redisson简介" class="headerlink" title="Redisson简介"></a>Redisson简介</h4><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="D:\Blog\source\img\redisson_type.png" alt="redisson_type"></p><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://IP地址:端口号&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Redission的分布式锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redission可重入锁原理"><a href="#redission可重入锁原理" class="headerlink" title="redission可重入锁原理"></a>redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0时，表示当前这把锁没有被人持有。</p><p>在redission中也支持支持可重入锁</p><p>在分布式锁中，采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，小key表示当前这把锁被哪个线程持有，分析一下当前的这个lua表达式:</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure><p>此处一共有3个参数：</p><p><strong>KEYS[1]：锁名称</strong></p><p><strong>ARGV[1]：锁失效时间</strong></p><p><strong>ARGV[2]：id + “:” + threadId；锁的小key</strong></p><p>exists: 判断数据是否存在</p><p>name：是lock是否存在,如果&#x3D;&#x3D;0，就表示当前这把锁不存在</p><p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p><p>Lock{</p><p>​    id + <strong>“:”</strong> + threadId :  1</p><p>}</p><p>如果当前这把锁存在，则第一个条件不满足，再判断</p><p>redis.call(‘hexists’, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1</p><p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p><p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p><p>将当前这个锁的value进行+1</p><p>redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p><p>他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p><p><img src="D:\Blog\source\img\getLock.png" alt="getLock"></p><h3 id="锁重试和WatchDog机制"><a href="#锁重试和WatchDog机制" class="headerlink" title="锁重试和WatchDog机制"></a>锁重试和WatchDog机制</h3><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前该线程已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，存在一个while(true) 进行tryAcquire抢锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br></pre></td></tr></table></figure><p>如果是没有传入时间，则此时也会进行抢锁，而且抢锁时间是默认看门狗时间<code>commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</code></p><p><code>ttlRemainingFuture.onComplete((ttlRemaining, e)</code>相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure><p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（）方法Method(<strong>new</strong> TimerTask(){}, 参数2, 参数3)</p><p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MutiLock原理"><a href="#MutiLock原理" class="headerlink" title="MutiLock原理"></a>MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="D:\Blog\source\img\mutilock_1.png" alt="mutilock_1"></p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功，那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试</p><p><img src="D:\Blog\source\img\mutilock_2.png" alt="mutilock_2"></p><h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><p>消息队列的字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>使用队列的好处在于 <strong>解耦：</strong>生产者不必等待消费者，生产出来的东西可以直接放到队列中，消费者也不必等待生产者，直接从队列中获得所需的消息，二者异步执行，增加效率。</p><h3 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a>基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h3 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream是Redis 5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="D:\Blog\source\img\stream_1.png" alt="stream_1"></p><p>例如：</p><p><code>XADD user * name jack age 18</code>:创建名为users的队列，并向其中发送一个消息，内容为{name&#x3D;jack,age&#x3D;18},使用Redis自动生成ID</p><p>读取消息的方式之一：XREAD</p><p><img src="D:\Blog\source\img\stream_xread.png" alt="stream_xread"></p><p>例如，使用XREAD读取第一个消息：<code>XREAD COUNT 1 STREAMS users 0</code></p><p>XREAD阻塞方式，读取最新的消息：<code>XREAD COUNT 1 BLOCK 1000 STREAMS user $</code></p><p>可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 尝试读取队列中的消息，最多阻塞2秒</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.execute(<span class="string">&quot;XREAD COUNT 1 BLOCK 2000 STREAMS user $&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    handleMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p><img src="D:\Blog\source\img\user_group.png" alt="user_group"></p><p>创建消费者组：<code>XGROUP CREATE key gruopName ID [MKSTREAM]</code><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><h2 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，根据经纬度来检索数据。</p><p>常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li></ul><p><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></p><ul><li>GEODIST：计算指定的两个点之间的距离并返回</li></ul><p><code>GEODIST key member1 member2 [m|km|ft|mi]</code></p><ul><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li></ul><p><code>GEOHASH key member [member ...]</code></p><ul><li>GEOPOS：返回指定member的坐标</li></ul><p><code>GEOPOS key member [member ...]</code></p><ul><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。(已废弃)</li></ul><p><code>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></p><ul><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。</li></ul><p><code>GEOSEARCH key [FROMMEMBER member] [FROMCOORD longitude latitude] [BYRADIUS radius unit] [BYBOX width height unit] [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count] [STORE key] [STOREDIST key]</code></p><p>其中，<code>key</code>是指定的键，可选的查询参数包括：</p><p>​<code>FROMMEMBER member</code>：从指定的位置成员开始搜索。</p><p>​<code>FROMCOORD longitude latitude</code>：从指定的经度和纬度开始搜索。</p><p>​<code>BYRADIUS radius unit</code>：根据半径进行搜索。</p><p>​<code>BYBOX width height unit</code>：根据矩形区域进行搜索。</p><p>​<code>WITHCOORD</code>：返回位置的经度和纬度。</p><p>​<code>WITHDIST</code>：返回位置与查询点的距离。</p><p>​<code>ASC|DESC</code>：按距离升序或降序排序。</p><p>​<code>COUNT count</code>：返回最多指定数量的结果。</p><p>​<code>STORE key</code>：将结果存储到指定的键中。</p><p>​<code>STOREDIST key</code>：将结果存储到指定的键中，并同时存储位置与查询点的距离。</p><ul><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个新的key中。</li></ul><p><code>GEOSEARCHSTORE destkey key [FROMMEMBER member] [FROMCOORD longitude latitude] [BYRADIUS radius unit] [BYBOX width height unit] [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count] [STOREDIST key]</code></p><h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>Bitmap并不是实际的数据类型，而是定义在String类型上的一个面向字节操作的集合。因为字符串是二进制安全的块，他们的最大长度是512M，最适合设置成2^32个不同字节。Bitmap的最大优势之一在存储信息时极其节约空间。</p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT：获取指定位置（offset）的bit值</li><li>BITCOUNT：统计BitMap中值为1的bit位的数量</li><li>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/redis/">redis</category>
      
      
      <category domain="http://example.com/tags/redis/">redis</category>
      
      
      <comments>http://example.com/inori/a9e82450.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git入门</title>
      <link>http://example.com/inori/8e7db504.html</link>
      <guid>http://example.com/inori/8e7db504.html</guid>
      <pubDate>Wed, 10 Apr 2024 07:23:21 GMT</pubDate>
      
      <description>Git常用命令</description>
      
      
      
      <content:encoded><![CDATA[<p>Git是一个分布式的版本控制系统，可以管理应用开发版本，同样可以作为部署工具使用。</p><p>常用的git平台：<a href="https://github.com/">GitHub</a>、<a href="https://gitee.com/">Gitee</a>、<a href="https://gitlab.com/">GitLab</a>等</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>工作区：仓库的目录。工作区是独立于各个分支的。</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本。</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在<del>&#x2F;.gitconfig文件中<br><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在</del>&#x2F;.gitconfig文件中<br><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中<br><code>git add XX</code>：将XX文件添加到暂存区</p><ul><li><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</li></ul><p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉<br><code>git commit -m &quot;备注信息&quot;</code>：将暂存区的内容提交到当前分支<br><code>git status</code>：查看仓库状态<br><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容<br><code>git log</code>：查看当前分支的所有版本<br><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）<br><code>git reset --hard HEAD^ 或 git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><ul><li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li><li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li><li><code>git reset --hard 版本号</code>：回滚到某一特定版本</li></ul><p><code>git checkout — XX或git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销<br><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库<br><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库</p><ul><li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li></ul><p><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下<br><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支<br><code>git branch</code>：查看所有分支和当前所处分支<br><code>git checkout branch_name</code>：切换到branch_name这个分支<br><code>git merge branch_name</code>：将分支branch_name合并到当前分支上<br><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支<br><code>git branch branch_name</code>：创建新分支<br><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支<br><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支<br><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p><ul><li><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</li></ul><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应<br><code>git checkout -t origin/branch_name</code>: 将远程的branch_name分支拉取到本地<br><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中<br><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素<br><code>git stash drop</code>：删除栈顶存储的修改<br><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素<br><code>git stash list</code>：查看栈中所有元素</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/git/">git</category>
      
      
      <category domain="http://example.com/tags/git/">git</category>
      
      
      <comments>http://example.com/inori/8e7db504.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux基础</title>
      <link>http://example.com/inori/a4a81253.html</link>
      <guid>http://example.com/inori/a4a81253.html</guid>
      <pubDate>Wed, 10 Apr 2024 07:23:05 GMT</pubDate>
      
      <description>Linux</description>
      
      
      
      <content:encoded><![CDATA[<p>转载自<a href="https://www.acwing.com/activity/content/57/">AcWing——Linux基础课</a></p><h2 id="文件操作常用命令"><a href="#文件操作常用命令" class="headerlink" title="文件操作常用命令"></a>文件操作常用命令</h2><ul><li><p>ctrl c: 取消命令，并且换行</p></li><li><p>ctrl u: 清空本行命令</p></li><li><p>tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li><li><p>ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p></li><li><p>pwd: 显示当前路径</p></li><li><p>cd XXX: 进入XXX目录下, cd .. 返回上层目录</p></li><li><p>cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如..&#x2F;dir_c&#x2F;a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p></li><li><p>mkdir XXX: 创建目录XXX</p></li><li><p>rm XXX: 删除普通文件</p><ul><li>rm XXX -r: 删除文件夹</li></ul></li><li><p>mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令</p></li><li><p>touch XXX: 创建一个文件</p></li><li><p>cat XXX: 展示文件XXX中的内容</p></li><li><p>复制文本</p><ul><li><p>windows&#x2F;Linux下：Ctrl + insert</p></li><li><p>Mac下：command + c</p></li></ul></li><li><p>粘贴文本</p><ul><li><p>windows&#x2F;Linux下：Shift + insert</p></li><li><p>Mac下：command + v</p></li></ul></li></ul><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><ul><li><p>功能</p><ul><li><p>分屏</p></li><li><p>允许断开Terminal连接后，继续运行进程</p></li></ul></li><li><p>结构：</p><ul><li>一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane</li><li>操作（魔改后）：<ul><li>tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</li><li>按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。</li><li>按下Ctrl + a后手指松开，然后按”（注意是双引号”）：将当前pane上下平分成两个pane。</li><li>Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</li><li>鼠标点击可以选pane。</li><li>按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。</li><li>鼠标拖动pane之间的分割线，可以调整分割线的位置。</li><li>按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。</li><li>按下ctrl + a后手指松开，然后按z：将当前pane全屏&#x2F;取消全屏。</li><li>按下ctrl + a后手指松开，然后按d：挂起当前session。</li><li>tmux a：打开之前挂起的session。</li><li>按下ctrl + a后手指松开，然后按s：选择其它session。<br>方向键 —— 上：选择上一项 session&#x2F;window&#x2F;pane<br>方向键 —— 下：选择下一项 session&#x2F;window&#x2F;pane<br>方向键 —— 右：展开当前项 session&#x2F;window<br>方向键 —— 左：闭合当前项 session&#x2F;window</li><li>按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。</li><li>按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。</li><li>按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。</li><li>鼠标滚轮：翻阅当前pane内的内容。</li><li>在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</li><li>tmux中复制&#x2F;粘贴文本的通用方式：<br> 1. 按下Ctrl + a后松开手指，然后按[<br>      2. 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板<br>      3. 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</li></ul></li></ul></li></ul><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><ul><li>功能：<ul><li>命令行模式下的文本编辑器。</li><li>根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</li><li>使用方式：vim filename<ul><li>如果已有该文件，则打开它。</li><li>如果没有该文件，则打开个一个新的文件，并命名为filename</li></ul></li></ul></li><li>模式：<ul><li>一般命令模式<ul><li>默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</li><li>编辑模式<br>   在一般命令模式里按下i，会进入编辑模式。<br>   按下ESC会退出编辑模式，返回到一般命令模式。</li><li>命令行模式<br>   在一般命令模式里按下:&#x2F;?三个字母中的任意一个，会进入命令行模式。命令行在最下面。<br>   可以查找、替换、保存、退出、配置编辑器等。</li></ul></li></ul></li><li>操作：<ul><li>i和a：进入编辑模式</li><li>ESC：进入一般命令模式<ul><li>h 或 左箭头键：光标向左移动一个字符</li><li>j 或 向下箭头：光标向下移动一个字符</li><li>k 或 向上箭头：光标向上移动一个字符</li><li>l 或 向右箭头：光标向右移动一个字符</li><li>n<Space>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</li><li>0 或 功能键[Home]：光标移动到本行开头</li><li><code>$ 或 功能键[End]</code>：光标移动到本行末尾</li><li>G：光标移动到最后一行</li><li>:n 或 nG：n为数字，光标移动到第n行</li><li>gg：光标移动到第一行，相当于1G</li><li>n<Enter>：n为数字，光标向下移动n行</li><li>&#x2F;word：向光标之下寻找第一个值为word的字符串。</li><li>?word：向光标之上寻找第一个值为word的字符串。</li><li>n：重复前一个查找操作</li><li>N：反向重复前一个查找操作</li><li>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</li><li>:1,$s&#x2F;word1&#x2F;word2&#x2F;g：将全文的word1替换为word2<br>        (20) :1,$s&#x2F;word1&#x2F;word2&#x2F;gc：将全文的word1替换为word2，且在替换前要求用户确认。</li><li>v：选中文本</li><li>d：删除选中的文本</li><li>dd: 删除当前行</li><li>y：复制选中的文本</li><li>yy: 复制当前行</li><li>p: 将复制的数据在光标的下一行&#x2F;下一个位置粘贴</li><li>u：撤销</li><li>Ctrl + r：取消撤销</li><li>大于号 &gt;：将选中的文本整体向右缩进一次</li><li>小于号 &lt;：将选中的文本整体向左缩进一次</li><li>:w 保存</li><li>:w! 强制保存</li><li>:q 退出</li><li>:q! 强制退出</li><li>:wq 保存并退出</li><li>:set paste 设置成粘贴模式，取消代码自动缩进</li><li>:set nopaste 取消粘贴模式，开启代码自动缩进</li><li>:set nu 显示行号</li><li>:set nonu 隐藏行号</li><li>gg&#x3D;G：将全文代码格式化</li><li>:noh 关闭查找关键词高亮</li><li>Ctrl + q：当vim卡死时，可以取消当前正在执行的命令</li></ul></li></ul></li><li>异常处理：<ul><li>每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。</li><li>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<ol><li>找到正在打开该文件的程序，并退出</li><li>直接删掉该swp文件</li></ol></li></ul></li></ul><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>远程登录服务器：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname</span><br></pre></td></tr></table></figure><p>user: 用户名<br>hostname: IP地址或域名</p><ul><li>第一次登录时会提示：</li></ul><blockquote><p> The authenticity of host ‘123.57.47.211 (123.57.47.211)’ can’t be established.<br>ECDSA key fingerprint is SHA256:iy237yysfCe013&#x2F;l+kpDGfEG9xxHxm0dnxnAbJTPpG8.<br>Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])?</p></blockquote><p>输入yes，然后回车即可。<br>这样会将该服务器的信息记录在~&#x2F;.ssh&#x2F;known_hosts文件中。</p><p>然后输入密码即可登录到远程服务器中。</p><p>默认登录端口号为22。如果想登录某一特定端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname -p 22</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>创建文件 ~&#x2F;.ssh&#x2F;config。</p><p>然后在文件中输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host myserver1</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br><span class="line"></span><br><span class="line">Host myserver2</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure><p>之后再使用服务器时，可以直接使用别名myserver1、myserver2。</p><h3 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h3><p>创建密钥：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>执行结束后，~&#x2F;.ssh&#x2F;目录下会多两个文件：</p><ol><li>id_rsa：私钥</li><li>id_rsa.pub：公钥</li></ol><p>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</p><p>例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~&#x2F;.ssh&#x2F;authorized_keys文件里即可。</p><p>也可以使用如下命令一键添加公钥：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id myserver</span><br></pre></td></tr></table></figure><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>命令格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh user@hostname command</span><br></pre></td></tr></table></figure><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道类似于文件重定向，可以将前一个命令的stdout重定向到下一个命令的stdin。</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li><p>管道命令仅处理<code>stdout</code>，会忽略<code>stderr</code></p></li><li><p>管道右边的命令必须能接受<code>stdin</code></p></li><li><p>多个管道命令可以串联</p></li><li><p>与文件重定向的区别</p></li><li><p>文件重定向左边为命令，右边为文件。</p></li><li><p>管道左右两边均为命令，左边有stdout，右边有stdin。</p></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>统计当前目录下所有python文件的总行数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &#x27;*.py&#x27; | xargs cat | wc -l</span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Linux系统中会用很多环境变量来记录配置信息。<br>环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>列出当前环境下的所有环境变量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env  # 显示当前用户的变量</span><br><span class="line">set  # 显示当前shell的变量，包括当前用户的变量;</span><br><span class="line">export  # 显示当前导出成用户变量的shell变量</span><br></pre></td></tr></table></figure><p>输出某个环境变量的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>为了将对环境变量的修改应用到未来所有环境下，可以将修改命令放到<del>&#x2F;.bashrc文件中。<br>修改完</del>&#x2F;.bashrc文件后，记得执行source ~&#x2F;.bashrc，来将修改应用到当前的bash环境下。</p><p>为何将修改命令放到~&#x2F;.bashrc，就可以确保修改会影响未来所有的环境呢？</p><ul><li>每次启动bash，都会先执行~&#x2F;.bashrc。</li><li>每次ssh登陆远程服务器，都会启动一个bash命令行给我们。</li><li>每次tmux新开一个pane，都会启动一个bash命令行给我们。</li><li>所以未来所有新开的环境都会加载我们修改的内容。</li></ul><h3 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h3><ol><li>HOME：用户的家目录。</li><li>PATH：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。</li><li>LD_LIBRARY_PATH：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。</li><li>C_INCLUDE_PATH：C语言的头文件路径，内容是以冒号分隔的路径列表。</li><li>CPLUS_INCLUDE_PATH：CPP的头文件路径，内容是以冒号分隔的路径列表。</li><li>PYTHONPATH：Python导入包的路径，内容是以冒号分隔的路径列表。</li><li>JAVA_HOME：jdk的安装目录。</li><li>CLASSPATH：存放Java导入类的路径，内容是以冒号分隔的路径列表。</li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="系统状况"><a href="#系统状况" class="headerlink" title="系统状况"></a>系统状况</h3><ol><li><p>top：查看所有进程的信息（Linux的任务管理器）</p><ul><li>打开后，输入M：按使用内存排序</li><li>打开后，输入P：按使用CPU排序</li><li>打开后，输入q：退出</li></ul></li><li><p>df -h：查看硬盘使用情况</p></li><li><p>free -h：查看内存使用情况</p></li><li><p>du -sh：查看当前目录占用的硬盘空间</p></li><li><p>ps aux：查看所有进程</p></li><li><p>kill -9 pid：杀死编号为pid的进程</p><ul><li>传递某个具体的信号：<code>kill -s SIGTERM pid</code></li></ul></li><li><p>netstat -nt：查看所有网络连接</p></li><li><p>w：列出当前登陆的用户</p></li><li><p>ping <code>某url</code>：检查是否连网</p></li></ol><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li>chmod：修改文件权限<ul><li>chmod +x xxx：给xxx添加可执行权限</li><li>chmod -x xxx：去掉xxx的可执行权限</li><li>chmod 777 xxx：将xxx的权限改成777</li><li>chmod 777 xxx -R：递归修改整个文件夹的权限</li></ul></li></ul><h3 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h3><ol><li><p>find &#x2F;path&#x2F;to&#x2F;directory&#x2F; -name ‘<em>.py’：搜索某个文件路径下的所有</em>.py文件</p></li><li><p>grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。</p></li><li><p>wc：统计行数、单词数、字节数</p><ul><li>既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；</li><li>wc -l：统计行数</li><li>wc -w：统计单词数</li><li>wc -c：统计字节数</li></ul></li><li><p>tree：展示当前目录的文件结构</p><ul><li>tree &#x2F;path&#x2F;to&#x2F;directory&#x2F;：展示某个目录的文件结构</li><li>tree -a：展示隐藏文件</li></ul></li><li><p>ag xxx：搜索当前目录下的所有文件，检索xxx字符串</p></li><li><p>cut：分割一行内容</p><ul><li>从stdin中读入多行数据</li><li><code>echo $PATH | cut -d &#39;:&#39; -f 3,5</code>：输出PATH用:分割后第3、5列数据</li><li><code>echo $PATH | cut -d &#39;:&#39; -f 3-5</code>：输出PATH用:分割后第3-5列数据</li><li><code>echo $PATH | cut -c 3,5</code>：输出PATH的第3、5个字符</li><li><code>echo $PATH | cut -c 3-5</code>：输出PATH的第3-5个字符</li></ul></li><li><p>sort：将每行内容按字典序排序</p><ul><li><p>可以从stdin中读取多行数据</p></li><li><p>可以从命令行参数中读取文件名列表</p></li></ul></li><li><p>xargs：将stdin中的数据用空格或回车分割成命令行参数</p><ul><li>find . -name ‘*.py’ | xargs cat | wc -l：统计当前目录下所有python文件的总行数</li></ul></li></ol><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><ol><li><p>more：浏览文件内容</p><ul><li><p>回车：下一行</p></li><li><p>空格：下一页</p></li><li><p>b：上一页</p></li><li><p>q：退出</p></li></ul></li><li><p>less：与more类似，功能更全</p><ul><li>回车：下一行</li><li>y：上一行</li><li>Page Down：下一页</li><li>Page Up：上一页</li><li>q：退出</li></ul></li><li><p>head -3 xxx：展示xxx的前3行内容，同时支持从stdin读入内容</p></li><li><p>ail -3 xxx：展示xxx末尾3行内容，同时支持从stdin读入内容</p></li></ol><h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3><p><code>history</code>：展示当前用户的历史操作。内容存放在~&#x2F;.bash_history中</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol><li>md5sum：计算md5哈希值<ul><li>可以从stdin读入内容</li><li>可以在命令行参数中传入文件名列表</li></ul></li><li>time command：统计command命令的执行时间</li><li>ipython3：交互式python3环境。可以当做计算器，或者批量管理文件<ul><li><code>! echo &quot;Hello World&quot;</code>：!表示执行shell脚本</li></ul></li><li>watch -n 0.1 command：每0.1秒执行一次command命令</li><li>tar：压缩文件<ul><li>tar -zcvf xxx.tar.gz &#x2F;path&#x2F;to&#x2F;file&#x2F;*：压缩</li><li>tar -zxvf xxx.tar.gz：解压缩</li></ul></li><li>diff xxx yyy：查找文件xxx与yyy的不同点</li></ol><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><ul><li>sudo command：以root身份执行command命令</li><li>apt-get install xxx：安装软件</li><li>pip install xxx –user –upgrade：安装python包</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux/">Linux</category>
      
      
      <category domain="http://example.com/tags/Linux/">Linux</category>
      
      
      <comments>http://example.com/inori/a4a81253.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis入门篇</title>
      <link>http://example.com/inori/8660e5c0.html</link>
      <guid>http://example.com/inori/8660e5c0.html</guid>
      <pubDate>Fri, 05 Apr 2024 08:40:29 GMT</pubDate>
      
      <description>redis入门</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://www.redis.net.cn/">Redis</a>是一个基于<strong>内存</strong>的<u>key-value</u>结构NoSql数据库。相比于常规的数据库，Redis</p><ul><li>基于内存存储，读写性能高</li><li>适合存储热点数据（热点商品、资讯、新闻）和在短时间内有大量访问的数据</li><li>应用广泛</li></ul><h2 id="Redis启动"><a href="#Redis启动" class="headerlink" title="Redis启动"></a>Redis启动</h2><p>安装好Redis并配置好环境变量之后，在cmd中使用<code>redis-server</code>启动redis，Redis服务默认端口号为6379。</p><p>使用命令<code>redis-cli</code>连接客户端，默认连接的是本地的redis服务，并且使用默认6379端口。也可以通过指定如下参数连接：-h ip地址-p 端口号 -a 密码（如果有）</p><p>也可以使用<a href="https://github.com/qishibo/AnotherRedisDesktopManager">Another-Redis-Desktop-Manager</a>图形化工具连接和管理Redis</p><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串(string)：普通字符串，Redis中最简单的数据类型</li><li>哈希(hash)：类似于Java中的HashMap结构</li><li>列表(list)：按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList</li><li>集合(set)：无序集合，没有重复元素，类似于Java中的HashSet</li><li>有序集合(zset)：集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素</li></ul><h2 id="Redis操作命令"><a href="#Redis操作命令" class="headerlink" title="Redis操作命令"></a>Redis操作命令</h2><h3 id="字符串操作命令"><a href="#字符串操作命令" class="headerlink" title="字符串操作命令"></a>字符串操作命令</h3><ul><li><code>SET key value</code>：设置指定key的值</li><li><code>GET key</code>：获取指定key的值</li><li><code>SETEX key seconds value</code>：设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><code>SETNX key value</code>：只有在 key 不存在时设置 key 的值</li></ul><h3 id="哈希操作命令"><a href="#哈希操作命令" class="headerlink" title="哈希操作命令"></a>哈希操作命令</h3><ul><li><code>HSET key field value</code>：将哈希表 key 中的字段 field 的值设为 value</li><li><code>HGET key field</code>：获取存储在哈希表中指定字段的值</li><li><code>HDEL key field</code>：删除存储在哈希表中的指定字段</li><li><code>HKEYS key</code>：获取哈希表中所有字段</li><li><code>HVALS key</code>：获取哈希表中所有值</li></ul><h3 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h3><ul><li><code>LPUSH key value1 [value2]</code>：将一个或多个值插入到列表头部(左边)</li><li><code>LRANGE key start stop</code>：获取列表指定范围内的元素</li><li><code>RPOP key</code>：移除并获取列表最后一个元素(右边)</li><li><code>LLEN key</code>：获取列表长度</li></ul><h3 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h3><ul><li><code>SADD key member1 [member2]</code>：向集合添加一个或多个成员</li><li><code>SMEMBERS key</code>：返回集合中的所有成员</li><li><code>SCARD key</code>：获取集合的成员数</li><li><code>SINTER key1 [key2]</code>：返回给定所有集合的交集</li><li><code>SUNION key1 [key2]</code>：返回所有给定集合的并集</li><li><code>SREM key member1 [member2]</code>：删除集合中一个或多个成员</li></ul><h3 id="有序集合操作命令"><a href="#有序集合操作命令" class="headerlink" title="有序集合操作命令"></a>有序集合操作命令</h3><ul><li><code>ZADD key score1 member1 [score2 member2]</code>：向有序集合添加一个或多个成员</li><li><code>ZRANGE key start stop [WITHSCORES]</code>：通过索引区间返回有序集合中指定区间内的成员</li><li><code>ZINCRBY key increment member</code>：有序集合中对指定成员的分数加上增量increment</li><li><code>ZREM key member [member ...]</code>：移除有序集合中的一个或多个成员</li></ul><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li><code>KEYS pattern</code>：查找所有符合给定模式(pattern)的key </li><li><code>EXISTS key</code>：检查给定key是否存在</li><li><code>TYPE key</code>：返回key所储存的值的类型</li><li><code>DEL key</code>：该命令用于在key存在时删除 key</li></ul><h2 id="在Java中操作Redis"><a href="#在Java中操作Redis" class="headerlink" title="在Java中操作Redis"></a>在Java中操作Redis</h2><p>Redis的Java客户端很多，常用的有：<u>Jedis</u>、<u>Lettuce</u>、<u><strong>Spring Data Redis</strong></u></p><p>其中Spring Data Redis是Spring的一部分，对Redis底层开发包进行了高度封装。在Spring项目中，可以使用Spring Data Redis来简化操作。</p><h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><ol><li>导入Spring Data Redis的maven坐标</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置Redis数据源</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;lty.redis.host&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;lty.redis.port&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;lty.redis.database&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>编写配置类，创建RedisTemplate对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer将key序列化，避免乱码</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>通过RedisTemplate对象操作Redis</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishService dishService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;DishVO&gt;&gt; <span class="title function_">test</span><span class="params">(Long categoryId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + categoryId;</span><br><span class="line">        List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(list != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// redis中存在数据，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> Result.success(list);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 否则从数据库中查数据</span></span><br><span class="line">        <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dish</span>();</span><br><span class="line">        dish.setCategoryId(categoryId);</span><br><span class="line">        dish.setStatus(StatusConstant.ENABLE);</span><br><span class="line">        list = dishService.listWithFlavor(dish);</span><br><span class="line">        <span class="comment">// 查出来的数据加入到redis中</span></span><br><span class="line">        redisTemplate.opsForValue().set(key, list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Data-Redis使用方式"><a href="#Spring-Data-Redis使用方式" class="headerlink" title="Spring Data Redis使用方式"></a>Spring Data Redis使用方式</h2><p>RedisTemplate针对大量api进行了归类封装,将同一数据类型的操作封装为对应的Operation接口，具体分类如下：</p><ul><li>ValueOperations：string类型数据操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：hash类型的数据操作</li><li>ListOperations：list类型的数据操作</li></ul><h3 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h3><p><code>set void set(K key, V value)</code>：添加获取数据</p><p><code>set void set(K key, V value, long timeout, TimeUnit unit)</code>：设置数据有效期</p><blockquote><p>TimeUnit.DAYS          &#x2F;&#x2F;天<br>TimeUnit.HOURS         &#x2F;&#x2F;小时<br>TimeUnit.MINUTES       &#x2F;&#x2F;分钟<br>TimeUnit.SECONDS       &#x2F;&#x2F;秒<br>TimeUnit.MILLISECONDS  &#x2F;&#x2F;毫秒</p></blockquote><p><code>set void set(K key, V value, long offset)</code>:根据key设置value指定下标字符</p><p><code>get V get(Object key)</code>:Get操作</p><p><code>getAndSet V getAndSet(K key, V value)</code>:设置键的字符串值并返回其旧值</p><p><code>append Integer append(K key, String value)</code>:根据key拼接value的值，如果被拼接的key没值则为空字符串</p><p><code>size Long size(K key)</code>:根据key获取value的长度</p><h3 id="List操作"><a href="#List操作" class="headerlink" title="List操作"></a>List操作</h3><p><code>Long size(K key)</code>:返回存储在键中的列表的长度。如果键不存在，则将其解释为空列表，并返回0。当key存储的值不是列表时返回错误。</p><p><code>Long leftPush(K key, V value)</code>:（从左边插入）将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。</p><p><code>Long leftPushAll(K key, V... values)</code>:（从左边插入）批量把一个数组插入到列表中</p><p><code>Long rightPush(K key, V value)</code>:（从右边插入）将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。（从右边插入）</p><p><code>Long rightPushAll(K key, V... values)</code>:（从右边插入）批量把一个数组插入到列表中</p><p><code>void set(K key, long index, V value)</code>:在列表中index的位置设置value值</p><p><code>Long remove(K key, long count, Object value)</code>:从存储在键中的列表中删除等于值的元素的第一个计数事件。</p><blockquote><p>计数参数以下列方式影响操作：<br>count&gt; 0：删除等于从头到尾移动的值的元素。<br>count &lt;0：删除等于从尾到头移动的值的元素。<br>count &#x3D; 0：删除等于value的所有元素。 </p></blockquote><p><code>V index(K key, long index)</code>:根据下标获取列表中的值，下标是从0开始的，-1为获取全部</p><p><code>V leftPop(K key)</code>:弹出最左边的元素</p><p><code>V rightPop(K key)</code>:弹出最右边的元素</p><h3 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h3><p><code>Long delete(H key, Object... hashKeys)</code>:删除给定的哈希hashKeys</p><p><code>Boolean hasKey(H key, Object hashKey)</code>:判断哈希hashKey是否存在</p><p><code>HV get(H key, Object hashKey)</code>:从键中的哈希获取给定hashKey的值</p><p><code>Set keys(H key)</code>:获取key所对应的散列表的key</p><p><code>Long size(H key)</code>:获取key所对应的散列表的大小个数</p><p><code>void putAll(H key, Map&lt;? extends HK, ? extends HV&gt; m)</code>:使用m中提供的多个散列字段设置到key对应的散列表中</p><p><code>void put(H key, HK hashKey, HV value)</code>:设置散列hashKey的值</p><p><code>List values(H key)</code>:获取整个哈希存储的值根据密钥</p><p><code>Map&lt;HK, HV&gt; entries(H key)</code>:获取整个哈希存储根据密钥</p><p><code>Cursor&lt;Map.Entry&lt;HK, HV&gt;&gt; scan(H key, ScanOptions options)</code>:使用Cursor在key的hash中迭代，相当于迭代器。</p><h3 id="Set操作"><a href="#Set操作" class="headerlink" title="Set操作"></a>Set操作</h3><p><code>Long add(K key, V... values)</code>:无序集合中添加元素，返回添加个数也可以直接在add里面添加多个值 如：template.opsForSet().add(“setTest”,”aaa”,”bbb”)</p><p><code>Long remove(K key, Object... values)</code>:移除集合中一个或多个成员</p><p><code>V pop(K key)</code>:移除并返回集合中的一个随机元素</p><p><code>Boolean move(K key, V value, K destKey)</code>:将 member 元素从 source 集合移动到 destination 集合</p><p><code>Long size(K key)</code>:无序集合的大小长度</p><p><code>et members(K key)</code>:返回集合中的所有成员</p><p><code>Cursor scan(K key, ScanOptions options)</code>:遍历set</p><h3 id="ZSet操作"><a href="#ZSet操作" class="headerlink" title="ZSet操作"></a>ZSet操作</h3><p><code>Boolean add(K key, V value, double score)</code>:新增一个有序集合，存在的话为false，不存在的话为true</p><p><code>Long add(K key, Set&lt;TypedTuple&gt; tuples)</code>:新增一个有序集合</p><p><code>Long remove(K key, Object... values)</code>:从有序集合中移除一个或者多个元素</p><p><code>Long rank(K key, Object o)</code>:返回有序集中指定成员的排名，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Set range(K key, long start, long end)</code>:通过索引区间返回有序集合成指定区间内的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Long count(K key, double min, double max)</code>:通过分数返回有序集合指定区间内的成员个数</p><p><code>Long size(K key)</code>:获取有序集合的成员数，内部调用的就是zCard方法</p><p><code>Double score(K key, Object o)</code>:获取指定成员的score值</p><p><code>Long removeRange(K key, long start, long end)</code>:移除指定索引位置的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Cursor&lt;TypedTuple&gt; scan(K key, ScanOptions options)</code>:遍历zset</p><h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>Spring Cache 是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。</p><p>它提供了一层抽象，底层可以切换不同的缓存实现，例如：</p><ul><li>EHCache</li><li>Caffeine</li><li>Redis</li></ul><p>需要引入Maven坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@EnableCaching</td><td align="center">开启缓存注解功能，通常加在启动类上</td></tr><tr><td align="center">@Cacheable(cacheNames&#x3D;”数据库名”,key&#x3D;”存储的键”)</td><td align="center">在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td align="center">@CachePut</td><td align="center">将方法的返回值放到缓存中</td></tr><tr><td align="center">@CacheEvict(cacheNames &#x3D; “数据库名”,[allEntries(是否全部删除) &#x3D; true],key &#x3D; “要删除的键”)</td><td align="center">将一条或多条数据从缓存中删除</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/redis/">redis</category>
      
      
      <category domain="http://example.com/tags/redis/">redis</category>
      
      
      <comments>http://example.com/inori/8660e5c0.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MyBatis-Plus</title>
      <link>http://example.com/inori/1276cc28.html</link>
      <guid>http://example.com/inori/1276cc28.html</guid>
      <pubDate>Wed, 27 Mar 2024 04:09:06 GMT</pubDate>
      
      <description>MyBatis</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://baomidou.com/">MyBatis-Plus</a>是<a href="https://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生</p><p>特性：</p><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><p>支持数据库：</p><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库，优炫数据库</li></ul><h2 id="MyBatis-Plus核心功能"><a href="#MyBatis-Plus核心功能" class="headerlink" title="MyBatis-Plus核心功能"></a>MyBatis-Plus核心功能</h2><h3 id="基于Mapper接口CRUD"><a href="#基于Mapper接口CRUD" class="headerlink" title="基于Mapper接口CRUD"></a>基于Mapper接口CRUD</h3><blockquote><p>通用 CRUD 封装BaseMapper接口，<code>Mybatis-Plus</code>启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器! 内部包含常见的单表操作！</p></blockquote><h4 id="Insert方法"><a href="#Insert方法" class="headerlink" title="Insert方法"></a>Insert方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="comment">// T 就是要插入的实体对象</span></span><br><span class="line"><span class="comment">// 默认主键生成策略为雪花算法（后面讲解）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>T</td><td>entity</td><td>实体对象</td></tr></tbody></table><h4 id="Delete方法"><a href="#Delete方法" class="headerlink" title="Delete方法"></a>Delete方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>Wrapper<T></td><td>wrapper</td><td>实体对象封装操作类（可以为 null）</td></tr><tr><td>Collection&lt;? extends Serializable&gt;</td><td>idList</td><td>主键 ID 列表(不能为 null 以及 empty)</td></tr><tr><td>Serializable</td><td>id</td><td>主键 ID</td></tr><tr><td>Map&lt;String, Object&gt;</td><td>columnMap</td><td>表字段 map 对象</td></tr></tbody></table><h4 id="Update方法"><a href="#Update方法" class="headerlink" title="Update方法"></a>Update方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, </span></span><br><span class="line"><span class="params"><span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 修改  主键属性必须值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>T</td><td>entity</td><td>实体对象 (set 条件值,可为 null)</td></tr><tr><td>Wrapper<T></td><td>updateWrapper</td><td>实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</td></tr></tbody></table><h4 id="Select方法"><a href="#Select方法" class="headerlink" title="Select方法"></a>Select方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><p>参数说明</p><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>Serializable</td><td>id</td><td>主键 ID</td></tr><tr><td>Wrapper<T></td><td>queryWrapper</td><td>实体对象封装操作类（可以为 null）</td></tr><tr><td>Collection&lt;? extends Serializable&gt;</td><td>idList</td><td>主键 ID 列表(不能为 null 以及 empty)</td></tr><tr><td>Map&lt;String, Object&gt;</td><td>columnMap</td><td>表字段 map 对象</td></tr><tr><td>IPage<T></td><td>page</td><td>分页查询条件（可以为 RowBounds.DEFAULT）</td></tr></tbody></table><h4 id="自定义和多表映射"><a href="#自定义和多表映射" class="headerlink" title="自定义和多表映射"></a>自定义和多表映射</h4><p>mybatis-plus的默认mapperxml位置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> <span class="comment"># mybatis-plus的配置</span></span><br><span class="line"><span class="comment"># 默认位置 private String[] mapperLocations = new String[]&#123;&quot;classpath*:/mapper/**/*.xml&quot;&#125;;    </span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>自定义mapper方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常自定义方法！</span></span><br><span class="line"><span class="comment">//可以使用注解@Select或者mapper.xml实现</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于mapper.xml实现：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace = 接口的全限定符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于Service接口CRUD"><a href="#基于Service接口CRUD" class="headerlink" title="基于Service接口CRUD"></a>基于Service接口CRUD</h3><p>通用 Service CRUD 封装<a href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java">IService (opens new window)</a>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</p><h4 id="对比Mapper接口CRUD区别："><a href="#对比Mapper接口CRUD区别：" class="headerlink" title="对比Mapper接口CRUD区别："></a>对比Mapper接口CRUD区别：</h4><ul><li>service添加了批量方法</li><li>service层的方法自动添加事务</li></ul><h4 id="使用Iservice接口方式"><a href="#使用Iservice接口方式" class="headerlink" title="使用Iservice接口方式"></a>使用Iservice接口方式</h4><p>接口继承IService接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类继承ServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CRUD方法介绍"><a href="#CRUD方法介绍" class="headerlink" title="CRUD方法介绍"></a>CRUD方法介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">保存：</span><br><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">修改或者保存：</span><br><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">移除：</span><br><span class="line"><span class="comment">// 根据 queryWrapper 设置的条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">更新：</span><br><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">数量： </span><br><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">查询：</span><br><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line">集合：</span><br><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分页查询实现"><a href="#分页查询实现" class="headerlink" title="分页查询实现"></a>分页查询实现</h3><ol><li>导入分页插件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用分页查询</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置分页参数</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//获取分页数据</span></span><br><span class="line">    List&lt;User&gt; list = page.getRecords();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页：&quot;</span>+page.getCurrent());</span><br><span class="line">    System.out.println(<span class="string">&quot;每页显示的条数：&quot;</span>+page.getSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span>+page.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span>+page.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有上一页：&quot;</span>+page.hasPrevious());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有下一页：&quot;</span>+page.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义的mapper方法使用分页</li></ol><p>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数携带Ipage接口</span></span><br><span class="line"><span class="comment">//返回结果为IPage</span></span><br><span class="line">IPage&lt;User&gt; <span class="title function_">selectPageVo</span><span class="params">(IPage&lt;?&gt; page, Integer id)</span>;</span><br></pre></td></tr></table></figure><p>接口实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectPageVo&quot;</span> resultType=<span class="string">&quot;xxx.xxx.xxx.User&quot;</span>&gt;</span><br><span class="line">SELECT * FROM user WHERE id &gt; #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    userMapper.selectPageVo(page,<span class="number">2</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> page.getCurrent();</span><br><span class="line">    System.out.println(<span class="string">&quot;current = &quot;</span> + current);</span><br><span class="line">    <span class="type">long</span> <span class="variable">pages</span> <span class="operator">=</span> page.getPages();</span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + pages);</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();</span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + total);</span><br><span class="line">    <span class="type">List</span> <span class="variable">records</span> <span class="operator">=</span> page.getRecords();</span><br><span class="line">    System.out.println(<span class="string">&quot;records = &quot;</span> + records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件构造器使用"><a href="#条件构造器使用" class="headerlink" title="条件构造器使用"></a>条件构造器使用</h3><h4 id="条件构造器作用"><a href="#条件构造器作用" class="headerlink" title="条件构造器作用"></a>条件构造器作用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>); <span class="comment">// 添加等于条件</span></span><br><span class="line">queryWrapper.ne(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>); <span class="comment">// 添加不等于条件</span></span><br><span class="line">queryWrapper.like(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;@gmail.com&quot;</span>); <span class="comment">// 添加模糊匹配条件</span></span><br><span class="line">等同于： </span><br><span class="line">delete from user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;John&quot;</span> and age != <span class="number">30</span></span><br><span class="line">and email like <span class="string">&quot;%@gmail.com%&quot;</span></span><br><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure><p>使用MyBatis-Plus的条件构造器，你可以构建灵活、高效的查询条件，而不需要手动编写复杂的 SQL 语句。它提供了许多方法来支持各种条件操作符，并且可以通过链式调用来组合多个条件。这样可以简化查询的编写过程，并提高开发效率。</p><h4 id="条件构造器继承结构"><a href="#条件构造器继承结构" class="headerlink" title="条件构造器继承结构"></a>条件构造器继承结构</h4><p>Wrapper：条件构造抽象类，最顶端父类</p><ul><li>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件</li><li>QueryWrapper ： 查询&#x2F;删除条件封装</li><li>UpdateWrapper ： 修改条件封装</li><li>AbstractLambdaWrapper ： 使用Lambda 语法</li><li>LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper</li><li>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</li></ul><h4 id="基于QueryWrapper-组装条件"><a href="#基于QueryWrapper-组装条件" class="headerlink" title="基于QueryWrapper 组装条件"></a>基于QueryWrapper 组装条件</h4><p>组装查询条件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息</span></span><br><span class="line"><span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    .between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">    .isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装排序条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//按年龄降序查询用户，如果年龄相同则按id升序排列</span></span><br><span class="line"><span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">    .orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    .orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装删除条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//删除email为空的用户</span></span><br><span class="line"><span class="comment">//DELETE FROM t_user WHERE (email IS NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="comment">//条件构造器也可以构建删除语句的条件</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and和or关键字使用(修改)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改</span></span><br><span class="line"><span class="comment">//UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL)</span></span><br><span class="line">    queryWrapper</span><br><span class="line">    .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    .gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    .or()</span><br><span class="line">    .isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定列映射查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//查询用户信息的username和age字段</span></span><br><span class="line"><span class="comment">//SELECT username,age FROM t_user</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="comment">//selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>condition判断组织条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//判断条件拼接</span></span><br><span class="line">    <span class="comment">//当name不为null拼接等于, age &gt; 1 拼接等于判断</span></span><br><span class="line">    <span class="comment">//方案1: 手动判断</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(name))&#123;</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方案2: 拼接condition判断</span></span><br><span class="line">    <span class="comment">//每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!</span></span><br><span class="line">    <span class="comment">//eq(condition,列名,值)</span></span><br><span class="line">    queryWrapper.eq(!StringUtils.isEmpty(name),<span class="string">&quot;name&quot;</span>,name)</span><br><span class="line">    .eq(age&gt;<span class="number">1</span>,<span class="string">&quot;age&quot;</span>,age);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于-UpdateWrapper组装条件"><a href="#基于-UpdateWrapper组装条件" class="headerlink" title="基于 UpdateWrapper组装条件"></a>基于 UpdateWrapper组装条件</h4><p>使用queryWrapper + 实体类形式可以实现修改，但是无法将列值修改为null值！</p><p>使用updateWrapper:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将id = 3 的email设置为null, age = 18</span></span><br><span class="line">updateWrapper.eq(<span class="string">&quot;id&quot;</span>,<span class="number">3</span>)</span><br><span class="line">.set(<span class="string">&quot;email&quot;</span>,<span class="literal">null</span>)  <span class="comment">// set 指定列和结果</span></span><br><span class="line">.set(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="comment">//如果使用updateWrapper 实体对象写null即可!</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用updateWrapper可以随意设置列的值！！</p><h4 id="基于LambdaQueryWrapper组装条件"><a href="#基于LambdaQueryWrapper组装条件" class="headerlink" title="基于LambdaQueryWrapper组装条件"></a>基于LambdaQueryWrapper组装条件</h4><ol><li><strong>LambdaQueryWrapper对比QueryWrapper优势</strong></li></ol><p>QueryWrapper 示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>)</span><br><span class="line">.ge(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">.orderByDesc(<span class="string">&quot;create_time&quot;</span>)</span><br><span class="line">.last(<span class="string">&quot;limit 10&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure><p>LambdaQueryWrapper 示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">lambdaQueryWrapper.eq(User::getName, <span class="string">&quot;John&quot;</span>)</span><br><span class="line">.ge(User::getAge, <span class="number">18</span>)</span><br><span class="line">.orderByDesc(User::getCreateTime)</span><br><span class="line">.last(<span class="string">&quot;limit 10&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(lambdaQueryWrapper);</span><br></pre></td></tr></table></figure><p>从上面的代码对比可以看出，相比于 QueryWrapper，LambdaQueryWrapper 使用了实体类的属性引用（例如 <code>User::getName</code>、<code>User::getAge</code>），而不是字符串来表示字段名，这提高了代码的可读性和可维护性。</p><ol start="2"><li><strong>lambda表达式</strong></li></ol><p>Lambda 表达式是 Java 8 引入的一种函数式编程特性，它提供了一种更简洁、更直观的方式来表示匿名函数或函数式接口的实现。Lambda 表达式可以用于简化代码，提高代码的可读性和可维护性。</p><p>Lambda 表达式的语法可以分为以下几个部分：</p><ul><li><strong>参数列表：</strong> 参数列表用小括号 <code>()</code> 括起来，可以指定零个或多个参数。如果没有参数，可以省略小括号；如果只有一个参数，可以省略小括号。</li></ul><p>示例：<code>(a, b)</code>, <code>x -&gt;</code>, <code>() -&gt;</code></p><ul><li><strong>箭头符号：</strong> 箭头符号 <code>-&gt;</code> 分割参数列表和 Lambda 表达式的主体部分。</li></ul><p>示例：<code>-&gt;</code></p><ul><li><strong>Lambda 表达式的主体：</strong> Lambda 表达式的主体部分可以是一个表达式或一个代码块。如果是一个表达式，可以省略 return 关键字；如果是多条语句的代码块，需要使用大括号 <code>&#123;&#125;</code> 括起来，并且需要明确指定 return 关键字。</li></ul><p>示例：</p><ul><li>单个表达式：<code>x -&gt; x * x</code></li><li>代码块：<code>(x, y) -&gt; &#123; int sum = x + y; return sum; &#125;</code></li></ul><p>Lambda 表达式的语法可以更具体地描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式实现一个接口的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始匿名内部类方式</span></span><br><span class="line"><span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a-&gt;System.out.println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lambda 表达式实现接口的方法</span></span><br><span class="line">greeting = () -&gt; System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out::println;</span><br><span class="line">() -&gt;  类.XXX(); -&gt; 类：：方法名</span><br><span class="line"><span class="comment">// 调用接口的方法</span></span><br><span class="line">greeting.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 方法引用:</strong></p><p>方法引用是 Java 8 中引入的一种语法特性，它提供了一种简洁的方式来直接引用已有的方法或构造函数。方法引用可以替代 Lambda 表达式，使代码更简洁、更易读。</p><p>Java 8 支持以下几种方法引用的形式：</p><ul><li><p><strong>静态方法引用：</strong> 引用静态方法，语法为 <code>类名::静态方法名</code>。</p></li><li><p><strong>实例方法引用：</strong> 引用实例方法，语法为 <code>实例对象::实例方法名</code>。</p></li><li><p><strong>对象方法引用：</strong> 引用特定对象的实例方法，语法为 <code>类名::实例方法名</code>。</p></li><li><p><strong>构造函数引用：</strong> 引用构造函数，语法为 <code>类名::new</code>。</p></li></ul><p>演示代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReferenceExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">        names.forEach(name -&gt; System.out.println(name));</span><br><span class="line">        <span class="comment">// 使用方法引用</span></span><br><span class="line">        names.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. lambdaQueryWrapper使用案例:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">int</span>    <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!</span></span><br><span class="line">    <span class="comment">//eq(condition,列名,值)</span></span><br><span class="line">    queryWrapper.eq(!StringUtils.isEmpty(name),<span class="string">&quot;name&quot;</span>,name)</span><br><span class="line">    .eq(age&gt;<span class="number">1</span>,<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 使用lambdaQueryWrapper</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//注意: 需要使用方法引用</span></span><br><span class="line">    <span class="comment">//技巧: 类名::方法名</span></span><br><span class="line">    lambdaQueryWrapper.eq(!StringUtils.isEmpty(name), User::getName,name);</span><br><span class="line">    List&lt;User&gt; users= userMapper.selectList(lambdaQueryWrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于LambdaUpdateWrapper组装条件"><a href="#基于LambdaUpdateWrapper组装条件" class="headerlink" title="基于LambdaUpdateWrapper组装条件"></a>基于LambdaUpdateWrapper组装条件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将id = 3 的email设置为null, age = 18</span></span><br><span class="line">updateWrapper.eq(<span class="string">&quot;id&quot;</span>,<span class="number">3</span>)</span><br><span class="line">.set(<span class="string">&quot;email&quot;</span>,<span class="literal">null</span>)  <span class="comment">// set 指定列和结果</span></span><br><span class="line">.set(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambdaUpdateWrapper</span></span><br><span class="line">LambdaUpdateWrapper&lt;User&gt; updateWrapper1 = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">updateWrapper1.eq(User::getId,<span class="number">3</span>)</span><br><span class="line">.set(User::getEmail,<span class="literal">null</span>)</span><br><span class="line">.set(User::getAge,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用updateWrapper 实体对象写null即可!</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心注解使用"><a href="#核心注解使用" class="headerlink" title="核心注解使用"></a>核心注解使用</h3><ol><li>理解和介绍</li></ol><p>MyBatis-Plus是一个基于MyBatis框架的增强工具，提供了一系列简化和增强的功能，用于加快开发人员在使用MyBatis进行数据库访问时的效率。</p><p>MyBatis-Plus提供了一种基于注解的方式来定义和映射数据库操作，其中的注解起到了重要作用。</p><p>理解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口对应的方法为什么会自动触发 user表的crud呢？</p><p>默认情况下， 根据指定的&lt;实体类&gt;的名称对应数据库表名，属性名对应数据库的列名！</p><p>但是不是所有数据库的信息和实体类都完全映射！</p><p>例如： 表名 t_user  → 实体类 User 这时候就不对应了！</p><p>自定义映射关系就可以使用mybatis-plus提供的注解即可！<br>2. @TableName注解</p><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span> <span class="comment">//对应数据库表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊情况：如果表名和实体类名相同（忽略大小写）可以省略该注解！</p><p>其他解决方案：<a href="https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">全局设置前缀</a></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> <span class="comment"># mybatis-plus的配置</span></span><br><span class="line"><span class="attr">global-config:</span></span><br><span class="line"><span class="attr">db-config:</span></span><br><span class="line"><span class="attr">table-prefix:</span> <span class="string">sys_</span> <span class="comment"># 表名前缀字符串</span></span><br></pre></td></tr></table></figure><ol start="3"><li>@TableId 注解</li></ol><ul><li>描述：主键注解</li><li>使用位置：实体类主键字段</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@TableId(value=&quot;主键列名&quot;,type=主键策略)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>类型</th><th>必须指定</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>主键字段名</td></tr><tr><td>type</td><td>Enum</td><td>否</td><td>IdType.NONE</td><td>指定主键类型</td></tr></tbody></table><p><a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/IdType.java">IdType</a>属性可选值：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>AUTO</td><td>数据库 ID 自增 (mysql配置主键自增长)</td></tr><tr><td>ASSIGN_ID（默认）</td><td>分配 ID(主键类型为 Number(Long )或 String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td></tr></tbody></table><p>全局配置修改主键策略:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">configuration:</span><br><span class="line"># 配置MyBatis日志</span><br><span class="line">log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">global-config:</span><br><span class="line">db-config:</span><br><span class="line"># 配置MyBatis-Plus操作表的默认前缀</span><br><span class="line">table-prefix: t_</span><br><span class="line"># 配置MyBatis-Plus的主键策略</span><br><span class="line">id-type: auto</span><br></pre></td></tr></table></figure><p>在以下场景下，添加<code>@TableId</code>注解是必要的：</p><ol><li>实体类的字段与数据库表的主键字段不同名：如果实体类中的字段与数据库表的主键字段不一致，需要使用<code>@TableId</code>注解来指定实体类中表示主键的字段。</li><li>主键生成策略不是默认策略：如果需要使用除了默认主键生成策略以外的策略，也需要添加<code>@TableId</code>注解，并通过<code>value</code>属性指定生成策略。</li><li>雪花算法使用场景</li></ol><p>雪花算法（Snowflake Algorithm）是一种用于生成唯一ID的算法。它由Twitter公司提出，用于解决分布式系统中生成全局唯一ID的需求。</p><p>在传统的自增ID生成方式中，使用单点数据库生成ID会成为系统的瓶颈，而雪花算法通过在分布式系统中生成唯一ID，避免了单点故障和性能瓶颈的问题。</p><p>雪花算法生成的ID是一个64位的整数，由以下几个部分组成：</p><ol><li>时间戳：41位，精确到毫秒级，可以使用69年。</li><li>节点ID：10位，用于标识分布式系统中的不同节点。</li><li>序列号：12位，表示在同一毫秒内生成的不同ID的序号。</li></ol><p>通过将这三个部分组合在一起，雪花算法可以在分布式系统中生成全局唯一的ID，并保证ID的生成顺序性。</p><p>雪花算法的工作方式如下：</p><ol><li>当前时间戳从某一固定的起始时间开始计算，可以用于计算ID的时间部分。</li><li>节点ID是分布式系统中每个节点的唯一标识，可以通过配置或自动分配的方式获得。</li><li>序列号用于记录在同一毫秒内生成的不同ID的序号，从0开始自增，最多支持4096个ID生成。</li></ol><p>需要注意的是，雪花算法依赖于系统的时钟，需要确保系统时钟的准确性和单调性，否则可能会导致生成的ID不唯一或不符合预期的顺序。</p><p>雪花算法是一种简单但有效的生成唯一ID的算法，广泛应用于分布式系统中，如微服务架构、分布式数据库、分布式锁等场景，以满足全局唯一标识的需求。</p><p>雪花算法生成的数字,需要使用Long 或者 String类型主键<br>5. @TableField</p><p>描述：字段注解（非主键）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@TableId</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="meta">@TableField(&quot;nickname&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MyBatis-Plus会自动开启驼峰命名风格映射</strong></p><h2 id="MyBatis-Plus高级扩展"><a href="#MyBatis-Plus高级扩展" class="headerlink" title="MyBatis-Plus高级扩展"></a>MyBatis-Plus高级扩展</h2><h3 id="逻辑删除实现"><a href="#逻辑删除实现" class="headerlink" title="逻辑删除实现"></a>逻辑删除实现</h3><p><strong>概念:</strong></p><p>逻辑删除，可以方便地实现对数据库记录的逻辑删除而不是物理删除。逻辑删除是指通过更改记录的状态或添加标记字段来模拟删除操作，从而保留了删除前的数据，便于后续的数据分析和恢复。</p><ul><li>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</li><li>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</li></ul><p><strong>逻辑删除实现:</strong></p><ol><li>数据库和实体类添加逻辑删除字段</li><li>表添加逻辑删除字段</li></ol><p>可以是一个布尔类型、整数类型或枚举类型。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> deleted <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> ;  # <span class="type">int</span> 类型 <span class="number">1</span> 逻辑删除 <span class="number">0</span> 未逻辑删除</span><br></pre></td></tr></table></figure><ol start="2"><li>实体类添加逻辑删除属性</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line">public class <span class="keyword">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="variable">@TableId</span></span><br><span class="line">private <span class="type">Integer</span> id;</span><br><span class="line">private String name;</span><br><span class="line">private <span class="type">Integer</span> age;</span><br><span class="line">private String email;</span><br><span class="line"></span><br><span class="line"><span class="variable">@TableLogic</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>逻辑删除字段 <span class="type">int</span> mybatis<span class="operator">-</span>plus下,默认 逻辑删除值为<span class="number">1</span> 未逻辑删除 <span class="number">1</span> </span><br><span class="line">private <span class="type">Integer</span> deleted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>指定逻辑删除字段和属性值</li><li>单一指定</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line">public class <span class="keyword">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="variable">@TableId</span></span><br><span class="line">private <span class="type">Integer</span> id;</span><br><span class="line">private String name;</span><br><span class="line">private <span class="type">Integer</span> age;</span><br><span class="line">private String email;</span><br><span class="line"><span class="variable">@TableLogic</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>逻辑删除字段 <span class="type">int</span> mybatis<span class="operator">-</span>plus下,默认 逻辑删除值为<span class="number">1</span> 未逻辑删除 <span class="number">1</span> </span><br><span class="line">private <span class="type">Integer</span> deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>全局指定</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"><span class="attr">global-config:</span></span><br><span class="line"><span class="attr">db-config:</span></span><br><span class="line"><span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line"><span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line"><span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><h4 id="悲观锁和乐观锁场景和介绍"><a href="#悲观锁和乐观锁场景和介绍" class="headerlink" title="悲观锁和乐观锁场景和介绍"></a>悲观锁和乐观锁场景和介绍</h4><p><strong>并发问题场景演示:</strong></p><p><img src="https://secure2.wostatic.cn/static/nWoVTstK7jnH8ida2Urujn/image.png?auth_key=1711513165-swYv5xUT1t4HAcN64ZBD7D-0-aa35481fb137c5a1fb50a1488ffff7bf"></p><p>​    </p><p>**解决思路: **</p><p>乐观锁和悲观锁是在并发编程中用于处理并发访问和资源竞争的两种不同的锁机制!!</p><p>悲观锁:<br>悲观锁的基本思想是，在整个数据访问过程中，将共享资源锁定，以确保其他线程或进程不能同时访问和修改该资源。悲观锁的核心思想是”先保护，再修改”。在悲观锁的应用中，线程在访问共享资源之前会获取到锁，并在整个操作过程中保持锁的状态，阻塞其他线程的访问。只有当前线程完成操作后，才会释放锁，让其他线程继续操作资源。这种锁机制可以确保资源独占性和数据的一致性，但是在高并发环境下，悲观锁的效率相对较低。</p><p>乐观锁:<br>乐观锁的基本思想是，认为并发冲突的概率较低，因此不需要提前加锁，而是在数据更新阶段进行冲突检测和处理。乐观锁的核心思想是”先修改，后校验”。在乐观锁的应用中，线程在读取共享资源时不会加锁，而是记录特定的版本信息。当线程准备更新资源时，会先检查该资源的版本信息是否与之前读取的版本信息一致，如果一致则执行更新操作，否则说明有其他线程修改了该资源，需要进行相应的冲突处理。乐观锁通过避免加锁操作，提高了系统的并发性能和吞吐量，但是在并发冲突较为频繁的情况下，乐观锁会导致较多的冲突处理和重试操作。</p><p>理解点: 悲观锁和乐观锁是两种解决并发数据问题的思路</p><p><strong>具体技术和方案:</strong></p><ol><li>乐观锁实现方案和技术：</li></ol><ul><li>版本号&#x2F;时间戳：为数据添加一个版本号或时间戳字段，每次更新数据时，比较当前版本号或时间戳与期望值是否一致，若一致则更新成功，否则表示数据已被修改，需要进行冲突处理。</li><li>CAS（Compare-and-Swap）：使用原子操作比较当前值与旧值是否一致，若一致则进行更新操作，否则重新尝试。</li><li>无锁数据结构：采用无锁数据结构，如无锁队列、无锁哈希表等，通过使用原子操作实现并发安全。</li></ul><ol start="2"><li>悲观锁实现方案和技术：</li></ol><ul><li>锁机制：使用传统的锁机制，如互斥锁（Mutex Lock）或读写锁（Read-Write Lock）来保证对共享资源的独占访问。</li><li>数据库锁：在数据库层面使用行级锁或表级锁来控制并发访问。</li><li>信号量（Semaphore）：使用信号量来限制对资源的并发访问。</li></ul><p><strong>介绍版本号乐观锁技术的实现流程:</strong></p><ul><li>每条数据添加一个版本号字段version</li><li>取出记录时，获取当前 version</li><li>更新时，检查获取版本号是不是数据库当前最新版本号</li><li>如果是[证明没有人修改数据], 执行更新, set 数据更新 , version &#x3D; version+ 1 </li><li>如果 version 不对[证明有人已经修改了]，我们现在的其他记录就是失效数据!就更新失败</li></ul><h4 id="使用mybatis-plus数据使用乐观锁"><a href="#使用mybatis-plus数据使用乐观锁" class="headerlink" title="使用mybatis-plus数据使用乐观锁"></a>使用mybatis-plus数据使用乐观锁</h4><ol><li>添加版本号更新插件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乐观锁字段添加@Version注解</p><p>注意: 数据库也需要添加version字段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER ADD VERSION INT DEFAULT <span class="number">1</span> ;  # <span class="type">int</span> 类型 乐观锁字段</span><br></pre></td></tr></table></figure><ul><li>支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime</li><li>仅支持 <code>updateById(id)</code> 与 <code>update(entity, wrapper)</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure><ol start="2"><li>正常更新使用即可</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示乐观锁生效场景</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//步骤1: 先查询,在更新 获取version数据</span></span><br><span class="line">    <span class="comment">//同时查询两条,但是version唯一,最后更新的失败</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span>  <span class="operator">=</span> userMapper.selectById(<span class="number">5</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span>  <span class="operator">=</span> userMapper.selectById(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user1.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">    <span class="comment">//乐观锁生效,失败!</span></span><br><span class="line">    userMapper.updateById(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防全表更新和删除实现"><a href="#防全表更新和删除实现" class="headerlink" title="防全表更新和删除实现"></a>防全表更新和删除实现</h3><p>针对 update 和 delete 语句 作用: 阻止恶意的全表更新删除</p><p>添加防止全表更新和删除拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试全部更新或者删除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick8</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;custom_name&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;xxx@mail.com&quot;</span>);</span><br><span class="line">    <span class="comment">//Caused by: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: Prohibition of table update operation</span></span><br><span class="line">    <span class="comment">//全局更新,报错</span></span><br><span class="line">    userService.saveOrUpdate(user,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向工程和MybatisX插件"><a href="#逆向工程和MybatisX插件" class="headerlink" title="逆向工程和MybatisX插件"></a>逆向工程和MybatisX插件</h2><h3 id="ORM思维介绍"><a href="#ORM思维介绍" class="headerlink" title="ORM思维介绍"></a>ORM思维介绍</h3><p>ORM（Object-Relational Mapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作!!</p><p>最终<strong>可以使用面向对象思维进行数据库操作</strong></p><p><strong>ORM 框架通常有半自动和全自动两种方式</strong></p><ul><li>半自动 ORM 通常需要程序员手动编写 SQL 语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。</li><li>全自动 ORM 则是将实体类和数据表进行自动映射，使用 API 进行数据库操作时，ORM 框架会自动执行 SQL 语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL 语句和转换代码。</li></ul><p><strong>半自动和全自动 ORM 框架的区别：</strong></p><ol><li>映射方式：半自动 ORM 框架需要程序员手动指定实体类和数据表之间的映射关系，通常使用 XML 文件或注解方式来指定；全自动 ORM 框架则可以自动进行实体类和数据表的映射，无需手动干预。</li><li>查询方式：半自动 ORM 框架通常需要程序员手动编写 SQL 语句并将查询结果集转换成实体对象；全自动 ORM 框架可以自动组装 SQL 语句、执行查询操作，并将查询结果转换成实体对象。</li><li>性能：由于半自动 ORM 框架需要手动编写 SQL 语句，因此程序员必须对 SQL 语句和数据库的底层知识有一定的了解，才能编写高效的 SQL 语句；而全自动 ORM 框架通过自动优化生成的 SQL 语句来提高性能，程序员无需进行优化。</li><li>学习成本：半自动 ORM 框架需要程序员手动编写 SQL 语句和映射配置，要求程序员具备较高的数据库和 SQL 知识；全自动 ORM 框架可以自动生成 SQL 语句和映射配置，程序员无需了解过多的数据库和 SQL 知识。</li></ol><p>常见的半自动 ORM 框架包括 MyBatis 等；常见的全自动 ORM 框架包括 Hibernate、Spring Data JPA、MyBatis-Plus 等。</p><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>MyBatis 的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml 文件、Mapper 接口等代码文件，简化了开发者手动生成的过程。逆向工程使开发者可以快速地构建起 DAO 层，并快速上手进行业务开发。<br>MyBatis 的逆向工程有两种方式：通过 MyBatis Generator 插件实现和通过 Maven 插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接 URL、用户名、密码、要生成的表名、生成的文件路径等等。<br>总的来说，逆向工程为程序员提供了一种方便快捷的方式，能够快速地生成持久层代码和映射文件，是半自动 ORM 思维像全自动发展的过程，提高程序员的开发效率。</p><p>逆向工程只能生成单表crud的操作，多表查询依然需要自己编写！</p><h3 id="逆向工程插件MyBatisX使用"><a href="#逆向工程插件MyBatisX使用" class="headerlink" title="逆向工程插件MyBatisX使用"></a>逆向工程插件MyBatisX使用</h3><p>MyBatisX 是一个 MyBatis 的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo 类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤：</p><ol><li>安装插件：</li></ol><p>在 IntelliJ IDEA 中打开插件市场，搜索 MyBatisX 并安装。<br>2. 使用 IntelliJ IDEA连接数据库</p><ul><li><p>连接数据库</p></li><li><p>逆向工程使用</p></li></ul><p><img src="https://secure2.wostatic.cn/static/s6LMYQtxCLAQ86ScJS5Kam/image.png?auth_key=1711513456-irs5D2suoMaDcbvLMLPAvw-0-6770defa442ddcfaf7713d246a720652"></p><p>逆向工程案例使用,自动生成单表的crud方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> 针对表【user】的数据库操作Mapper</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertSelective</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">User <span class="title function_">selectByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateByPrimaryKeySelective</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/1276cc28.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringBoot3框架入门</title>
      <link>http://example.com/inori/21ae6bf2.html</link>
      <guid>http://example.com/inori/21ae6bf2.html</guid>
      <pubDate>Wed, 27 Mar 2024 03:52:46 GMT</pubDate>
      
      <description>SpringBoot</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="SpringBoot3介绍"><a href="#SpringBoot3介绍" class="headerlink" title="SpringBoot3介绍"></a>SpringBoot3介绍</h2><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.introducing-spring-boot">SpringBoot</a>帮我们简单、快速地创建一个独立的、生产级别的 <strong>Spring应用（说明：SpringBoot底层是Spring）</strong>，大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术</p><p>SpringBoot的主要目标是：</p><ul><li>为所有 Spring 开发提供更快速、可广泛访问的入门体验。</li><li>开箱即用，设置合理的默认值，但是也可以根据需求进行适当的调整。</li><li>提供一系列大型项目通用的非功能性程序（如嵌入式服务器、安全性、指标、运行检查等）。</li><li>约定大于配置，基本不需要主动编写配置类、也不需要 XML 配置文件。</li></ul><p><strong>总结：简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。</strong></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><blockquote><p>场景：浏览器发送**&#x2F;hello**请求，返回”<strong>Hello,Spring Boot 3!</strong>“</p></blockquote><ol><li><p>开发步骤</p><ol><li><strong>创建Maven工程</strong></li><li><strong>添加依赖(springboot父工程依赖 , web启动器依赖)</strong></li><li><strong>编写启动引导类(springboot项目运行的入口)</strong></li><li><strong>编写处理器Controller</strong></li><li><strong>启动项目</strong></li></ol></li><li><p>创建项目</p></li><li><p>添加依赖</p></li></ol><ul><li>添加父工程坐标</li></ul><p>SpringBoot可以帮我们方便的管理项目依赖 , 在Spring Boot提供了一个名为<strong>spring-boot-starter-parent</strong>的工程，里面已经对各种常用依赖的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标(不需要添加版本)即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--所有springboot项目都必须继承自 spring-boot-starter-parent--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>添加web启动器</li></ul><p>为了让Spring Boot帮我们完成各种自动配置，我们必须引入Spring Boot提供的<strong>自动配置依赖</strong>，我们称为<strong>启动器</strong>。因为我们是web项目，这里我们引入web启动器，在 pom.xml 文件中加入如下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--web开发的场景启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>创建package和启动类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@SpringBootApplication</span>是一个特殊的注解，用于标识一个Spring Boot应用程序的入口类。它的主要作用是将三个常用注解组合在一起，简化了配置的过程。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 具体而言，<span class="doctag">@SpringBootApplication</span>注解包含以下三个注解的功能：</span></span><br><span class="line"><span class="comment">*     <span class="doctag">@Configuration</span>：将该类标识为应用程序的配置类。它允许使用Java代码定义和配置Bean。</span></span><br><span class="line"><span class="comment">*     <span class="doctag">@EnableAutoConfiguration</span>：启用Spring Boot的自动配置机制。它根据项目的依赖项自动配置Spring应用程序的行为。自动配置根据类路径、注解和配置属性等条件来决定要使用的功能和配置。</span></span><br><span class="line"><span class="comment">*     <span class="doctag">@ComponentScan</span>：自动扫描并加载应用程序中的组件，如控制器、服务、存储库等。它默认扫描<span class="doctag">@SpringBootApplication</span>注解所在类的包及其子包中的组件。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 使用<span class="doctag">@SpringBootApplication</span>注解，可以将上述三个注解的功能集中在一个注解上，简化了配置文件的编写和组件的加载和扫描过程。它是Spring Boot应用程序的入口点，标识了应用程序的主类，</span></span><br><span class="line"><span class="comment">* 并告诉Spring Boot在启动时应如何配置和加载应用程序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SpringApplication.run() 方法是启动 Spring Boot 应用程序的关键步骤。它创建应用程序上下文、</span></span><br><span class="line"><span class="comment">// 自动配置应用程序、启动应用程序，并处理命令行参数，使应用程序能够运行和提供所需的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(MainApplication.class,args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>编写处理器Controller</p><p>IoC和DI注解需要在启动类的同包或者子包下方可生效！无需指定，约束俗称。</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot 3!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>为什么依赖不需要写版本？</li></ol><ul><li>每个boot项目都有一个父项目<code>spring-boot-starter-parent</code></li><li>parent的父项目是<code>spring-boot-dependencies</code></li><li>父项目 <strong>版本仲裁中心</strong>，把所有常见的jar的依赖版本都声明好了。</li></ul><ol start="2"><li>启动器(Starter)</li></ol><p>Spring Boot提供了一种叫做Starter的概念，它是一组预定义的依赖项集合，旨在简化Spring应用程序的配置和构建过程。Starter包含了一组相关的依赖项，以便在启动应用程序时自动引入所需的库、配置和功能。</p><p>主要作用如下：</p><ol><li>简化依赖管理：Spring Boot Starter通过捆绑和管理一组相关的依赖项，减少了手动解析和配置依赖项的工作。只需引入一个相关的Starter依赖，即可获取应用程序所需的全部依赖。</li><li>自动配置：Spring Boot Starter在应用程序启动时自动配置所需的组件和功能。通过根据类路径和其他设置的自动检测，Starter可以自动配置Spring Bean、数据源、消息传递等常见组件，从而使应用程序的配置变得简单和维护成本降低。</li><li>提供约定优于配置：Spring Boot Starter遵循“约定优于配置”的原则，通过提供一组默认设置和约定，减少了手动配置的需要。它定义了标准的配置文件命名约定、默认属性值、日志配置等，使得开发者可以更专注于业务逻辑而不是繁琐的配置细节。</li><li>快速启动和开发应用程序：Spring Boot Starter使得从零开始构建一个完整的Spring Boot应用程序变得容易。它提供了主要领域（如Web开发、数据访问、安全性、消息传递等）的Starter，帮助开发者快速搭建一个具备特定功能的应用程序原型。</li><li>模块化和可扩展性：Spring Boot Starter的组织结构使得应用程序的不同模块可以进行分离和解耦。每个模块可以有自己的Starter和依赖项，使得应用程序的不同部分可以按需进行开发和扩展。</li></ol><p>Spring Boot提供了许多预定义的Starter，例如spring-boot-starter-web用于构建Web应用程序，spring-boot-starter-data-jpa用于使用JPA进行数据库访问，spring-boot-starter-security用于安全认证和授权等等。</p><p>使用Starter非常简单，只需要在项目的构建文件（例如Maven的pom.xml）中添加所需的Starter依赖，Spring Boot会自动处理依赖管理和配置。</p><p>通过使用Starter，开发人员可以方便地引入和配置应用程序所需的功能，避免了手动添加大量的依赖项和编写冗长的配置文件的繁琐过程。同时，Starter也提供了一致的依赖项版本管理，确保依赖项之间的兼容性和稳定性。</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">spring boot提供的全部启动器</a></p><p>命名规范：</p><ul><li>官方提供的场景：命名为：<code>spring-boot-starter-*</code></li><li>第三方提供场景：命名为：<code>*-spring-boot-starter</code></li></ul><ol start="3"><li>@SpringBootApplication注解的功效？</li></ol><p>@SpringBootApplication添加到启动类上，是一个组合注解，他的功效有具体的子注解实现！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;&#125;</span><br></pre></td></tr></table></figure><p>@SpringBootApplication注解是Spring Boot框架中的核心注解，它的主要作用是简化和加速Spring Boot应用程序的配置和启动过程。</p><p>具体而言，@SpringBootApplication注解起到以下几个主要作用：</p><ol><li>自动配置：@SpringBootApplication注解包含了@EnableAutoConfiguration注解，用于启用Spring Boot的自动配置机制。自动配置会根据应用程序的依赖项和类路径，自动配置各种常见的Spring配置和功能，减少开发者的手动配置工作。它通过智能地分析类路径、加载配置和条件判断，为应用程序提供适当的默认配置。</li><li>组件扫描：@SpringBootApplication注解包含了@ComponentScan注解，用于自动扫描并加载应用程序中的组件，例如控制器（Controllers）、服务（Services）、存储库（Repositories）等。它默认会扫描@SpringBootApplication注解所在类的包及其子包中的组件，并将它们纳入Spring Boot应用程序的上下文中，使它们可被自动注入和使用。</li><li>声明配置类：@SpringBootApplication注解本身就是一个组合注解，它包含了@Configuration注解，将被标注的类声明为配置类。配置类可以包含Spring框架相关的配置、Bean定义，以及其他的自定义配置。通过@SpringBootApplication注解，开发者可以将配置类与启动类合并在一起，使得配置和启动可以同时发生。</li></ol><p>总的来说，@SpringBootApplication注解的主要作用是简化Spring Boot应用程序的配置和启动过程。它自动配置应用程序、扫描并加载组件，并将配置和启动类合二为一，简化了开发者的工作量，提高了开发效率。</p><h2 id="SpringBoot3配置文件"><a href="#SpringBoot3配置文件" class="headerlink" title="SpringBoot3配置文件"></a>SpringBoot3配置文件</h2><h3 id="统一配置管理概述"><a href="#统一配置管理概述" class="headerlink" title="统一配置管理概述"></a>统一配置管理概述</h3><p>SpringBoot工程下，进行统一的配置管理，你想设置的任何参数（端口号、项目根路径、数据库连接信息等等)都集中到一个固定位置和命名的配置文件（<code>application.properties</code>或<code>application.yml</code>）中！</p><p>配置文件应该放置在Spring Boot工程的<code>src/main/resources</code>目录下。这是因为<code>src/main/resources</code>目录是Spring Boot默认的类路径（classpath），配置文件会被自动加载并可供应用程序访问。</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">功能配置参数说明</a></p><p>细节总结：</p><ul><li>集中式管理配置。统一在一个文件完成程序功能参数设置和自定义参数声明 。</li><li>位置：resources文件夹下，必须命名application  后缀 .properties &#x2F; .yaml &#x2F;  .yml 。</li><li>如果同时存在application.properties | application.yml(.yaml) , properties的优先级更高。</li><li>配置基本都有默认值。</li></ul><h3 id="属性配置文件使用"><a href="#属性配置文件使用" class="headerlink" title="属性配置文件使用"></a>属性配置文件使用</h3><ol><li>配置文件</li></ol><p>在 resource 文件夹下面新建 application.properties 配置文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># application.properties 为统一配置文件</span><br><span class="line"># 内部包含: 固定功能的key,自定义的key</span><br><span class="line"># 此处的配置信息,我们都可以在程序中@Value等注解读取</span><br><span class="line"></span><br><span class="line"># 固定的key</span><br><span class="line"># 启动端口号</span><br><span class="line">server.port=80 </span><br><span class="line"></span><br><span class="line"># 自定义</span><br><span class="line">spring.jdbc.datasource.driverClassName=com.mysql.cj.jdbc.driver</span><br><span class="line">spring.jdbc.datasource.url=jdbc:mysql:///springboot</span><br><span class="line">spring.jdbc.datasource.username=root</span><br><span class="line">spring.jdbc.datasource.password=root</span><br></pre></td></tr></table></figure><ol start="2"><li>读取配置文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.driverClassName&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.url&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.username&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;spring.jdbc.datasource.password&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试效果</li></ol><p>在controller注入，输出进行测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSourceProperties dataSourceProperties ;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(path = &quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(dataSourceProperties);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Hello Spring Boot ! &quot;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="YAML配置文件使用"><a href="#YAML配置文件使用" class="headerlink" title="YAML配置文件使用"></a>YAML配置文件使用</h3><ol><li>yaml格式介绍</li></ol><p>YAML（YAML Ain’t Markup Language）是一种基于层次结构的数据序列化格式，旨在提供一种易读、人类友好的数据表示方式。</p><p>与<code>.properties</code>文件相比，YAML格式有以下优势：</p><ul><li>层次结构：YAML文件使用缩进和冒号来表示层次结构，使得数据之间的关系更加清晰和直观。这样可以更容易理解和维护复杂的配置，特别适用于深层次嵌套的配置情况。</li><li>自我描述性：YAML文件具有自我描述性，字段和值之间使用冒号分隔，并使用缩进表示层级关系。这使得配置文件更易于阅读和理解，并且可以减少冗余的标点符号和引号。</li><li>注释支持：YAML格式支持注释，可以在配置文件中添加说明性的注释，使配置更具可读性和可维护性。相比之下，<code>.properties</code>文件不支持注释，无法提供类似的解释和说明。</li><li>多行文本：YAML格式支持多行文本的表示，可以更方便地表示长文本或数据块。相比之下，<code>.properties</code>文件需要使用转义符或将长文本拆分为多行。</li><li>类型支持：YAML格式天然支持复杂的数据类型，如列表、映射等。这使得在配置文件中表示嵌套结构或数据集合更加容易，而不需要进行额外的解析或转换。</li><li>更好的可读性：由于YAML格式的特点，它更容易被人类读懂和解释。它减少了配置文件中需要的特殊字符和语法，让配置更加清晰明了，从而减少了错误和歧义。</li></ul><p>综上所述，YAML格式相对于<code>.properties</code>文件具有更好的层次结构表示、自我描述性、注释支持、多行文本表示、复杂数据类型支持和更好的可读性。这些特点使YAML成为一种有力的配置文件格式，尤其适用于复杂的配置需求和人类可读的场景。然而，选择使用YAML还是<code>.properties</code>取决于实际需求和团队的偏好，简单的配置可以使用<code>.properties</code>，而复杂的配置可以选择YAML以获得更多的灵活性和可读性<br>2. yaml语法说明</p><ol><li>数据结构用树形结构呈现，通过缩进来表示层级，</li><li>连续的项目（集合）通过减号 ” - ” 来表示</li><li>键值结构里面的key&#x2F;value对用冒号 ” : ” 来分隔。</li><li>YAML配置文件的扩展名是yaml 或 yml</li><li>例如：</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># YAML配置文件示例</span></span><br><span class="line"><span class="attr">app_name:</span> <span class="string">我的应用程序</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">张三</span></span><br><span class="line"></span><br><span class="line"><span class="attr">database:</span></span><br><span class="line"><span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">5432</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">password123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">features:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">登录</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">注册</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">仪表盘</span></span><br><span class="line"></span><br><span class="line"><span class="attr">settings:</span></span><br><span class="line"><span class="attr">analytics:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">dark</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///springboot_02</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><ol start="4"><li>读取配置文件</li></ol><p>读取方式和properties一致</p><h3 id="批量配置文件注入"><a href="#批量配置文件注入" class="headerlink" title="批量配置文件注入"></a>批量配置文件注入</h3><blockquote><p> <strong>@ConfigurationProperties</strong>是SpringBoot提供的重要注解, 他可以将一些配置属性批量注入到bean对象。</p></blockquote><ol><li>创建类，添加属性和注解</li></ol><p>在类上通过@ConfigurationProperties注解声明该类要读取属性配置</p><p>prefix&#x3D;”spring.jdbc.datasource” 读取属性文件中前缀为spring.jdbc.datasource的值。前缀和属性名称和配置文件中的key必须要保持一致才可以注入成功</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.jdbc.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfigurationProperties</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String driverClassName;</span><br><span class="line"><span class="keyword">private</span> String url;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><ol start="2"><li>测试效果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSourceProperties dataSourceProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DataSourceConfigurationProperties dataSourceConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;dataSourceProperties = &quot;</span> + dataSourceProperties);</span><br><span class="line">    System.out.println(<span class="string">&quot;dataSourceConfigurationProperties = &quot;</span> + dataSourceConfigurationProperties);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello,Spring Boot 3!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多环境配置和使用"><a href="#多环境配置和使用" class="headerlink" title="多环境配置和使用"></a>多环境配置和使用</h3><ol><li>需求</li></ol><p>在Spring Boot中，可以使用多环境配置来根据不同的运行环境（如开发、测试、生产）加载不同的配置。SpringBoot支持多环境配置让应用程序在不同的环境中使用不同的配置参数，例如数据库连接信息、日志级别、缓存配置等。</p><p>以下是实现Spring Boot多环境配置的常见方法：</p><ol><li>属性文件分离：将应用程序的配置参数分离到不同的属性文件中，每个环境对应一个属性文件。例如，可以创建<code>application-dev.properties</code>、<code>application-prod.properties</code>和<code>application-test.properties</code>等文件。在这些文件中，可以定义各自环境的配置参数，如数据库连接信息、端口号等。然后，在<code>application.properties</code>中通过<code>spring.profiles.active</code>属性指定当前使用的环境。Spring Boot会根据该属性来加载对应环境的属性文件，覆盖默认的配置。</li><li>YAML配置文件：与属性文件类似，可以将配置参数分离到不同的YAML文件中，每个环境对应一个文件。例如，可以创建<code>application-dev.yml</code>、<code>application-prod.yml</code>和<code>application-test.yml</code>等文件。在这些文件中，可以使用YAML语法定义各自环境的配置参数。同样，通过<code>spring.profiles.active</code>属性指定当前的环境，Spring Boot会加载相应的YAML文件。</li><li>命令行参数(动态)：可以通过命令行参数来指定当前的环境。例如，可以使用<code>--spring.profiles.active=dev</code>来指定使用开发环境的配置。</li></ol><p>通过上述方法，Spring Boot会根据当前指定的环境来加载相应的配置文件或参数，从而实现多环境配置。这样可以简化在不同环境之间的配置切换，并且确保应用程序在不同环境中具有正确的配置。<br>2. 多环境配置（基于方式b实践）</p><blockquote><p>创建开发、测试、生产三个环境的配置文件</p></blockquote><p>application-dev.yml（开发）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///dev</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p>application-test.yml（测试）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///test</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><p>application-prod.yml（生产）</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">jdbc:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">driverClassName:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///prod</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure><ol start="3"><li>环境激活</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line"><span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><p><strong>注意 :</strong></p><p>如果设置了spring.profiles.active，并且和application有重叠属性，以active设置优先。</p><p>如果设置了spring.profiles.active，和application无重叠属性，application设置依然生效！</p><h2 id="SpringBoot3整合SpringMVC"><a href="#SpringBoot3整合SpringMVC" class="headerlink" title="SpringBoot3整合SpringMVC"></a>SpringBoot3整合SpringMVC</h2><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><ol><li>创建程序</li><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-starter-springmvc-03<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        web开发的场景启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建启动类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>创建实体类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username ;</span><br><span class="line">    <span class="keyword">private</span> String password ;</span><br><span class="line">    <span class="keyword">private</span> Integer age ;</span><br><span class="line">    <span class="keyword">private</span> String sex ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>编写Controller</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;杨过&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        user.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="web相关配置"><a href="#web相关配置" class="headerlink" title="web相关配置"></a>web相关配置</h3><p>位置：application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># web相关的配置</span></span><br><span class="line"><span class="comment"># https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment"># 端口号设置</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># 项目根路径</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/boot</span></span><br></pre></td></tr></table></figure><p>当涉及Spring Boot的Web应用程序配置时，以下是五个重要的配置参数：</p><ol><li><code>server.port</code>: 指定应用程序的HTTP服务器端口号。默认情况下，Spring Boot使用8080作为默认端口。您可以通过在配置文件中设置<code>server.port</code>来更改端口号。</li><li><code>server.servlet.context-path</code>: 设置应用程序的上下文路径。这是应用程序在URL中的基本路径。默认情况下，上下文路径为空。您可以通过在配置文件中设置<code>server.servlet.context-path</code>属性来指定自定义的上下文路径。</li><li><code>spring.mvc.view.prefix</code>和<code>spring.mvc.view.suffix</code>: 这两个属性用于配置视图解析器的前缀和后缀。视图解析器用于解析控制器返回的视图名称，并将其映射到实际的视图页面。<code>spring.mvc.view.prefix</code>定义视图的前缀，<code>spring.mvc.view.suffix</code>定义视图的后缀。</li><li><code>spring.resources.static-locations</code>: 配置静态资源的位置。静态资源可以是CSS、JavaScript、图像等。默认情况下，Spring Boot会将静态资源放在<code>classpath:/static</code>目录下。您可以通过在配置文件中设置<code>spring.resources.static-locations</code>属性来自定义静态资源的位置。</li><li><code>spring.http.encoding.charset</code>和<code>spring.http.encoding.enabled</code>: 这两个属性用于配置HTTP请求和响应的字符编码。<code>spring.http.encoding.charset</code>定义字符编码的名称（例如UTF-8），<code>spring.http.encoding.enabled</code>用于启用或禁用字符编码的自动配置。</li></ol><p>这些是在Spring Boot的配置文件中与Web应用程序相关的一些重要配置参数。根据您的需求，您可以在配置文件中设置这些参数来定制和配置您的Web应用程序</p><h3 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h3><blockquote><p>在WEB开发中我们需要引入一些静态资源 , 例如 : HTML , CSS , JS , 图片等 , 如果是普通的项目静态资源可以放在项目的webapp目录下。现在使用Spring Boot做开发 , 项目中没有webapp目录 , 我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？</p></blockquote><ol><li>默认路径</li></ol><p>在springboot中就定义了静态资源的默认查找路径：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.boot.autoconfigure.web;</span><br><span class="line"><span class="comment">//..................</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Resources</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;classpath:/META-INF/resources/&quot;</span>, <span class="string">&quot;classpath:/resources/&quot;</span>, <span class="string">&quot;classpath:/static/&quot;</span>, <span class="string">&quot;classpath:/public/&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">private</span> String[] staticLocations;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> addMappings;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> customized;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Chain chain;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Resources</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br><span class="line"><span class="built_in">this</span>.addMappings = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">this</span>.customized = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">this</span>.chain = <span class="keyword">new</span> <span class="title class_">Chain</span>();</span><br><span class="line"><span class="built_in">this</span>.cache = <span class="keyword">new</span> <span class="title class_">Cache</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...........        </span></span><br></pre></td></tr></table></figure><p><strong>默认的静态资源路径为：</strong></p><p><strong>· classpath:&#x2F;META-INF&#x2F;resources&#x2F;</strong></p><p><strong>· classpath:&#x2F;resources&#x2F;</strong></p><p><strong>· classpath:&#x2F;static&#x2F;</strong></p><p><strong>· classpath:&#x2F;public&#x2F;</strong></p><p>我们只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:&#x2F;static&#x2F; 目录下。在resources目录下创建index.html文件</p><ol start="2"><li>覆盖路径</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># web相关的配置</span></span><br><span class="line"><span class="comment"># https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment"># 端口号设置</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># 项目根路径</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/boot</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">web:</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="comment"># 配置静态资源地址,如果设置,会覆盖默认值</span></span><br><span class="line"><span class="attr">static-locations:</span> <span class="string">classpath:/webapp</span></span><br></pre></td></tr></table></figure><h3 id="自定义拦截器-SpringMVC配置"><a href="#自定义拦截器-SpringMVC配置" class="headerlink" title="自定义拦截器(SpringMVC配置)"></a>自定义拦截器(SpringMVC配置)</h3><ol><li>拦截器声明</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor拦截器的preHandle方法执行....&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor拦截器的postHandle方法执行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;MyInterceptor拦截器的afterCompletion方法执行....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>拦截器配置</li></ol><p>正常使用配置类，只要保证，<strong>配置类要在启动类的同包或者子包方可生效！</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MyInterceptor myInterceptor ;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* /**  拦截当前目录及子目录下的所有路径 /user/**   /user/findAll  /user/order/findAll</span></span><br><span class="line"><span class="comment">* /*   拦截当前目录下的以及子路径   /user/*     /user/findAll</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">registry.addInterceptor(myInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot3整合Druid数据源"><a href="#SpringBoot3整合Druid数据源" class="headerlink" title="SpringBoot3整合Druid数据源"></a>SpringBoot3整合Druid数据源</h2><ol><li>创建程序</li><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-starter-druid-04<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>17<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  web开发的场景启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 jdbctemplate 事务相关--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid启动器的依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 驱动类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>配置文件编写</li></ol><blockquote><p>添加druid连接池的基本配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="comment"># 连接池类型 </span></span><br><span class="line"><span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Druid的其他属性配置 springboot3整合情况下,数据库连接信息必须在Druid属性下!</span></span><br><span class="line"><span class="attr">druid:</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/day01</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"># 初始化时建立物理连接的个数</span></span><br><span class="line"><span class="attr">initial-size:</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># 连接池的最小空闲数量</span></span><br><span class="line"><span class="attr">min-idle:</span> <span class="number">5</span></span><br><span class="line"><span class="comment"># 连接池最大连接数量</span></span><br><span class="line"><span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line"><span class="comment"># 获取连接时最大等待时间，单位毫秒</span></span><br><span class="line"><span class="attr">max-wait:</span> <span class="number">60000</span></span><br><span class="line"><span class="comment"># 申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</span></span><br><span class="line"><span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 既作为检测的间隔时间又作为testWhileIdel执行的依据</span></span><br><span class="line"><span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span></span><br><span class="line"><span class="comment"># 销毁线程时检测当前连接的最后活动时间和当前时间差大于该值时，关闭当前连接(配置连接在池中的最小生存时间)</span></span><br><span class="line"><span class="attr">min-evictable-idle-time-millis:</span> <span class="number">30000</span></span><br><span class="line"><span class="comment"># 用来检测数据库连接是否有效的sql 必须是一个查询语句(oracle中为 select 1 from dual)</span></span><br><span class="line"><span class="attr">validation-query:</span> <span class="string">select</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 申请连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line"><span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 归还连接时会执行validationQuery检测连接是否有效,开启会降低性能,默认为true</span></span><br><span class="line"><span class="attr">test-on-return:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 是否缓存preparedStatement, 也就是PSCache,PSCache对支持游标的数据库性能提升巨大，比如说oracle,在mysql下建议关闭。</span></span><br><span class="line"><span class="attr">pool-prepared-statements:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</span></span><br><span class="line"><span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">-1</span></span><br><span class="line"><span class="comment"># 合并多个DruidDataSource的监控数据</span></span><br><span class="line"><span class="attr">use-global-data-source-stat:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">level:</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><ol start="5"><li>编写Controller</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getUser&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from users where id = ? ; &quot;</span>;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> jdbcTemplate.queryForObject(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class), <span class="number">1</span>);</span><br><span class="line">log.info(<span class="string">&quot;查询的user数据为:&#123;&#125;&quot;</span>,user.toString());</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>启动测试</li></ol><h2 id="SpringBoot3整合Mybatis"><a href="#SpringBoot3整合Mybatis" class="headerlink" title="SpringBoot3整合Mybatis"></a>SpringBoot3整合Mybatis</h2><h3 id="MyBatis整合步骤"><a href="#MyBatis整合步骤" class="headerlink" title="MyBatis整合步骤"></a>MyBatis整合步骤</h3><ol><li>导入依赖：在Spring Boot项目的构建文件（如pom.xml）中添加MyBatis和数据库驱动的相关依赖。例如，如果使用MySQL数据库，您需要添加MyBatis和MySQL驱动的依赖。</li><li>配置数据源：在<code>application.properties</code>或<code>application.yml</code>中配置数据库连接信息，包括数据库URL、用户名、密码、mybatis的功能配置等。</li><li>创建实体类：创建与数据库表对应的实体类。</li><li>创建Mapper接口：创建与数据库表交互的Mapper接口。</li><li>创建Mapper接口SQL实现:可以使用mapperxml文件或者注解方式</li><li>创建程序启动类</li><li>注解扫描：在Spring Boot的主应用类上添加<code>@MapperScan</code>注解，用于扫描和注册Mapper接口。</li><li>使用Mapper接口：在需要使用数据库操作的地方，通过依赖注入或直接实例化Mapper接口，并调用其中的方法进行数据库操作。</li></ol><h3 id="Mybatis整合实践"><a href="#Mybatis整合实践" class="headerlink" title="Mybatis整合实践"></a>Mybatis整合实践</h3><ol><li>创建项目</li><li>导入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据库相关配置启动器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- druid启动器的依赖  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-3-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 驱动类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.28<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">servlet:</span></span><br><span class="line"><span class="attr">context-path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">druid:</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql:///day01</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">configuration:</span>  <span class="comment"># setting配置</span></span><br><span class="line"><span class="attr">auto-mapping-behavior:</span> <span class="string">full</span></span><br><span class="line"><span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.slf4j.Slf4jImpl</span></span><br><span class="line"><span class="attr">type-aliases-package:</span> <span class="string">pojo</span> <span class="comment"># 配置别名</span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span> <span class="comment"># mapperxml位置</span></span><br></pre></td></tr></table></figure><ol start="4"><li>实体类准备</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String account ;</span><br><span class="line">    <span class="keyword">private</span> String password ;</span><br><span class="line">    <span class="keyword">private</span> Integer id ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>Mapper接口准备</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>Mapper接口实现（XML）</li></ol><p>位置：resources&#x2F;mapper&#x2F;UserMapper.xml</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line"><span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;!-- namespace = 接口的全限定符 --&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;queryAll&quot;</span> resultType=<span class="string">&quot;user&quot;</span>&gt;</span><br><span class="line">select * from users</span><br><span class="line">&lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><ol start="7"><li>编写三层架构代码</li></ol><p>controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUser</span><span class="params">()</span>&#123;</span><br><span class="line">List&lt;User&gt; userList = userService.findList();</span><br><span class="line">log.info(<span class="string">&quot;查询的user数据为:&#123;&#125;&quot;</span>,userList);</span><br><span class="line"><span class="keyword">return</span> userList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findList</span><span class="params">()</span>&#123;</span><br><span class="line">List&lt;User&gt; users = userMapper.queryAll();</span><br><span class="line">log.info(<span class="string">&quot;查询全部数据:&#123;&#125;&quot;</span>,users);</span><br><span class="line"><span class="keyword">return</span> users;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>启动类和接口扫描</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MapperScan(&quot;mapper&quot;)</span> <span class="comment">//mapper接口扫描配置</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="9"><li>启动测试</li></ol><h3 id="声明式事务整合配置"><a href="#声明式事务整合配置" class="headerlink" title="声明式事务整合配置"></a>声明式事务整合配置</h3><p>依赖导入:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注：SpringBoot项目会自动配置一个 DataSourceTransactionManager，所以我们只需在方法（或者类）加上 @Transactional 注解，就自动纳入 Spring 的事务管理了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setId(<span class="number">1</span>);</span><br><span class="line">user.setPassword(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">user.setAccount(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">userMapper.update(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AOP整合配置"><a href="#AOP整合配置" class="headerlink" title="AOP整合配置"></a>AOP整合配置</h3><p>依赖导入:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接使用aop注解即可: </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com..service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;LogAdvice.before&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;joinPoint = &quot;</span> + joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot3项目打包和运行"><a href="#SpringBoot3项目打包和运行" class="headerlink" title="SpringBoot3项目打包和运行"></a>SpringBoot3项目打包和运行</h2><h3 id="添加打包插件"><a href="#添加打包插件" class="headerlink" title="添加打包插件"></a>添加打包插件</h3><blockquote><p>在Spring Boot项目中添加<code>spring-boot-maven-plugin</code>插件是为了支持将项目打包成可执行的可运行jar包。如果不添加<code>spring-boot-maven-plugin</code>插件配置，使用常规的<code>java -jar</code>命令来运行打包后的Spring Boot项目是无法找到应用程序的入口点，因此导致无法运行。</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    SpringBoot应用打包插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="执行打包"><a href="#执行打包" class="headerlink" title="执行打包"></a>执行打包</h3><p>在idea点击package进行打包,可以在编译的target文件中查看jar包</p><h3 id="命令启动和参数说明"><a href="#命令启动和参数说明" class="headerlink" title="命令启动和参数说明"></a>命令启动和参数说明</h3><p><code>java -jar</code>命令用于在Java环境中执行可执行的JAR文件。下面是关于<code>java -jar</code>命令的说明：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">命令格式：java -jar  [选项] [参数] <span class="tag">&lt;<span class="name">jar文件名</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><code>-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性，可以通过<code>System.getProperty()</code>方法在应用程序中获取该属性值。例如：<code>java -jar -Dserver.port=8080 myapp.jar</code>。</li><li><code>-X</code>：设置JVM参数，例如内存大小、垃圾回收策略等。常用的选项包括：</li></ol><ul><li><code>-Xmx&lt;size&gt;</code>：设置JVM的最大堆内存大小，例如 <code>-Xmx512m</code> 表示设置最大堆内存为512MB。</li><li><code>-Xms&lt;size&gt;</code>：设置JVM的初始堆内存大小，例如 <code>-Xms256m</code> 表示设置初始堆内存为256MB。</li></ul><ol start="3"><li><code>-Dspring.profiles.active=&lt;profile&gt;</code>：指定Spring Boot的激活配置文件，可以通过<code>application-&lt;profile&gt;.properties</code>或<code>application-&lt;profile&gt;.yml</code>文件来加载相应的配置。例如：<code>java -jar -Dspring.profiles.active=dev myapp.jar</code>。</li></ol><p>注意：-D 参数必须要在jar之前！否者不生效！</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/21ae6bf2.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringMVC框架入门</title>
      <link>http://example.com/inori/faa8450.html</link>
      <guid>http://example.com/inori/faa8450.html</guid>
      <pubDate>Wed, 27 Mar 2024 03:24:46 GMT</pubDate>
      
      <description>SpringMVC</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc.html">Spring Web MVC</a>是基于Servlet API构建的原始Web框架,SSM框架构建起单体项目的技术栈需求！其中的SpringMVC负责表述层（控制层）实现简化</p><p><img src="https://secure2.wostatic.cn/static/bnm9zUQo34z7FgXA9vAmfm/image.png?auth_key=1711510047-qBsPAaHR88tC2aDLqhpekV-0-b3cb1c35742a1e107a3a8c3877ea1ebe"></p><p>SpringMVC的作用主要覆盖的是表述层，例如：</p><ul><li>请求映射</li><li>数据输入</li><li>视图界面</li><li>请求分发</li><li>表单回显</li><li>会话控制</li><li>过滤拦截</li><li>异步交互</li><li>文件上传</li><li>文件下载</li><li>数据校验</li><li>类型转换</li></ul><p><strong>总结：</strong></p><ol><li>简化前端参数接收( 形参列表 )</li><li>简化后端数据响应(返回值)</li><li>以及其他……</li></ol><h2 id="SpringMVC核心组件和调用流程"><a href="#SpringMVC核心组件和调用流程" class="headerlink" title="SpringMVC核心组件和调用流程"></a>SpringMVC核心组件和调用流程</h2><p>Spring MVC与许多其他Web框架一样，是围绕前端控制器模式设计的，其中中央 <code>Servlet</code> <code>DispatcherServlet</code> 做整体请求处理调度！</p><p>除了<code>DispatcherServlet</code>SpringMVC还会提供其他特殊的组件协作完成请求处理和响应呈现。</p><p><strong>SpringMVC处理请求流程：</strong></p><p><img src="https://secure2.wostatic.cn/static/no1PDXU3JX5K4cecSAx5oL/image.png?auth_key=1711510176-53NMzAsNwUn8BfjGcoEv4M-0-fd69e4a59e527b36adecb53b624ec5d2"></p><p><strong>SpringMVC涉及组件理解：</strong></p><ol><li>DispatcherServlet:SpringMVC提供，我们需要使用web.xml配置使其生效，它是整个流程处理的核心，所有请求都经过它的处理和分发</li><li>HandlerMapping:SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它内部缓存handler(controller方法)和handler访问路径数据，被DispatcherServlet调用，用于查找路径对应的handler</li><li>HandlerAdapter:SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效，它可以处理请求参数和处理响应数据数据，每次DispatcherServlet都是通过handlerAdapter间接调用handler，他是handler和DispatcherServlet之间的适配器</li><li>Handler:handler又称处理器，他是Controller类内部的方法简称，是由我们自己定义，用来接收参数，向后调用业务，最终返回响应结果</li><li>ViewResovler:SpringMVC提供，我们需要进行IoC配置使其加入IoC容器方可生效！视图解析器主要作用简化模版视图页面查找的，但是需要注意，前后端分离项目，后端只返回JSON数据，不返回页面，那就不需要视图解析器！所以，视图解析器，相对其他的组件不是必须的</li></ol><h2 id="SpringMVC接收数据"><a href="#SpringMVC接收数据" class="headerlink" title="SpringMVC接收数据"></a>SpringMVC接收数据</h2><h3 id="访问路径设置"><a href="#访问路径设置" class="headerlink" title="访问路径设置"></a>访问路径设置</h3><p>@RequestMapping注解的作用就是将请求的URL地址和处理请求的方式（handler方法）关联起来，建立映射关系。</p><p>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的方法来处理这个请求。</p><ol><li><strong>精准路径匹配</strong></li></ol><p>在@RequestMapping注解指定 URL 地址时，不使用任何通配符，按照请求地址进行精确匹配。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>模糊路径匹配</strong></li></ol><p>在@RequestMapping注解指定 URL 地址时，通过使用通配符，匹配多个类似的地址。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  路径设置为 /product/*  </span></span><br><span class="line"><span class="comment">*    /* 为单层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">*    /product/a/a 不可以</span></span><br><span class="line"><span class="comment">*  路径设置为 /product/** </span></span><br><span class="line"><span class="comment">*   /** 为任意层任意字符串  /product/a  /product/aaa 可以访问此handler  </span></span><br><span class="line"><span class="comment">*   /product/a/a 也可以访问</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/product/*&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductController.show&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;product show!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单层匹配和多层匹配：<br><code>/*</code>：只能匹配URL地址中的一层，如果想准确匹配两层，那么就写“&#x2F;*&#x2F;*”以此类推。<br><code>/**</code>：可以匹配URL地址中的多层。<br>其中所谓的一层或多层是指一个URL地址字符串被“&#x2F;”划分出来的各个层次<br>这个知识点虽然对于@RequestMapping注解来说实用性不大，但是将来配置拦截器的时候也遵循这个规则。</p><ol start="3"><li><strong>类和方法级别区别</strong></li></ol><p><code>@RequestMapping</code> 注解可以用于类级别和方法级别，它们之间的区别如下：</p><ol><li>设置到类级别：<code>@RequestMapping</code> 注解可以设置在控制器类上，用于映射整个控制器的通用请求路径。这样，如果控制器中的多个方法都需要映射同一请求路径，就不需要在每个方法上都添加映射路径。</li><li>设置到方法级别：<code>@RequestMapping</code> 注解也可以单独设置在控制器方法上，用于更细粒度地映射请求路径和处理方法。当多个方法处理同一个路径的不同操作时，可以使用方法级别的 <code>@RequestMapping</code> 注解进行更精细的映射。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.标记到handler方法</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/logout&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.优化标记类+handler方法</span></span><br><span class="line"><span class="comment">//类上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="comment">//handler方法上</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/register&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/logout&quot;)</span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>附带请求方式限制</strong></li></ol><p>HTTP 协议定义了八种请求方式，在 SpringMVC 中封装到了下面这个枚举类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMethod</span> &#123;</span><br><span class="line">GET, HEAD, POST, PUT, PATCH, DELETE, OPTIONS, TRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下：@RequestMapping(“&#x2F;logout”) 任何请求方式都可以访问</p><p>如果需要特定指定：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 精准设置访问地址 /user/login</span></span><br><span class="line"><span class="comment">* method = RequestMethod.POST 可以指定单个或者多个请求方式!</span></span><br><span class="line"><span class="comment">* 注意:违背请求方式会出现405异常!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/login&quot;&#125; , method = RequestMethod.POST)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.login&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 精准设置访问地址 /user/register</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &#123;&quot;/user/register&quot;&#125;,method = &#123;RequestMethod.POST,RequestMethod.GET&#125;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">register</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserController.register&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;register success!!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>进阶注解</strong></li></ol><p>还有 <code>@RequestMapping</code> 的 HTTP 方法特定快捷方式变体：</p><ul><li><code>@GetMapping</code></li><li><code>@PostMapping</code></li><li><code>@PutMapping</code></li><li><code>@DeleteMapping</code></li><li><code>@PatchMapping</code></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value=&quot;/login&quot;,method=RequestMethod.GET)</span></span><br><span class="line">||</span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/login&quot;)</span></span><br></pre></td></tr></table></figure><p>注意：进阶注解只能添加到handler方法上，无法添加到类上！</p><h3 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h3><h4 id="param和json参数比较"><a href="#param和json参数比较" class="headerlink" title="param和json参数比较"></a>param和json参数比较</h4><p>在 HTTP 请求中，我们可以选择不同的参数类型，如 param 类型和 JSON 类型。下面对这两种参数类型进行区别和对比：</p><ol><li>参数编码：</li></ol><p>param 类型的参数会被编码为 ASCII 码。例如，假设 <code>name=john doe</code>，则会被编码为 <code>name=john%20doe</code>。而 JSON 类型的参数会被编码为 UTF-8。<br>2. 参数顺序：  </p><p>param 类型的参数没有顺序限制。但是，JSON 类型的参数是有序的。JSON 采用键值对的形式进行传递，其中键值对是有序排列的。<br>3. 数据类型：  </p><p>param 类型的参数仅支持字符串类型、数值类型和布尔类型等简单数据类型。而 JSON 类型的参数则支持更复杂的数据类型，如数组、对象等。<br>4. 嵌套性：  </p><p>param 类型的参数不支持嵌套。但是，JSON 类型的参数支持嵌套，可以传递更为复杂的数据结构。<br>5. 可读性：  </p><p>param 类型的参数格式比 JSON 类型的参数更加简单、易读。但是，JSON 格式在传递嵌套数据结构时更加清晰易懂。</p><p>总的来说，param 类型的参数适用于单一的数据传递，而 JSON 类型的参数则更适用于更复杂的数据结构传递。根据具体的业务需求，需要选择合适的参数类型。在实际开发中，常见的做法是：在 GET 请求中采用 param 类型的参数，而在 POST 请求中采用 JSON 类型的参数传递。</p><h4 id="param参数接收"><a href="#param参数接收" class="headerlink" title="param参数接收"></a>param参数接收</h4><ol><li><strong>直接接值</strong></li></ol><p>handler接收参数</p><p>只要形参数名和类型与传递参数相同，即可自动接收!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前端请求: http://localhost:8080/param/value?name=xx&amp;age=18</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 可以利用形参列表,直接接收前端传递的param参数!</span></span><br><span class="line"><span class="comment">*    要求: 参数名 = 形参名</span></span><br><span class="line"><span class="comment">*          类型相同</span></span><br><span class="line"><span class="comment">* 出现乱码正常，json接收具体解决！！</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回前端数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="meta">@GetMapping(value=&quot;/value&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">setupForm</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> name + age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>@RequestParam注解</strong></li></ol><p>可以使用 <code>@RequestParam</code> 注释将 Servlet 请求参数（即查询参数或表单数据）绑定到控制器中的方法参数。</p><p><code>@RequestParam</code>使用场景：</p><ul><li>指定绑定的请求参数名</li><li>要求请求参数必须传递</li><li>为请求参数提供默认值</li></ul><p>基本用法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前端请求: http://localhost:8080/param/data?name=xx&amp;stuAge=18</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*  使用<span class="doctag">@RequestParam</span>注解标记handler方法的形参</span></span><br><span class="line"><span class="comment">*  指定形参对应的请求参数<span class="doctag">@RequestParam</span>(请求参数名称)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params">                        <span class="meta">@RequestParam(&quot;stuAge&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line">    <span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，使用此批注的方法参数是必需的，但您可以通过将 <code>@RequestParam</code> 批注的 <code>required</code> 标志设置为 <code>false</code>！</p><p>将参数设置非必须，并且设置默认值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(value=&quot;/data&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">paramForm</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String name, </span></span><br><span class="line"><span class="params"><span class="meta">@RequestParam(value = &quot;stuAge&quot;,required = false,defaultValue = &quot;18&quot;)</span> <span class="type">int</span> age)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age);</span><br><span class="line"><span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>特殊场景接值</strong></li></ol><p>一名多值:多选框，提交的数据的时候一个key对应多个值，我们可以使用集合进行接收！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 前端请求: http://localhost:8080/param/mul?hbs=吃&amp;hbs=喝</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  一名多值,可以使用集合接收即可!但是需要使用<span class="doctag">@RequestParam</span>注解指定</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(value=&quot;/mul&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">mulForm</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; hbs)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;hbs = &quot;</span> + hbs);</span><br><span class="line"><span class="keyword">return</span> hbs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体接收:Spring MVC 是 Spring 框架提供的 Web 框架，它允许开发者使用实体对象来接收 HTTP 请求中的参数。通过这种方式，可以在方法内部直接使用对象的属性来访问请求参数，而不需要每个参数都写一遍。</p><p>定义一个用于接收参数的实体类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 和 setter 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制器中，使用实体对象接收，示例代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line"><span class="comment">// 在这里可以使用 user 对象的属性来接收请求参数</span></span><br><span class="line">System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，将请求参数name和age映射到实体类属性上！要求属性名必须等于参数名！否则无法映射！</p><h4 id="路径-参数接收"><a href="#路径-参数接收" class="headerlink" title="路径 参数接收"></a>路径 参数接收</h4><p>路径传递参数是一种在 URL 路径中传递参数的方式。在 RESTful 的 Web 应用程序中，经常使用路径传递参数来表示资源的唯一标识符或更复杂的表示方式。而 Spring MVC 框架提供了 <code>@PathVariable</code> 注解来处理路径传递参数。</p><p><code>@PathVariable</code> 注解允许将 URL 中的占位符映射到控制器方法中的参数。</p><p>例如，如果我们想将 <code>/user/&#123;id&#125;</code> 路径下的 <code>&#123;id&#125;</code> 映射到控制器方法的一个参数中，则可以使用 <code>@PathVariable</code> 注解来实现。</p><p>下面是一个使用 <code>@PathVariable</code> 注解处理路径传递参数的示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 动态路径设计: /user/&#123;动态部分&#125;/&#123;动态部分&#125;   动态部分使用&#123;&#125;包含即可! &#123;&#125;内部动态标识!</span></span><br><span class="line"><span class="comment">* 形参列表取值: <span class="doctag">@PathVariable</span> Long id  如果形参名 = &#123;动态标识&#125; 自动赋值!</span></span><br><span class="line"><span class="comment">*              <span class="doctag">@PathVariable</span>(&quot;动态标识&quot;) Long id  如果形参名 != &#123;动态标识&#125; 可以通过指定动态标识赋值!</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 访问测试:  /param/user/1/root  -&gt; id = 1  uname = root</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getUser</span><span class="params">(<span class="meta">@PathVariable</span> Long id, </span></span><br><span class="line"><span class="params">    <span class="meta">@PathVariable(&quot;name&quot;)</span> String uname)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;id = &quot;</span> + id + <span class="string">&quot;, uname = &quot;</span> + uname);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;user_detail&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="json参数接收"><a href="#json参数接收" class="headerlink" title="json参数接收"></a>json参数接收</h4><p>前端传递 JSON 数据时，Spring MVC 框架可以使用 <code>@RequestBody</code> 注解来将 JSON 数据转换为 Java 对象。<code>@RequestBody</code> 注解表示当前方法参数的值应该从请求体中获取，并且需要指定 value 属性来指示请求体应该映射到哪个参数上。其使用方式和示例代码如下：</p><ol><li>前端发送 JSON 数据的示例：</li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;男&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义一个用于接收 JSON 数据的 Java 类，例如：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在控制器中，使用 <code>@RequestBody</code> 注解来接收 JSON 数据，并将其转换为 Java 对象，例如：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/person&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addPerson</span><span class="params">(<span class="meta">@RequestBody</span> Person person)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这里可以使用 person 对象来操作 JSON 数据中包含的属性</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>@RequestBody</code> 注解将请求体中的 JSON 数据映射到 <code>Person</code> 类型的 <code>person</code> 参数上，并将其作为一个对象来传递给 <code>addPerson()</code> 方法进行处理。<br>4. 完善配置</p><p>springmvc handlerAdpater配置json转化器,配置类需要明确：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"><span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"><span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"><span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pom.xml 加入jackson依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>@EnableWebMvc注解说明</li></ol><p>@EnableWebMvc注解效果等同于在 XML 配置中，可以使用 <code>&lt;mvc:annotation-driven&gt;</code> 元素</p><h3 id="接收Cookie数据"><a href="#接收Cookie数据" class="headerlink" title="接收Cookie数据"></a>接收Cookie数据</h3><p>可以使用 <code>@CookieValue</code> 注释将 HTTP Cookie 的值绑定到控制器中的方法参数。</p><p>考虑使用以下 cookie 的请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(<span class="meta">@CookieValue(&quot;JSESSIONID&quot;)</span> String cookie)</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接收请求头数据"><a href="#接收请求头数据" class="headerlink" title="接收请求头数据"></a>接收请求头数据</h3><p>可以使用 <code>@RequestHeader</code> 批注将请求标头绑定到控制器中的方法参数。</p><p>请考虑以下带有标头的请求：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Host                    localhost:<span class="number">8080</span></span><br><span class="line">Accept                  text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span></span><br><span class="line">Accept-Language         fr,en-gb;q=<span class="number">0.7</span>,en;q=<span class="number">0.3</span></span><br><span class="line">Accept-Encoding         gzip,deflate</span><br><span class="line">Accept-Charset          ISO-<span class="number">8859</span>-<span class="number">1</span>,utf-<span class="number">8</span>;q=<span class="number">0.7</span>,*;q=<span class="number">0.7</span></span><br><span class="line">Keep-Alive              <span class="number">300</span></span><br></pre></td></tr></table></figure><p>下面的示例获取 <code>Accept-Encoding</code> 和 <code>Keep-Alive</code> 标头的值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="meta">@RequestHeader(&quot;Accept-Encoding&quot;)</span> String encoding, </span></span><br><span class="line"><span class="params"><span class="meta">@RequestHeader(&quot;Keep-Alive&quot;)</span> <span class="type">long</span> keepAlive)</span> &#123; </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原生Api对象操作"><a href="#原生Api对象操作" class="headerlink" title="原生Api对象操作"></a>原生Api对象操作</h3><p><a href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html">https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/arguments.html</a></p><p>下表描述了支持的控制器方法参数</p><table><thead><tr><th>Controller method argument 控制器方法参数</th><th>Description</th></tr></thead><tbody><tr><td><code>jakarta.servlet.ServletRequest</code>, <code>jakarta.servlet.ServletResponse</code></td><td>请求&#x2F;响应对象</td></tr><tr><td><code>jakarta.servlet.http.HttpSession</code></td><td>强制存在会话。因此，这样的参数永远不会为 <code>null</code> 。</td></tr><tr><td><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td>用于访问由 Servlet API 公开的原始请求正文。</td></tr><tr><td><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td>用于访问由 Servlet API 公开的原始响应正文。</td></tr><tr><td><code>@PathVariable</code></td><td>接收路径参数注解</td></tr><tr><td><code>@RequestParam</code></td><td>用于访问 Servlet 请求参数，包括多部分文件。参数值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestHeader</code></td><td>用于访问请求标头。标头值将转换为声明的方法参数类型。</td></tr><tr><td><code>@CookieValue</code></td><td>用于访问Cookie。Cookie 值将转换为声明的方法参数类型。</td></tr><tr><td><code>@RequestBody</code></td><td>用于访问 HTTP 请求正文。正文内容通过使用 <code>HttpMessageConverter</code> 实现转换为声明的方法参数类型。</td></tr><tr><td><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td>共享域对象，并在视图呈现过程中向模板公开。</td></tr><tr><td><code>Errors</code>, <code>BindingResult</code></td><td>验证和数据绑定中的错误信息获取对象！</td></tr></tbody></table><p>获取原生对象示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果想要获取请求或者响应对象,或者会话等,可以直接在形参列表传入,并且不分先后顺序!</span></span><br><span class="line"><span class="comment">* 注意: 接收原生对象,并不影响参数接收!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;api&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">api</span><span class="params">(HttpSession session , HttpServletRequest request,</span></span><br><span class="line"><span class="params">    HttpServletResponse response)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    System.out.println(<span class="string">&quot;method = &quot;</span> + method);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;api&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享域对象操作"><a href="#共享域对象操作" class="headerlink" title="共享域对象操作"></a>共享域对象操作</h3><h4 id="属性（共享）域作用回顾"><a href="#属性（共享）域作用回顾" class="headerlink" title="属性（共享）域作用回顾"></a>属性（共享）域作用回顾</h4><p>在 JavaWeb 中，共享域指的是在 Servlet 中存储数据，以便在同一 Web 应用程序的多个组件中进行共享和访问。常见的共享域有四种：<code>ServletContext</code>、<code>HttpSession</code>、<code>HttpServletRequest</code>、<code>PageContext</code>。</p><ol><li><code>ServletContext</code> 共享域：<code>ServletContext</code> 对象可以在整个 Web 应用程序中共享数据，是最大的共享域。一般可以用于保存整个 Web 应用程序的全局配置信息，以及所有用户都共享的数据。在 <code>ServletContext</code> 中保存的数据是线程安全的。</li><li><code>HttpSession</code> 共享域：<code>HttpSession</code> 对象可以在同一用户发出的多个请求之间共享数据，但只能在同一个会话中使用。比如，可以将用户登录状态保存在 <code>HttpSession</code> 中，让用户在多个页面间保持登录状态。</li><li><code>HttpServletRequest</code> 共享域：<code>HttpServletRequest</code> 对象可以在同一个请求的多个处理器方法之间共享数据。比如，可以将请求的参数和属性存储在 <code>HttpServletRequest</code> 中，让处理器方法之间可以访问这些数据。</li><li><code>PageContext</code> 共享域：<code>PageContext</code> 对象是在 JSP 页面Servlet 创建时自动创建的。它可以在 JSP 的各个作用域中共享数据，包括<code>pageScope</code>、<code>requestScope</code>、<code>sessionScope</code>、<code>applicationScope</code> 等作用域。</li></ol><p>共享域的作用是提供了方便实用的方式在同一 Web 应用程序的多个组件之间传递数据，并且可以将数据保存在不同的共享域中，根据需要进行选择和使用。</p><h4 id="Request级别属性（共享）域"><a href="#Request级别属性（共享）域" class="headerlink" title="Request级别属性（共享）域"></a>Request级别属性（共享）域</h4><ol><li>使用 Model 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModel</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 在形参位置声明Model类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">Model model)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line"><span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">model.addAttribute(<span class="string">&quot;requestScopeMessageModel&quot;</span>,<span class="string">&quot;i am very happy[model]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 ModelMap 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/model/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestModelMap</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 在形参位置声明ModelMap类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">ModelMap modelMap)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line"><span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">modelMap.addAttribute(<span class="string">&quot;requestScopeMessageModelMap&quot;</span>,<span class="string">&quot;i am very happy[model map]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 Map 类型的形参</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/map&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrRequestMap</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 在形参位置声明Map类型变量，用于存储模型数据</span></span><br><span class="line"><span class="params">Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们将数据存入模型，SpringMVC 会帮我们把模型数据存入请求域</span></span><br><span class="line"><span class="comment">// 存入请求域这个动作也被称为暴露到请求域</span></span><br><span class="line">map.put(<span class="string">&quot;requestScopeMessageMap&quot;</span>, <span class="string">&quot;i am very happy[map]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>使用原生 request 对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/original&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrOriginalRequest</span><span class="params">(</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">// 拿到原生对象，就可以调用原生方法执行各种操作</span></span><br><span class="line"><span class="params">HttpServletRequest request)</span> &#123;</span><br><span class="line"></span><br><span class="line">request.setAttribute(<span class="string">&quot;requestScopeMessageOriginal&quot;</span>, <span class="string">&quot;i am very happy[original]&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用 ModelAndView 对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/request/mav&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">testAttrByModelAndView</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.创建ModelAndView对象</span></span><br><span class="line"><span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line"><span class="comment">// 2.存入模型数据</span></span><br><span class="line">modelAndView.addObject(<span class="string">&quot;requestScopeMessageMAV&quot;</span>, <span class="string">&quot;i am very happy[mav]&quot;</span>);</span><br><span class="line"><span class="comment">// 3.设置视图名称</span></span><br><span class="line">modelAndView.setViewName(<span class="string">&quot;target&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Session级别属性（共享）域"><a href="#Session级别属性（共享）域" class="headerlink" title="Session级别属性（共享）域"></a>Session级别属性（共享）域</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/attr/session&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testAttrSession</span><span class="params">(HttpSession session)</span> &#123;</span><br><span class="line"><span class="comment">//直接对session对象操作,即对会话范围操作!</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Application级别属性（共享）域"><a href="#Application级别属性（共享）域" class="headerlink" title="Application级别属性（共享）域"></a>Application级别属性（共享）域</h4><p>springmvc会在初始化容器的时候，把servletContext对象存储到ioc容器中</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/attr/application&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">attrApplication</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">servletContext.setAttribute(<span class="string">&quot;appScopeMsg&quot;</span>, <span class="string">&quot;i am hungry...&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;target&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC响应数据"><a href="#SpringMVC响应数据" class="headerlink" title="SpringMVC响应数据"></a>SpringMVC响应数据</h2><h3 id="handler方法分析"><a href="#handler方法分析" class="headerlink" title="handler方法分析"></a>handler方法分析</h3><p>理解handler方法的作用和组成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> 一个controller的方法是控制层的一个处理器,我们称为handler</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> handler需要使用<span class="doctag">@RequestMapping</span>/<span class="doctag">@GetMapping</span>系列,声明路径,在HandlerMapping中注册,供DS查找!</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> handler作用总结:</span></span><br><span class="line"><span class="comment">*       1.接收请求参数(param,json,pathVariable,共享域等) </span></span><br><span class="line"><span class="comment">*       2.调用业务逻辑 </span></span><br><span class="line"><span class="comment">*       3.响应前端数据(页面（不讲解模版页面跳转）,json,转发和重定向等)</span></span><br><span class="line"><span class="comment">* <span class="doctag">TODO:</span> handler如何处理呢</span></span><br><span class="line"><span class="comment">*       1.接收参数: handler(形参列表: 主要的作用就是用来接收参数)</span></span><br><span class="line"><span class="comment">*       2.调用业务: &#123; 方法体  可以向后调用业务方法 service.xx() &#125;</span></span><br><span class="line"><span class="comment">*       3.响应数据: return 返回结果,可以快速响应前端数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handler</span><span class="params">(简化请求参数接收)</span>&#123;</span><br><span class="line">    调用业务方法</span><br><span class="line">    返回的结果 （页面跳转，返回数据（json））</span><br><span class="line">    <span class="keyword">return</span> 简化响应前端数据;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求数据接收，我们都是通过handler的形参列表</p><p>前端数据响应，我们都是通过handler的return关键字快速处理</p><p>springmvc简化了参数接收和响应</p><h3 id="页面跳转控制"><a href="#页面跳转控制" class="headerlink" title="页面跳转控制"></a>页面跳转控制</h3><h4 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h4><p>在 Spring MVC 中，Handler 方法返回值来实现快速转发，可以使用 <code>redirect</code> 或者 <code>forward</code> 关键字来实现重定向。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirectDemo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 重定向到 /demo 路径 </span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/forward-demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forwardDemo</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 转发到 /demo 路径</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/demo&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>将方法的返回值，设置String类型</li><li>转发使用forward关键字，重定向使用redirect关键字</li><li>关键字: &#x2F;路径</li><li>注意：如果是项目下的资源，转发和重定向都一样都是项目下路径！都不需要添加项目根路径！</li></ul><h3 id="返回JSON数据"><a href="#返回JSON数据" class="headerlink" title="返回JSON数据"></a>返回JSON数据</h3><h4 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h4><p>导入jackson依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加json数据转化器</p><p>@EnableWebMvc </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">TODO:</span> SpringMVC对应组件的配置类 [声明SpringMVC需要的组件信息]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> 导入handlerMapping和handlerAdapter的三种方式</span></span><br><span class="line"><span class="comment">//1.自动导入handlerMapping和handlerAdapter [推荐]</span></span><br><span class="line"><span class="comment">//2.可以不添加,springmvc会检查是否配置handlerMapping和handlerAdapter,没有配置默认加载</span></span><br><span class="line"><span class="comment">//3.使用@Bean方式配置handlerMapper和handlerAdapter</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h4><ol><li>方法上使用@ResponseBody</li></ol><p>可以在方法上使用 <code>@ResponseBody</code>注解，用于将方法返回的对象序列化为 JSON 或 XML 格式的数据，并发送给客户端。在前后端分离的项目中使用！</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/accounts/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，<code>@ResponseBody</code> 注解可以用来标识方法或者方法返回值，表示方法的返回值是要直接返回给客户端的数据，而不是由视图解析器来解析并渲染生成响应体（viewResolver没用）。</p><p>测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/user/detail&quot;, method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(<span class="meta">@RequestBody</span> User userParam)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;userParam = &quot;</span> + userParam);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">user.setAge(<span class="number">18</span>);</span><br><span class="line">user.setName(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"><span class="comment">//返回的对象,会使用jackson的序列化工具,转成json返回给前端!</span></span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>类上使用@ResponseBody</li></ol><p>如果类中每个方法上都标记了@ResponseBody注解，那么这些注解就可以提取到类上</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span>  <span class="comment">//responseBody可以添加到类上,代表默认类中的所有方法都生效!</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;param&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamController</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h4><p>类上的 @ResponseBody 注解可以和 @Controller 注解合并为 @RestController 注解。所以使用了 @RestController 注解就相当于给类中的每个方法都加了 @ResponseBody 注解</p><p>RestController源码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RestController &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The value may indicate a suggestion for a logical component name,</span></span><br><span class="line"><span class="comment">* to be turned into a Spring bean in case of an autodetected component.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the suggested component name, if any (or empty String otherwise)</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 4.0.1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@AliasFor(annotation = Controller.class)</span></span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回静态资源处理"><a href="#返回静态资源处理" class="headerlink" title="返回静态资源处理"></a>返回静态资源处理</h3><ol><li><strong>静态资源概念</strong></li></ol><p>资源本身已经是可以直接拿到浏览器上使用的程度了，<strong>不需要在服务器端做任何运算、处理</strong>。典型的静态资源包括但不限于：</p><ul><li>HTML文件</li><li>图片</li><li>CSS文件</li><li>JavaScript文件</li></ul><ol start="2"><li><strong>静态资源访问问题解决</strong></li></ol><ul><li><p>web应用加入静态资源</p></li><li><p>手动构建确保编译</p></li><li><p>访问静态资源</p></li><li><p>此时访问不到，问题分析：</p><ul><li>DispatcherServlet 的 url-pattern 配置的是“&#x2F;”</li><li>url-pattern 配置“&#x2F;”表示整个 Web 应用范围内所有请求都由 SpringMVC 来处理</li><li>对 SpringMVC 来说，必须有对应的 @RequestMapping 才能找到处理请求的方法</li><li>现在 images&#x2F;mi.jpg 请求没有对应的 @RequestMapping 所以返回 404</li></ul></li></ul><p>在 SpringMVC 配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;controller&quot;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新的问题：其他原本正常的handler请求访问不了了</p><p>解决方案：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@EnableWebMvc  //json数据处理,必须使用此注解,因为他会加入json处理器</span><br></pre></td></tr></table></figure><h2 id="RESTFul风格设计和实战"><a href="#RESTFul风格设计和实战" class="headerlink" title="RESTFul风格设计和实战"></a>RESTFul风格设计和实战</h2><p>RESTful（Representational State Transfer）是一种软件架构风格，用于设计网络应用程序和服务之间的通信。它是一种基于标准 HTTP 方法的简单和轻量级的通信协议，广泛应用于现代的Web服务开发</p><p>通过遵循 RESTful 架构的设计原则，可以构建出易于理解、可扩展、松耦合和可重用的 Web 服务。RESTful API 的特点是简单、清晰，并且易于使用和理解，它们使用标准的 HTTP 方法和状态码进行通信，不需要额外的协议和中间件</p><p>总而言之，RESTful 是一种基于 HTTP 和标准化的设计原则的软件架构风格，用于设计和实现可靠、可扩展和易于集成的 Web 服务和应用程序</p><h3 id="RESTFul风格特点"><a href="#RESTFul风格特点" class="headerlink" title="RESTFul风格特点"></a>RESTFul风格特点</h3><ol><li>每一个URI代表1种资源（URI 是名词）；</li><li>客户端使用GET、POST、PUT、DELETE 4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li><li>资源的表现形式是XML或者<strong>JSON</strong>；</li><li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li></ol><h3 id="RESTFul风格设计规范"><a href="#RESTFul风格设计规范" class="headerlink" title="RESTFul风格设计规范"></a>RESTFul风格设计规范</h3><ol><li><strong>HTTP协议请求方式要求</strong></li></ol><p>REST 风格主张在项目设计、开发过程中，具体的操作符合<strong>HTTP协议定义的请求方式的语义</strong>。</p><table><thead><tr><th>操作</th><th>请求方式</th></tr></thead><tbody><tr><td>查询操作</td><td>GET</td></tr><tr><td>保存操作</td><td>POST</td></tr><tr><td>删除操作</td><td>DELETE</td></tr><tr><td>更新操作</td><td>PUT</td></tr></tbody></table><ol start="2"><li><strong>URL路径风格要求</strong></li></ol><p>REST风格下每个资源都应该有一个唯一的标识符，例如一个 URI（统一资源标识符）或者一个 URL（统一资源定位符）。资源的标识符应该能明确地说明该资源的信息，同时也应该是可被理解和解释的！</p><p>使用URL+请求方式确定具体的动作，他也是一种标准的HTTP协议请求！</p><table><thead><tr><th>操作</th><th>传统风格</th><th>REST 风格</th></tr></thead><tbody><tr><td>保存</td><td>&#x2F;CRUD&#x2F;saveEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：POST</td></tr><tr><td>删除</td><td>&#x2F;CRUD&#x2F;removeEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：DELETE</td></tr><tr><td>更新</td><td>&#x2F;CRUD&#x2F;updateEmp</td><td>URL 地址：&#x2F;CRUD&#x2F;emp 请求方式：PUT</td></tr><tr><td>查询</td><td>&#x2F;CRUD&#x2F;editEmp?empId&#x3D;2</td><td>URL 地址：&#x2F;CRUD&#x2F;emp&#x2F;2 请求方式：GET</td></tr></tbody></table><ul><li>总结</li></ul><p>根据接口的具体动作，选择具体的HTTP协议请求方式</p><p>路径设计从原来携带动标识，改成名词，对应资源的唯一标识即可</p><h2 id="SpringMVC其他扩展"><a href="#SpringMVC其他扩展" class="headerlink" title="SpringMVC其他扩展"></a>SpringMVC其他扩展</h2><h3 id="全局异常处理机制"><a href="#全局异常处理机制" class="headerlink" title="全局异常处理机制"></a>全局异常处理机制</h3><h4 id="异常处理两种方式"><a href="#异常处理两种方式" class="headerlink" title="异常处理两种方式"></a>异常处理两种方式</h4><p>开发过程中是不可避免地会出现各种异常情况的，例如网络连接异常、数据格式异常、空指针异常等等。异常的出现可能导致程序的运行出现问题，甚至直接导致程序崩溃。因此，在开发过程中，合理处理异常、避免异常产生、以及对异常进行有效的调试是非常重要的。</p><p>对于异常的处理，一般分为两种方式：</p><ul><li>编程式异常处理：是指在代码中显式地编写处理异常的逻辑。它通常涉及到对异常类型的检测及其处理，例如使用 try-catch 块来捕获异常，然后在 catch 块中编写特定的处理代码，或者在 finally 块中执行一些清理操作。在编程式异常处理中，开发人员需要显式地进行异常处理，异常处理代码混杂在业务代码中，导致代码可读性较差。</li><li>声明式异常处理：则是将异常处理的逻辑从具体的业务逻辑中分离出来，通过配置等方式进行统一的管理和处理。在声明式异常处理中，开发人员只需要为方法或类标注相应的注解（如 <code>@Throws</code> 或 <code>@ExceptionHandler</code>），就可以处理特定类型的异常。相较于编程式异常处理，声明式异常处理可以使代码更加简洁、易于维护和扩展。</li></ul><p>站在宏观角度来看待声明式事务处理：</p><p>整个项目从架构这个层面设计的异常处理的统一机制和规范。</p><p>一个项目中会包含很多个模块，各个模块需要分工完成。如果张三负责的模块按照 A 方案处理异常，李四负责的模块按照 B 方案处理异常……各个模块处理异常的思路、代码、命名细节都不一样，那么就会让整个项目非常混乱。</p><p>使用声明式异常处理，可以统一项目处理异常思路，项目更加清晰明了！</p><h4 id="基于注解异常声明异常处理"><a href="#基于注解异常声明异常处理" class="headerlink" title="基于注解异常声明异常处理"></a>基于注解异常声明异常处理</h4><ol><li>声明异常处理控制器类</li></ol><p>异常处理控制类，统一定义异常处理handler方法！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* description: 全局异常处理器,内部可以定义异常处理Handler!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@RestControllerAdvice</span> = <span class="doctag">@ControllerAdvice</span> + <span class="doctag">@ResponseBody</span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@ControllerAdvice</span> 代表当前类的异常处理controller! </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明异常处理hander方法</li></ol><p>异常处理handler方法和普通的handler方法参数接收和响应都一致！</p><p>只不过异常处理handler方法要映射异常，发生对应的异常会调用！</p><p>普通的handler方法要使用@RequestMapping注解映射路径，发生对应的路径调用！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 异常处理handler </span></span><br><span class="line"><span class="comment">* <span class="doctag">@ExceptionHandler</span>(HttpMessageNotReadableException.class) </span></span><br><span class="line"><span class="comment">* 该注解标记异常处理Handler,并且指定发生异常调用该方法!</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e 获取异常对象!</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回handler处理结果!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler(HttpMessageNotReadableException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerJsonDateException</span><span class="params">(HttpMessageNotReadableException e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当发生空指针异常会触发此方法!</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler(NullPointerException.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerNullException</span><span class="params">(NullPointerException e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 所有异常都会触发此方法!但是如果有具体的异常处理Handler! </span></span><br><span class="line"><span class="comment">* 具体异常处理Handler优先级更高!</span></span><br><span class="line"><span class="comment">* 例如: 发生NullPointerException异常!</span></span><br><span class="line"><span class="comment">*       会触发handlerNullException方法,不会触发handlerException方法!</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">handlerException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件扫描控制器类配置</li></ol><p>确保异常处理控制类被扫描</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 扫描controller对应的包,将handler加入到ioc--&gt;</span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;controller&quot;,</span></span><br><span class="line"><span class="meta">&quot;exceptionhandler&quot;&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="拦截器使用"><a href="#拦截器使用" class="headerlink" title="拦截器使用"></a>拦截器使用</h3><p>在程序中，使用拦截器在请求到达具体 handler 方法前，统一执行检测</p><p><img src="https://secure2.wostatic.cn/static/eBwRN4iKLw9e9DHpVGP4WX/img009.png?auth_key=1711509897-q84g4d16Pi8edgQsgjFxX1-0-e1f8aae4836ccd17e30f941dfd3a90ff"></p><p>拦截器 Springmvc VS 过滤器 javaWeb：</p><ul><li><p>相似点</p><ul><li>拦截：必须先把请求拦住，才能执行后续操作</li><li>过滤：拦截器或过滤器存在的意义就是对请求进行统一处理</li><li>放行：对请求执行了必要操作后，放请求过去，让它访问原本想要访问的资源</li></ul></li><li><p>不同点</p><ul><li>工作平台不同</li><li>过滤器工作在 Servlet 容器中</li><li>拦截器工作在 SpringMVC 的基础上</li></ul></li><li><p>拦截的范围</p><ul><li><p>过滤器：能够拦截到的最大范围是整个 Web 应用</p></li><li><p>拦截器：能够拦截到的最大范围是整个 SpringMVC 负责的请求</p></li></ul></li><li><p>IOC 容器支持</p><ul><li><p>过滤器：想得到 IOC 容器需要调用专门的工具方法，是间接的</p></li><li><p>拦截器：它自己就在 IOC 容器中，所以可以直接从 IOC 容器中装配组件，也就是可以直接得到 IOC 容器的支持</p></li></ul></li></ul><p>选择：</p><p>功能需要如果用 SpringMVC 的拦截器能够实现，就不使用过滤器</p><p><img src="https://secure-bigfile.wostatic.cn/static/prqG4dtu3rDWj7VwX4WgsW/image.png?auth_key=1711509897-HdeEsMAR2ZKmzeit5j184-0-290313fb34c39d5661341d38a3a72010"></p><h4 id="拦截器使用-1"><a href="#拦截器使用-1" class="headerlink" title="拦截器使用"></a>拦截器使用</h4><ol><li>创建拦截器类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Process01Interceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if( ! preHandler())&#123;return;&#125;</span></span><br><span class="line"><span class="comment">// 在处理请求的目标 handler 方法前执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler);</span><br><span class="line">    System.out.println(<span class="string">&quot;Process01Interceptor.preHandle&quot;</span>);</span><br><span class="line">    <span class="comment">// 返回true：放行</span></span><br><span class="line">    <span class="comment">// 返回false：不放行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在目标 handler 方法之后，handler报错不执行!</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, modelAndView = &quot;</span> + modelAndView);</span><br><span class="line">    System.out.println(<span class="string">&quot;Process01Interceptor.postHandle&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染视图之后执行(最后),一定执行!</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;request = &quot;</span> + request + <span class="string">&quot;, response = &quot;</span> + response + <span class="string">&quot;, handler = &quot;</span> + handler + <span class="string">&quot;, ex = &quot;</span> + ex);</span><br><span class="line">    System.out.println(<span class="string">&quot;Process01Interceptor.afterCompletion&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器方法拦截位置：</p><p><img src="https://secure2.wostatic.cn/static/9W6TF7dUwqdv2qi4KHAkAr/image.png?auth_key=1711509897-vQhhyorhLrk5H8FZd39JZZ-0-4b9cc18640fe0235a5931bcc1d5a7699"><br>2. 修改配置类添加拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebMvc</span>  <span class="comment">//json数据处理,必须使用此注解,因为他会加入json处理器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;controller&quot;,&quot;exceptionhandler&quot;&#125;)</span> <span class="comment">//<span class="doctag">TODO:</span> 进行controller扫描</span></span><br><span class="line"><span class="comment">//WebMvcConfigurer springMvc进行组件配置的规范,配置组件,提供各种方法! 前期可以实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置jsp对应的视图解析器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//快速配置jsp模板语言对应的</span></span><br><span class="line">registry.jsp(<span class="string">&quot;/WEB-INF/views/&quot;</span>,<span class="string">&quot;.jsp&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启静态资源处理 &lt;mvc:default-servlet-handler/&gt;</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span> &#123;</span><br><span class="line">configurer.enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123; </span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>配置详解</li><li>默认拦截全部</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>精准配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line"><span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line"><span class="comment">//也支持 /* 和 /** 模糊路径。 * 任意一层字符串 ** 任意层 任意字符串</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>排除配置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加拦截器</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将拦截器添加到Springmvc环境,默认拦截所有Springmvc分发的请求</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//精准匹配,设置拦截器处理指定请求 路径可以设置一个或者多个,为项目下路径即可</span></span><br><span class="line"><span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>()).addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//排除匹配,排除应该在匹配的范围内排除</span></span><br><span class="line"><span class="comment">//addPathPatterns(&quot;/common/request/one&quot;) 添加拦截路径</span></span><br><span class="line"><span class="comment">//excludePathPatterns(&quot;/common/request/tow&quot;); 排除路径,排除应该在拦截的范围内</span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">Process01Interceptor</span>())</span><br><span class="line">.addPathPatterns(<span class="string">&quot;/common/request/one&quot;</span>,<span class="string">&quot;/common/request/tow&quot;</span>)</span><br><span class="line">.excludePathPatterns(<span class="string">&quot;/common/request/tow&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>多个拦截器执行顺序</li><li>preHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置顺序调用各个 preHandle() 方法。</li><li>postHandle() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 postHandle() 方法。</li><li>afterCompletion() 方法：SpringMVC 会把所有拦截器收集到一起，然后按照配置相反的顺序调用各个 afterCompletion() 方法。</li></ol><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><blockquote><p>在 Web 应用三层架构体系中，表述层负责接收浏览器提交的数据，业务逻辑层负责数据的处理。为了能够让业务逻辑层基于正确的数据进行处理，我们需要在表述层对数据进行检查，将错误的数据隔绝在业务逻辑层之外。</p></blockquote><ol><li><strong>校验概述</strong></li></ol><p>JSR 303 是 Java 为 Bean 数据合法性校验提供的标准框架，它已经包含在 JavaEE 6.0 标准中。JSR 303 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Null</td><td>标注值必须为 null</td></tr><tr><td>@NotNull</td><td>标注值不可为 null</td></tr><tr><td>@AssertTrue</td><td>标注值必须为 true</td></tr><tr><td>@AssertFalse</td><td>标注值必须为 false</td></tr><tr><td>@Min(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@Max(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@DecimalMin(value)</td><td>标注值必须大于或等于 value</td></tr><tr><td>@DecimalMax(value)</td><td>标注值必须小于或等于 value</td></tr><tr><td>@Size(max,min)</td><td>标注值大小必须在 max 和 min 限定的范围内</td></tr><tr><td>@Digits(integer,fratction)</td><td>标注值值必须是一个数字，且必须在可接受的范围内</td></tr><tr><td>@Past</td><td>标注值只能用于日期型，且必须是过去的日期</td></tr><tr><td>@Future</td><td>标注值只能用于日期型，且必须是将来的日期</td></tr><tr><td>@Pattern(value)</td><td>标注值必须符合指定的正则表达式</td></tr></tbody></table><p>JSR 303 只是一套标准，需要提供其实现才可以使用。Hibernate Validator 是 JSR 303 的一个参考实现，除支持所有标准的校验注解外，它还支持以下的扩展注解：</p><table><thead><tr><th>注解</th><th>规则</th></tr></thead><tbody><tr><td>@Email</td><td>标注值必须是格式正确的 Email 地址</td></tr><tr><td>@Length</td><td>标注值字符串大小必须在指定的范围内</td></tr><tr><td>@NotEmpty</td><td>标注值字符串不能是空字符串</td></tr><tr><td>@Range</td><td>标注值必须在指定的范围内</td></tr></tbody></table><p>Spring 4.0 版本已经拥有自己独立的数据校验框架，同时支持 JSR 303 标准的校验框架。Spring 在进行数据绑定时，可同时调用校验框架完成数据校验工作。在SpringMVC 中，可直接通过注解驱动 @EnableWebMvc 的方式进行数据校验。Spring 的 LocalValidatorFactoryBean 既实现了 Spring 的 Validator 接口，也实现了 JSR 303 的 Validator 接口。只要在Spring容器中定义了一个LocalValidatorFactoryBean，即可将其注入到需要数据校验的 Bean中。Spring本身并没有提供JSR 303的实现，所以必须将JSR 303的实现者的jar包放到类路径下。</p><p>配置 @EnableWebMvc后，SpringMVC 会默认装配好一个 LocalValidatorFactoryBean，通过在处理方法的入参上标注 @Validated 注解即可让 SpringMVC 在完成数据绑定后执行数据校验的工作。<br>2. <strong>操作演示</strong></p><ul><li>导入依赖</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 校验注解 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.jakartaee-web-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>9.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 校验注解实现--&gt;</span>        </span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator-annotation-processor --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator-annotation-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>应用校验注解</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="comment">//age   1 &lt;=  age &lt; = 150</span></span><br><span class="line"><span class="meta">@Min(10)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//name 3 &lt;= name.length &lt;= 6</span></span><br><span class="line"><span class="meta">@Length(min = 3,max = 10)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//email 邮箱格式</span></span><br><span class="line"><span class="meta">@Email</span></span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>handler标记和绑定错误收集</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Validated</span> 代表应用校验注解! 必须添加!</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;save&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">save</span><span class="params">(<span class="meta">@Validated</span> <span class="meta">@RequestBody</span> User user,</span></span><br><span class="line"><span class="params">//在实体类参数和 BindingResult 之间不能有任何其他参数, BindingResult可以接受错误信息,避免信息抛出!</span></span><br><span class="line"><span class="params">BindingResult result)</span>&#123;</span><br><span class="line"><span class="comment">//判断是否有信息绑定错误! 有可以自行处理!</span></span><br><span class="line"><span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> result.getFieldError().toString();</span><br><span class="line"><span class="keyword">return</span> errorMsg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有,正常处理业务即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;正常&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>易混总结</strong></li></ol><p>@NotNull、@NotEmpty、@NotBlank 都是用于在数据校验中检查字段值是否为空的注解，但是它们的用法和校验规则有所不同。</p><ol><li>@NotNull  (包装类型不为null)</li></ol><p>@NotNull 注解是 JSR 303 规范中定义的注解，当被标注的字段值为 null 时，会认为校验失败而抛出异常。该注解不能用于字符串类型的校验，若要对字符串进行校验，应该使用 @NotBlank 或 @NotEmpty 注解。<br>2. @NotEmpty (集合类型长度大于0)</p><p>@NotEmpty 注解同样是 JSR 303 规范中定义的注解，对于 CharSequence、Collection、Map 或者数组对象类型的属性进行校验，校验时会检查该属性是否为 Null 或者 size()&#x3D;&#x3D;0，如果是的话就会校验失败。但是对于其他类型的属性，该注解无效。需要注意的是只校验空格前后的字符串，如果该字符串中间只有空格，不会被认为是空字符串，校验不会失败。<br>3. @NotBlank （字符串，不为null，切不为”  “字符串）</p><p>@NotBlank 注解是 Hibernate Validator 附加的注解，对于字符串类型的属性进行校验，校验时会检查该属性是否为 Null 或 “” 或者只包含空格，如果是的话就会校验失败。需要注意的是，@NotBlank 注解只能用于字符串类型的校验。</p><p>总之，这三种注解都是用于校验字段值是否为空的注解，但是其校验规则和用法有所不同。在进行数据校验时，需要根据具体情况选择合适的注解进行校验。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/faa8450.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MyBatis框架入门</title>
      <link>http://example.com/inori/6f411126.html</link>
      <guid>http://example.com/inori/6f411126.html</guid>
      <pubDate>Wed, 27 Mar 2024 01:55:00 GMT</pubDate>
      
      <description>MyBatis</description>
      
      
      
      <content:encoded><![CDATA[<p>​MyBatis是一款优秀的持久层框架，它支持自定义SQL、存储过程以及高级映射。MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作。MyBatis可以通过简单的XML或注解来配置和映射原始类型、接口和Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="向SQL语句传参"><a href="#向SQL语句传参" class="headerlink" title="向SQL语句传参"></a>向SQL语句传参</h3><h4 id="mybatis日志输出配置"><a href="#mybatis日志输出配置" class="headerlink" title="mybatis日志输出配置"></a><strong>mybatis日志输出配置</strong></h4><p>mybatis配置文件设计标签和顶层结构如下：</p><ul><li>configuration（配置）</li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#environments">environments（环境配置）</a></li><li>environment（环境变量）</li><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a></li><li><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></li></ul><p>我们可以在mybatis的配置文件使用<strong>settings标签</strong>设置，输出运行过程SQL日志，通过查看日志，我们可以判定#{}和${}的输出效果</p><h4 id="形式"><a href="#形式" class="headerlink" title="#{}形式"></a><strong>#{}形式</strong></h4><p>Mybatis会将SQL语句中的<code>#&#123;&#125;</code>转换为问号占位符</p><h4 id="形式-1"><a href="#形式-1" class="headerlink" title="${}形式"></a><strong>${}形式</strong></h4><p><code>$&#123;&#125;</code>形式传参，底层Mybatis做的是字符串拼接操作。通常不会采用<code>$&#123;&#125;</code>的方式传值。一个特定的适用场景是：通过Java程序动态生成数据库表，表名部分需要Java程序通过参数传入；而JDBC对于表名部分是不能使用问号占位符的，此时只能使用<code>$&#123;&#125;</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user where $&#123;column&#125; = #&#123;value&#125;&quot;)</span></span><br><span class="line">User <span class="title function_">findByColumn</span><span class="params">(<span class="meta">@Param(&quot;column&quot;)</span> String column, </span></span><br><span class="line"><span class="params"><span class="meta">@Param(&quot;value&quot;)</span> String value)</span>;</span><br></pre></td></tr></table></figure><h3 id="数据输入"><a href="#数据输入" class="headerlink" title="数据输入"></a>数据输入</h3><h4 id="Mybatis总体机制概括"><a href="#Mybatis总体机制概括" class="headerlink" title="Mybatis总体机制概括"></a><strong>Mybatis总体机制概括</strong></h4><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img005.ebd8c6a3.png"></p><h4 id="单个简单类型参数"><a href="#单个简单类型参数" class="headerlink" title="单个简单类型参数"></a><strong>单个简单类型参数</strong></h4><p>Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee <span class="title function_">selectEmployee</span><span class="params">(Integer empId)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>单个简单类型参数，在#{}中可以随意命名，但是没有必要。通常还是使用和接口方法参数同名</p></blockquote><h4 id="实体类类型参数"><a href="#实体类类型参数" class="headerlink" title="实体类类型参数"></a><strong>实体类类型参数</strong></h4><p>Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertEmployee</span><span class="params">(Employee employee)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmployee&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp(emp_name,emp_salary) values(#&#123;empName&#125;,#&#123;empSalary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应关系<br><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img006.f9958c52.png"><br>Mybatis会根据#{}中传入的数据，加工成getXxx()方法，通过反射在实体类对象中调用这个方法，从而获取到对应的数据。填充到#{}解析后的问号占位符这个位置</p><h4 id="零散的简单类型数据"><a href="#零散的简单类型数据" class="headerlink" title="零散的简单类型数据"></a><strong>零散的简单类型数据</strong></h4><p>零散的多个简单类型参数，如果没有特殊处理，那么Mybatis无法识别自定义名称,需要在Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">updateEmployee</span><span class="params">(<span class="meta">@Param(&quot;empId&quot;)</span> Integer empId,<span class="meta">@Param(&quot;empSalary&quot;)</span> Double empSalary)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployee&quot;</span>&gt;</span></span><br><span class="line">update t_emp set emp_salary=#&#123;empSalary&#125; where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应关系<br><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img007.976da128.png"></p><h4 id="Map类型参数"><a href="#Map类型参数" class="headerlink" title="Map类型参数"></a><strong>Map类型参数</strong></h4><p>Mapper接口中抽象方法的声明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">updateEmployeeByMap</span><span class="params">(Map&lt;String, Object&gt; paramMap)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeByMap&quot;</span>&gt;</span></span><br><span class="line">update t_emp set emp_salary=#&#123;empSalaryKey&#125; where emp_id=#&#123;empIdKey&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>junit测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession session;</span><br><span class="line"><span class="comment">//junit5会在每一个@Test方法前执行@BeforeEach方法</span></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">session = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>()</span><br><span class="line">.build(</span><br><span class="line">Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line">.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUpdateEmpNameByMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">EmployeeMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> session.getMapper(EmployeeMapper.class);</span><br><span class="line">Map&lt;String, Object&gt; paramMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">&quot;empSalaryKey&quot;</span>, <span class="number">999.99</span>);</span><br><span class="line">paramMap.put(<span class="string">&quot;empIdKey&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.updateEmployeeByMap(paramMap);</span><br><span class="line">log.info(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//junit5会在每一个@Test方法后执行@@AfterEach方法</span></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对应关系</strong>：#{}中写Map中的key<br><strong>使用场景</strong>：有很多零散的参数需要传递，但是没有对应的实体类类型可以使用。使用@Param注解一个一个传入又太麻烦了。所以都封装到Map中。</p><h3 id="数据输出"><a href="#数据输出" class="headerlink" title="数据输出"></a>数据输出</h3><p>数据输出总体上有两种形式：</p><ul><li>增删改操作返回的受影响行数：直接使用 int 或 long 类型接收即可</li><li>查询操作的查询结果</li></ul><p>我们需要做的是，指定查询的输出数据类型即可</p><h4 id="单个简单类型"><a href="#单个简单类型" class="headerlink" title="单个简单类型"></a>单个简单类型</h4><p>Mapper接口中的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">selectEmpCount</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">select count(*) from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Mybatis 内部给常用的数据类型设定了很多别名。 以 int 类型为例，可以写的名称有：int、integer、Integer、java.lang.Integer、Int、INT、INTEGER 等等。</p></blockquote><p><strong>细节解释：</strong><br>select标签，通过resultType指定查询返回值类型<br>resultType &#x3D; 全限定符 ｜ 别名 ｜ 如果是返回集合类型，写范型类型即可<br>别名问题：<a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases</a><br>类型别名可为Java类型设置一个缩写名字。 它仅用于XML配置，意在降低冗余的全限定类名书写</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当这样配置时，<code>Blog</code>可以用在任何使用domain.blog.Blog的地方，也可以指定一个包名，MyBatis会在包名下面搜索需要的Java Bean，比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span> <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span> <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。见下面的例子</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是Mybatis为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。</p><table><thead><tr><th>别名</th><th>映射的类型</th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_char (since 3.5.10)</td><td>char</td></tr><tr><td>_character (since 3.5.10)</td><td>char</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>char (since 3.5.10)</td><td>Character</td></tr><tr><td>character (since 3.5.10)</td><td>Character</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>biginteger</td><td>BigInteger</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>object[]</td><td>Object[]</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr></tbody></table><h4 id="返回实体类对象Mapper"><a href="#返回实体类对象Mapper" class="headerlink" title="返回实体类对象Mapper"></a>返回实体类对象Mapper</h4><p>接口的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee <span class="title function_">selectEmployee</span><span class="params">(Integer empId)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;</span></span><br><span class="line">select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过给数据库表字段加别名，让查询结果的每一列都和Java实体类中属性对应起来<br>增加全局配置自动识别对应关系，Mybatis全局配置文件中，做了下面的配置，select语句中可以不给字段设置别名</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在全局范围内对Mybatis进行配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 从org.apache.ibatis.session.Configuration类中可以查看能使用的配置项 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将mapUnderscoreToCamelCase属性配置为true，表示开启自动映射驼峰式命名规则 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 规则要求数据库表字段命名方式：单词_单词 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 规则要求Java实体类属性名命名方式：首字母小写的驼峰式命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="返回主键值"><a href="#返回主键值" class="headerlink" title="返回主键值"></a>返回主键值</h4><ol><li><strong>自增长类型主键</strong></li></ol><p>Mapper接口中的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">insertEmployee</span><span class="params">(Employee employee)</span>;</span><br></pre></td></tr></table></figure><p>SQL语句</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int insertEmployee(Employee employee); --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- useGeneratedKeys属性字面意思就是“使用生成的主键” --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- keyProperty属性可以指定主键在实体类对象中对应的属性名，Mybatis会将拿到的主键值存入这个属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertEmployee&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;empId&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp(emp_name,emp_salary)</span><br><span class="line">values(#&#123;empName&#125;,#&#123;empSalary&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>junit测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSaveEmp</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">EmployeeMapper</span> <span class="variable">employeeMapper</span> <span class="operator">=</span> session.getMapper(EmployeeMapper.class);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    employee.setEmpName(<span class="string">&quot;john&quot;</span>);</span><br><span class="line">    employee.setEmpSalary(<span class="number">666.66</span>);</span><br><span class="line">    employeeMapper.insertEmployee(employee);</span><br><span class="line">    log.info(<span class="string">&quot;employee.getEmpId() = &quot;</span> + employee.getEmpId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><p>Mybatis是将自增主键的值设置到实体类对象中，而不是以Mapper接口方法返回值的形式返回。<br>2. <strong>非自增长类型主键</strong></p><p>而对于不支持自增型主键的数据库（例如 Oracle）或者字符串类型主键，则可以使用 selectKey 子元素：selectKey 元素将会首先运行，id 会被设置，然后插入语句会被调用！</p><p>使用 <code>selectKey</code> 帮助插入UUID作为字符串类型主键示例：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span>&gt;</span></span><br><span class="line">SELECT UUID() as id</span><br><span class="line"><span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    INSERT INTO user (id, username, password) </span><br><span class="line">    VALUES (</span><br><span class="line">    #&#123;id&#125;,</span><br><span class="line">    #&#123;username&#125;,</span><br><span class="line">    #&#123;password&#125;</span><br><span class="line">    )</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上例中定义了一个<code>insertUser</code>的插入语句来将 <code>User</code> 对象插入到 <code>user</code> 表中。我们使用<code>selectKey</code>来查询 UUID 并设置到 <code>id</code>字段中。</p><p>通过 <code>keyProperty</code> 属性来指定查询到的 UUID 赋值给对象中的 <code>id</code> 属性，而 <code>resultType</code> 属性指定了 UUID 的类型为 <code>java.lang.String</code></p><p>需要注意的是，我们将 <code>selectKey</code> 放在了插入语句的前面，这是因为 MySQL 在 <code>insert</code> 语句中只支持一个 <code>select</code> 子句，而 <code>selectKey</code> 中查询 UUID 的语句就是一个 <code>select</code> 子句，因此我们需要将其放在前面。</p><p>最后，在将<code>User</code>对象插入到 <code>user</code> 表中时，我们直接使用对象中的 <code>id</code> 属性来插入主键值。</p><p>使用这种方式，可以方便地插入 UUID 作为字符串类型主键。</p><h4 id="实体类属性和数据库字段对应关系"><a href="#实体类属性和数据库字段对应关系" class="headerlink" title="实体类属性和数据库字段对应关系"></a>实体类属性和数据库字段对应关系</h4><ol><li>别名对应</li></ol><p>将字段的别名设置成和实体类属性一致。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编写具体的SQL语句，使用id属性唯一的标记一条SQL语句 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultType属性：指定封装查询结果的Java实体类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis负责把SQL语句中的#&#123;&#125;部分替换成“?”占位符 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给每一个字段设置一个别名，让别名和Java实体类中属性名一致 --&gt;</span></span><br><span class="line">select emp_id empId,emp_name empName,emp_salary empSalary from t_emp where emp_id=#&#123;maomi&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>关于实体类属性的约定：</p></blockquote><p>getXxx()方法、setXxx()方法把方法名中的get或set去掉，首字母小写。<br>2. 全局配置自动识别驼峰式命名规则</p><p>在Mybatis全局配置文件加入如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用settings对Mybatis全局进行设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将xxx_xxx这样的列名自动映射到xxXxx这样驼峰式命名的属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SQL语句中可以不使用别名</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Employee selectEmployee(Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployee&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用resultMap</li></ol><p>使用resultMap标签定义对应关系，再在后面的SQL语句中引用这个对应关系</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 专门声明一个resultMap设定column到property之间的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用id标签设置主键列和主键属性之间的对应关系 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- column属性用于指定字段名；property属性用于指定Java实体类属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;emp_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用result标签设置普通字段和Java实体类属性之间的关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;emp_salary&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empSalary&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Employee selectEmployeeByRM(Integer empId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByRM&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectEmployeeByRMResultMap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp where emp_id=#&#123;empId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mapperXML标签总结"><a href="#mapperXML标签总结" class="headerlink" title="mapperXML标签总结"></a>mapperXML标签总结</h3><p>MyBatis 的真正强大在于它的语句映射，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 致力于减少使用成本，让用户能更专注于 SQL 代码。</p><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>insert</code> – 映射插入语句。</li><li><code>update</code> – 映射更新语句。</li><li><code>delete</code> – 映射删除语句。</li><li><code>select</code> – 映射查询语句。</li></ul><p><strong>select标签：</strong></p><p>MyBatis 在查询和结果映射做了相当多的改进。一个简单查询的 select 元素是非常简单：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPerson&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;自定义结构&quot;</span>&gt;</span> SELECT * FROM PERSON WHERE ID = #&#123;id&#125; <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个语句名为 selectPerson，接受一个 int（或 Integer）类型的参数，并返回一个 HashMap 类型的对象，其中的键是列名，值便是结果行中的对应值。</p><p>注意参数符号：#{id}  ${key}</p><p>MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 近似的 JDBC 代码，非 MyBatis 代码...</span></span><br><span class="line"><span class="type">String</span> <span class="variable">selectPerson</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM PERSON WHERE ID=?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> conn.prepareStatement(selectPerson);</span><br><span class="line">ps.setInt(<span class="number">1</span>,id);</span><br></pre></td></tr></table></figure><p>select 元素允许你配置很多属性来配置每条语句的行为细节：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>resultType</code></td><td>期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td><code>resultMap</code></td><td>对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td><code>timeout</code></td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td><code>statementType</code></td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr></tbody></table><p><strong>insert, update 和 delete标签：</strong></p><p>数据变更语句 insert，update 和 delete 的实现非常接近：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">keyProperty</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">keyColumn</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">useGeneratedKeys</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;updateAuthor&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;deleteAuthor&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td><code>timeout</code></td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td><code>statementType</code></td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td><code>useGeneratedKeys</code></td><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td><code>keyProperty</code></td><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td><code>keyColumn</code></td><td>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr></tbody></table><h2 id="MyBatis多表映射"><a href="#MyBatis多表映射" class="headerlink" title="MyBatis多表映射"></a>MyBatis多表映射</h2><h3 id="对一映射"><a href="#对一映射" class="headerlink" title="对一映射"></a>对一映射</h3><ol><li>需求说明</li></ol><p>根据ID查询订单，以及订单关联的用户的信息！<br>2. OrderMapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">Order <span class="title function_">selectOrderWithCustomer</span><span class="params">(Integer orderId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>OrderMapper.xml配置文件</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建resultMap实现“对一”关联关系映射 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id属性：通常设置为这个resultMap所服务的那条SQL语句的id加上“ResultMap” --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- type属性：要设置为这个resultMap所服务的那条SQL语句最终要返回的类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;selectOrderWithCustomerResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;order&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 先设置Order自身属性和字段的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderId&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;order_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;orderName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用association标签配置“对一”关联关系 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- property属性：在Order类中对一的一端进行引用时使用的属性名 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- javaType属性：一的一端类的全类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;customer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置Customer类的属性和字段名之间的对应关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;customer_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerId&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;customer_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;customerName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Order selectOrderWithCustomer(Integer orderId); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectOrderWithCustomer&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;selectOrderWithCustomerResultMap&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">SELECT order_id,order_name,c.customer_id,customer_name</span><br><span class="line">FROM t_order o</span><br><span class="line">LEFT JOIN t_customer c</span><br><span class="line">ON o.customer_id=c.customer_id</span><br><span class="line">WHERE o.order_id=#&#123;orderId&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应关系可以参考下图：</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img018.6c3cfc17.png"><br>4. Mybatis全局注册Mapper文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/OrderMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>junit测试程序</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> SqlSession session;</span><br><span class="line"><span class="comment">// junit会在每一个@Test方法前执行@BeforeEach方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">session = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>()</span><br><span class="line">.build(</span><br><span class="line">Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>))</span><br><span class="line">.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRelationshipToOne</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">OrderMapper</span> <span class="variable">orderMapper</span> <span class="operator">=</span> session.getMapper(OrderMapper.class);</span><br><span class="line"><span class="comment">// 查询Order对象，检查是否同时查询了关联的Customer对象</span></span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectOrderWithCustomer(<span class="number">2</span>);</span><br><span class="line">log.info(<span class="string">&quot;order = &quot;</span> + order);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// junit会在每一个@Test方法后执行@@AfterEach方法</span></span><br><span class="line"><span class="meta">@AfterEach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">session.commit();</span><br><span class="line">session.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>关键词</li></ol><p>在“对一”关联关系中，我们的配置比较多，但是关键词就只有：<strong>association</strong>和<strong>javaType</strong></p><h3 id="对多映射"><a href="#对多映射" class="headerlink" title="对多映射"></a>对多映射</h3><ol><li>需求说明</li></ol><p>查询客户和客户关联的订单信息！<br>2. CustomerMapper接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CustomerMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">Customer <span class="title function_">selectCustomerWithOrderList</span><span class="params">(Integer customerId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>CustomerMapper.xml文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置resultMap实现从Customer到OrderList的“对多”关联关系 --&gt;</span><br><span class="line">&lt;resultMap id=<span class="string">&quot;selectCustomerWithOrderListResultMap&quot;</span></span><br><span class="line"></span><br><span class="line">type=<span class="string">&quot;customer&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 映射Customer本身的属性 --&gt;</span><br><span class="line">&lt;id column=<span class="string">&quot;customer_id&quot;</span> property=<span class="string">&quot;customerId&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;result column=<span class="string">&quot;customer_name&quot;</span> property=<span class="string">&quot;customerName&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- collection标签：映射“对多”的关联关系 --&gt;</span><br><span class="line">&lt;!-- property属性：在Customer类中，关联“多”的一端的属性名 --&gt;</span><br><span class="line">&lt;!-- ofType属性：集合属性中元素的类型 --&gt;</span><br><span class="line">&lt;collection property=<span class="string">&quot;orderList&quot;</span> ofType=<span class="string">&quot;order&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 映射Order的属性 --&gt;</span><br><span class="line">&lt;id column=<span class="string">&quot;order_id&quot;</span> property=<span class="string">&quot;orderId&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;result column=<span class="string">&quot;order_name&quot;</span> property=<span class="string">&quot;orderName&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/collection&gt;</span><br><span class="line"></span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Customer <span class="title function_">selectCustomerWithOrderList</span><span class="params">(Integer customerId)</span>; --&gt;</span><br><span class="line">&lt;select id=<span class="string">&quot;selectCustomerWithOrderList&quot;</span> resultMap=<span class="string">&quot;selectCustomerWithOrderListResultMap&quot;</span>&gt;</span><br><span class="line">SELECT c.customer_id,c.customer_name,o.order_id,o.order_name</span><br><span class="line">FROM t_customer c</span><br><span class="line">LEFT JOIN t_order o</span><br><span class="line">ON c.customer_id=o.customer_id</span><br><span class="line">WHERE c.customer_id=#&#123;customerId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>对应关系可以参考下图：</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img019.dba418c1.png"><br>4. Mybatis全局注册Mapper文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册Mapper配置文件：告诉Mybatis我们的Mapper配置文件的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在mapper标签的resource属性中指定Mapper配置文件以“类路径根目录”为基准的相对路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/OrderMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/CustomerMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="5"><li>junit测试程序</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRelationshipToMulti</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">CustomerMapper</span> <span class="variable">customerMapper</span> <span class="operator">=</span> session.getMapper(CustomerMapper.class);</span><br><span class="line"><span class="comment">// 查询Customer对象同时将关联的Order集合查询出来</span></span><br><span class="line"><span class="type">Customer</span> <span class="variable">customer</span> <span class="operator">=</span> customerMapper.selectCustomerWithOrderList(<span class="number">1</span>);</span><br><span class="line">log.info(<span class="string">&quot;customer.getCustomerId() = &quot;</span> + customer.getCustomerId());</span><br><span class="line">log.info(<span class="string">&quot;customer.getCustomerName() = &quot;</span> + customer.getCustomerName());</span><br><span class="line">List&lt;Order&gt; orderList = customer.getOrderList();</span><br><span class="line"><span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">log.info(<span class="string">&quot;order = &quot;</span> + order);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>关键词</li></ol><p>在“对多”关联关系中，同样有很多配置，但是提炼出来最关键的就是：“collection”和“ofType”</p><h3 id="多表映射优化"><a href="#多表映射优化" class="headerlink" title="多表映射优化"></a>多表映射优化</h3><table><thead><tr><th>setting属性</th><th>属性含义</th><th>可选值</th><th>默认值</th></tr></thead><tbody><tr><td>autoMappingBehavior</td><td>指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。</td><td>NONE, PARTIAL, FULL</td><td>PARTIAL</td></tr></tbody></table><p>我们可以将autoMappingBehavior设置为full,进行多表resultMap映射的时候，可以省略符合列和属性命名映射规则（列名&#x3D;属性名，或者开启驼峰映射也可以自定映射）的result标签！</p><p>修改mybati-sconfig.xml:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启resultMap自动映射 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;FULL&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>修改teacherMapper.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;teacherMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;teacher&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;tId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;t_id&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启自动映射,并且开启驼峰式支持!可以省略 result!--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;result property=&quot;tName&quot; column=&quot;t_name&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;student&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;sId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;s_id&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;result property=&quot;sName&quot; column=&quot;s_name&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多表映射总结"><a href="#多表映射总结" class="headerlink" title="多表映射总结"></a>多表映射总结</h3><table><thead><tr><th>关联关系</th><th>配置项关键词</th><th>所在配置文件和具体位置</th></tr></thead><tbody><tr><td>对一</td><td>association标签&#x2F;javaType属性&#x2F;property属性</td><td>Mapper配置文件中的resultMap标签内</td></tr><tr><td>对多</td><td>collection标签&#x2F;ofType属性&#x2F;property属性</td><td>Mapper配置文件中的resultMap标签内</td></tr></tbody></table><h2 id="MyBatis动态语句"><a href="#MyBatis动态语句" class="headerlink" title="MyBatis动态语句"></a>MyBatis动态语句</h2><h3 id="if和where标签"><a href="#if和where标签" class="headerlink" title="if和where标签"></a>if和where标签</h3><p>使用动态 SQL 最常见情景是根据条件包含 where  &#x2F; if 子句的一部分。比如：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByCondition(Employee employee); --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;employee&quot;</span>&gt;</span></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp</span><br><span class="line"><span class="comment">&lt;!-- where标签会自动去掉“标签体内前面多余的and/or” --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用if标签，让我们可以有选择的加入SQL语句的片段。这个SQL语句片段是否要加入整个SQL语句，就看if标签判断的结果是否为true --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在if标签的test属性中，可以访问实体类的属性，不可以访问数据库表的字段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在if标签内部，需要访问接口的参数时还是正常写#&#123;&#125; --&gt;</span></span><br><span class="line">or emp_name=#&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;gt;</span> 2000&quot;</span>&gt;</span></span><br><span class="line">or emp_salary&gt;#&#123;empSalary&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">第一种情况：所有条件都满足 WHERE emp_name=? or emp_salary&gt;?</span></span><br><span class="line"><span class="comment">第二种情况：部分条件满足 WHERE emp_salary&gt;?</span></span><br><span class="line"><span class="comment">第三种情况：所有条件都不满足 没有where子句</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- void updateEmployeeDynamic(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeDynamic&quot;</span>&gt;</span></span><br><span class="line">update t_emp</span><br><span class="line"><span class="comment">&lt;!-- set emp_name=#&#123;empName&#125;,emp_salary=#&#123;empSalary&#125; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用set标签动态管理set子句，并且动态去掉两端多余的逗号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span></span><br><span class="line">emp_name=#&#123;empName&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span></span><br><span class="line">emp_salary=#&#123;empSalary&#125;,</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">where emp_id=#&#123;empId&#125;</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">第一种情况：所有条件都满足 SET emp_name=?, emp_salary=?</span></span><br><span class="line"><span class="comment">第二种情况：部分条件满足 SET emp_salary=?</span></span><br><span class="line"><span class="comment">第三种情况：所有条件都不满足 update t_emp where emp_id=?</span></span><br><span class="line"><span class="comment">没有set子句的update语句会导致SQL语法错误</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="choose-when-otherwise标签"><a href="#choose-when-otherwise标签" class="headerlink" title="choose&#x2F;when&#x2F;otherwise标签"></a>choose&#x2F;when&#x2F;otherwise标签</h3><p>在多个分支条件中，仅执行一个。</p><ul><li>从上到下依次执行条件判断</li><li>遇到的第一个满足条件的分支会被采纳</li><li>被采纳分支后面的分支都将不被考虑</li><li>如果所有的when分支都不满足，那么就执行otherwise分支</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Employee&gt; selectEmployeeByConditionByChoose(Employee employee) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmployeeByConditionByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;mybatis.entity.Employee&quot;</span>&gt;</span></span><br><span class="line">select emp_id,emp_name,emp_salary from t_emp</span><br><span class="line">where</span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null&quot;</span>&gt;</span>emp_name=#&#123;empName&#125;<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empSalary <span class="symbol">&amp;lt;</span> 3000&quot;</span>&gt;</span>emp_salary <span class="symbol">&amp;lt;</span> 3000<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>1=1<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">第一种情况：第一个when满足条件 where emp_name=?</span></span><br><span class="line"><span class="comment">第二种情况：第二个when满足条件 where emp_salary &lt; 3000</span></span><br><span class="line"><span class="comment">第三种情况：两个when都不满足 where 1=1 执行了otherwise</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p><strong>基本用法</strong></p><p>用批量插入举例</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">collection属性：要遍历的集合</span></span><br><span class="line"><span class="comment">item属性：遍历集合的过程中能得到每一个具体对象，在item属性中设置一个名字，将来通过这个名字引用遍历出来的对象</span></span><br><span class="line"><span class="comment">separator属性：指定当foreach标签的标签体重复拼接字符串时，各个标签体字符串之间的分隔符</span></span><br><span class="line"><span class="comment">open属性：指定整个循环把字符串拼好后，字符串整体的前面要添加的字符串</span></span><br><span class="line"><span class="comment">close属性：指定整个循环把字符串拼好后，字符串整体的后面要添加的字符串</span></span><br><span class="line"><span class="comment">index属性：这里起一个名字，便于后面引用</span></span><br><span class="line"><span class="comment">遍历List集合，这里能够得到List集合的索引值</span></span><br><span class="line"><span class="comment">遍历Map集合，这里能够得到Map集合的key</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;values&quot;</span> <span class="attr">index</span>=<span class="string">&quot;myIndex&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在foreach标签内部如果需要引用遍历得到的具体的一个对象，需要使用item属性声明的名称 --&gt;</span></span><br><span class="line">(#&#123;emp.empName&#125;,#&#123;myIndex&#125;,#&#123;emp.empSalary&#125;,#&#123;emp.empGender&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>批量更新时需要注意</strong></p><p>上面批量插入的例子本质上是一条SQL语句，而实现批量更新则需要多条SQL语句拼起来，用分号分开。也就是一次性发送多条SQL语句让数据库执行。此时需要在数据库连接信息的URL地址中设置：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dev.url=jdbc:mysql:///mybatis-example?allowMultiQueries=true</span><br></pre></td></tr></table></figure><p>对应的foreach标签如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int updateEmployeeBatch(@Param(&quot;empList&quot;) List&lt;Employee&gt; empList) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmployeeBatch&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;empList&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;;&quot;</span>&gt;</span></span><br><span class="line">update t_emp set emp_name=#&#123;emp.empName&#125; where emp_id=#&#123;emp.empId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>关于foreach标签的collection属性</strong></p><p>如果没有给接口中List类型的参数使用@Param注解指定一个具体的名字，那么在collection属性中默认可以使用collection或list来引用这个list集合。这一点可以通过异常信息看出来：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Parameter &#x27;empList&#x27; not found. Available parameters are [arg0, collection, list]</span><br></pre></td></tr></table></figure><p>在实际开发中，为了避免隐晦的表达造成一定的误会，建议使用@Param注解明确声明变量的名称，然后在foreach标签的collection属性中按照@Param注解指定的名称来引用传入的参数。</p><h3 id="sql片段"><a href="#sql片段" class="headerlink" title="sql片段"></a>sql片段</h3><p><strong>抽取重复的SQL片段</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用sql标签抽取重复出现的SQL片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;mySelectSql&quot;</span>&gt;</span></span><br><span class="line">select emp_id,emp_name,emp_age,emp_salary,emp_gender from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用已抽取的SQL片段</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用include标签引用声明的SQL片段 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;mySelectSql&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Mapper批量映射优化"><a href="#Mapper批量映射优化" class="headerlink" title="Mapper批量映射优化"></a>Mapper批量映射优化</h2><ol><li>需求</li></ol><p>Mapper配置文件很多时，在全局配置文件中一个一个注册太麻烦，希望有一个办法能够一劳永逸。<br>2. 配置方式</p><p>Mybatis允许在指定 Mapper 映射文件时，只指定其所在的包：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时这个包下的所有 Mapper 配置文件将被自动加载、注册，比较方便。<br>3. 资源创建要求</p><ul><li>Mapper 接口和 Mapper 配置文件名称一致</li><li>Mapper 接口：EmployeeMapper.java</li><li>Mapper 配置文件：EmployeeMapper.xml</li><li>Mapper 配置文件放在 Mapper 接口所在的包内</li><li>可以将mapperxml文件放在mapper接口所在的包！</li><li>可以在sources下创建mapper接口包一致的文件夹结构存放mapper.xml文件</li></ul><h2 id="MyBatis总结"><a href="#MyBatis总结" class="headerlink" title="MyBatis总结"></a>MyBatis总结</h2><table><thead><tr><th>核心点</th><th>掌握目标</th></tr></thead><tbody><tr><td>mybatis基础</td><td>使用流程, 参数输入,#{} ${},参数输出</td></tr><tr><td>mybatis多表</td><td>实体类设计,resultMap多表结果映射</td></tr><tr><td>mybatis动态语句</td><td>Mybatis动态语句概念, where , if , foreach标签</td></tr><tr><td>mybatis扩展</td><td>Mapper批量处理,分页插件,逆向工程</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/6f411126.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Spring框架入门</title>
      <link>http://example.com/inori/6c8c2c4f.html</link>
      <guid>http://example.com/inori/6c8c2c4f.html</guid>
      <pubDate>Tue, 26 Mar 2024 10:17:02 GMT</pubDate>
      
      <description>Spring</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Spring与SpringFramework"><a href="#Spring与SpringFramework" class="headerlink" title="Spring与SpringFramework"></a>Spring与SpringFramework</h2><p><strong>广义的 Spring：Spring 技术栈</strong>（全家桶）</p><p>广义上的 Spring 泛指以 Spring Framework 为基础的 Spring 技术栈。</p><p>经过十多年的发展，Spring 已经不再是一个单纯的应用框架，而是逐渐发展成为一个由多个不同子项目（模块）组成的成熟技术，例如 Spring Framework、Spring MVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，其中 Spring Framework 是其他子项目的基础。</p><p>这些子项目涵盖了从企业级应用开发到云计算等各方面的内容，能够帮助开发人员解决软件发展过程中不断产生的各种实际问题，给开发人员带来了更好的开发体验。</p><p><strong>狭义的 Spring：Spring Framework</strong>（基础框架）</p><p>狭义的 Spring 特指 Spring Framework，通常我们将它称为 Spring 框架。</p><p>Spring Framework（Spring框架）是一个开源的应用程序框架，由SpringSource公司开发，最初是为了解决企业级开发中各种常见问题而创建的。它提供了很多功能，例如：依赖注入（Dependency Injection）、面向切面编程（AOP）、声明式事务管理（TX）等。其主要目标是使企业级应用程序的开发变得更加简单和快速，并且Spring框架被广泛应用于Java企业开发领域。</p><p>Spring全家桶的其他框架都是以SpringFramework框架为基础</p><h2 id="SpringFramework主要功能"><a href="#SpringFramework主要功能" class="headerlink" title="SpringFramework主要功能"></a>SpringFramework主要功能</h2><table><thead><tr><th>功能模块</th><th>功能介绍</th></tr></thead><tbody><tr><td>Core Container</td><td>核心容器，在 Spring 环境下使用任何功能都必须基于 IOC 容器。</td></tr><tr><td>AOP&amp;Aspects</td><td>面向切面编程</td></tr><tr><td>TX</td><td>声明式事务管理。</td></tr><tr><td>Spring MVC</td><td>提供了面向Web应用程序的集成功能。</td></tr></tbody></table><h2 id="Spring-IoC容器"><a href="#Spring-IoC容器" class="headerlink" title="Spring IoC容器"></a>Spring IoC容器</h2><p>IoC(Inversion of Control)控制反转，对象创建责任的反转，在spring中BeanFacotory是IoC容器的核心接口，负责实例化，定位，配置应用程序中的对象及建立这些对象间的依赖。XmlBeanFacotory实现BeanFactory接口，通过获取xml配置文件数据，组成应用对象及对象间的依赖关系<br>spring中有三种注入方式，一种是set注入，一种是接口注入，另一种是构造方法注入</p><p>IOC，字面理解是控制反转，即对象的控制权被反转了(是什么)。之前一个对象中依赖另一个对象，需要自己new出来，当对象间的依赖关系非常复杂时，这个过程就变得很繁琐，并且代码间的耦合会很高。现在可以通过Ioc容器来管理控制对象的生成，可以把对象的实例化过程简单化，代码间解耦(为什么)。具体可以从DI(Dependency Injection) DL(Dependency Lookup)两个角度理解Ioc。DI中注入的方式包括属性，构造器，setter注入，DL含义是通过容器的API来查找所依赖的资源和协作对象，从Ioc容器维护的bean map中取出来(怎么做)</p><h3 id="组件和组件管理"><a href="#组件和组件管理" class="headerlink" title="组件和组件管理"></a>组件和组件管理</h3><p>整个项目就是由各种组件搭建而成的，原本使用组件需要先new出来并赋值才能使用，现在有了Spring之后组件可以完全交给Spring框架进行管理，Spring框架替代了程序员原有的new对象和对象属性赋值动作等</p><p><img src="https://secure2.wostatic.cn/static/8LSuy5YWXmufYmPWM894rN/image.png?auth_key=1711448434-igtjNj6H9qouMJDfHrzR1E-0-1708de84eac4b57242780981def9cfef"></p><p>Spring具体的组件管理动作包含：</p><ul><li>组件对象实例化</li><li>组件属性属性赋值</li><li>组件对象之间引用</li><li>组件对象存活周期管理</li></ul><p>我们只需要编写元数据（配置文件）告知Spring管理哪些类组件和他们的关系即可！</p><p>注意：组件是映射到应用程序中所有可重用组件的Java对象，应该是可复用的功能对象！</p><ul><li>组件一定是对象</li><li>对象不一定是组件</li></ul><p>综上所述，Spring 充当一个组件容器，创建、管理、存储组件，减少了我们的编码压力，让我们更加专注进行业务编写！</p><h3 id="Spring-IoC容器和容器实现"><a href="#Spring-IoC容器和容器实现" class="headerlink" title="Spring IoC容器和容器实现"></a>Spring IoC容器和容器实现</h3><h4 id="普通和复杂容器"><a href="#普通和复杂容器" class="headerlink" title="普通和复杂容器"></a>普通和复杂容器</h4><blockquote><p>普通容器只能用来存储，没有更多功能。</p></blockquote><ul><li>数组</li><li>集合：List</li><li>集合：Set</li></ul><blockquote><p>复杂容器可以持续管理组件，从产生到销毁</p></blockquote><p>  如：Servlet容器能够管理Servlet(init,service,destroy)、Filter、Listener这样的组件的一生，所以它是一个复杂容器。</p><table><thead><tr><th>名称</th><th>时机</th><th>次数</th></tr></thead><tbody><tr><td>创建对象</td><td>默认情况：接收到第一次请求  修改启动顺序后：Web应用启动过程中</td><td>一次</td></tr><tr><td>初始化操作</td><td>创建对象之后</td><td>一次</td></tr><tr><td>处理请求</td><td>接收到请求</td><td>多次</td></tr><tr><td>销毁操作</td><td>Web应用卸载之前</td><td>一次</td></tr></tbody></table><p>SpringIoC容器也是一个复杂容器。它们不仅要负责创建组件的对象、存储组件的对象，还要负责调用组件的方法让它们工作，最终在特定情况下销毁组件。<br>Spring管理组件的容器，就是一个复杂容器，不仅存储组件，也可以管理组件之间依赖关系，并且创建和销毁组件等</p><h4 id="IoC容器具体接口和实现类"><a href="#IoC容器具体接口和实现类" class="headerlink" title="IoC容器具体接口和实现类"></a>IoC容器具体接口和实现类</h4><p><strong>SpringIoc容器接口</strong><br><code>BeanFactory</code> 接口提供了一种高级配置机制，能够管理任何类型的对象，它是SpringIoC容器标准化超接口！<br><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的子接口。它扩展了以下功能：</p><ul><li><p>更容易与 Spring 的 AOP 功能集成</p></li><li><p>消息资源处理（用于国际化）</p></li><li><p>特定于应用程序给予此接口实现，例如Web应用程序的 <code>WebApplicationContext</code></p><p>  简而言之，<code>BeanFactory</code> 提供了配置框架和基本功能，而 <code>ApplicationContext</code> 添加了更多特定于企业的功能<code>ApplicationContext</code>是<code>BeanFactory</code>的完整超集！</p></li></ul><p><strong>ApplicationContext容器实现类</strong></p><table><thead><tr><th>类型名</th><th>简介</th></tr></thead><tbody><tr><td>ClassPathXmlApplicationContext</td><td>通过读取类路径下的 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>FileSystemXmlApplicationContext</td><td>通过文件系统路径读取 XML 格式的配置文件创建 IOC 容器对象</td></tr><tr><td>AnnotationConfigApplicationContext</td><td>通过读取Java配置类创建 IOC 容器对象</td></tr><tr><td>WebApplicationContext</td><td>专门为 Web 应用准备，基于 Web 环境创建 IOC 容器对象，并将对象引入存入 ServletContext 域中。</td></tr></tbody></table><p><strong>SpringIoC容器管理配置方式</strong></p><p>Spring IoC容器使用多种形式的配置元数据。此配置元数据表示作为应用程序开发人员如何告诉Spring容器实例化、配置和组装应用程序中的对象。<br>Spring框架提供了多种配置方式：XML配置方式、注解方式和Java配置类方式</p><ol><li>XML配置方式：是Spring框架最早的配置方式之一，通过在XML文件中定义Bean及其依赖关系、Bean的作用域等信息，让Spring IoC容器来管理Bean之间的依赖关系。该方式从Spring框架的第一版开始提供支持</li><li>注解方式：从Spring 2.5版本开始提供支持，可以通过在Bean类上使用注解来代替XML配置文件中的配置信息。通过在Bean类上加上相应的注解（如@Component, @Service, @Autowired等），将Bean注册到Spring IoC容器中，这样Spring IoC容器就可以管理这些Bean之间的依赖关系</li><li>Java配置类方式：从Spring 3.0版本开始提供支持，通过Java类来定义Bean、Bean之间的依赖关系和配置信息，从而代替XML配置文件的方式。Java配置类是一种使用Java编写配置信息的方式，通过@Configuration、@Bean等注解来实现Bean和依赖关系的配置</li></ol><h4 id="SpringIoC-DI概念总结"><a href="#SpringIoC-DI概念总结" class="headerlink" title="SpringIoC&#x2F;DI概念总结"></a>SpringIoC&#x2F;DI概念总结</h4><ul><li><p><strong>IoC容器</strong></p><p>Spring IoC 容器，负责实例化、配置和组装 bean（组件）核心容器。容器通过读取配置元数据来获取有关要实例化、配置和组装组件的指令</p></li><li><p><strong>IoC（Inversion of Control）控制反转</strong></p><p>IoC主要是针对对象的创建和调用控制而言的，也就是说，当应用程序需要使用一个对象时，不再是应用程序直接创建该对象，而是由 IoC容器来创建和管理，即控制权由应用程序转移到IoC容器中，也就是“反转”了控制权。这种方式基本上是通过依赖查找的方式来实现的，即IoC容器维护着构成应用程序的对象，并负责创建这些对象</p></li><li><p><strong>DI (Dependency Injection) 依赖注入</strong></p><p>DI 是指在组件之间传递依赖关系的过程中，将依赖关系在容器内部进行处理，这样就不必在应用程序代码中硬编码对象之间的依赖关系，实现了对象之间的解耦合。在Spring中，DI是通过XML配置文件或注解的方式实现的。它提供了三种形式的依赖注入：构造函数注入、Setter方法注入和接口注入</p></li></ul><h2 id="Spring-IoC实践"><a href="#Spring-IoC实践" class="headerlink" title="Spring IoC实践"></a>Spring IoC实践</h2><h3 id="Spring-IoC-DI实现步骤"><a href="#Spring-IoC-DI实现步骤" class="headerlink" title="Spring IoC&#x2F;DI实现步骤"></a>Spring IoC&#x2F;DI实现步骤</h3><ol><li><strong>配置元数据（配置）</strong></li></ol><p>基于 XML 的配置元数据的基本结构：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">1</span>] <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">2</span>]&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处要添加一些约束，配置文件的标签并不是随意命名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">1</span>] <span class="attr">class</span>=<span class="string">&quot;...&quot;</span> [<span class="attr">2</span>]&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;...&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring IoC容器管理一个或多个组件。这些组件是使用你提供给容器的配置元数据（例如，以 XML <code>&lt;bean/&gt;</code> 定义的形式）创建的。<br><code>&lt;bean/&gt;</code>标签等于组件信息声明</p><ul><li><code>id</code>属性是标识单个 Bean 定义的字符串</li><li><code>class</code>属性定义 Bean 的类型并使用完全限定的类名</li></ul><ol start="2"><li><strong>实例化IoC容器</strong></li></ol><p>提供给 <code>ApplicationContext</code> 构造函数的位置路径是资源字符串地址，允许容器从各种外部资源（如本地文件系统、Java <code>CLASSPATH</code> 等）加载配置元数据。<br>选择一个合适的容器实现类，进行IoC容器的实例化工作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化ioc容器,读取外部配置文件,最终会在容器内进行ioc和di动作</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>获取Bean（组件）</strong></li></ol><p><code>ApplicationContext</code>是一个高级工厂的接口，能够维护不同 bean 及其依赖项的注册表。通过使用方法<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>，可以检索 bean 的实例。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建ioc容器对象，指定配置文件，ioc也开始实例组件对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;services.xml&quot;</span>, <span class="string">&quot;daos.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获取ioc容器的组件对象</span></span><br><span class="line"><span class="type">PetStoreService</span> <span class="variable">service</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;petStore&quot;</span>, PetStoreService.class);</span><br><span class="line"><span class="comment">//使用组件对象</span></span><br><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span><br></pre></td></tr></table></figure><h3 id="基于配置类方式管理Bean"><a href="#基于配置类方式管理Bean" class="headerlink" title="基于配置类方式管理Bean"></a>基于配置类方式管理Bean</h3><h4 id="完全注解开发理解"><a href="#完全注解开发理解" class="headerlink" title="完全注解开发理解"></a>完全注解开发理解</h4><p>​Spring完全注解配置是指通过Java配置类代码来配置Spring应用程序，使用注解来替代原本在XML配置文件中的配置。相对于XML配置，完全注解配置具有更强的类型安全性和更好的可读性。<br><strong>两种方式思维转化</strong>：<br>​<br><img src="https://secure2.wostatic.cn/static/uhRgky6LmFBAaYDJfS5SEm/image.png?auth_key=1711452973-o84mq7McYxi2kcJ7eJNooQ-0-8582a6ab10c941bc27775f9a4f2c775b"></p><h4 id="配置类和扫描注解"><a href="#配置类和扫描注解" class="headerlink" title="配置类和扫描注解"></a>配置类和扫描注解</h4><p><strong>xml+注解方式</strong></p><p>配置application.xml</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置自动扫描的包 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.包要精准,提高性能!</span></span><br><span class="line"><span class="comment">         2.会扫描指定的包和子包内容</span></span><br><span class="line"><span class="comment">         3.多个包可以使用,分割 例如: com.atguigu.controller,com.atguigu.service等</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.components&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入外部配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;application.properties&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试创建IoC容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xml方式配置文件使用ClassPathXmlApplicationContext容器读取</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line">               <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>配置类+注解方式（完全注解方式）</strong><br>使用<code>@Configuration</code>注解将一个普通的类标记为Spring的配置类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标注当前类是配置类，替代application.xml    </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//使用注解读取外部配置，替代 &lt;context:property-placeholder标签</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.properties&quot;)</span></span><br><span class="line"><span class="comment">//使用@ComponentScan注解,可以配置扫描包,替代&lt;context:component-scan标签</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>测试创建IoC容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigApplicationContext 根据配置类创建 IOC 容器对象</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">iocContainerAnnotation</span> <span class="operator">=</span> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfiguration.class);</span><br></pre></td></tr></table></figure><h4 id="Bean定义组件"><a href="#Bean定义组件" class="headerlink" title="@Bean定义组件"></a>@Bean定义组件</h4><p><strong>场景需求</strong>：将Druid连接池对象存储到IoC容器<br><strong>需求分析</strong>：第三方jar包的类，添加到ioc容器，无法使用@Component等相关注解！因为源码jar包内容为只读模式<br>配置类方式实现：<br><code>@Bean</code>注释用于指示方法实例化、配置和初始化要由Spring IoC容器管理的新对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标注当前类是配置类，替代application.xml    </span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//引入jdbc.properties文件</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;&quot;classpath:application.properties&quot;,&quot;classpath:jdbc.properties&quot;&#125;)</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.atguigu.components&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">//如果第三方类进行IoC管理,无法直接使用@Component相关注解</span></span><br><span class="line">    <span class="comment">//解决方案: xml方式可以使用&lt;bean标签</span></span><br><span class="line">    <span class="comment">//解决方案: 配置类方式,可以使用方法返回值+@Bean注解</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">createDataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.user&#125;&quot;)</span> String username,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span>String password,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span>String url,</span></span><br><span class="line"><span class="params">                                       <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>String driverClassName)</span>&#123;</span><br><span class="line">        <span class="comment">//使用Java代码实例化</span></span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种配置方式对比"><a href="#三种配置方式对比" class="headerlink" title="三种配置方式对比"></a>三种配置方式对比</h3><h4 id="XML方式配置"><a href="#XML方式配置" class="headerlink" title="XML方式配置"></a>XML方式配置</h4><ol><li>所有内容写到xml格式配置文件中</li><li>声明bean通过&lt;bean标签</li><li>&lt;bean标签包含基本信息（id,class）和属性信息 &lt;property name value &#x2F; ref</li><li>引入外部的properties文件可以通过&lt;context:property-placeholder</li><li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li></ol><h4 id="XML-注解方式配置"><a href="#XML-注解方式配置" class="headerlink" title="XML+注解方式配置"></a>XML+注解方式配置</h4><ol><li>注解负责标记IoC的类和进行属性装配</li><li>xml文件依然需要，需要通过&lt;context:component-scan标签指定注解范围</li><li>标记IoC注解：@Component,@Service,@Controller,@Repository </li><li>标记DI注解：@Autowired @Qualifier @Resource @Value</li><li>IoC具体容器实现选择ClassPathXmlApplicationContext对象</li></ol><h4 id="完全注解方式配置"><a href="#完全注解方式配置" class="headerlink" title="完全注解方式配置"></a>完全注解方式配置</h4><ol><li>完全注解方式指的是去掉xml文件，使用配置类 + 注解实现</li><li>xml文件替换成使用@Configuration注解标记的类</li><li>标记IoC注解：@Component,@Service,@Controller,@Repository </li><li>标记DI注解：@Autowired @Qualifier @Resource @Value</li><li><code>&lt;context:component-scan&gt;</code>标签指定注解范围使用@ComponentScan(basePackages &#x3D; {“”})替代</li><li><code>&lt;context:property-placeholder&gt;</code>引入外部配置文件使用@PropertySource({“classpath:application.properties”,”classpath:jdbc.properties”})替代</li><li><code>&lt;bean&gt;</code>标签使用@Bean注解和方法实现</li><li>IoC具体容器实现选择AnnotationConfigApplicationContext对象</li></ol><h3 id="整合Spring5-Test5搭建测试环境"><a href="#整合Spring5-Test5搭建测试环境" class="headerlink" title="整合Spring5-Test5搭建测试环境"></a>整合Spring5-Test5搭建测试环境</h3><ol><li><p>整合测试环境作用</p><p> 好处1：不需要自己创建IOC容器对象了</p><p> 好处2：任何需要的bean都可以在测试类中直接享受自动装配</p></li><li><p>导入相关依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>整合测试注解使用</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@SpringJUnitConfig(locations = &#123;&quot;classpath:spring-context.xml&quot;&#125;)  //指定配置文件xml</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = &#123;BeanConfig.class&#125;)</span>  <span class="comment">//指定配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Junit5IntegrationTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJunit5</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="为什么要有Spring-AOP"><a href="#为什么要有Spring-AOP" class="headerlink" title="为什么要有Spring AOP"></a>为什么要有Spring AOP</h3><p>业务代码已经被一些非核心的代码所混淆，并且占据了大量的空间，显然这种显示的调用过程成为了我们开发过程中的一个痛点，如何将类似这种的非核心的代码剥离出去成为一个迫切需要解决的问题。<br>诸如日志记录，登录权限控制，还有数据库事务的控制，数据库连接的创建和关闭等等，这些都充斥这大量重复性的模板代码</p><h3 id="解决技术代理模式"><a href="#解决技术代理模式" class="headerlink" title="解决技术代理模式"></a>解决技术代理模式</h3><p><strong>代理模式</strong></p><p>​二十三种设计模式中的一种，属于结构型模式。它的作用就是通过提供一个代理类，让我们在调用目标方法的时候，不再是直接对目标方法进行调用，而是通过代理类间接调用。让不属于目标方法核心逻辑的代码从目标方法中剥离出来——解耦。调用目标方法时先调用代理对象的方法，减少对目标方法的调用和打扰，同时让附加功能能够集中在一起也有利于统一维护。</p><p>相关术语：</p><ul><li>代理：将非核心逻辑剥离出来以后，封装这些非核心逻辑的类、对象、方法。</li><li>动词：指做代理这个动作，或这项工作</li><li>名词：扮演代理这个角色的类、对象、方法</li><li>目标：<strong>被代理</strong>“套用”了核心逻辑代码的类、对象、方法。<br>代理在开发中实现的方式具体有两种：静态代理，[动态代理技术]</li></ul><p><strong>动态代理</strong><br>动态代理技术分类</p><ul><li>JDK动态代理：JDK原生的实现方式，需要被代理的目标类必须<strong>实现接口</strong>！他会根据目标类的接口动态生成一个代理对象！代理对象和目标对象有相同的接口</li><li>cglib：通过继承被代理的目标类实现代理，所以不需要目标类实现接口</li></ul><h3 id="面向切面编程思维（AOP）"><a href="#面向切面编程思维（AOP）" class="headerlink" title="面向切面编程思维（AOP）"></a>面向切面编程思维（AOP）</h3><ol><li><strong>面向切面编程思想AOP</strong></li></ol><p>AOP：Aspect Oriented Programming面向切面编程<br>AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<br>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。<br>使用AOP，可以在不修改原来代码的基础上添加新功能</p><ol start="2"><li><strong>AOP思想主要的应用场景</strong></li></ol><p>AOP（面向切面编程）是一种编程范式，它通过将通用的横切关注点（如日志、事务、权限控制等）与业务逻辑分离，使得代码更加清晰、简洁、易于维护。AOP可以应用于各种场景，以下是一些常见的AOP应用场景：</p><ul><li><p>日志记录：在系统中记录日志是非常重要的，可以使用AOP来实现日志记录的功能，可以在方法执行前、执行后或异常抛出时记录日志。</p></li><li><p>事务处理：在数据库操作中使用事务可以保证数据的一致性，可以使用AOP来实现事务处理的功能，可以在方法开始前开启事务，在方法执行完毕后提交或回滚事务。</p></li><li><p>安全控制：在系统中包含某些需要安全控制的操作，如登录、修改密码、授权等，可以使用AOP来实现安全控制的功能。可以在方法执行前进行权限判断，如果用户没有权限，则抛出异常或转向到错误页面，以防止未经授权的访问。</p></li><li><p>性能监控：在系统运行过程中，有时需要对某些方法的性能进行监控，以找到系统的瓶颈并进行优化。可以使用AOP来实现性能监控的功能，可以在方法执行前记录时间戳，在方法执行完毕后计算方法执行时间并输出到日志中。</p></li><li><p>异常处理：系统中可能出现各种异常情况，如空指针异常、数据库连接异常等，可以使用AOP来实现异常处理的功能，在方法执行过程中，如果出现异常，则进行异常处理（如记录日志、发送邮件等）。</p></li><li><p>缓存控制：在系统中有些数据可以缓存起来以提高访问速度，可以使用AOP来实现缓存控制的功能，可以在方法执行前查询缓存中是否有数据，如果有则返回，否则执行方法并将方法返回值存入缓存中。</p></li><li><p>动态代理：AOP的实现方式之一是通过动态代理，可以代理某个类的所有方法，用于实现各种功能。</p></li></ul><ol start="3"><li><strong>AOP术语名词介绍</strong></li></ol><ul><li>横切关注点</li></ul><p>​从每个方法中抽取出来的同一类非核心业务。在同一个项目中，我们可以使用多个横切关注点对相关方法进行多个不同方面的增强。这个概念不是语法层面天然存在的，而是根据附加功能的逻辑上的需要：有十个附加功能，就有十个横切关注点。<br>​AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事务、异常等。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><ul><li><p>通知(增强)：每一个横切关注点上要做的事情都需要写一个方法来实现，这样的方法就叫通知方法。</p><ul><li>前置通知：在被代理的目标方法前执行</li><li>返回通知：在被代理的目标方法成功结束后执行</li><li>异常通知：在被代理的目标方法异常结束后执行</li><li>后置通知：在被代理的目标方法最终结束后执行</li><li>环绕通知：使用try…catch…finally结构围绕整个被代理的目标方法，包括上面四种通知对应的所有位置</li></ul></li><li><p>连接点 joinpoint</p></li></ul><p>​这也是一个纯逻辑概念，不是语法定义的。指那些被拦截到的点。在Spring中，可以被动态代理拦截目标类的方法<br>​    <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img010.5af189f7.png"></p><ul><li>切入点 pointcut</li></ul><p>​定位连接点的方式，或者可以理解成被选中的连接点！</p><ul><li>切面 aspect</li></ul><p>​切入点和通知的结合。是一个类。</p><ul><li>目标 target</li></ul><p>​被代理的目标对象。</p><ul><li>代理 proxy</li></ul><p>​向目标对象应用通知之后创建的代理对象。</p><ul><li>织入 weave</li></ul><p>​指把通知应用到目标上，生成代理对象的过程。可以在编译期织入，也可以在运行期织入，Spring采用后者。</p><h3 id="Spring-AOP框架介绍和关系梳理"><a href="#Spring-AOP框架介绍和关系梳理" class="headerlink" title="Spring AOP框架介绍和关系梳理"></a>Spring AOP框架介绍和关系梳理</h3><ol><li>AOP一种区别于OOP的编程思维，用来完善和解决OOP的非核心代码冗余和不方便统一维护问题！</li><li>代理技术（动态代理|静态代理）是实现AOP思维编程的具体技术，但是自己使用动态代理实现代码比较繁琐！</li><li>Spring AOP框架，基于AOP编程思维，封装动态代理技术，简化动态代理技术实现的框架！SpringAOP内部帮助我们实现动态代理，我们只需写少量的配置，指定生效范围即可,即可完成面向切面思维编程的实现！</li></ol><h3 id="Spring-AOP基于注解方式实现和细节"><a href="#Spring-AOP基于注解方式实现和细节" class="headerlink" title="Spring AOP基于注解方式实现和细节"></a>Spring AOP基于注解方式实现和细节</h3><h4 id="Spring-AOP底层技术组成"><a href="#Spring-AOP底层技术组成" class="headerlink" title="Spring AOP底层技术组成"></a>Spring AOP底层技术组成</h4><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img006.84eb95b7.png"></p><ul><li>动态代理（InvocationHandler）：JDK原生的实现方式，需要被代理的目标类必须实现接口。因为这个技术要求代理对象和目标对象实现同样的接口（兄弟两个拜把子模式）。</li><li>cglib：通过继承被代理的目标类（认干爹模式）实现代理，所以不需要目标类实现接口。</li><li>AspectJ：早期的AOP实现的框架，SpringAOP借用了AspectJ中的AOP注解。</li></ul><h4 id="初步实现"><a href="#初步实现" class="headerlink" title="初步实现"></a>初步实现</h4><ol><li>加入依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring-aspects会帮我们传递过来aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>准备接口</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>纯净实现类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorPureImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i + j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i - j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i * j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> i / j;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>声明切面类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Aspect表示这个类是一个切面类</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="comment">// @Component注解保证这个切面类能够放入IOC容器</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// @Before注解：声明当前方法是前置通知方法</span></span><br><span class="line">    <span class="comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP前置通知] 方法开始了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterException</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@After(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogFinallyEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>开启aspectj注解支持<ol><li>xml方式</li></ol></li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 进行包扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启aspectj框架注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​2. 配置类方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;&quot;)</span></span><br><span class="line"><span class="comment">//作用等于 &lt;aop:aspectj-autoproxy /&gt; 配置类上开启 Aspectj注解支持!</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="6"><li>测试效果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@SpringJUnitConfig(locations = &quot;classpath:spring-aop.xml&quot;)</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(value = &#123;MyConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCalculator</span><span class="params">()</span>&#123;</span><br><span class="line">        calculator.add(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.intellij.rt.junit.JUnitStarter -ideVersion5 -junit5 com.atguigu.test.AopTest,testCalculator</span><br><span class="line">[AOP前置通知] 方法开始了</span><br><span class="line">[AOP返回通知] 方法成功返回了</span><br><span class="line">[AOP后置通知] 方法最终结束了</span><br></pre></td></tr></table></figure><h4 id="获取通知细节信息"><a href="#获取通知细节信息" class="headerlink" title="获取通知细节信息"></a>获取通知细节信息</h4><ol><li><strong>JointPoint接口</strong><br>需要获取方法签名、传入的实参等信息时，可以在通知方法声明JoinPoint类型的形参。</li></ol><ul><li>要点1：JoinPoint 接口通过 getSignature() 方法获取目标方法的签名（方法声明时的完整信息）</li><li>要点2：通过目标方法签名对象获取方法名</li><li>要点3：通过JoinPoint对象获取外界调用目标方法时传入的实参列表组成的数组</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @Before注解标记前置通知方法</span></span><br><span class="line"><span class="comment">// value属性：切入点表达式，告诉Spring当前通知方法要套用到哪个目标方法上</span></span><br><span class="line"><span class="comment">// 在前置通知方法形参位置声明一个JoinPoint类型的参数，Spring就会将这个对象传入</span></span><br><span class="line"><span class="comment">// 根据JoinPoint对象就可以获取目标方法名称、实际参数列表</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(public int aop.api.Calculator.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.通过JoinPoint对象获取目标方法签名对象</span></span><br><span class="line">    <span class="comment">// 方法的签名：一个方法的全部声明信息</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.通过方法的签名对象获取目标方法的详细信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;methodName = &quot;</span> + methodName);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> signature.getModifiers();</span><br><span class="line">    System.out.println(<span class="string">&quot;modifiers = &quot;</span> + modifiers);</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">declaringTypeName</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">    System.out.println(<span class="string">&quot;declaringTypeName = &quot;</span> + declaringTypeName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.通过JoinPoint对象获取外界调用目标方法时传入的实参列表</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4.由于数组直接打印看不到具体数据，所以转换为List集合</span></span><br><span class="line">    List&lt;Object&gt; argList = Arrays.asList(args);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP前置通知] &quot;</span> + methodName + <span class="string">&quot;方法开始了，参数列表：&quot;</span> + argList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>方法返回值</strong></li></ol><p>在返回通知中，通过**@AfterReturning**注解的returning属性获取目标方法的返回值！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @AfterReturning注解标记返回通知方法</span></span><br><span class="line"><span class="comment">// 在返回通知中获取目标方法返回值分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterReturning注解中通过returning属性设置一个名称</span></span><br><span class="line"><span class="comment">// 第二步：使用returning属性设置的名称在通知方法中声明一个对应的形参</span></span><br><span class="line"><span class="meta">@AfterReturning(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        returning = &quot;targetMethodReturnValue&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreSuccess</span><span class="params">(JoinPoint joinPoint, Object targetMethodReturnValue)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP返回通知] &quot;</span>+methodName+<span class="string">&quot;方法成功结束了，返回值是：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>异常对象捕捉</strong></li></ol><p>在异常通知中，通过@AfterThrowing注解的throwing属性获取目标方法抛出的异常对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @AfterThrowing注解标记异常通知方法</span></span><br><span class="line"><span class="comment">// 在异常通知中获取目标方法抛出的异常分两步：</span></span><br><span class="line"><span class="comment">// 第一步：在@AfterThrowing注解中声明一个throwing属性设定形参名称</span></span><br><span class="line"><span class="comment">// 第二步：使用throwing属性指定的名称在通知方法声明形参，Spring会将目标方法抛出的异常对象从这里传给我们</span></span><br><span class="line"><span class="meta">@AfterThrowing(</span></span><br><span class="line"><span class="meta">        value = &quot;execution(public int aop.api.Calculator.add(int,int))&quot;,</span></span><br><span class="line"><span class="meta">        throwing = &quot;targetMethodException&quot;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterCoreException</span><span class="params">(JoinPoint joinPoint, Throwable targetMethodException)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP异常通知] &quot;</span>+methodName+<span class="string">&quot;方法抛异常了，异常类型是：&quot;</span> + targetMethodException.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切点表达式语法"><a href="#切点表达式语法" class="headerlink" title="切点表达式语法"></a>切点表达式语法</h4><ol><li><strong>切点表达式</strong></li></ol><p>AOP切点表达式（Pointcut Expression）是一种用于指定切点的语言，它可以通过定义匹配规则，来选择需要被切入的目标对象。</p><ol start="2"><li><strong>切点表达式语法</strong></li></ol><p> <img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img011.dde1a79a.png"></p><p>语法细节</p><ul><li>第一位：execution( )固定开头</li><li>第二位：方法访问修饰符</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">private</span> 直接描述对应修饰符即可</span><br></pre></td></tr></table></figure><ul><li>第三位：方法返回值</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> String <span class="keyword">void</span> 直接描述返回值类型</span><br></pre></td></tr></table></figure><ul><li>第四位：指定包的地址</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">固定的包: com.atguigu.api | service | dao</span><br><span class="line">单层的任意命名: com.atguigu.*  = api dao  * = 任意一层的任意命名</span><br><span class="line">任意层任意命名: com.. = api.erdaye com.a.a.a.a.a.a.a  ..任意层,任意命名 用在包上!</span><br><span class="line">注意: ..不能用作包开头   <span class="keyword">public</span> <span class="type">int</span> .. 错误语法  com..</span><br><span class="line">找到任何包下: *..</span><br></pre></td></tr></table></figure><ul><li>第五位：指定类名称</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">固定名称: UserService</span><br><span class="line">任意类名: *</span><br><span class="line">部分任意: com..service.impl.*Impl</span><br><span class="line">任意包任意类: *..*</span><br></pre></td></tr></table></figure><ul><li>第六位：指定方法名称<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">语法和类名一致</span><br><span class="line">任意访问修饰符,任意类的任意方法: * *..*.*</span><br></pre></td></tr></table></figure></li><li>第七位：方法参数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第七位: 方法的参数描述</span><br><span class="line">       具体值: (String,<span class="type">int</span>) != (<span class="type">int</span>,String) 没有参数 ()</span><br><span class="line">       模糊值: 任意参数 有 或者 没有 (..)  ..任意参数的意识</span><br><span class="line">       部分具体和模糊:</span><br><span class="line">         第一个参数是字符串的方法 (String..)</span><br><span class="line">         最后一个参数是字符串 (..String)</span><br><span class="line">         字符串开头,<span class="type">int</span>结尾 (String..<span class="type">int</span>)</span><br><span class="line">         包含<span class="type">int</span>类型(..<span class="type">int</span>..)</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>切点表达式案例</strong></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>查询某包某类下，访问修饰符是公有，返回值是<span class="type">int</span>的全部方法</span><br><span class="line"><span class="number">2.</span>查询某包下类中第一个参数是String的方法</span><br><span class="line"><span class="number">3.</span>查询全部包下，无参数的方法！</span><br><span class="line"><span class="number">4.</span>查询com包下，以<span class="type">int</span>参数类型结尾的方法</span><br><span class="line"><span class="number">5.</span>查询指定包下，Service开头类的私有返回值<span class="type">int</span>的无参数方法</span><br></pre></td></tr></table></figure><h4 id="重用（提取）切点表达式"><a href="#重用（提取）切点表达式" class="headerlink" title="重用（提取）切点表达式"></a>重用（提取）切点表达式</h4><ol><li>重用切点表达式</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// @Before注解：声明当前方法是前置通知方法</span></span><br><span class="line"><span class="comment">// value属性：指定切入点表达式，由切入点表达式控制当前通知方法要作用在哪一个目标方法上</span></span><br><span class="line"><span class="meta">@Before(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCore</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP前置通知] 方法开始了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterReturning(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP返回通知] 方法成功返回了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@AfterThrowing(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogAfterException</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP异常通知] 方法抛异常了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After(value = &quot;execution(public int proxy.CalculatorPureImpl.add(int,int))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogFinallyEnd</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[AOP后置通知] 方法最终结束了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同一类内部引用</li></ol><p>提取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 切入点表达式重用</span></span><br><span class="line"><span class="meta">@Pointcut(&quot;execution(public int aop.api.Calculator.add(int,int)))</span><span class="string">&quot;)</span></span><br><span class="line"><span class="string">public void declarPointCut() &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>注意：提取切点注解使用@Pointcut(切点表达式) ， 需要添加到一个无参数无返回值方法上即可！<br>引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;declarPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printLogBeforeCoreOperation</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br></pre></td></tr></table></figure><ol start="3"><li>不同类中引用</li></ol><p>不同类在引用切点，只需要添加类的全限定符+方法名即可！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;aop.aspect.LogAspect.declarPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">roundAdvice</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br></pre></td></tr></table></figure><ol start="4"><li>切点统一管理</li></ol><p>建议：将切点表达式统一存储到一个类中进行集中管理和维护！</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtguiguPointCut</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(public int *..Calculator.sub(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atguiguGlobalPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(public int *..Calculator.add(int,int))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">atguiguSecondPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* *..*Service.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transactionPointCut</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h4><p>环绕通知对应整个 try…catch…finally 结构，包括前面四种通知的所有功能。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用@Around注解标明环绕通知方法</span></span><br><span class="line"><span class="meta">@Around(value = &quot;aop.aspect.AtguiguPointCut.transactionPointCut()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">manageTransaction</span><span class="params">(</span></span><br><span class="line"><span class="params">    </span></span><br><span class="line"><span class="params">        // 通过在通知方法形参位置声明ProceedingJoinPoint类型的形参，</span></span><br><span class="line"><span class="params">        // Spring会将这个类型的对象传给我们</span></span><br><span class="line"><span class="params">        ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ProceedingJoinPoint对象获取外界调用目标方法时传入的实参数组</span></span><br><span class="line">    Object[] args = joinPoint.getArgs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过ProceedingJoinPoint对象获取目标方法的签名对象</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> joinPoint.getSignature();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过签名对象获取目标方法的方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明变量用来存储目标方法的返回值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">targetMethodReturnValue</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在目标方法执行前：开启事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 开启事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，参数列表：&quot;</span> + Arrays.asList(args));</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 过ProceedingJoinPoint对象调用目标方法</span></span><br><span class="line">        <span class="comment">// 目标方法的返回值一定要返回给外界调用者</span></span><br><span class="line">        targetMethodReturnValue = joinPoint.proceed(args);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法成功返回后：提交事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 提交事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，方法返回值：&quot;</span> + targetMethodReturnValue);</span><br><span class="line">    </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">        <span class="comment">// 在目标方法抛异常后：回滚事务（模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 回滚事务，方法名：&quot;</span> + methodName + <span class="string">&quot;，异常：&quot;</span> + e.getClass().getName());</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 在目标方法最终结束后：释放数据库连接</span></span><br><span class="line">        log.debug(<span class="string">&quot;[AOP 环绕通知] 释放数据库连接，方法名：&quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> targetMethodReturnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="切面优先级设置"><a href="#切面优先级设置" class="headerlink" title="切面优先级设置"></a>切面优先级设置</h4><p>相同目标方法上同时存在多个切面时，切面的优先级控制切面的内外嵌套顺序。</p><ul><li>优先级高的切面：外面</li><li>优先级低的切面：里面</li></ul><p>使用@Order注解可以控制切面的优先级： </p><ul><li>@Order(较小的数)：优先级高</li><li>@Order(较大的数)：优先级低</li></ul><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img012.b353bc56.png"></p><p>此时应该将缓存切面的优先级提高，在事务操作之前先检查缓存中是否存在目标数据。</p><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img014.ee4ed40a.png"></p><h4 id="CGLib动态代理生效"><a href="#CGLib动态代理生效" class="headerlink" title="CGLib动态代理生效"></a>CGLib动态代理生效</h4><p>在目标类没有实现任何接口的情况下，Spring会自动使用cglib技术实现代理。</p><p>使用总结：</p><ul><li>如果目标类有接口,选择使用jdk动态代理</li><li>如果目标类没有接口,选择cglib动态代理</li><li>如果有接口,接口接值</li><li>如果没有接口,类进行接值</li></ul><h4 id="注解实现小结"><a href="#注解实现小结" class="headerlink" title="注解实现小结"></a>注解实现小结</h4><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img015.9c921baf.png"></p><h2 id="Spring-声明式事务"><a href="#Spring-声明式事务" class="headerlink" title="Spring 声明式事务"></a>Spring 声明式事务</h2><h3 id="声明式事务概念"><a href="#声明式事务概念" class="headerlink" title="声明式事务概念"></a>声明式事务概念</h3><p>声明式事务是指使用注解或XML配置的方式来控制事务的提交和回滚。<br>开发者只需要添加配置即可，具体事务的实现由第三方框架实现，避免我们直接进行事务操作！<br>使用声明式事务可以将事务的控制和业务逻辑分离开来，提高代码的可读性和可维护性。</p><h4 id="Spring事务管理器"><a href="#Spring事务管理器" class="headerlink" title="Spring事务管理器"></a>Spring事务管理器</h4><ol><li>Spring声明式事务对应依赖</li></ol><ul><li>spring-tx: 包含声明式事务实现的基本规范（事务管理器规范接口和事务增强等等）</li><li>spring-jdbc: 包含DataSource方式事务管理器实现类DataSourceTransactionManager</li><li>spring-orm: 包含其他持久层框架的事务管理器实现类例如：Hibernate&#x2F;Jpa等</li></ul><ol start="2"><li>Spring声明式事务对应事务管理器接口</li></ol><p>​使用的事务管理器是<code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code>，将来整合JDBC方式、JdbcTemplate方式、Mybatis方式的事务实现</p><p>DataSourceTransactionManager类中的主要方法：</p><ul><li>doBegin()：开启事务</li><li>doSuspend()：挂起事务</li><li>doResume()：恢复挂起的事务</li><li>doCommit()：提交事务</li><li>doRollback()：回滚事务</li></ul><h3 id="基于注解的声明式事务"><a href="#基于注解的声明式事务" class="headerlink" title="基于注解的声明式事务"></a>基于注解的声明式事务</h3><ol><li>准备项目</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--spring context依赖--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--当你引入Spring Context依赖之后，表示将Spring的基础依赖引入了--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--junit5测试--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.jupiter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-jupiter-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 数据库驱动 和 连接池--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- spring-jdbc --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 声明式事务依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>外部配置文件</li></ol><p>jdbc.properties</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql://localhost:3306/studb</span><br><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure><ol start="3"><li>spring配置文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//druid连接池</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//jdbcTemplate</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>准备dao&#x2F;service层</li></ol><p>dao</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateNameById</span><span class="params">(String name,Integer id)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update students set name = ? where id = ? ;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> jdbcTemplate.update(sql, name, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAgeById</span><span class="params">(Integer age,Integer id)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update students set age = ? where id = ? ;&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql,age,id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>service</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>测试环境搭建</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringJUnitConfig(JavaConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testTx</span><span class="params">()</span>&#123;</span><br><span class="line">        studentService.changeInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="基本事务控制"><a href="#基本事务控制" class="headerlink" title="基本事务控制"></a>基本事务控制</h4><ol><li>配置事务管理器</li></ol><p>数据库相关的配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * description: 数据库和连接池配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponenScan(&quot;/&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(value = &quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化dataSource加入到ioc容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> driver</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">(<span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span>String url,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>String driver,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span>String username,</span></span><br><span class="line"><span class="params">                                 <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span>String password)</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化JdbcTemplate对象,需要使用ioc中的DataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JdbcTemplate <span class="title function_">jdbcTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>();</span><br><span class="line">        jdbcTemplate.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 装配事务管理实现对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用声明事务注解@Transactional</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试事务效果</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(classes = DataSourceConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testTx</span><span class="params">()</span>&#123;</span><br><span class="line">        studentService.changeInfo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="事务属性：只读"><a href="#事务属性：只读" class="headerlink" title="事务属性：只读"></a>事务属性：只读</h4><ol><li>只读介绍</li></ol><p>对一个查询操作来说，如果我们把它设置成只读，就能够明确告诉数据库，这个操作不涉及写操作。这样数据库就能够针对查询操作来进行优化</p><ol start="2"><li>设置方式</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readOnly = true把当前事务设置为只读 默认是false!</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>针对DML动作设置只读模式</li></ol><p>会抛出下面异常：</p><blockquote><p>Caused by: java.sql.SQLException: Connection is read-only. Queries leading to data modification are not allowed</p></blockquote><ol start="4"><li>@Transactional注解放在类上</li><li>生效原则</li></ol><p>​如果一个类中每一个方法上都使用了 @Transactional 注解，那么就可以将 @Transactional 注解提取到类上。反过来说：@Transactional 注解在类级别标记，会影响到类中的每一个方法。同时，类级别标记的 @Transactional 注解中设置的事务属性也会延续影响到方法执行时的事务属性。除非在方法上又设置了 @Transactional 注解。对一个方法来说，离它最近的 @Transactional 注解中的事务属性设置生效。</p><ol start="6"><li>用法举例</li></ol><p>​在类级别@Transactional注解中设置只读，这样类中所有的查询方法都不需要设置@Transactional注解了。因为对查询操作来说，其他属性通常不需要设置，所以使用公共设置即可。然后在这个基础上，对增删改方法设置@Transactional注解 readOnly 属性为 false。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmpService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了便于核对数据库操作结果，不要修改同一条记录</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateTwice</span><span class="params">(……)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// readOnly = true把当前事务设置为只读</span></span><br><span class="line">    <span class="comment">// @Transactional(readOnly = true)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEmpName</span><span class="params">(Integer empId)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务属性：超时时间"><a href="#事务属性：超时时间" class="headerlink" title="事务属性：超时时间"></a>事务属性：超时时间</h4><ol><li>需求</li></ol><p>​事务在执行过程中，有可能因为遇到某些问题，导致程序卡住，从而长时间占用数据库资源。而长时间占用资源，大概率是因为程序运行出现了问题（可能是Java程序或MySQL数据库或网络连接等等）。<br>​此时这个很可能出问题的程序应该被回滚，撤销它已做的操作，事务结束，把资源让出来，让其他正常程序可以执行。</p><p>概括来说就是一句话：超时回滚，释放资源。</p><ol start="2"><li>设置超时时间</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,timeout = 3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//休眠4秒,等待方法超时!</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>测试超时效果</li></ol><p>执行抛出事务超时异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.transaction.TransactionTimedOutException: Transaction timed out: deadline was Wed May <span class="number">24</span> 09:<span class="number">10</span>:<span class="number">43</span> IRKT <span class="number">2023</span></span><br><span class="line"></span><br><span class="line">  at org.springframework.transaction.support.ResourceHolderSupport.checkTransactionTimeout(ResourceHolderSupport.java:<span class="number">155</span>)</span><br><span class="line">  at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInMillis(ResourceHolderSupport.java:<span class="number">144</span>)</span><br><span class="line">  at org.springframework.transaction.support.ResourceHolderSupport.getTimeToLiveInSeconds(ResourceHolderSupport.java:<span class="number">128</span>)</span><br><span class="line">  at org.springframework.jdbc.datasource.DataSourceUtils.applyTimeout(DataSourceUtils.java:<span class="number">341</span>)</span><br><span class="line">  at org.springframework.jdbc.core.JdbcTemplate.applyStatementSettings(JdbcTemplate.java:<span class="number">1467</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="事务属性：事务异常"><a href="#事务属性：事务异常" class="headerlink" title="事务属性：事务异常"></a>事务属性：事务异常</h4><ol><li>默认情况</li></ol><p>默认只针对运行时异常回滚，编译时异常不回滚。情景模拟代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,timeout = 3)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! </span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>设置回滚异常</li></ol><p>rollbackFor属性：指定哪些异常类才会回滚,默认是 RuntimeException and Error 异常方可回滚!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment"> * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment"> * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">    studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内! </span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">    studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>设置不回滚的异常</li></ol><p>在默认设置和已有设置的基础上，再指定一个异常类型，碰到它不回滚。</p><p>noRollbackFor属性：指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,timeout = 3,rollbackFor = Exception.class,noRollbackFor = FileNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="事务属性：事务隔离级别"><a href="#事务属性：事务隔离级别" class="headerlink" title="事务属性：事务隔离级别"></a>事务属性：事务隔离级别</h4><ol><li>事务隔离级别</li></ol><p>数据库事务的隔离级别是指在多个事务并发执行时，数据库系统为了保证数据一致性所遵循的规定。常见的隔离级别包括：</p><ul><li><p>读未提交（Read Uncommitted）：事务可以读取未被提交的数据，容易产生脏读、不可重复读和幻读等问题。实现简单但不太安全，一般不用。</p></li><li><p>读已提交（Read Committed）：事务只能读取已经提交的数据，可以避免脏读问题，但可能引发不可重复读和幻读。</p></li><li><p>可重复读（Repeatable Read）：在一个事务中，相同的查询将返回相同的结果集，不管其他事务对数据做了什么修改。可以避免脏读和不可重复读，但仍有幻读的问题。</p></li><li><p>串行化（Serializable）：最高的隔离级别，完全禁止了并发，只允许一个事务执行完毕之后才能执行另一个事务。可以避免以上所有问题，但效率较低，不适用于高并发场景。</p></li></ul><p>不同的隔离级别适用于不同的场景，需要根据实际业务需求进行选择和调整。</p><ol start="2"><li>事务隔离级别设置</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,</span></span><br><span class="line"><span class="meta">                   timeout = 3,</span></span><br><span class="line"><span class="meta">                   rollbackFor = Exception.class,</span></span><br><span class="line"><span class="meta">                   noRollbackFor = FileNotFoundException.class,</span></span><br><span class="line"><span class="meta">                   isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务属性：事务传播行为"><a href="#事务属性：事务传播行为" class="headerlink" title="事务属性：事务传播行为"></a>事务属性：事务传播行为</h4><ol><li>事务传播行为要研究的问题</li></ol><p><img src="http://heavy_code_industry.gitee.io/code_heavy_industry/assets/img/img012.faac2cb7.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MethodA</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    MethodB();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在被调用的子方法中设置传播行为，代表如何处理调用的事务！ 是加入，还是新事务等！</span></span><br><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">MethodB</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>propagation属性</li></ol><p>@Transactional注解通过propagation属性设置事务的传播行为。它的默认值是：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Propagation <span class="title function_">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED;</span><br></pre></td></tr></table></figure><p>propagation属性的可选值由org.springframework.transaction.annotation.Propagation枚举类提供：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>REQUIRED 默认值</td><td>如果父方法有事务，就加入，如果没有就新建自己独立</td></tr><tr><td>REQUIRES_NEW</td><td>不管父方法是否有事务，都新建事务，都是独立的</td></tr></tbody></table><ul><li>声明两个业务方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentDao studentDao;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * timeout设置事务超时时间,单位秒! 默认: -1 永不超时,不限制事务时间!</span></span><br><span class="line"><span class="comment">     * rollbackFor = 指定哪些异常才会回滚,默认是 RuntimeException and Error 异常方可回滚!</span></span><br><span class="line"><span class="comment">     * noRollbackFor = 指定哪些异常不会回滚, 默认没有指定,如果指定,应该在rollbackFor的范围内!</span></span><br><span class="line"><span class="comment">     * isolation = 设置事务的隔离级别,mysql默认是repeatable read!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(readOnly = false,</span></span><br><span class="line"><span class="meta">                   timeout = 3,</span></span><br><span class="line"><span class="meta">                   rollbackFor = Exception.class,</span></span><br><span class="line"><span class="meta">                   noRollbackFor = FileNotFoundException.class,</span></span><br><span class="line"><span class="meta">                   isolation = Isolation.REPEATABLE_READ)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeInfo</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//主动抛出一个检查异常,测试! 发现不会回滚,因为不在rollbackFor的默认范围内!</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test1&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明两个独立修改数据库的事务业务方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeAge</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateAgeById(<span class="number">99</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeName</span><span class="params">()</span>&#123;</span><br><span class="line">        studentDao.updateNameById(<span class="string">&quot;test2&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>声明一个整合业务方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">topService</span><span class="params">()</span>&#123;</span><br><span class="line">        studentService.changeAge();</span><br><span class="line">        studentService.changeName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加传播行为测试</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringJUnitConfig(classes = AppConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TxTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TopService topService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">testTx</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        topService.topService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>    在同一个类中，对于@Transactional注解的方法调用，事务传播行为不会生效。这是因为Spring框架中使用代理模式实现了事务机制，在同一个类中的方法调用并不经过代理，而是通过对象的方法调用，因此@Transactional注解的设置不会被代理捕获，也就不会产生任何事务传播行为的效果。</p><h5 id="其他传播行为值"><a href="#其他传播行为值" class="headerlink" title="其他传播行为值"></a>其他传播行为值</h5><ul><li>Propagation.REQUIRED：如果当前存在事务，则加入当前事务，否则创建一个新事务。</li><li>Propagation.REQUIRES_NEW：创建一个新事务，并在新事务中执行。如果当前存在事务，则挂起当前事务，即使新事务抛出异常，也不会影响当前事务。</li><li>Propagation.NESTED：如果当前存在事务，则在该事务中嵌套一个新事务，如果没有事务，则与Propagation.REQUIRED一样。</li><li>Propagation.SUPPORTS：如果当前存在事务，则加入该事务，否则以非事务方式执行。</li><li>Propagation.NOT_SUPPORTED：以非事务方式执行，如果当前存在事务，挂起该事务。</li><li>Propagation.MANDATORY：必须在一个已有的事务中执行，否则抛出异常。</li><li>Propagation.NEVER：必须在没有事务的情况下执行，否则抛出异常。</li></ul><h2 id="Spring核心点"><a href="#Spring核心点" class="headerlink" title="Spring核心点"></a>Spring核心点</h2><table><thead><tr><th>核心点</th><th>掌握目标</th></tr></thead><tbody><tr><td>spring框架理解</td><td>spring家族和spring framework框架</td></tr><tr><td>spring核心功能</td><td>ioc&#x2F;di , aop , tx</td></tr><tr><td>spring ioc &#x2F; di</td><td>组件管理、ioc容器、ioc&#x2F;di , 三种配置方式</td></tr><tr><td>spring aop</td><td>aop和aop框架和代理技术、基于注解的aop配置</td></tr><tr><td>spring tx</td><td>声明式和编程式事务、动态事务管理器、事务注解、属性</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/6c8c2c4f.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
