<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>楪祈のBlog</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>星座になれたら。</description>
    <pubDate>Wed, 23 Apr 2025 06:16:18 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Zookeeper基础入门</title>
      <link>http://example.com/inori/f8d5b7cd.html</link>
      <guid>http://example.com/inori/f8d5b7cd.html</guid>
      <pubDate>Wed, 23 Apr 2025 02:05:45 GMT</pubDate>
      
      <description>Zookeeper入门</description>
      
      
      
      <content:encoded><![CDATA[<p>Zookeeper是一个分布式的、开源的分布式应用程序的协调服务，基于ZAB协议（ZooKeeper Atomic Broadcast）实现分布式数据一致性</p><p>Zookeeper内部的数据模型类似文件系统的树形结构（ZNode），每个节点可存储不超过1MB的数据</p><p>Zookeeper提供的主要功能包括：</p><ul><li>服务注册与发现</li><li>配置管理</li><li>分布式锁</li><li>集群管理</li></ul><h2 id="Zookeeper数据模型"><a href="#Zookeeper数据模型" class="headerlink" title="Zookeeper数据模型"></a>Zookeeper数据模型</h2><p>ZooKeeper是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构</p><p>这里面的每一个节点都被称为ZNode，每个节点上都会保存自己的数据和节点信息</p><p>节点可以拥有子节点，同时也允许少量（1MB）数据存储在该节点之下（可以通过jute.maxbuffer修改单个节点数据大小限制）</p><p>节点可以分为四大类：</p><ul><li>PERSISTENT：持久化节点，创建后永久存在（除非显式删除）</li><li>EPHEMERAL：临时节点 -e，会话结束后自动删除（用于实现服务注册与心跳检测）</li><li>PERSISTENT_SEQUENTIAL：持久化顺序节点 -s，顺序节点的名称后面会自动追加单调递增序号（如 <code>/lock/seq-0000000001</code>）</li><li>EPHEMERAL_SEQUENTIAL ：临时顺序节点 -es</li><li>TTL节点：3.6.0+ 版本支持，设置存活时间后自动删除</li></ul><p><img src="/inori/f8d5b7cd/zookeeper.png"></p><h2 id="Zookeeper常用命令"><a href="#Zookeeper常用命令" class="headerlink" title="Zookeeper常用命令"></a>Zookeeper常用命令</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul><li>启动ZooKeeper服务: .&#x2F;zkServer.sh start</li><li>查看ZooKeeper服务状态: .&#x2F;zkServer.sh status</li><li>停止ZooKeeper服务: .&#x2F;zkServer.sh stop</li><li>重启ZooKeeper服务: .&#x2F;zkServer.sh restart</li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>连接ZooKeeper服务端：.&#x2F;zkCli.sh –server ip:port</li><li>断开连接：quit</li><li>设置节点值：set &#x2F;节点path value</li><li>删除单个节点：delete &#x2F;节点path</li><li>显示指定目录下节点：ls 目录</li><li>删除带有子节点的节点：deleteall &#x2F;节点path</li><li>创建节点：create &#x2F;节点path value</li><li>获取节点值：get &#x2F;节点path</li><li>创建临时节点：create -e &#x2F;节点path value</li><li>创建顺序节点：create -s &#x2F;节点path value</li><li>查询节点详细信息：ls –s &#x2F;节点path<ul><li>czxid：节点被创建的事务ID</li><li>ctime: 创建时间</li><li>mzxid: 最后一次被更新的事务ID</li><li>mtime: 修改时间</li><li>pzxid：子节点列表最后一次被更新的事务ID</li><li>cversion：子节点的版本号 </li><li>dataversion：数据版本号</li><li>aclversion：权限版本号</li><li>ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0</li><li>dataLength：节点存储的数据的长度</li><li>numChildren：当前节点的子节点个数</li></ul></li></ul><h2 id="ZooKeeper-JavaAPI-操作"><a href="#ZooKeeper-JavaAPI-操作" class="headerlink" title="ZooKeeper JavaAPI 操作"></a>ZooKeeper JavaAPI 操作</h2><p><strong>Curator</strong>是Netflix开源的高级客户端，可以简化ZooKeeper客户端的使用</p><p>Curator API常用操作有：</p><ul><li>建立连接</li><li>添加节点</li><li>删除节点</li><li>修改节点</li><li>查询节点</li><li>Watch事件</li><li>监听</li><li>分布式锁实现</li></ul><p>添加Maven依赖并启动Zookeeper服务：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Curator 核心库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Curator 扩展工具 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建客户端连接：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ZK_ADDRESS</span> <span class="operator">=</span> <span class="string">&quot;localhost:2181&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework <span class="title function_">createClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重试策略：初始等待1秒，最多重试3次</span></span><br><span class="line">        <span class="type">ExponentialBackoffRetry</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(ZK_ADDRESS)<span class="comment">// ip地址+端口</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)<span class="comment">// 会话超时时间（毫秒）</span></span><br><span class="line">                .connectionTimeoutMs(<span class="number">3000</span>)<span class="comment">// 连接建立超时时间（毫秒）</span></span><br><span class="line">            .namespace(<span class="string">&quot;/demo&quot;</span>)<span class="comment">// 设置命名空间（所有操作路径自动添加前缀）</span></span><br><span class="line">                .retryPolicy(retry)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> createClient();</span><br><span class="line">        client.start(); <span class="comment">// 启动连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ZooKeeper 连接状态: &quot;</span> + client.getState());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        client.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建持久节点（默认开放权限）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create()</span><br><span class="line">    .forPath(<span class="string">&quot;/persistent-node&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建临时顺序节点（会话结束后自动删除，名称追加序号）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">seqPath</span> <span class="operator">=</span> client.create()</span><br><span class="line">    .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)</span><br><span class="line">    .forPath(<span class="string">&quot;/temp-seq-&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>方法链</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>.withMode()</code></td><td>指定节点类型（共6种）</td><td><code>CreateMode.PERSISTENT_SEQUENTIAL</code></td></tr><tr><td><code>.withACL()</code></td><td>设置自定义权限列表</td><td><code>.withACL(ZooDefs.Ids.CREATOR_ALL_ACL)</code></td></tr><tr><td><code>.creatingParentsIfNeeded()</code></td><td>自动创建父节点（递归）</td><td>适用于深度路径如 <code>/a/b/c</code></td></tr><tr><td><code>.withTtl()</code></td><td>设置TTL（需ZK 3.5+，且需配置<code>ExtendedFeatureType.TTL</code>）</td><td><code>.withTtl(10000L)</code> &#x2F;&#x2F; 10秒后自动删除</td></tr><tr><td><code>.withProtection()</code></td><td>保护模式（防重放攻击）</td><td>配合临时顺序节点使用</td></tr></tbody></table><p>删除节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除叶子节点</span></span><br><span class="line">client.delete()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带版本号的删除（CAS）</span></span><br><span class="line">client.delete()</span><br><span class="line">    .withVersion(stat.getVersion())</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>方法链</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>.deletingChildrenIfNeeded()</code></td><td>递归删除子节点</td><td>用于删除非空目录</td></tr><tr><td><code>.guaranteed()</code></td><td>确保删除成功（持续重试直到ZK确认）</td><td>配合<code>.withVersion()</code>使用</td></tr><tr><td><code>.withVersion()</code></td><td>指定版本号（实现CAS删除）</td><td><code>.withVersion(5)</code></td></tr></tbody></table><p>修改节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础更新</span></span><br><span class="line">client.setData()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;new-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带版本号的原子更新（CAS操作）</span></span><br><span class="line"><span class="type">Stat</span> <span class="variable">newStat</span> <span class="operator">=</span> client.setData()</span><br><span class="line">    .withVersion(stat.getVersion()) <span class="comment">// 使用之前获取的版本号</span></span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;cas-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无条件强制更新</span></span><br><span class="line">client.setData()</span><br><span class="line">    .withVersion(-<span class="number">1</span>) <span class="comment">// 忽略版本冲突</span></span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;force-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调更新</span></span><br><span class="line">client.setData()</span><br><span class="line">    .inBackground((curator, event) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步更新结果: &quot;</span> + event.getResultCode());</span><br><span class="line">    &#125;)</span><br><span class="line">    .forPath(<span class="string">&quot;/async-path&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><p>获取节点数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本读取（返回byte[]）</span></span><br><span class="line"><span class="type">byte</span>[] data = client.getData()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带状态读取（获取Stat元信息）</span></span><br><span class="line"><span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line"><span class="type">byte</span>[] dataWithStat = client.getData()</span><br><span class="line">    .storingStatIn(stat) <span class="comment">// 存储节点状态</span></span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;版本号: &quot;</span> + stat.getVersion());</span><br></pre></td></tr></table></figure><p>子节点查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取子节点列表</span></span><br><span class="line">List&lt;String&gt; children = client.getChildren()</span><br><span class="line">    .forPath(<span class="string">&quot;/parent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带监听器的查询（子节点变化时触发）</span></span><br><span class="line">List&lt;String&gt; watchedChildren = client.getChildren()</span><br><span class="line">    .usingWatcher((CuratorWatcher) event -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子节点变化: &quot;</span> + event.getType());</span><br><span class="line">    &#125;).forPath(<span class="string">&quot;/parent&quot;</span>);</span><br></pre></td></tr></table></figure><p>存在性检查：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查节点是否存在（返回Stat或null）</span></span><br><span class="line"><span class="type">Stat</span> <span class="variable">existsStat</span> <span class="operator">=</span> client.checkExists()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带监听的存在检查</span></span><br><span class="line">client.checkExists()</span><br><span class="line">    .usingWatcher((CuratorWatcher) event -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getType() == Watcher.Event.EventType.NodeCreated) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点被创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forPath(<span class="string">&quot;/path-to-watch&quot;</span>);</span><br></pre></td></tr></table></figure><p>事务操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建事务</span></span><br><span class="line"><span class="type">CuratorTransactionFinal</span> <span class="variable">txFinal</span> <span class="operator">=</span> client.inTransaction()</span><br><span class="line">    .create().forPath(<span class="string">&quot;/txn-node1&quot;</span>, <span class="string">&quot;data1&quot;</span>.getBytes()).and()</span><br><span class="line">    .setData().forPath(<span class="string">&quot;/txn-node2&quot;</span>, <span class="string">&quot;data2&quot;</span>.getBytes()).and()</span><br><span class="line">    .delete().forPath(<span class="string">&quot;/txn-node3&quot;</span>).and()</span><br><span class="line">    .commit(); <span class="comment">// 原子化执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查结果</span></span><br><span class="line"><span class="keyword">for</span> (CuratorTransactionResult result : txFinal.getResults()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;操作类型: &quot;</span> + result.getType() + <span class="string">&quot;, 路径: &quot;</span> + result.getForPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>批量操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建批量操作</span></span><br><span class="line">List&lt;CuratorOp&gt; ops = Arrays.asList(</span><br><span class="line">    client.transactionOp().create().forPath(<span class="string">&quot;/batch/new&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes()),</span><br><span class="line">    client.transactionOp().setData().forPath(<span class="string">&quot;/batch/existing&quot;</span>, <span class="string">&quot;update&quot;</span>.getBytes()),</span><br><span class="line">    client.transactionOp().delete().forPath(<span class="string">&quot;/batch/old&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行批量操作</span></span><br><span class="line">List&lt;CuratorTransactionResult&gt; results = client.transaction().forOperations(ops);</span><br></pre></td></tr></table></figure><h2 id="Watch事件监听"><a href="#Watch事件监听" class="headerlink" title="Watch事件监听"></a>Watch事件监听</h2><p>ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。</p><p>ZooKeeper中引入了Watcher机制来实现了发布&#x2F;订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会通知所有订阅者。</p><p>ZooKeeper原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便，需要开发人员自己反复注册Watcher，比较繁琐。Curator引入了Cache来实现对 ZooKeeper服务端事件的监听。</p><p>ZooKeeper提供了三种Watcher：</p><ul><li>NodeCache:只是监听某一个特定的节点</li><li>PathChildrenCache:监控一个ZNode的子节点</li><li>TreeCache:可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</li></ul><p>一次侦听：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.api.CuratorWatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneTimeWatcherDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加一次性Watcher（触发后自动移除）</span></span><br><span class="line">        <span class="type">byte</span>[] data = client.getData()</span><br><span class="line">                .usingWatcher((CuratorWatcher) event -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;【一次性监听】事件类型: &quot;</span> + event.getType() + <span class="string">&quot;, 路径: &quot;</span> + event.getPath());</span><br><span class="line">                &#125;)</span><br><span class="line">                .forPath(<span class="string">&quot;/test-watch&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试触发（修改节点数据）</span></span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-watch&quot;</span>, <span class="string">&quot;new-data&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 再次修改不会触发，因为Watcher已被移除</span></span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-watch&quot;</span>, <span class="string">&quot;another-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathChildrenCache持续侦听：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistentWatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        client.create().creatingParentsIfNeeded().forPath(<span class="string">&quot;/test-parent&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建PathChildrenCache监听器</span></span><br><span class="line">        <span class="type">PathChildrenCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client, <span class="string">&quot;/test-parent&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听回调</span></span><br><span class="line">        cache.getListenable().addListener((client1, event) -&gt; &#123;</span><br><span class="line">            <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> CHILD_ADDED:</span><br><span class="line">                    System.out.println(<span class="string">&quot;【子节点新增】路径: &quot;</span> + event.getData().getPath());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CHILD_UPDATED:</span><br><span class="line">                    System.out.println(<span class="string">&quot;【子节点更新】路径: &quot;</span> + event.getData().getPath() + </span><br><span class="line">                                     <span class="string">&quot;, 数据: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(event.getData().getData()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CHILD_REMOVED:</span><br><span class="line">                    System.out.println(<span class="string">&quot;【子节点删除】路径: &quot;</span> + event.getData().getPath());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试操作</span></span><br><span class="line">        client.create().forPath(<span class="string">&quot;/test-parent/child1&quot;</span>, <span class="string">&quot;data1&quot;</span>.getBytes());</span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-parent/child1&quot;</span>, <span class="string">&quot;updated&quot;</span>.getBytes());</span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/test-parent/child1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        cache.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NodeCache节点全量监听:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCacheListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeCacheDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        client.create().forPath(<span class="string">&quot;/test-node&quot;</span>, <span class="string">&quot;init&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建NodeCache监听指定节点</span></span><br><span class="line">        <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client, <span class="string">&quot;/test-node&quot;</span>);</span><br><span class="line">        nodeCache.start(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听器</span></span><br><span class="line">        nodeCache.getListenable().addListener(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;【节点数据变更】当前数据: &quot;</span> + </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span>(nodeCache.getCurrentData().getData()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;【节点被删除】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试操作</span></span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-node&quot;</span>, <span class="string">&quot;changed&quot;</span>.getBytes());</span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/test-node&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        nodeCache.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeCache树形结构监听:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCacheEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeCacheDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        client.create().creatingParentsIfNeeded().forPath(<span class="string">&quot;/test-tree/sub1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建TreeCache监听子树</span></span><br><span class="line">        <span class="type">TreeCache</span> <span class="variable">treeCache</span> <span class="operator">=</span> TreeCache.newBuilder(client, <span class="string">&quot;/test-tree&quot;</span>).build();</span><br><span class="line">        treeCache.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听器</span></span><br><span class="line">        treeCache.getListenable().addListener((client1, event) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getData() != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;【树形事件】类型: %s, 路径: %s, 数据: %s\n&quot;</span>,</span><br><span class="line">                    event.getType(),</span><br><span class="line">                    event.getData().getPath(),</span><br><span class="line">                    event.getData().getData() != <span class="literal">null</span> ? </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">String</span>(event.getData().getData()) : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试操作</span></span><br><span class="line">        client.create().forPath(<span class="string">&quot;/test-tree/sub2&quot;</span>, <span class="string">&quot;sub2-data&quot;</span>.getBytes());</span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-tree/sub1&quot;</span>, <span class="string">&quot;update&quot;</span>.getBytes());</span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/test-tree/sub1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        treeCache.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>事件类型</strong></th><th><strong>触发条件</strong></th><th><strong>适用监听器</strong></th></tr></thead><tbody><tr><td>NodeCreated</td><td>节点被创建</td><td>Watcher&#x2F;NodeCache</td></tr><tr><td>NodeDeleted</td><td>节点被删除</td><td>所有监听器</td></tr><tr><td>NodeDataChanged</td><td>节点数据变更</td><td>所有监听器</td></tr><tr><td>NodeChildrenChanged</td><td>子节点数量变化（不包含数据变更）</td><td>PathChildrenCache</td></tr><tr><td>INITIALIZED</td><td>TreeCache初始化完成</td><td>TreeCache</td></tr><tr><td>CONNECTION_LOST</td><td>连接断开</td><td>所有监听器</td></tr></tbody></table><h2 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h2><p>核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点。</p><ol><li>客户端获取锁时，在lock节点下创建<strong>临时顺序</strong>节点。</li><li>然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。</li><li>如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。（每个节点只监听比自己小的、最大的那个节点）</li><li>如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。</li></ol><h3 id="锁类型及其应用"><a href="#锁类型及其应用" class="headerlink" title="锁类型及其应用"></a>锁类型及其应用</h3><p>互斥锁（InterProcessMutex）：基于临时顺序节点实现，通过竞争最小序号获得锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutexLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        </span><br><span class="line">        <span class="type">InterProcessMutex</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/locks/mutex&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取锁（阻塞等待，支持超时设置）</span></span><br><span class="line">            <span class="keyword">if</span> (lock.acquire(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得锁&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟业务处理</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock.isAcquiredInThisProcess()) &#123;</span><br><span class="line">                    lock.release();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁（InterProcessReadWriteLock）:</p><ul><li>读锁：共享锁，多个客户端可同时持有</li></ul><ul><li>写锁：独占锁，与其他所有锁互斥</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InterProcessReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(client, <span class="string">&quot;/locks/rwlock&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();</span><br><span class="line">readLock.acquire();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();</span><br><span class="line">writeLock.acquire();</span><br></pre></td></tr></table></figure><p>联锁（InterProcessMultiLock）:同时锁定多个路径，<strong>原子性</strong>获取&#x2F;释放多个锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;InterProcessLock&gt; locks = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/locks/lock1&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/locks/lock2&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">InterProcessMultiLock</span> <span class="variable">multiLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMultiLock</span>(locks);</span><br><span class="line">multiLock.acquire(); <span class="comment">// 所有锁同时获取</span></span><br><span class="line">multiLock.release(); <span class="comment">// 所有锁同时释放</span></span><br></pre></td></tr></table></figure><p>信号量（InterProcessSemaphoreV2）:控制同时访问资源的客户端数量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InterProcessSemaphoreV2</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreV2</span>(client, <span class="string">&quot;/locks/semaphore&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">Lease</span> <span class="variable">lease</span> <span class="operator">=</span> semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">semaphore.returnLease(lease);      <span class="comment">// 释放许可</span></span><br></pre></td></tr></table></figure><h2 id="Zookeeper集群"><a href="#Zookeeper集群" class="headerlink" title="Zookeeper集群"></a>Zookeeper集群</h2><p>节点角色：</p><table><thead><tr><th><strong>角色</strong></th><th><strong>职责</strong></th><th><strong>数量要求</strong></th></tr></thead><tbody><tr><td><strong>Leader</strong></td><td>处理所有写请求，发起提案投票</td><td>1（唯一活跃）</td></tr><tr><td><strong>Follower</strong></td><td>参与投票，处理读请求（可能返回旧数据）</td><td>≥1</td></tr><tr><td><strong>Observer</strong></td><td>仅同步数据，不参与投票（扩展读性能）</td><td>可选（可水平扩展）</td></tr></tbody></table><h3 id="Leader的选举（Fast-Leader-Election算法）"><a href="#Leader的选举（Fast-Leader-Election算法）" class="headerlink" title="Leader的选举（Fast Leader Election算法）"></a>Leader的选举（Fast Leader Election算法）</h3><p>Serverid：服务器ID，比如有三台服务器，编号分别是1,2,3。编号越大在选择算法中的权重越大。</p><p>Zxid：数据ID，服务器中存放的最大数据ID。值越大说明数据越新，在选举算法中数据越新权重越大。</p><p>在Leader选举的过程中，如果某台ZooKeeper获得了超过半数的选票，则此ZooKeeper就可以成为Leader了。</p><p>并且在选取leader后新增节点，只要leader节点不挂，就不会重新选举</p><h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><p>ZAB协议（ZooKeeper Atomic Broadcast）</p><ul><li>两种模式<ol><li>崩溃恢复：选举新Leader并同步数据</li><li>消息广播：Leader将写请求转化为Proposal广播给所有Follower</li></ol></li><li>数据一致性<ul><li>顺序一致性：所有请求按全局顺序执行</li><li>原子性：更新要么全部成功，要么全部失败</li></ul></li></ul><p>会话管理</p><ul><li>会话周期：客户端连接时创建，超时或断开时结束</li><li>临时节点：会话结束自动删除（用于实现服务注册）</li></ul><p>数据同步流程</p><ol><li>客户端向Leader发起写请求</li><li>Leader生成Proposal广播给所有Follower</li><li>Follower持久化Proposal后返回ACK</li><li>Leader收到半数以上ACK后提交Commit</li><li>Leader通知所有节点应用变更</li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>如果Leader挂了，其他节点没挂会怎么样？</li></ol><p>那么会在其他Follower中选取新Leader，如果节点数量过少，就直接显示不可用</p><ol start="2"><li>如果Follower挂了会怎么样？</li></ol><p>不怎么样，其他节点继续工作，但是如果剩余节点过少，就显示不可用</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Zookeeper/">Zookeeper</category>
      
      
      <category domain="http://example.com/tags/Zookeeper/">Zookeeper</category>
      
      
      <comments>http://example.com/inori/f8d5b7cd.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>dubbo基础入门</title>
      <link>http://example.com/inori/741a547a.html</link>
      <guid>http://example.com/inori/741a547a.html</guid>
      <pubDate>Mon, 21 Apr 2025 04:42:46 GMT</pubDate>
      
      <description>dubbo基础入门</description>
      
      
      
      <content:encoded><![CDATA[<p>Dubbo是一款高性能RPC(Remote Procedure Call，远程过程调用)框架，专注于分布式服务治理，提供服务发现、负载均衡、容错等能力</p><h2 id="Dubbo架构"><a href="#Dubbo架构" class="headerlink" title="Dubbo架构"></a>Dubbo架构</h2><p>Dubbo的架构包含5个核心角色：</p><ol><li>Provider：服务提供者，暴露服务接口</li><li>Consumer：服务消费者，调用远程服务</li><li>Registry（注册中心）：服务注册和发现的注册中心，存储服务元数据（如 IP、端口），支持 ZooKeeper&#x2F;Nacos&#x2F;Redis等注册中心</li><li>Monitor（监控中心）：统计服务调用次数和耗时</li><li>Config Center（配置中心）：动态调整参数（如超时时间）</li></ol><p><img src="/inori/741a547a/dubbo.png"></p><h2 id="Dubbo快速入门"><a href="#Dubbo快速入门" class="headerlink" title="Dubbo快速入门"></a>Dubbo快速入门</h2><p>采用SpringBoot+Dubbo+Zookeeper实现服务提供者和消费者之间的调用：</p><ul><li>dubbo-provider: 服务提供者</li><li>dubbo-consumer: 服务消费者</li></ul><p>由于提供者和消费者之间需要统一类，所以两者通常要依赖同一个公共接口，编写一个接口类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建提供者模块启动类<code>DubboProviderApplication.java</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboProviderApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DubboProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口实现类<code>GreetingServiceImpl.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.api.GreetingService;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.annotation.DubboService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DubboService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GreetingServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">GreetingService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot; from provider!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>application.yml</code></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-demo-provider</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br><span class="line">  <span class="attr">protocol:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">20880</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建消费者模块启动类<code>DubboConsumerApplication.java</code>:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableDubbo</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboConsumerApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> com.example.api.GreetingService greetingService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DubboConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> greetingService.sayHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Received: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>application.yml</code>:</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dubbo:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dubbo-demo-consumer</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">address:</span> <span class="string">zookeeper://127.0.0.1:2181</span></span><br></pre></td></tr></table></figure><h2 id="Dubbo工作流程"><a href="#Dubbo工作流程" class="headerlink" title="Dubbo工作流程"></a>Dubbo工作流程</h2><ol><li><strong>服务暴露</strong>：<ul><li>Provider启动时向注册中心注册服务</li><li>注册中心存储服务元数据（如 <code>com.example.UserService</code> → <code>192.168.1.1:20880</code>）</li></ul></li><li><strong>服务发现</strong>：<ul><li>Consumer订阅注册中心，获取Provider地址列表</li><li>注册中心通过Watcher机制推送变更（如新增 Provider）</li></ul></li><li><strong>服务调用</strong>：<ul><li>Consumer通过负载均衡策略选择Provider</li><li>通过Netty发送序列化后的请求数据</li><li>Provider 执行本地方法并返回结果</li></ul></li><li><strong>监控上报</strong>：<ul><li>调用次数、耗时等数据异步上报到Monitor</li></ul></li></ol><h2 id="Dubbo高级特性"><a href="#Dubbo高级特性" class="headerlink" title="Dubbo高级特性"></a>Dubbo高级特性</h2><ol><li>序列化</li></ol><p>两个机器在传输数据时，如何传输Java对象？</p><p>答：Dubbo内部已经将序列化和反序列化的过程内部封装了，我们只需要在定义pojo类时实现<code>Serializable</code>接口即可，一般会定义一个公共的pojo模块，让生产者和消费者都依赖该模块。</p><ol start="2"><li>地址缓存</li></ol><p>注册中心挂了，服务是否可以正常访问？</p><p>答：可以，因为Dubbo服务消费者在第一次调用时，会将服务提供方地址缓存到本地，以后再调用则不会访问注册中心。当服务提供者地址发生变化时，注册中心会通知服务消费者。</p><ol start="3"><li>超时重试</li></ol><p>服务消费者在调用服务提供者的时候如果发生了阻塞、等待的情形，如果不做处理，服务消费者会一直等待下去，在某个峰值时刻，大量的请求都在同时请求服务消费者，会造成线程的大量堆积，势必会造成雪崩，Dubbo是如何解决的？</p><p>答：Dubbo利用超时机制来解决这个问题，设置一个超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。使用timeout属性配置超时时间，默认1000毫秒。如果出现网络抖动，则这一次请求就会失败。Dubbo还提供重试机制来避免类似问题的发生。通过retries属性来设置重试次数，默认为2次。</p><ol start="4"><li>多版本管理</li></ol><p>灰度发布：当出现新功能时，会让一部分用户先使用新功能，用户反馈没问题时，再将所有用户迁移到新功能。<br>Dubbo中使用<code>version</code>属性来设置和调用同一个接口的不同版本，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(version = &quot;1.0.0&quot;)</span><span class="comment">// 1.0版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User-&quot;</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dubbo服务治理"><a href="#Dubbo服务治理" class="headerlink" title="Dubbo服务治理"></a>Dubbo服务治理</h2><table><thead><tr><th>功能</th><th>实现方式</th></tr></thead><tbody><tr><td><strong>负载均衡</strong></td><td>Random（默认）&#x2F;RoundRobin&#x2F;LeastActive&#x2F;一致性 Hash</td></tr><tr><td><strong>集群容错</strong></td><td>Failover（自动重试其他节点）&#x2F;Failfast（快速失败）&#x2F;Failsafe（忽略错误）</td></tr><tr><td><strong>服务路由</strong></td><td>基于条件规则（如 tag 路由）或脚本路由</td></tr><tr><td><strong>服务降级</strong></td><td>Mock 机制（在调用失败时返回本地模拟数据）</td></tr></tbody></table><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><ul><li>Random：按权重随机，默认值。按权重设置随机概率</li><li>RoundRobin：按权重轮询</li><li>LeastActive：最少活跃调用数，相同活跃数的随机</li><li>ConsistentHash：一致性Hash，相同参数的请求总是发到同一提供者</li></ul><h3 id="集群容错策略"><a href="#集群容错策略" class="headerlink" title="集群容错策略"></a>集群容错策略</h3><ul><li>Failover Cluster：失败重试。默认值。当出现失败，重试其它服务器 ，默认重试2次，使用 retries 配置。一般用于读操作</li><li>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于写操作</li><li>Failsafe Cluster：失败安全，出现异常时，直接忽略。返回一个空结果</li><li>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作</li><li>Forking Cluster：并行调用多个服务器，只要一个成功即返回</li><li>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错。</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/dubbo/">dubbo</category>
      
      
      <category domain="http://example.com/tags/dubbo/">dubbo</category>
      
      
      <comments>http://example.com/inori/741a547a.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JUC线程池</title>
      <link>http://example.com/inori/e590136b.html</link>
      <guid>http://example.com/inori/e590136b.html</guid>
      <pubDate>Wed, 19 Mar 2025 11:14:16 GMT</pubDate>
      
      <description>java多线程</description>
      
      
      
      <content:encoded><![CDATA[<p>利用多线程，程序可以更加合理地使用CPU多核心资源，在同一时间完成更多的工作。但是，如果程序频繁地创建线程，由于线程的创建和销毁也需要占用系统资源，因此这样会降低整个程序的性能，利用线程池可以将已创建的线程复用，利用池化技术，就像数据库连接池一样，创建很多个线程，然后反复地使用这些线程，而不对它们进行销毁。</p><p>由于线程池可以反复利用已有线程执行多线程操作，所以它一般是有容量限制的，当所有的线程都处于工作状态时，那么新的多线程请求会被阻塞，直到有一个线程空闲出来为止，这里会用到阻塞队列</p><p><img src="/inori/e590136b/threadPool.png"></p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>线程池的构造方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">            <span class="literal">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="built_in">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的参数：</p><ul><li>corePoolSize：<strong>核心线程池大小</strong>，每向线程池提交一个多线程任务都会创建一个新的<code>核心线程</code>，无论是否存在其他空闲线程，直到到达核心线程池大小为止，之后会尝试复用线程资源。也可以在一开始就全部初始化好，调用<code> prestartAllCoreThreads()</code>即可</li><li>maximumPoolSize：<strong>最大线程池大小</strong>，当目前线程池中所有的线程都处于运行状态，并且等待队列已满，那么就会直接尝试继续创建新的<code>非核心线程</code>运行，但是不能超过最大线程池大小</li><li>keepAliveTime：<strong>线程最大空闲时间</strong>，当一个<code>非核心线程</code>空闲超过一定时间，会自动销毁。</li><li>unit：<strong>线程最大空闲时间的时间单位</strong></li><li>workQueue：<strong>线程等待队列</strong>，当线程池中核心线程数已满时，就会将任务暂时存到等待队列中，直到有线程资源可用为止，这里可以使用我们上一章学到的阻塞队列</li><li>threadFactory：<strong>线程创建工厂</strong>，我们可以干涉线程池中线程的创建过程，进行自定义。</li><li>handler：<strong>拒绝策略</strong>，当等待队列和线程池都没有空间了，真的不能再来新的任务时，来了个新的多线程任务，那么只能拒绝了，这时就会根据当前设定的拒绝策略进行处理</li></ul><p>整体流程：<u>核心线程 -&gt; 核心线程满 -&gt; 剩余任务进入阻塞队列 -&gt; 阻塞队列满 -&gt; 开启非核心线程执行阻塞队列满后面到的任务 -&gt; 线程数量超过<code>maximumPoolSize</code> -&gt; 拒绝后续任务</u></p><p>线程池的拒绝策略默认有四个：</p><ul><li><code>AbortPolicy(默认)</code>：直接抛异常</li><li><code>CallerRunsPolicy</code>：直接让提交任务的线程运行这个任务，比如在主线程向线程池提交了任务，那么就直接由主线程执行</li><li><code>DiscardOldestPolicy</code>：丢弃队列中最近的一个任务，替换为当前任务</li><li><code>DiscardPolicy</code>：直接丢弃新提交的任务</li></ul><p>注意：如果任务在运行过程中出现异常了，会导致线程池中的线程被销毁,线程池会自动创建新的线程来替代被销毁的线程</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>, <span class="number">4</span>,   <span class="comment">//2个核心线程，最大线程数为4个</span></span><br><span class="line">                    <span class="number">3</span>, TimeUnit.SECONDS,        <span class="comment">//最大空闲时间为3秒钟</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>));     <span class="comment">//这里使用容量为2的ArrayBlockingQueue队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;   <span class="comment">//开始6个任务</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">        executor.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 开始执行！（&quot;</span>+ finalI);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 已结束！（&quot;</span>+finalI);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);    <span class="comment">//看看当前线程池中的线程数量</span></span><br><span class="line">    System.out.println(<span class="string">&quot;线程池中线程数量：&quot;</span>+executor.getPoolSize());</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);     <span class="comment">//等到超过空闲时间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;线程池中线程数量：&quot;</span>+executor.getPoolSize());</span><br><span class="line"></span><br><span class="line">    executor.shutdownNow();    <span class="comment">//使用完线程池记得关闭，不然程序不会结束，它会取消所有等待中的任务以及试图中断正在执行的任务，关闭后，无法再提交任务，一律拒绝</span></span><br><span class="line">  <span class="comment">//executor.shutdown();     //同样可以关闭，但是会执行完等待队列中的任务再关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池类"><a href="#线程池类" class="headerlink" title="线程池类"></a>线程池类</h3><ol><li><code>newFixedThreadPool(int nThreads)</code></li></ol><ul><li>作用：创建一个<strong>固定大小</strong>的线程池</li><li>特点：<ul><li>线程池中的线程数量固定，不会动态变化</li><li>任务队列是无界的（<code>LinkedBlockingQueue</code>），如果任务数量超过线程数量，任务会排队等待</li></ul></li><li>适用场景：适用于负载比较稳定的服务器，或者需要限制线程数量的场景</li></ul><ol start="2"><li><code>newCachedThreadPool()</code></li></ol><ul><li>作用：创建一个<strong>可缓存</strong>的线程池</li><li>特点：<ul><li>线程池中的线程数量会根据任务数量动态调整，所有的线程都是<code>非核心线程</code></li><li>空闲线程会在60秒后被回收</li><li>任务队列是同步队列（<code>SynchronousQueue</code>），不会存储任务，新任务会立即执行或创建新线程</li></ul></li><li>适用场景：适用于执行大量短期异步任务，或者任务执行时间较短的场景</li></ul><ol start="3"><li><code>newSingleThreadExecutor()</code></li></ol><ul><li>作用：创建一个<strong>单线程</strong>的线程池</li><li>特点：<ul><li>线程池中只有一个线程，所有任务按顺序执行</li><li>任务队列是无界的（<code>LinkedBlockingQueue</code>）</li></ul></li><li>适用场景：适用于需要保证任务顺序执行的场景</li></ul><ol start="4"><li><code>newScheduledThreadPool(int corePoolSize)</code></li></ol><ul><li>作用：创建一个<strong>支持定时任务</strong>的线程池</li><li>特点：<ul><li>线程池可以执行定时任务或周期性任务</li><li>任务队列是延迟队列（<code>DelayedWorkQueue</code>）</li></ul></li><li>适用场景：适用于需要执行定时任务或周期性任务的场景</li></ul><h2 id="执行带返回值的任务"><a href="#执行带返回值的任务" class="headerlink" title="执行带返回值的任务"></a>执行带返回值的任务</h2><p>一个多线程任务不仅仅可以是void任务，也可以使用Future得到一个任务的返回值，可以通过它来获取任务的结果以及任务当前是否完成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务，返回 Future 对象</span></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取任务结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务结果: &quot;</span> + future.get());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future还可以取消任务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureCancelExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; future = executor.submit(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消任务</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">cancelled</span> <span class="operator">=</span> future.cancel(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;任务是否被取消: &quot;</span> + cancelled);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查任务状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;任务是否完成: &quot;</span> + future.isDone());</span><br><span class="line">        System.out.println(<span class="string">&quot;任务是否被取消: &quot;</span> + future.isCancelled());</span><br><span class="line"></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用<code>future.cancel(true)</code>取消任务，并中断任务执行</li><li><code>isDone()</code>和<code>isCancelled()</code>方法返回 <code>true</code>，表示任务已被取消</li></ul><h2 id="执行定时任务"><a href="#执行定时任务" class="headerlink" title="执行定时任务"></a>执行定时任务</h2><p>JDK5之后，可以使用<code>ScheduledThreadPoolExecutor</code>来提交定时任务，它继承自<code>ThreadPoolExecutor</code>，并且所有的构造方法都必须要求最大线程池容量为<code>Integer.MAX_VALUE</code>，并且都是采用的<code>DelayedWorkQueue</code>作为等待队列</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><ol><li><code>schedule(Runnable command, long delay, TimeUnit unit)</code></li></ol><ul><li>作用：提交一个延迟任务，在指定的延迟时间<code>delay</code>后执行</li><li>参数：<ul><li><code>command</code>：要执行的任务</li><li><code>delay</code>：延迟时间</li><li><code>unit</code>：时间单位</li></ul></li></ul><ol start="2"><li><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></li></ol><ul><li>作用：提交一个延迟任务，在指定的延迟时间<code>delay</code>后执行，并返回<code>Future</code>对象</li><li>参数：<ul><li><code>callable</code>：要执行的任务</li></ul></li></ul><ol start="3"><li><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></li></ol><ul><li>作用：提交一个周期性任务，在初始延迟时间后开始执行，之后按固定的时间间隔重复执行。</li><li>参数:<ul><li><code>command</code>：要执行的任务</li><li><code>initialDelay</code>：初始延迟时间</li><li><code>period</code>：任务执行的时间间隔</li></ul></li></ul><ol start="4"><li><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></li></ol><ul><li>作用：提交一个周期性任务，在初始延迟时间后开始执行，之后在上一次任务执行完成后，再延迟指定的时间执行下一次任务</li><li>参数：<ul><li><code>command</code>：要执行的任务</li><li><code>initialDelay</code>：初始延迟时间</li><li><code>delay</code>：任务执行完成后的延迟时间</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol><li>延迟任务</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledThreadPoolExecutorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 ScheduledThreadPoolExecutor</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交延迟任务</span></span><br><span class="line">        executor.schedule(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;延迟任务执行，线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">3</span>, TimeUnit.SECONDS); <span class="comment">// 3 秒后执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>固定速率周期性任务</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledAtFixedRateExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交周期性任务</span></span><br><span class="line">        executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;周期性任务执行，线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 1 秒后开始执行，每隔 2 秒执行一次</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>); <span class="comment">// 主线程休眠 10 秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>固定延迟周期性任务</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledWithFixedDelayExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交周期性任务</span></span><br><span class="line">        executor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;周期性任务执行，线程: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 模拟任务执行</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS); <span class="comment">// 1 秒后开始执行，任务执行完成后延迟 2 秒执行下一次任务</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>); <span class="comment">// 主线程休眠 10 秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>scheduleAtFixedRate</code>是如果任务执行时间不到<code>period</code>，就休息到<code>period</code>，否则立刻执行下一次；<code>scheduleWithFixedDelay</code>是无论任务执行用了多长时间，两次任务的时间间隔一定是<code>delay</code></p><h2 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h2><p>在<code>ThreadPoolExecutor</code>中，<code>ctl</code>变量是一个<code>AtomicInteger</code>类型的字段，用于同时表示线程池的状态和线程数量。它是线程池实现中的核心变量，通过位运算来高效地管理线程池的状态和线程数量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个变量比较关键，用到了原子AtomicInteger，用于同时保存线程池运行状态和线程数量（使用原子类是为了保证原子性）</span></span><br><span class="line"><span class="comment">//它是通过拆分32个bit位来保存数据的，前3位保存状态，后29位保存工作线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;    <span class="comment">//29位，线程数量位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;   <span class="comment">//计算得出最大容量（1左移29位，最大容量为2的29次方-1）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的运行状态，都只占用前3位，不会占用后29位</span></span><br><span class="line"><span class="comment">// 接收新任务，并等待执行队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;   <span class="comment">//111 | 0000... (后29数量位，下同)</span></span><br><span class="line"><span class="comment">// 不接收新任务，但是依然等待执行队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;   <span class="comment">//000 | 数量位</span></span><br><span class="line"><span class="comment">// 不接收新任务，也不执行队列中的任务，并且还要中断正在执行中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;   <span class="comment">//001 | 数量位</span></span><br><span class="line"><span class="comment">// 所有的任务都已结束，线程数量为0，即将完全关闭</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;   <span class="comment">//010 | 数量位</span></span><br><span class="line"><span class="comment">// 完全关闭</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;   <span class="comment">//011 | 数量位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装和解析ctl变量的一些方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;   <span class="comment">//对CAPACITY取反就是后29位全部为0，前三位全部为1，接着与c进行与运算，这样就可以只得到前三位的结果了，所以这里是取运行状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//同上，这里是为了得到后29位的结果，所以这里是取线程数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;   </span><br><span class="line"><span class="comment">// 比如上面的RUNNING, 0，进行与运算之后：</span></span><br><span class="line"><span class="comment">// 111 | 0000000000000000000000000</span></span><br></pre></td></tr></table></figure><h3 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h3><p><code>execute</code> 方法是线程池的入口，用于提交任务到线程池，具体流程：</p><ol><li>任务提交<ul><li>将任务提交到线程池中执行</li></ul></li><li>线程池状态检查<ul><li>如果线程池状态不是 <code>RUNNING</code>，则拒绝任务</li></ul></li><li>线程数量检查<ul><li>如果线程数量小于 <code>corePoolSize</code>，则创建新的核心线程执行任务</li></ul></li><li>任务队列检查<ul><li>如果线程数量已达到 <code>corePoolSize</code>，则将任务放入任务队列中</li></ul></li><li>创建新线程<ul><li>如果任务队列已满且线程数量小于 <code>maximumPoolSize</code>，则创建新的非核心线程执行任务</li></ul></li><li>拒绝策略<ul><li>如果任务队列已满且线程数量已达到 <code>maximumPoolSize</code>，则执行拒绝策略</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里没加锁，所以ctl才会使用原子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();     <span class="comment">//如果任务为null，返回空指针</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();      <span class="comment">//获取ctl的值，读取信息</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;   <span class="comment">//判断工作线程数量是否小于核心线程数</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))    <span class="comment">//直接加新的线程执行</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();    <span class="comment">//如果线程添加失败（有可能其他线程也在对线程池进行操作），就更新c的值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;   <span class="comment">//继续判断，如果当前线程池是运行状态，那就尝试向阻塞队列中添加一个新的等待任务</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();   <span class="comment">//再次获取ctl的值</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))   <span class="comment">//这里是再次确认当前线程池是否关闭，如果添加等待任务后线程池关闭了，那就把刚刚加进去任务的又拿出来</span></span><br><span class="line">            reject(command);   <span class="comment">//然后直接拒绝当前任务的提交（会根据拒绝策略决定如何进行拒绝操作）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)   <span class="comment">//如果这个时候线程池依然在运行状态，那么就检查一下当前工作线程数是否为0，如果是那就直接添加新线程执行</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);   <span class="comment">//添加一个新的非核心线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))   <span class="comment">//这种情况要么就是线程池没有运行，要么就是队列满了，按照我们之前的规则，核心线程数已满且队列已满，那么会直接添加新的非核心线程，但是如果已经添加到最大数量，这里肯定会失败</span></span><br><span class="line">        reject(command);   <span class="comment">//确实装不下了，只能拒绝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h3><p><code>addWorker</code>方法用于创建新线程并执行任务。主要逻辑：</p><ol><li>线程数量检查<ul><li>如果线程数量已达到上限，则返回false</li></ul></li><li>创建线程<ul><li>创建新线程，并将其封装为Worker对象</li></ul></li><li>启动线程<ul><li>启动线程，开始执行任务</li></ul></li><li>线程池状态检查<ul><li>如果线程池状态不是<code>RUNNING</code>，则回滚线程的创建</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">  <span class="comment">//给最外层循环打了个标签，方便跳转操作</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//无限循环，全程没加锁</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();     <span class="comment">//获取ctl值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);    <span class="comment">//解析当前的运行状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;   <span class="comment">//判断线程池是否不是处于运行状态</span></span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;   <span class="comment">//如果不是运行状态，判断线程是SHUTDOWN状态并、任务不为null、等待队列不为空，只要有其中一者不满足，直接返回false，添加失败</span></span><br><span class="line">               firstTask == <span class="literal">null</span> &amp;&amp;   </span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;   <span class="comment">//内层循环是为了将线程计数增加，然后才可以真正地添加一个新的线程</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);    <span class="comment">//解析当前的工作线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))    <span class="comment">//判断一下还装得下不，如果装得下，看看是核心线程还是非核心线程，如果是核心线程，不能大于核心线程数的限制，如果是非核心线程，不能大于最大线程数限制</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))    <span class="comment">//CAS自增线程计数，如果增加成功，任务完成，直接跳出继续</span></span><br><span class="line">                <span class="keyword">break</span> retry;    <span class="comment">//注意这里要直接跳出最外层循环，所以用到了标签（类似于goto语句）</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// 如果CAS失败，更新一下c的值</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)    <span class="comment">//如果CAS失败的原因是因为线程池状态和一开始的不一样了，那么就重新从外层循环再来一次</span></span><br><span class="line">                <span class="keyword">continue</span> retry;    <span class="comment">//注意这里要直接从最外层循环继续，所以用到了标签（类似于goto语句）</span></span><br><span class="line">            <span class="comment">// 如果是其他原因导致的CAS失败，那只可能是其他线程同时在自增，所以重新再来一次内层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加新的工作线程了</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;   <span class="comment">//工作线程是否已启动</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;    <span class="comment">//工作线程是否已添加</span></span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;     <span class="comment">//工作线程</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);     <span class="comment">//创建新的工作线程，传入提交的任务</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;    <span class="comment">//拿到工作线程中封装的Thread对象</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;      <span class="comment">//如果线程不为null，安排任务</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;      <span class="comment">//ReentrantLock加锁，只有一个线程能进入</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());    <span class="comment">//获取当前线程的运行状态</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;    <span class="comment">//只有当前线程池是正在运行状态，或是SHUTDOWN状态且firstTask为空，那么就继续</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 检查一下线程是否正在运行状态</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();   <span class="comment">//如果是就抛出异常</span></span><br><span class="line">                    workers.add(w);    <span class="comment">//直接将新创建的Work丢进workers集合中</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)   <span class="comment">//记录线程池运行以来，历史上的最多线程数</span></span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="literal">true</span>;   <span class="comment">//工作线程已添加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();   <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();   <span class="comment">//启动线程</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;  <span class="comment">//工作线程已启动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)    <span class="comment">//如果线程在上面的启动过程中失败了</span></span><br><span class="line">            addWorkerFailed(w);    <span class="comment">//将w移出workers并将计数器-1，最后如果线程池是终止状态，会尝试加速终止线程池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;   <span class="comment">//返回是否成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h3><p>继承自<code>AbstractQueuedSynchronizer</code>，也就是说，它本身就是一把锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span></span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//用来干活的线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">//要执行的第一个任务，构造时就确定好了</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">//干活数量计数器，也就是这个线程完成了多少个任务</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// 执行Task之前不让中断，将AQS的state设定为-1</span></span><br><span class="line">        <span class="built_in">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="built_in">this</span>.thread = getThreadFactory().newThread(<span class="built_in">this</span>);   <span class="comment">//通过预定义或是我们自定义的线程工厂创建线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        runWorker(<span class="built_in">this</span>);   <span class="comment">//真正开始干活，包括当前活干完了又要等新的活来</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//0就是没加锁，1就是已加锁</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h3><p><code>unWorker</code> 方法是线程执行任务的核心逻辑：</p><ol><li>任务执行<ul><li>从任务队列中获取任务并执行</li></ul></li><li>线程中断处理<ul><li>如果线程被中断，则退出执行</li></ul></li><li>任务完成处理<ul><li>任务执行完成后，更新线程池状态</li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();   <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;    <span class="comment">//取出要执行的任务</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;   <span class="comment">//然后把Worker中的任务设定为null</span></span><br><span class="line">    w.unlock(); <span class="comment">// 因为一开始为-1，这里是通过unlock操作将其修改回0，只有state大于等于0才能响应中断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//只要任务不为null，或是任务为空但是可以从等待队列中取出任务不为空，那么就开始执行这个任务，注意这里是无限循环，也就是说如果当前没有任务了，那么会在getTask方法中卡住，因为要从阻塞队列中等着取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();    <span class="comment">//对当前Worker加锁，在shutdown时保护此任务的运行</span></span><br><span class="line">            </span><br><span class="line">          <span class="comment">//由于线程池在STOP状态及以上会禁止新线程加入并且中断正在进行的线程</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||   <span class="comment">//线程池是STOP及以上的状态，不能开始新任务</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp;       <span class="comment">//线程是否已经被打上中断标记并且线程一定是STOP及以上</span></span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())   <span class="comment">//再次确保线程被没有打上中断标记</span></span><br><span class="line">                wt.interrupt();     <span class="comment">//打中断标记</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);  <span class="comment">//开始之前的准备工作</span></span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();    <span class="comment">//开始执行任务</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);    <span class="comment">//执行之后的工作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;    <span class="comment">//任务已完成</span></span><br><span class="line">                w.completedTasks++;   <span class="comment">//任务完成数++</span></span><br><span class="line">                w.unlock();    <span class="comment">//解锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">//如果能走到这一步，那说明上面的循环肯定是跳出了，也就是说这个Worker可以丢弃了</span></span><br><span class="line">      <span class="comment">//所以这里会直接将Worker从workers里删除掉</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h3><p><code>getTask</code>方法用于从任务队列中获取任务：</p><ol><li>线程池状态检查<ul><li>如果线程池状态不是<code>RUNNING</code>，则返回<code>null</code></li></ul></li><li>任务队列检查<ul><li>从任务队列中获取任务</li></ul></li><li>线程超时处理<ul><li>如果线程空闲时间超过<code>keepAliveTime</code>，则返回<code>null</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;    <span class="comment">//无限循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();   <span class="comment">//获取ctl </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);      <span class="comment">//解析线程池运行状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;      <span class="comment">//判断是不是没有必要再执行等待队列中的任务了，也就是处于关闭线程池的状态了</span></span><br><span class="line">            decrementWorkerCount();     <span class="comment">//直接减少一个工作线程数量</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;    <span class="comment">//返回null，runWorker直接结束</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);   <span class="comment">//如果线程池运行正常，那就获取当前的工作线程数量</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;   <span class="comment">//如果线程数大于核心线程数或是允许核心线程等待超时，那么就标记为可超时的</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//超时或maximumPoolSize在运行期间被修改了，并且线程数大于1或等待队列为空，那也是不能获取到任务的</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))   <span class="comment">//如果CAS减少工作线程成功</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;    <span class="comment">//返回null</span></span><br><span class="line">            <span class="keyword">continue</span>;   <span class="comment">//否则开下一轮循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :   <span class="comment">//如果可超时，那么最多等到超时时间</span></span><br><span class="line">                workQueue.take();    <span class="comment">//如果不可超时，那就一直等着拿任务</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)    <span class="comment">//成功拿到任务就返回</span></span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="literal">true</span>;   <span class="comment">//否则就是超时了，下一轮循环将直接返回null</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shutdown和shutdownNow方法"><a href="#shutdown和shutdownNow方法" class="headerlink" title="shutdown和shutdownNow方法"></a>shutdown和shutdownNow方法</h3><p>shutdown会继续将等待队列中的线程执行完成后再关闭线程池:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//判断是否有权限终止</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      <span class="comment">//CAS将线程池运行状态改为SHUTDOWN状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">       <span class="comment">//让闲着的线程（比如正在等新的任务）中断，但是并不会影响正在运行的线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">//给ScheduledThreadPoolExecutor提供的钩子方法，就是等ScheduledThreadPoolExecutor去实现的，当前类没有实现</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();   <span class="comment">//最后尝试终止线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shutdownNow开始后，不仅不允许新的任务到来，也不会再执行等待队列的线程，而且会终止正在执行的线程:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">      <span class="comment">//直接设定为STOP状态了</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">      <span class="comment">//中断所有工作线程</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">      <span class="comment">//取出仍处于阻塞队列中的线程</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;   <span class="comment">//最后返回还没开始的任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tryTerminate方法"><a href="#tryTerminate方法" class="headerlink" title="tryTerminate方法"></a>tryTerminate方法</h3><p><code>tryTerminate</code>方法用于尝试终止线程池：</p><ol><li>线程池状态检查<ul><li>如果线程池状态不是<code>SHUTDOWN</code>或<code>STOP</code>，则返回</li></ul></li><li>线程数量检查<ul><li>如果线程数量不为 0，则中断空闲线程</li></ul></li><li>状态转换<ul><li>如果线程池状态为 <code>TIDYING</code>，则调用 <code>terminated()</code> 方法，将状态转换为 <code>TERMINATED</code></li></ul></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryTerminate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;     <span class="comment">//无限循环</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();    <span class="comment">//上来先获取一下ctl值</span></span><br><span class="line">      <span class="comment">//只要是正在运行 或 线程池基本关闭 或 处于SHUTDOWN状态且工作队列不为空，还不能关闭线程池，返回</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//处于SHUTDOWN状态且等待队列为空 或 STOP状态</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// 如果工作线程数不是0，中断空闲状态下的线程</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);   <span class="comment">//最多只中断一个空闲线程，然后返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//终止线程池</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;   <span class="comment">//先CAS将状态设定为TIDYING表示基本终止</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();   <span class="comment">//终止</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));   <span class="comment">//将状态设定为TERMINATED</span></span><br><span class="line">                    <span class="comment">//如果有线程调用了awaitTermination方法，会等待当前线程池终止，这里就可以唤醒那些等待线程池终止的线程</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//注意如果CAS失败会直接进下一轮循环重新判断</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/e590136b.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JUC并发容器与并发工具</title>
      <link>http://example.com/inori/db6966ce.html</link>
      <guid>http://example.com/inori/db6966ce.html</guid>
      <pubDate>Wed, 19 Mar 2025 07:36:39 GMT</pubDate>
      
      <description>java多线程</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>在单线程模式下，集合类提供的容器可以说是非常方便了，比如链表、顺序表、哈希表等数据结构，但是这些容器在多线程环境下，并不能正常工作。要解决并发情况下的容器问题，可以给方法前面加个synchronzed，或者使用Vector或是Hashtable，但是它们的效率实在是太低了，完全依靠锁来解决问题。</p><p>JUC提供了专用于并发场景下的容器，比如可以代替<code>ArrayList</code>的<code>CopyOnWriteArrayList</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();  <span class="comment">//使用CopyOnWriteArrayList保证线程安全</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            list.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(list.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CopyOnWriteArrayList</code>对于读操作不加锁，而对于写操作是加锁的，类似于读写锁机制，这样就可以保证不丢失读性能的情况下，写操作不会出现问题:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();   <span class="comment">//直接加锁，保证同一时间只有一个线程进行添加操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();  <span class="comment">//获取当前存储元素的数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);   <span class="comment">//直接复制一份数组</span></span><br><span class="line">        newElements[len] = e;   <span class="comment">//修改复制出来的数组</span></span><br><span class="line">        setArray(newElements);   <span class="comment">//将元素数组设定为复制出来的数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于HashMap的并发容器<code>ConcurrentHashMap</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Map&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">                map.put(tmp * <span class="number">100</span> + j, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(map.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK7之前，<code>ConcurrentHashMap</code>的原理类似于LongAdder的压力分散思想，既然每个线程都想抢锁，那就多搞几把锁，让每个线程都能拿到，就不会存在等待的问题了，<code>ConcurrentHashMap</code>将所有数据分为一段一段地存储，先分很多段出来，每一段都给一把锁，当一个线程占锁访问时，只会占用其中一把锁，也就是仅仅锁了一小段数据，而其他段的数据依然可以被其他线程正常访问。</p><p>JDK8之后，<code>ConcurrentHashMap</code>采用了CAS算法配合锁机制实现，其底层与<code>HashMap</code>大差不差，<code>HashMap</code>利用了一个用于存放后续节点的头结点的数组，数组里面的每一个元素都是一个头结点（也可以说就是一个链表），当要新插入一个数据时，会先计算该数据的哈希值，找到数组下标，然后创建一个新的节点，添加到对应的链表后面。当链表的长度达到8时，会自动将链表转换为红黑树，这样能使得原有的查询效率大幅度提高</p><p><img src="/inori/db6966ce/hashmap.png"></p><p><code>ConcurrentHashMap</code>也是维护了一个哈希表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());    <span class="comment">//计算键的hash值，用于确定在哈希表中的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//记录链表长度</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;    <span class="comment">//CAS自旋锁</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();    <span class="comment">//如果数组（哈希表）为空要进行初始化</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;   <span class="comment">//如果哈希表该位置为null，直接CAS插入结点作为头结即可（注意这里会将f设置当前哈希表位置上的头结点）</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))  </span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// 如果CAS成功，直接break结束put方法，失败那就继续下一轮循环</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)   <span class="comment">//头结点哈希值为-1，这里只需要知道是因为正在扩容即可</span></span><br><span class="line">            tab = helpTransfer(tab, f);   <span class="comment">//帮助进行迁移，完事之后再来下一次循环</span></span><br><span class="line">        <span class="keyword">else</span> &#123;     <span class="comment">//正常情况</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;   <span class="comment">//在前面的循环中f肯定是被设定为了哈希表某个位置上的头结点，这里直接把它作为锁加锁了，防止同一时间其他线程也在操作哈希表中这个位置上的链表或是红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;    <span class="comment">//头结点的哈希值大于等于0说明是链表，下面就是针对链表的一些列操作</span></span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;   <span class="comment">//针对红黑树的情况进行操作</span></span><br><span class="line">                      <span class="comment">//在ConcurrentHashMap并不是直接存储的TreeNode，而是TreeBin</span></span><br><span class="line">                        <span class="comment">//...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="comment">//根据链表长度决定是否要进化为红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);   <span class="comment">//这里只是可能会进化为红黑树，如果当前哈希表的长度小于64，会优先考虑对哈希表进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConcurrentHashMap</code>的put操作，实际上是对哈希表上的所有头结点元素分别加锁，理论上来说哈希表的长度很大程度上决定了<code>ConcurrentHashMap</code>在同一时间能够处理的线程数量，这也是为什么<code>treeifyBin()</code>会优先考虑为哈希表进行扩容的原因</p><p><img src="/inori/db6966ce/concurrentHashMap.png"></p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>除了常用的容器类之外，JUC还提供了各种各样的阻塞队列，用于不同的工作场景。</p><p>阻塞队列本身也是队列，基于ReentrantLock实现，它的接口定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BlockingQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Queue</span>&lt;E&gt; &#123;</span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，返回false否则返回true（非阻塞）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，阻塞线程直到能入队为止</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//入队，如果队列已满，阻塞线程直到能入队或超时、中断为止，入队成功返回true否则false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，如果队列为空，阻塞线程直到能出队为止</span></span><br><span class="line">    E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出队，如果队列为空，阻塞线程直到能出队超时、中断为止，出队成功正常返回，否则返回null</span></span><br><span class="line">    E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回此队列理想情况下（在没有内存或资源限制的情况下）可以不阻塞地入队的数量，如果没有限制，则返回 Integer.MAX_VALUE</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">remainingCapacity</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一次性从BlockingQueue中获取所有可用的数据对象（还可以指定获取数据的个数）</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">drainTo</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; c, <span class="type">int</span> maxElements)</span>;</span><br></pre></td></tr></table></figure><p>比如现在有一个容量为3的阻塞队列，这个时候一个线程<code>put</code>向其添加了三个元素，第二个线程接着<code>put</code>向其添加三个元素，那么这个时候由于容量已满，会直接被阻塞，而这时第三个线程从队列中取走2个元素，线程二停止阻塞，先丢两个进去，还有一个还是进不去，所以说继续阻塞。</p><p>可以理解为：当队列为空时，获取元素的操作会被阻塞；当队列已满时，添加元素的操作会被阻塞</p><h3 id="常用的实现类"><a href="#常用的实现类" class="headerlink" title="常用的实现类"></a>常用的实现类</h3><ol><li><code>ArrayBlockingQueue</code></li></ol><ul><li>基于数组实现的有界阻塞队列</li><li>初始化时需要指定队列容量:<code>BlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;&gt;(10)</code></li><li>支持公平锁和非公平锁</li></ul><ol start="2"><li><code>LinkedBlockingQueue</code></li></ol><ul><li>基于链表实现的可选有界阻塞队列</li><li>默认容量为<code>Integer.MAX_VALUE</code>，可以指定容量:<code>BlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;(10)</code></li><li>吞吐量通常高于 <code>ArrayBlockingQueue</code></li></ul><ol start="3"><li><code>PriorityBlockingQueue</code></li></ol><ul><li>基于堆实现的优先级阻塞队列</li><li>元素按优先级排序，默认自然顺序或通过 <code>Comparator</code> 指定</li><li>无界队列，容量为<code>Integer.MAX_VALUE</code>:<code>PriorityBlockingQueue&lt;Integer&gt; queue = new PriorityBlockingQueue&lt;&gt;()</code></li></ul><ol start="4"><li><code>DelayQueue</code></li></ol><ul><li>基于优先级队列实现的延迟队列</li><li>元素必须实现 <code>Delayed</code> 接口，只有在延迟时间到达后才能被取出</li><li>无界队列:<code>DelayQueue&lt;DelayedTask&gt; queue = new DelayQueue&lt;&gt;()</code></li></ul><ol start="5"><li><code>SynchronousQueue</code></li></ol><ul><li>一种不存储元素的阻塞队列:<code>SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;&gt;()</code></li><li>每个插入操作必须等待另一个线程的移除操作，反之亦然</li><li>适用于线程之间的直接传递数据</li></ul><table><thead><tr><th><strong>阻塞队列</strong></th><th><strong>特点</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><strong><code>ArrayBlockingQueue</code></strong></td><td>基于数组的有界队列，支持公平锁和非公平锁。</td><td>固定大小的队列，生产者-消费者模型。</td></tr><tr><td><strong><code>LinkedBlockingQueue</code></strong></td><td>基于链表的可选有界队列，默认无界，高吞吐量。</td><td>高吞吐量队列，生产者-消费者模型。</td></tr><tr><td><strong><code>PriorityBlockingQueue</code></strong></td><td>基于堆的优先级队列，无界。</td><td>按优先级处理任务，任务调度。</td></tr><tr><td><strong><code>DelayQueue</code></strong></td><td>延迟队列，元素必须实现 <code>Delayed</code> 接口。</td><td>延迟任务调度，缓存过期策略。</td></tr><tr><td><strong><code>SynchronousQueue</code></strong></td><td>不存储元素，直接传递数据。</td><td>线程间直接数据传递，高并发任务分发。</td></tr></tbody></table><h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="计数器锁-CountDownLatch"><a href="#计数器锁-CountDownLatch" class="headerlink" title="计数器锁 CountDownLatch"></a>计数器锁 CountDownLatch</h2><p>CountDownLatch允许一个或多个线程，等待其他线程完成工作。</p><p>比如有这样一个需求：</p><ul><li>有20个计算任务，需要将这些任务的结果全部计算出来后再汇总，每个任务的执行时间未知</li><li>当所有任务结束之后，立即整合统计最终结果</li></ul><p>使用CountDownLatch可以轻松实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">20</span>);  <span class="comment">//创建一个初始值为20的计数器锁</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (<span class="number">2000</span> * <span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble()));<span class="comment">//模拟任务执行耗时</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            latch.countDown();   <span class="comment">//每执行一次计数器都会-1</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始等待所有的线程完成，当计数器为0时，恢复运行</span></span><br><span class="line">    latch.await();   <span class="comment">//这个操作可以同时被多个线程执行，一起等待，这里只演示了一个</span></span><br><span class="line">    System.out.println(<span class="string">&quot;任务完成&quot;</span>);</span><br><span class="line">  <span class="comment">//注意这个计数器只能使用一次，用完只能重新创一个，没有重置的说法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在调用<code>await()</code>方法之后，实际上就是一个等待计数器衰减为0的过程，而进行自减操作则由各个子线程来完成，当子线程完成工作后，那么就将计数器-1，所有的子线程完成之后，计数器为0，结束等待</p><p>CountDownLatch的基本实现思路：</p><ul><li>利用共享锁实现，同一时刻能有多个线程拥有共享锁，如果一个线程刚获取了共享锁，那么在其之后等待的线程也很有可能能够获取到锁，所以得传播下去继续尝试唤醒后面的结点，并且如果一个线程刚释放了锁，不管是独占锁还是共享锁，都需要唤醒后续等待结点的线程</li><li>在一开始的时候就是已经上了count层锁的状态，也就是<code>state = count</code></li><li><code>await()</code>就是加共享锁，但是必须<code>state</code>为<code>0</code>才能加锁成功，否则按照AQS的机制，会进入等待队列阻塞，加锁成功后结束阻塞</li><li><code>countDown()</code>就是解<code>1</code>层锁，靠这个方法一点一点把<code>state</code>的值减到<code>0</code></li></ul><h2 id="循环屏障-CyclicBarrier"><a href="#循环屏障-CyclicBarrier" class="headerlink" title="循环屏障 CyclicBarrier"></a>循环屏障 CyclicBarrier</h2><p>CyclicBarrier用于让一组线程互相等待，直到所有线程都到达某个屏障点。它的底层实现基于 <code>ReentrantLock</code> 和 <code>Condition</code>，通过计数器机制和条件变量实现线程的等待和唤醒。</p><p>比如需要玩一个开房间游戏，不满足人数不能进，必须等待剩下的人到来之后才能开始游戏，并且保证游戏开始时所有玩家都是同时进入，就可以使用CyclicBarrier：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>,   <span class="comment">//创建一个初始值为10的循环屏障</span></span><br><span class="line">                () -&gt; System.out.println(<span class="string">&quot;准备开始&quot;</span>));   <span class="comment">//人等够之后执行的任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">finalI</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (<span class="number">2000</span> * <span class="keyword">new</span> <span class="title class_">Random</span>().nextDouble()));</span><br><span class="line">                System.out.println(<span class="string">&quot;玩家 &quot;</span>+ finalI +<span class="string">&quot; 进入房间进行等待... (&quot;</span>+barrier.getNumberWaiting()+<span class="string">&quot;/10)&quot;</span>);</span><br><span class="line"></span><br><span class="line">                barrier.await();    <span class="comment">//调用await方法进行等待，直到等待的线程足够多为止</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//所有玩家一起进入</span></span><br><span class="line">                System.out.println(<span class="string">&quot;玩家 &quot;</span>+ finalI +<span class="string">&quot; 进入游戏！&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环屏障会不断阻挡线程，直到被阻挡的线程足够多时，才能一起通过，并且屏障是可循环的，它在被冲破后，会重新开始计数，继续阻挡后续的线程，直到再次满足预定的线程数量。</p><p>除了自动重置之外，也可以调用<code>reset()</code>方法来手动进行重置操作，同样会重新计数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">500</span>);   <span class="comment">//等上面的线程开始运行</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前屏障前的等待线程数：&quot;</span>+barrier.getNumberWaiting());</span><br><span class="line"></span><br><span class="line">    barrier.reset();</span><br><span class="line">    System.out.println(<span class="string">&quot;重置后屏障前的等待线程数：&quot;</span>+barrier.getNumberWaiting());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用<code>reset()</code>之后，处于等待状态下的线程，全部被中断并且抛出<code>BrokenBarrierException</code>异常，循环屏障等待线程数归零。</p><h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h2><p>信号量可以决定某个资源同一时间能够被访问的最大线程数，它相当于对某个资源的访问进行了流量控制。简单来说，它就是一个可以被N个线程占用的排它锁（支持公平和非公平模式，默认是非公平模式），使用时可以在最开始设定Semaphore许可证的数量，每个线程都可以获得1个或n个许可证，当许可证耗尽或不足以供其他线程获取时，其他线程将被阻塞。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="comment">//每一个Semaphore都会在一开始获得指定的许可证数数量，也就是许可证配额</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);   <span class="comment">//许可证配额设定为2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;<span class="comment">// 有3个线程抢这2个信号量</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();   <span class="comment">//申请一个许可证，默认申请1个，acquire(n)则表示申请n个</span></span><br><span class="line">                System.out.println(<span class="string">&quot;许可证申请成功！&quot;</span>);</span><br><span class="line">                semaphore.release();   <span class="comment">//归还一个许可证</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过Semaphore获取一些常规信息：</p><ul><li><code>availablePermits</code>：剩余许可证数量</li><li><code>hasQueuedThreads</code>：是否存在线程等待许可证</li><li><code>getQueueLength</code>：等待许可证线程数量</li><li><code>drainPermits</code>：回收全部许可证</li></ul><p>Semaphore可以控制对共享资源的并发访问数量，避免资源过载。可以管理数据库连接池、线程池等资源，确保资源的使用不超过限制。可以控制并发任务的数量，避免系统资源耗尽等。</p><h2 id="数据交换-Exchanger"><a href="#数据交换-Exchanger" class="headerlink" title="数据交换 Exchanger"></a>数据交换 Exchanger</h2><p>Exchanger底层实现基于CAS和等待队列，能够实现线程之间的数据交换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    Exchanger&lt;String&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到主线程传递的交换数据：&quot;</span>+exchanger.exchange(<span class="string">&quot;AAAA&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    System.out.println(<span class="string">&quot;收到子线程传递的交换数据：&quot;</span>+exchanger.exchange(<span class="string">&quot;BBBB&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Exchanger</code>可以被重复使用，每次交换数据后，可以继续使用</p><p>在调用<code>exchange</code>方法后，当前线程会等待其他线程调用同一个exchanger对象的<code>exchange</code>方法，当另一个线程也调用之后，方法会返回对方线程传入的参数。如果一直没有另一个线程调用<code>exchanger</code>方法，当前线程会进入阻塞状态。</p><h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h2><p>在JDK7时，出现了一个新的框架用于并行执行任务，它能够把大型任务拆分为多个小任务，最后汇总多个小任务的结果，得到整大任务的结果，并且这些小任务都是并行执行的。Fork就是拆分，Join就是合并。它通过工作窃取（Work-Stealing）算法利用多核CPU资源。</p><blockquote><p>工作窃取算法：是指某个线程从其他队列里窃取任务来执行。一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。</p></blockquote><p>Fork&#x2F;Join框架的核心类包括：</p><ol><li><code>ForkJoinPool</code>：任务执行的线程池，负责管理线程和任务队列</li><li><code>ForkJoinTask</code>：表示一个任务，通常使用其子类：<ul><li><code>RecursiveAction</code>：用于没有返回值的任务</li><li><code>RecursiveTask</code>：用于有返回值的任务</li></ul></li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>任务拆分：将一个大任务拆分为多个小任务，直到任务足够小，可以直接执行</li><li>任务执行：将小任务提交到 <code>ForkJoinPool</code> 中执行</li><li>结果合并：将小任务的执行结果合并，得到最终结果</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>计算数组中1~1000的总和：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinSumExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            array[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        <span class="type">SumTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, <span class="number">0</span>, array.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(task); <span class="comment">// 提交任务并获取结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;数组元素和: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<span class="comment">//继承RecursiveTask，这样才可以作为一个任务，泛型就是计算结果类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] array;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> start;<span class="comment">// 限定范围</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">THRESHOLD</span> <span class="operator">=</span> <span class="number">125</span>; <span class="comment">// 任务拆分的阈值，拆分成8组</span></span><br><span class="line"></span><br><span class="line">    SumTask(<span class="type">int</span>[] array, <span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end - start &lt;= THRESHOLD) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小，直接计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;</span><br><span class="line">                sum += array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 任务较大，拆分为两个子任务，类似于递归</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">leftTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, start, mid);</span><br><span class="line">            <span class="type">SumTask</span> <span class="variable">rightTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(array, mid, end);</span><br><span class="line">            leftTask.fork(); <span class="comment">// 将leftTask提交到ForkJoinPool中，由其他线程异步执行，如果范围仍然较大会继续拆分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rightResult</span> <span class="operator">=</span> rightTask.compute(); <span class="comment">// 在当前线程中执行右子任务，如果范围仍然较大会继续拆分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">leftResult</span> <span class="operator">=</span> leftTask.join(); <span class="comment">// 获取左子任务的结果</span></span><br><span class="line">            <span class="keyword">return</span> leftResult + rightResult; <span class="comment">// 合并结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Arrays工具类提供的并行排序也是利用了ForkJoinPool来实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parallelSort</span><span class="params">(<span class="type">byte</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> a.length, p, g;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= MIN_ARRAY_SORT_GRAN ||</span><br><span class="line">        (p = ForkJoinPool.getCommonPoolParallelism()) == <span class="number">1</span>)</span><br><span class="line">        DualPivotQuicksort.sort(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArraysParallelSortHelpers</span>.FJByte.Sorter</span><br><span class="line">            (<span class="literal">null</span>, a, <span class="keyword">new</span> <span class="title class_">byte</span>[n], <span class="number">0</span>, n, <span class="number">0</span>,</span><br><span class="line">             ((g = n / (p &lt;&lt; <span class="number">2</span>)) &lt;= MIN_ARRAY_SORT_GRAN) ?</span><br><span class="line">             MIN_ARRAY_SORT_GRAN : g).invoke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/db6966ce.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JUC锁类和原子类</title>
      <link>http://example.com/inori/4fdd9583.html</link>
      <guid>http://example.com/inori/4fdd9583.html</guid>
      <pubDate>Mon, 17 Mar 2025 07:38:24 GMT</pubDate>
      
      <description>java多线程</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="锁类"><a href="#锁类" class="headerlink" title="锁类"></a>锁类</h1><p>在JDK 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，Lock接口提供了与synchronized关键字类似的同步功能，但需要在使用时手动获取锁和释放锁。</p><h2 id="Lock和Condition接口"><a href="#Lock和Condition接口" class="headerlink" title="Lock和Condition接口"></a>Lock和Condition接口</h2><p>使用并发包中的锁和synchronized锁不太一样，这里的锁可以认为是一把真正意义上的锁，每个锁都是一个对应的锁对象，只需要向锁对象获取锁或是释放锁即可。Lock接口定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">  <span class="comment">//获取锁，拿不到锁会阻塞，等待其他线程释放锁，获取到锁后返回</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//同上，但是等待过程中会响应中断</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//尝试获取锁，但是不会阻塞，如果能获取到会返回true，不能返回false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//尝试获取锁，但是可以限定超时时间，如果超出时间还没拿到锁返回false，否则返回true，可以响应中断</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//释放锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//暂时可以理解为替代传统的Object的wait()、notify()等操作的工具</span></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lock类来进行加锁和释放锁操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Lock</span> <span class="variable">testLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();   <span class="comment">//可重入锁ReentrantLock类是Lock类的一个实现</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">action</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++) &#123;   <span class="comment">//自增</span></span><br><span class="line">                testLock.lock();    <span class="comment">//加锁，加锁成功后其他线程如果也要获取锁，会阻塞，等待当前线程释放</span></span><br><span class="line">                i++;</span><br><span class="line">                testLock.unlock();  <span class="comment">//解锁，释放锁之后其他线程就可以获取这把锁了（在这之前一定得加锁，不然报错）</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(action).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(action).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);   <span class="comment">//等两个线程跑完</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前使用<code>synchronized</code>相比，我们这里是真正在操作一个”锁”对象，当我们需要加锁时，只需要调用<code>lock()</code>方法，而需要释放锁时，只需要调用<code>unlock()</code>方法。程序运行的最终结果和使用<code>synchronized</code>锁是一样的</p><p>如何像传统的加锁那样，调用对象的<code>wait()</code>和<code>notify()</code>方法呢，juc提供了Condition接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">  <span class="comment">//与调用锁对象的wait方法一样，会进入到等待状态，但是这里需要调用Condition的signal或signalAll方法进行唤醒（和普通对象的wait和notify类似）同时，等待状态下是可以响应中断的</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//同上，但不响应中断</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//等待指定时间，如果在指定时间（纳秒）内被唤醒，会返回剩余时间，如果超时，会返回0或负数，可以响应中断</span></span><br><span class="line">  <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//等待指定时间（可以指定时间单位），如果等待时间内被唤醒，返回true，否则返回false，可以响应中断</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//可以指定一个明确的时间点，如果在时间点之前被唤醒，返回true，否则返回false，可以响应中断</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">  <span class="comment">//唤醒一个处于等待状态的线程，注意还得获得锁才能接着运行</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">  <span class="comment">//唤醒所有等待线程</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例演示：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Lock</span> <span class="variable">testLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> testLock.newCondition();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        testLock.lock();   <span class="comment">//必须持有锁的情况下才能使用await</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程1进入等待状态！&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();   <span class="comment">//进入等待状态</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程1等待结束！&quot;</span>);</span><br><span class="line">        testLock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    Thread.sleep(<span class="number">100</span>); <span class="comment">//让线程1先运行</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        testLock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2开始唤醒其他等待线程&quot;</span>);</span><br><span class="line">        condition.signal();   <span class="comment">//唤醒线程1，但是此时线程1还必须要拿到锁才能继续运行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程2结束&quot;</span>);</span><br><span class="line">        testLock.unlock();   <span class="comment">//这里释放锁之后，线程1就可以拿到锁继续运行了</span></span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>前面用到了<code>ReentrantLock</code>，它其实是锁的一种，叫做可重入锁，即同一个线程，可以反复进行加锁操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    lock.lock();</span><br><span class="line">    lock.lock();   <span class="comment">//连续加锁2次</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2想要获取锁&quot;</span>);</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程2成功获取到锁&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1释放了一次锁&quot;</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1再次释放了一次锁&quot;</span>);  <span class="comment">//释放两次后其他线程才能加锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程连续进行了两次加锁操作（此操作是不会被阻塞的），在当前线程持有锁的情况下继续加锁不会被阻塞，并且，加锁几次，就必须要解锁几次，否则此线程依旧持有锁。</p><ul><li><p>可以使用<code>getHoldCount()</code>方法查看当前线程的加锁次数，当锁不再被任何线程持有时，值为<code>0</code>，并且通过<code>isLocked()</code>方法查询结果为<code>false</code></p></li><li><p>如果存在线程持有当前的锁，那么其他线程在获取锁时，会暂时进入到等待队列的，可以通过<code>getQueueLength()</code>方法获取等待中线程数量的预估值</p></li><li><p>可以通过<code>hasQueuedThread(Thread thread)</code>方法来判断某个线程是否正在等待获取锁状态</p></li><li><p>Condition也可以进行判断，通过使用<code>getWaitQueueLength()</code>方法能够查看同一个Condition目前有多少线程处于等待状态：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">       lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前Condition的等待线程数：&quot;</span>+lock.getWaitQueueLength(condition));</span><br><span class="line">    condition.signal();</span><br><span class="line">    System.out.println(<span class="string">&quot;当前Condition的等待线程数：&quot;</span>+lock.getWaitQueueLength(condition));</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>如果线程之间争抢同一把锁，会暂时进入到等待队列中，那么多个线程获得锁的顺序是不是一定是根据线程调用<code>lock()</code>方法时间来定的？</p><p>锁分为公平锁和非公平锁，默认我们创建出来的<code>ReentrantLock</code>是采用的非公平锁作为底层锁机制。</p><ul><li>公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。</li><li>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</li></ul><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>除了可重入锁之外，还有一种类型的锁叫做读写锁，当然它并不是专门用作读写操作的锁，它和可重入锁不同的地方在于，可重入锁是一种排他锁，当一个线程得到锁之后，另一个线程必须等待其释放锁，否则一律不允许获取到锁。而读写锁在同一时间，是可以让多个线程获取到锁的，它其实就是针对于读写场景而出现的。读写锁维护了一个读锁和一个写锁：</p><ul><li>读锁：在没有任何线程占用写锁的情况下，同一时间可以有多个线程加读锁。</li><li>写锁：在没有任何线程占用读锁的情况下，同一时间只能有一个线程加写锁。</li></ul><p>读写锁也有一个专门的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line">    <span class="comment">//获取读锁</span></span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取写锁</span></span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口有一个实现类ReentrantReadWriteLock（实现的是ReadWriteLock接口，不是Lock接口，它本身并不是锁），注意我们操作ReentrantReadWriteLock时，不能直接上锁，而是需要获取读锁或是写锁，再进行锁操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(lock.readLock()::lock).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReentrantReadWriteLock不仅具有读写锁的功能，还保留了可重入锁和公平&#x2F;非公平机制，比如同一个线程可以重复为写锁加锁，并且必须全部解锁才真正释放锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功获取到写锁！&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    System.out.println(<span class="string">&quot;释放第一层锁！&quot;</span>);</span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;释放第二层锁！&quot;</span>);</span><br><span class="line">    lock.writeLock().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁降级和锁升级"><a href="#锁降级和锁升级" class="headerlink" title="锁降级和锁升级"></a>锁降级和锁升级</h3><p>锁降级指的是写锁降级为读锁。当一个线程持有写锁的情况下，虽然其他线程不能加读锁，但是线程自己是可以加读锁的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    lock.writeLock().lock();</span><br><span class="line">    lock.readLock().lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;成功加读锁！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在同时加了写锁和读锁的情况下，释放写锁，其他的线程就可以一起加读锁，这种操作可以称之为”锁降级”（持有写锁的情况下申请读锁再释放写锁）</p><p>在仅持有读锁的情况下去申请写锁，属于”锁升级”，ReentrantReadWriteLock是<strong>不支持</strong>的</p><h2 id="队列同步器AbstractQueuedSynchronizer-AQS"><a href="#队列同步器AbstractQueuedSynchronizer-AQS" class="headerlink" title="队列同步器AbstractQueuedSynchronizer(AQS)"></a>队列同步器AbstractQueuedSynchronizer(AQS)</h2><p>AQS是实现锁机制的基础，它的内部封装了包括锁的获取、释放、以及等待队列</p><p>一个锁的基本功能就是获取锁、释放锁、当锁被占用时，其他线程来争抢会进入等待队列，AQS已经将这些基本的功能封装完成了，其中等待队列是核心内容，等待队列是由<strong>双向链表</strong>实现的，每个等待状态下的线程都可以被封装进结点中并放入双向链表中，而对于双向链表是以队列的形式进行操作的</p><p><img src="/inori/4fdd9583/clh.png" alt="clh"></p><p>AQS内部维护了两个关键变量：</p><ol><li>state（同步状态）</li></ol><ul><li>整数变量，表示资源的占用情况（例如：锁是否被占用，信号量剩余数量）</li><li>通过CAS操作进行更新，保证线程安全</li></ul><ol start="2"><li>FIFO等待队列（CLH队列）</li></ol><ul><li>线程获取资源失败时，会被加入等待队列，并阻塞</li><li>每个节点存储线程信息，便于后续唤醒</li></ul><p>AQS中有一个<code>head</code>字段和一个<code>tail</code>字段分别记录双向链表的头结点和尾结点，而之后的一系列操作都是围绕此队列来进行的。AQS的内部结构：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个处于等待状态的线程都可以是一个节点，并且每个节点有很多状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="comment">//每个节点都可以被分为独占模式节点或是共享模式节点，分别适用于独占锁和共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等待状态，这里都定义好了</span></span><br><span class="line">   <span class="comment">//唯一一个大于0的状态，表示已失效，可能是由于超时或中断，此节点被取消。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">  <span class="comment">//此节点后面的节点被挂起（进入等待状态）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//在条件队列中的节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">  <span class="comment">//传播，一般用于共享锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;    <span class="comment">//等待状态值</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;   <span class="comment">//每一个线程都可以被封装进一个节点进入到等待队列</span></span><br><span class="line">  </span><br><span class="line">    Node nextWaiter;   <span class="comment">//在等待队列中表示模式，条件队列中作为下一个结点的指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ol><li>获取锁（acquire）</li></ol><ul><li><p>尝试修改state（CAS操作），如果成功，直接获得锁</p></li><li><p>如果失败，则进入等待队列，并阻塞自己，等待前驱节点释放锁</p></li></ul><p>独占锁（ReentrantLock）acquire：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;<span class="comment">// arg表示资源数量，控制一次获取多个资源</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryAcquire(arg)</code>：尝试获取锁（由子类实现，如ReentrantLock）</li><li><code>addWaiter(Node.EXCLUSIVE)</code>：将当前线程加入等待队列</li><li><code>acquireQueued()</code>：阻塞当前线程，直到锁被释放</li></ul><ol start="2"><li>释放锁（release）</li></ol><ul><li>修改<code>state</code>变量，表示锁已释放</li><li>唤醒等待队列中的后继线程</li></ul><p>独占锁（ReentrantLock）release：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;<span class="comment">// arg表示资源数量，控制一次释放多个资源</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;  <span class="comment">// 尝试释放锁</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);  <span class="comment">// 唤醒后继线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryRelease(arg)</code>：释放锁（由子类实现）</li><li><code>unparkSuccessor(h)</code>：唤醒等待队列中的下一个线程</li></ul><p><img src="/inori/4fdd9583/aqs.png" alt="aqs"></p><h3 id="AQS的应用"><a href="#AQS的应用" class="headerlink" title="AQS的应用"></a>AQS的应用</h3><table><thead><tr><th>组件</th><th>模式</th><th>作用</th></tr></thead><tbody><tr><td><code>ReentrantLock</code></td><td>独占</td><td>可重入互斥锁</td></tr><tr><td><code>Semaphore</code></td><td>共享</td><td>控制并发访问数量</td></tr><tr><td><code>CountDownLatch</code></td><td>共享</td><td>线程同步（等待计数归零）</td></tr><tr><td><code>ReentrantReadWriteLock</code></td><td>共享&#x2F;独占</td><td>读写分离锁</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>基于AQS实现自定义独占锁：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123; <span class="comment">// CAS 获取锁</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// AQS 提供的模板方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        release(<span class="number">1</span>); <span class="comment">// AQS 提供的模板方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程</p><ol><li>线程调用<code>lock()</code>，进入<code>acquire(1)</code></li><li>尝试<code>tryAcquire()</code>，如果 <code>state=0</code>，CAS设置为1</li><li>如果<code>tryAcquire()</code> 失败，则进入等待队列，阻塞等待唤醒</li><li>调用<code>unlock()</code> 时，执行 <code>release(1)</code>，并唤醒等待队列中的线程</li></ol><h3 id="公平锁的逻辑"><a href="#公平锁的逻辑" class="headerlink" title="公平锁的逻辑"></a>公平锁的逻辑</h3><p>在并发的情况下，公平锁一定公平吗？回顾一下<code>tryAcquire()</code>方法的实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ReservedStackAccess</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;   <span class="comment">//公平锁的机制是，一开始会查看是否有节点处于等待</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;   <span class="comment">//如果前面的方法执行后发现没有等待节点，就直接进入占锁环节了</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以<code>hasQueuedPredecessors()</code>这个环节对于公平锁的公平与否至关重要，否则会直接破坏掉公平性，假如现在出现了这样的情况：</p><p>线程1已经持有锁了，这时线程2来争抢这把锁，走到<code>hasQueuedPredecessors()</code>，判断出为<code>false</code>，线程2继续运行，然后线程2肯定获取锁失败（因为锁这时是被线程1占有的），因此就进入到等待队列中，而这个时候线程3也来抢锁了，按照正常流程走到了<code>hasQueuedPredecessors()</code>方法，因为线程2已经在等待队列中了，所以<code>head!=tail</code>，因此，线程3这时就紧接着准备开始CAS操作了，又碰巧，这时线程1释放锁了，现在的情况就是，线程3直接开始CAS判断，而线程2还在等待队列中，结果可想而知，居然是线程3先拿到了锁，这显然是违背了公平锁的公平机制。</p><p><img src="/inori/4fdd9583/fairLock_nonfair.png" alt="fairLock_nonfair"></p><p>所以公平锁，只有在等待队列存在节点时，才是真正公平的。</p><h3 id="Condition原理"><a href="#Condition原理" class="headerlink" title="Condition原理"></a>Condition原理</h3><p>Condition类实际上就是用于代替传统对象的wait&#x2F;notify操作的，同样可以实现等待&#x2F;通知模式，并且同一把锁下可以创建多个Condition对象。</p><p>在AQS中，Condition有一个实现类ConditionObject，也是使用了链表实现条件队列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1173984872572414699L</span>;</span><br><span class="line">    <span class="comment">/** 条件队列的头结点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">/** 条件队列的尾结点 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>这里是直接使用了AQS中的Node类，但是使用的是Node类中的nextWaiter字段连接节点，并且Node的status为CONDITION：</p><p><img src="/inori/4fdd9583/conditionHead.png" alt="conditionHead"></p><p>当一个线程调用<code>await()</code>方法时，会进入等待状态，直到其他线程调用<code>signal()</code>方法将其唤醒，而这里的条件队列，正是用于存储这些处于等待状态的线程。</p><p><code>await()</code>方法的目标：</p><ul><li>只有已经持有锁的线程才可以使用此方法</li><li>当调用此方法后，会直接释放锁，无论加了多少次锁</li><li>只有其他线程调用<code>signal()</code>或是被中断时才会唤醒等待中的线程</li><li>被唤醒后，需要等待其他线程释放锁，拿到锁之后才可以继续执行，并且会恢复到之前的状态（await之前加了几层锁唤醒后依然是几层锁）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();   <span class="comment">//如果在调用await之前就被添加了中断标记，那么会直接抛出中断异常</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();    <span class="comment">//为当前线程创建一个新的节点，并将其加入到条件队列中</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);    <span class="comment">//完全释放当前线程持有的锁，并且保存一下state值，因为唤醒之后还得恢复</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;     <span class="comment">//用于保存中断状态</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;   <span class="comment">//循环判断是否位于同步队列中，如果等待状态下的线程被其他线程唤醒，那么会正常进入到AQS的等待队列中</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);   <span class="comment">//如果依然处于等待状态，那么继续挂起</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)   <span class="comment">//看看等待的时候是不是被中断了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//出了循环之后，那线程肯定是已经醒了，这时就差拿到锁就可以恢复运行了</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="comment">//acquireQueued尝试拿锁</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) </span><br><span class="line">        unlinkCancelledWaiters();  <span class="comment">//将等待队列中，不是Node.CONDITION状态的节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)   <span class="comment">//依响应中断</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>signal()</code>方法的目标：</p><ul><li>只有持有锁的线程才能唤醒锁所属的Condition等待的线程</li><li>优先唤醒条件队列中的第一个，如果唤醒过程中出现问题，接着找往下找，直到找到一个可以唤醒的</li><li>唤醒操作本质上是将条件队列中的结点直接丢进AQS等待队列中，让其参与到锁的竞争中</li><li>拿到锁之后，线程才能恢复运行</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())    <span class="comment">//当前线程是不是持有锁的状态</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;    <span class="comment">//获取条件队列的第一个结点</span></span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)    <span class="comment">//如果队列不为空，获取到了，那么就可以开始唤醒操作</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)   <span class="comment">//如果当前节点在本轮循环没有后继节点了，条件队列就为空了</span></span><br><span class="line">            lastWaiter = <span class="literal">null</span>;   <span class="comment">//直接清空</span></span><br><span class="line">        first.nextWaiter = <span class="literal">null</span>;   <span class="comment">//将给定节点的下一个结点设置为null，因为当前结点马上就会离开条件队列了</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="literal">null</span>);   <span class="comment">//能走到这里只能说明给定节点被设定为了取消状态，那就继续看下一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果这里CAS失败，那有可能此节点被设定为了取消状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CAS成功之后，结点的等待状态就变成了默认值0，接着通过enq方法直接将节点丢进AQS的等待队列中，相当于唤醒并且可以等待获取锁了</span></span><br><span class="line">  <span class="comment">//这里enq方法返回的是加入之后等待队列队尾的前驱节点，就是原来的tail</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;   <span class="comment">//保存前驱结点的等待状态</span></span><br><span class="line">  <span class="comment">//如果上一个节点的状态为取消, 或者尝试设置上一个节点的状态为SIGNAL失败（可能是在ws&gt;0判断完之后马上变成了取消状态，导致CAS失败）</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);  <span class="comment">//直接唤醒线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LockSupport.unpark(node.thread)</code>为什么要提前来一次unpark呢？</p><p>其实是为了进行优化而编写，直接unpark会有两种情况：</p><ul><li>如果插入结点前，AQS等待队列的队尾节点就已经被取消，则满足<code>wc &gt; 0</code></li><li>如果插入node后，AQS内部等待队列的队尾节点已经稳定，满足<code>tail.waitStatus == 0</code>，但在执行<code>ws &gt; 0</code>之后<code>!compareAndSetWaitStatus(p, ws,Node.SIGNAL)</code>之前被取消，则CAS也会失败，满足<code>compareAndSetWaitStatus(p, ws,Node.SIGNAL) == false</code></li></ul><p>如果这里被提前unpark，那么在<code>await()</code>方法中将可以被直接唤醒，并跳出while循环，直接开始争抢锁，因为前一个等待结点是被取消的状态，没有必要再等它了</p><p><img src="/inori/4fdd9583/await_signal.png" alt="await_signal"></p><h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>之前如果要保证某一个变量操作的原子性，那么我们的唯一选择就是加锁，现在除了加锁之外，JUC还为我们提供了原子类，底层采用CAS算法，它是一种用法简单、性能高效、线程安全地更新变量的方式。</p><p>所有的原子类都位于<code>java.util.concurrent.atomic</code>包下。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>常用基本数据类，有对应的原子类封装：</p><ul><li>AtomicInteger：原子更新int</li><li>AtomicLong：原子更新long</li><li>AtomicBoolean：原子更新boolean</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(i.getAndIncrement());  <span class="comment">//如果想实现i += 2这种操作，可以使用 addAndGet() 自由设置delta值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将int数值封装到此类中（注意必须调用构造方法，它不像Integer那样有装箱机制），并且通过调用此类提供的方法来获取或是对封装的int值进行自增：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100000</span>; j++)</span><br><span class="line">                i.getAndIncrement();</span><br><span class="line">            System.out.println(<span class="string">&quot;自增完成！&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(i.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了基本类有原子类以外，基本类型的数组类型也有原子类：</p><ul><li>AtomicIntegerArray：原子更新int数组</li><li>AtomicLongArray：原子更新long数组</li><li>AtomicReferenceArray：原子更新引用数组</li></ul><p>可以对数组内的元素进行原子操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">AtomicIntegerArray</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;);</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">            array.getAndAdd(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(array.get(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK8之后，新增了<code>DoubleAdder</code>和<code>LongAdder</code>，在高并发情况下，<code>LongAdder</code>的性能比<code>AtomicLong</code>的性能更好，主要体现在自增上，它的大致原理如下：在低并发情况下，和<code>AtomicLong</code>是一样的，对value值进行CAS操作，但是出现高并发的情况时，<code>AtomicLong</code>会进行大量的循环操作来保证同步，而<code>LongAdder</code>会将对value值的CAS操作分散为对数组<code>cells</code>中多个元素的CAS操作（内部维护一个Cell[] as数组，每个Cell里面有一个初始值为0的long型变量，在高并发时会进行分散CAS，就是不同的线程可以对数组中不同的元素进行CAS自增，这样就避免了所有线程都对同一个值进行CAS），只需要最后再将结果加起来即可。</p><p><img src="/inori/4fdd9583/automatic_adder.png" alt="automatic_adder"></p><p>使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">LongAdder</span> <span class="variable">adder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LongAdder</span>();</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">            adder.add(<span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(r).start();   <span class="comment">//100个线程</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    System.out.println(adder.sum());   <span class="comment">//最后求和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了对基本数据类型支持原子操作外，对于引用类型也可以实现原子操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    AtomicReference&lt;String&gt; reference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;(a);</span><br><span class="line">    reference.compareAndSet(a, b);</span><br><span class="line">    System.out.println(reference.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUC还提供了字段原子更新器，可以对类中的某个指定字段进行原子操作（字段必须添加volatile关键字）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        AtomicIntegerFieldUpdater&lt;Student&gt; fieldUpdater =</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(Student.class, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">        System.out.println(fieldUpdater.incrementAndGet(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>现在有这样一种场景：</p><p>线程1和线程2同时开始对<code>a</code>的值进行CAS修改，但是线程1的速度比较快，将a的值修改为2之后紧接着又修改回1，这时线程2才开始进行判断，发现a的值是1，所以CAS操作成功。</p><p>很明显，这里的1已经不是一开始的那个1了，而是被重新赋值的1，这也是CAS操作存在的问题，它只会机械地比较当前值是不是预期值，但是并不会关心当前值是否被修改过，这种问题称之为<code>ABA</code>问题。</p><p>对于ABA问题，JUC提供了带版本号的引用类型，只要每次操作都记录一下版本号，并且版本号不会重复：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line">    AtomicStampedReference&lt;String&gt; reference = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;&gt;(a, <span class="number">1</span>);  <span class="comment">//在构造时需要指定初始值和对应的版本号</span></span><br><span class="line">    reference.attemptStamp(a, <span class="number">2</span>);   <span class="comment">//可以中途对版本号进行修改，注意要填写当前的引用对象</span></span><br><span class="line">    System.out.println(reference.compareAndSet(a, b, <span class="number">2</span>, <span class="number">3</span>));   <span class="comment">//CAS操作时不仅需要提供预期值和修改值，还要提供预期版本号和新的版本号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/4fdd9583.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM类与类加载</title>
      <link>http://example.com/inori/e45c1800.html</link>
      <guid>http://example.com/inori/e45c1800.html</guid>
      <pubDate>Fri, 14 Mar 2025 06:22:49 GMT</pubDate>
      
      <description>JVM类加载部分</description>
      
      
      
      <content:encoded><![CDATA[<p>java的类字节码文件如何加载到内存中的？</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="类加载的触发条件"><a href="#类加载的触发条件" class="headerlink" title="类加载的触发条件"></a>类加载的触发条件</h3><p>JVM并不会一次性加载所有类，而是采用<strong>“按需加载”</strong>策略，即在需要的时候才会进行类的加载。</p><h4 id="触发类加载的操作"><a href="#触发类加载的操作" class="headerlink" title="触发类加载的操作"></a>触发类加载的操作</h4><p>一般在这些情况下，如果类没有被加载，那么会被自动加载：</p><ul><li>使用 <code>new</code> 关键字创建对象时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure><ul><li>访问类的静态变量（包括读取或写入，不是 <code>final</code> 修饰的常量）时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> MyClass.staticField;</span><br></pre></td></tr></table></figure><ul><li>调用类的静态方法时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClass.staticMethod();</span><br></pre></td></tr></table></figure><ul><li>使用反射机制（如 <code>Class.forName()</code>、<code>Class.getMethod()</code> 等）时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>子类初始化时，如果父类尚未初始化，会先触发父类的加载</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>; &#125;</span><br><span class="line">System.out.println(B.b); <span class="comment">// 先加载 A，再加载 B</span></span><br></pre></td></tr></table></figure><ul><li>作为 <code>main</code> 方法所在的类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; &#125; <span class="comment">// Main 类被加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不会触发类加载的操作"><a href="#不会触发类加载的操作" class="headerlink" title="不会触发类加载的操作"></a>不会触发类加载的操作</h4><ul><li>访问 <code>final</code> 修饰的静态变量,<code>final</code> 变量在编译时已确定，不会触发类的初始化</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(A.CONSTANT);<span class="comment">// A 类不会被加载</span></span><br></pre></td></tr></table></figure><ul><li>通过数组定义类的引用,只是创建了一个引用类型数组，并未真正使用A类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A[] array = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">10</span>];<span class="comment">// A 类不会被加载</span></span><br></pre></td></tr></table></figure><ul><li>通过子类访问父类的静态变量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line">System.out.println(B.a);<span class="comment">// 只会触发 A 的加载，B 不会被加载</span></span><br></pre></td></tr></table></figure><h3 id="类加载过程-1"><a href="#类加载过程-1" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>Java 类的加载过程主要包括<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）</strong>五个阶段</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过类的全限定名查找字节码文件（如<code>.class</code>文件）</li><li>将字节码文件转换为内存中的二进制数据</li><li>在方法区（JDK 8之前）或元空间（JDK 8及之后）中创建类的运行时数据结构</li><li>在堆内存中生成一个<code>Class</code>对象，作为方法区或元空间中数据的访问入口</li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul><li>检查字节码文件的正确性和安全性，确保其符合JVM规范</li><li>包括文件格式验证、元数据验证、字节码验证和符号引用验证<ul><li>文件格式验证：是否符合 <code>.class</code> 文件规范（开头八位数，即魔数<code>CAFEBABE</code>）</li><li>元数据验证：类、方法、字段的定义是否合法</li><li>字节码检查：方法调用是否合法，是否越界访问</li><li>符号引用检查：解析阶段前，确保引用的类、方法、字段存在</li></ul></li><li>如果验证失败，会抛出 <code>VerifyError</code></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>为<strong>类的静态变量</strong>分配内存，并赋默认值（非初始化值）</li><li>变量赋的是<strong>默认值</strong>（<code>int</code> -&gt; <code>0</code>，<code>boolean</code> -&gt; <code>false</code>，<code>reference</code> -&gt; <code>null</code>）。</li><li>如果静态变量是常量（<code>final</code>），则直接赋值为指定的初始值</li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将常量池中的<u>符号引用</u>转换为<u>直接引用</u></p><p>符号引用：类的字段、方法的名称和描述符</p><ul><li><code>com/example/A</code> 之类的字符串引用类</li><li><code>A.f</code> 代表字段</li><li><code>A.m()</code> 代表方法</li></ul><p>直接引用：字段、方法在内存中的实际地址</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>执行类的初始化代码，包括静态变量的赋值和静态代码块的执行</p><p>按照<strong>定义顺序</strong>执行类的静态初始化代码，包括：</p><ul><li><strong>静态变量赋值</strong></li><li><strong>静态代码块</strong></li><li><strong>执行 <code>&lt;clinit&gt;()</code> 方法</strong></li></ul><p>执行顺序：</p><ol><li>父类静态变量 &amp; 静态代码块</li><li>子类静态变量 &amp; 静态代码块</li><li>父类实例变量 &amp; 构造代码块</li><li>父类构造方法</li><li>子类实例变量 &amp; 构造代码块</li><li>子类构造方法</li></ol><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>条件：</p><ul><li>类的 <code>ClassLoader</code> 被回收</li><li>该类的所有实例都不可达（GC）</li><li>没有其他类引用该类</li></ul><p>特点：</p><ul><li>只会卸载<strong>用户自定义类</strong>，JDK的核心类不会被卸载</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java提供了类加载器，以便更好地控制类加载，可以自定义类加载器，也可以使用官方自带的类加载器去加载类。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。也就是说，一个类可以由不同的类加载器加载，并且，不同的类加载器加载的出来的类，即使来自同一个Class文件，也是不同的，<strong>只有两个类来自同一个Class文件并且是由同一个类加载器加载的，才能判断为是同一个</strong>。</p><p>默认情况下，所有的类都是由JDK自带的类加载器进行加载，类加载器实现了类的动态加载、隔离和安全性控制。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>类加载器是JVM的一部分，用于查找、加载和定义Java类。主要负责：</p><ol><li><strong>加载类文件</strong>（从磁盘、网络、JAR包等）</li><li><strong>将字节码转换为 Class 对象</strong></li><li><strong>缓存已加载的类</strong>，避免重复加载</li></ol><p>Java采用双亲委派机制来组织多个类加载器，确保类的加载顺序和安全性</p><p>主要有三种由JDK提供的类加载器：</p><table><thead><tr><th>类加载器</th><th>作用</th><th>负责加载的类</th></tr></thead><tbody><tr><td><strong>Bootstrap ClassLoader（启动类加载器）</strong></td><td>最顶层的类加载器，由 JVM 实现</td><td><code>rt.jar</code>（如 <code>java.lang.String</code>、<code>java.util.List</code>）</td></tr><tr><td><strong>Extension ClassLoader（扩展类加载器）</strong></td><td>加载扩展库中的类</td><td><code>lib/ext</code> 目录下的 JAR</td></tr><tr><td><strong>Application ClassLoader（应用类加载器）</strong></td><td>加载应用程序的类</td><td><code>classpath</code> 指定的类</td></tr></tbody></table><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ol><li>检查缓存：如果类已加载，则直接返回Class对象（避免重复加载）</li><li>双亲委派<ul><li>先让父类加载器尝试加载类</li><li>如果找不到，再由当前类加载器加载</li></ul></li><li>转换&amp;解析<ul><li>将字节码转换成Class对象，并存入JVM方法区</li></ul></li><li>返回Class对象，允许实例化对象</li></ol><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><ol><li>当一个类加载器要加载某个类时，先让自己的“父加载器”尝试加载</li><li>如果父加载器找不到该类，才由当前类加载器自己加载</li></ol><p>工作流程：</p><ol><li>类加载请求从最底层的<code>ClassLoader</code>向上层传递。</li><li>顶层加载器（Bootstrap ClassLoader）先尝试加载</li><li>如果上层加载器找不到类，才交给当前类加载器进行加载</li><li>如果类已加载，直接返回<code>Class</code>对象</li></ol><p><img src="/inori/e45c1800/parents_.png" alt="parents_"></p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>Java允许自定义类加载器，用于加载网络、加密、动态生成的类，通过继承 <code>java.lang.ClassLoader</code> 类，可以实现自定义的类加载器。举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath; <span class="comment">// 类路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取字节码文件</span></span><br><span class="line">            <span class="type">byte</span>[] data = loadClassData(name);</span><br><span class="line">            <span class="comment">// 生成 Class 对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;类未找到: &quot;</span> + name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载字节码文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String name) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classPath + name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">             <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建自定义类加载器</span></span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;path/to/classes/&quot;</span>);</span><br><span class="line">        <span class="comment">// 加载类</span></span><br><span class="line">        Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;类加载器: &quot;</span> + clazz.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>findClass</code>方法：</p><ul><li>自定义类加载器需要重写<code>findClass</code>方法，用于加载类的字节码文件</li></ul><p><code>defineClass</code>方法：</p><ul><li>将字节码文件转换为<code>Class</code>对象</li></ul><p><code>loadClassData</code>方法：</p><ul><li>从指定路径读取字节码文件</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/JVM/">JVM</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/e45c1800.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM垃圾回收机制</title>
      <link>http://example.com/inori/4af053c8.html</link>
      <guid>http://example.com/inori/4af053c8.html</guid>
      <pubDate>Fri, 14 Mar 2025 04:55:14 GMT</pubDate>
      
      <description>JVM垃圾回收部分</description>
      
      
      
      <content:encoded><![CDATA[<p>Java会自动管理和释放内存，它不像C&#x2F;C++那样要求我们手动管理内存，JVM提供了一套全自动的内存管理机制，当一个Java对象不再用到时，JVM会自动将其进行回收并释放内存，那么对象所占内存在什么时候被回收，如何判定对象可以被回收，以及如何去进行回收工作也是JVM需要关注的问题。</p><h2 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h2><p>对象在什么情况下可以被判定为不再使用已经可以回收了？</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>如果要经常操作一个对象，那么首先一定会创建一个引用变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str就是一个引用类型的变量，它持有对后面字符串对象的引用，可以代表后面这个字符串对象本身</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>只要一个对象还有使用价值，就可以通过它的引用变量来进行操作，那么可否这样判断一个对象是否还需要被使用：</p><ul><li>每个对象都包含一个引用计数器，用于存放引用计数（存放被引用的次数）</li><li>每当有一个地方引用此对象时，引用计数<code>+1</code></li><li>当引用失效（比如离开了局部变量的作用域或是引用被设定为<code>null</code>）时，引用计数<code>-1</code></li><li>当引用计数为<code>0</code>时，表示此对象不可能再被使用，因为这时我们已经没有任何方法可以得到此对象的引用了</li></ul><p>但是这样存在一个问题，如果两个对象相互引用呢？                  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        a.another = b;</span><br><span class="line">        b.another = a;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里直接把a和b赋值为null，这样前面的两个对象我们不可能再得到了</span></span><br><span class="line">        a = b = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        Test another;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照引用计数算法，那么当出现以上情况时，虽然无法得到此对象的引用，并且此对象也无需再使用，但是由于这两个对象直接存在相互引用的情况，那么引用计数器的值将会永远是<code>1</code>，永远不会被回收，引用计数法并不是最好的解决方案。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>目前比较主流的编程语言，一般都会使用可达性分析算法来判断对象是否存活，它采用了类似于树结构的搜索机制。</p><p>首先每个对象的引用都有机会成为树的根节点（GC Roots），可以被选定作为根节点条件如下：</p><ul><li><strong>虚拟机栈中的局部变量</strong>：当前正在执行的方法中的局部变量引用的对象</li><li><strong>方法区中的静态变量</strong>：类的静态成员变量引用的对象。</li><li><strong>方法区中的常量</strong>：运行时常量池中的常量引用的对象（如字符串常量）</li><li><strong>本地方法栈中的 JNI 引用</strong>：Native 方法引用的对象</li><li><strong>被添加了锁的对象</strong>：比如synchronized关键字</li><li><strong>JVM 内部的特殊对象</strong>：如基本数据类型对应的 Class 对象、异常对象等</li></ul><p>一旦已经存在的根节点不满足存在的条件时，那么根节点与对象之间的连接将被断开。此时虽然对象1仍存在对其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。只要某个对象无法到达任何GC Roots，则证明此对象是不可能再被使用的，就可以被回收。</p><h3 id="最终判定"><a href="#最终判定" class="headerlink" title="最终判定"></a>最终判定</h3><p>虽然在经历了可达性分析算法之后基本可能判定哪些对象能够被回收，但是并不代表此对象一定会被回收，我们依然可以在最终判定阶段对其进行挽留。</p><p><code>finalize()</code>是 Java 中的一个对象生命周期方法，定义在<code>Object</code>类中。它允许对象在垃圾回收之前执行一些清理操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called by the garbage collector on an object when garbage collection</span></span><br><span class="line"><span class="comment"> * determines that there are no more references to the object.</span></span><br><span class="line"><span class="comment"> * A subclass overrides the &#123;<span class="doctag">@code</span> finalize&#125; method to dispose of</span></span><br><span class="line"><span class="comment"> * system resources or to perform other cleanup.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>如果子类重写了此方法，那么子类对象在被判定为可回收时，会进行二次确认，也就是执行<code>finalize()</code>方法，而在此方法中，当前对象是完全有可能重新建立GC Roots的。</p><p>所以，如果在二次确认后对象不满足可回收的条件，那么此对象不会被回收，巧妙地逃过了垃圾回收的命运。比如下面这个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里直接把a赋值为null，这样前面的对象不可能再得到了</span></span><br><span class="line">        a  = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动申请执行垃圾回收操作（注意只是申请，并不一定会执行，但是一般情况下都会执行）</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等垃圾回收</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(a);<span class="comment">// 仍然没有被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            a = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>finalize()</code>方法并不是在主线程调用的，而是虚拟机自动建立的一个<strong>低优先级</strong>的<code>Finalizer</code>线程进行处理。同一个对象的<code>finalize()</code>方法只会有一次调用机会，也就是说，如果连续两次这样操作，那么第二次，对象必定被回收：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    a = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    <span class="comment">// 再来一次</span></span><br><span class="line">    a = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(a);<span class="comment">// a没了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>finalize()</code>方法也并不是专门防止对象被回收的，我们可以使用它来释放一些程序使用中的资源等。<code>finalize()</code>方法的使用需要非常谨慎，因为它可能导致性能问题和不可预测的行为。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>垃圾收集器会不定期地检查堆中的对象，查看它们是否满足被回收的条件。我们该如何对这些对象进行回收？</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记清楚算法会标记出所有需要回收的对象，然后再依次回收掉被标记的对象，或是标记出所有不需要回收的对象，只回收未标记的对象。</p><p><img src="/inori/4af053c8/clear.png" alt="clear"></p><p>虽然此方法非常简单，但是缺点也是非常明显的 ，首先如果内存中存在大量的对象，那么可能就会存在大量的标记，并且大规模进行清除。</p><p>并且一次标记清除之后，连续的内存空间可能会出现许许多多的空隙，碎片化会导致连续内存空间利用率降低</p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>标记复制算法就是将内存区域划分为大小相同的两块区域，每次只使用其中的一块区域，每次垃圾回收结束后，将所有存活的对象全部复制到另一块区域中，并一次性清空当前区域。虽然浪费了一些时间进行复制操作，但是这样能够很好地解决对象大面积回收后空间碎片化严重的问题</p><p><img src="/inori/4af053c8/copy.png" alt="copy"></p><p>这种算法非常适用于新生代（因为新生代的回收效率极高，一般不会留下太多的对象）的垃圾回收，新生代Survivor区就是这个思路，包括8:1:1的比例也正是为了对标记复制算法进行优化而采取的</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>虽然标记-复制算法能够很好地应对新生代高回收率的场景，但是放到老年代，它就显得很鸡肋了。一般长期不回收的对象，才有机会进入到老年代，所以老年代一般都是些钉子户，可能一次GC后，仍然存留很多对象。而标记复制算法会在GC后完整复制整个区域内容，并且会折损50%的区域，显然这并不适用于老年代。</p><p>标记整理算法在标记所有待回收对象之后，不急着去进行回收操作，而是将所有待回收的对象整齐排列在一段内存空间中，而需要回收的对象全部往后丢，这样，前半部分的所有对象都是无需进行回收的，而后半部分直接一次性清除即可。</p><p><img src="/inori/4af053c8/mark_clean.png" alt="mark_clean"></p><p>虽然这样能保证内存空间充分使用，并且也没有标记复制算法那么繁杂，但是缺点是效率比前两者都低。甚至，由于需要修改对象在内存中的位置，此时程序必须要暂停才可以，在极端情况下，可能会导致整个程序发生停顿</p><p>一般将标记清除算法和标记整理算法混合使用，在内存空间还不是很凌乱的时候，采用标记清除算法，当内存空间凌乱到一定程度后，进行一次标记整理算法</p><h3 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h3><p>JVM将堆内存划分为<strong>新生代</strong>、<strong>老年代</strong>和<strong>永久代</strong>（其中永久代是HotSpot虚拟机特有的概念，在JDK8之前方法区实际上就是采用的永久代作为实现，而在JDK8之后，方法区由<strong>元空间</strong>实现，并且使用的是本地内存，容量大小取决于物理机实际大小）</p><p>不同的分代内存回收机制也存在一些不同之处，在HotSpot虚拟机中，新生代被划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1，老年代的GC评率相对较低，永久代一般存放类信息等（其实就是方法区的实现）</p><p><img src="/inori/4af053c8/heap_memo.png" alt="heap_memo"></p><p>新生代</p><ul><li>存放新创建的对象</li><li>特点：<ul><li>大多数对象的生命周期很短，因此新生代是垃圾回收最频繁的区域</li><li>新生代采用<u>标记-复制算法</u>进行垃圾回收</li></ul></li><li>分区：<ul><li><strong>Eden区</strong>：新创建的对象首先分配到 Eden 区</li><li><strong>Survivor区</strong>：分为 <code>From</code> 区和 <code>To</code> 区，用于存放经过垃圾回收后仍然存活的对象</li></ul></li></ul><p>老年代</p><ul><li>存放生命周期较长的对象</li><li>特点：<ul><li>对象在新生代经过多次垃圾回收后仍然存活，会被晋升到老年代</li><li>老年代的垃圾回收频率较低，但每次回收的时间较长</li><li>老年代采用<u>标记-清除算法</u>或<u>标记-整理算法</u>进行垃圾回收</li></ul></li></ul><p>新生代的垃圾回收称为<strong>Minor GC</strong>：</p><p>首先，所有新创建的对象，在一开始都会进入到新生代的Eden区（如果是大对象会被直接丢进老年代），在进行新生代区域的垃圾回收时，首先会对所有新生代区域的对象进行扫描，并回收那些不再使用对象</p><p>接着，在一次垃圾回收之后，Eden区域没有被回收的对象，会进入到Survivor区。在一开始From和To都是空的，而GC之后，所有Eden区域存活的对象都会直接被放入到To区，最后From和To会发生一次交换，即From区是有数据的，To区是空的</p><p>下一次垃圾回收操作与上面是一样的，不过这时由于我们From区域中已经存在对象了，所有From区的对象会进行一次年龄判定（每经历一轮GC年龄<code>+1</code>，如果对象的年龄大于<code>默认值为15</code>，会直接进入到老年代），在Eden区和From区的存活对象复制到To区之后，清空Eden区和From区，交换From区和To区</p><p><strong>Major GC</strong>是针对老年代（Old Generation）的垃圾回收：</p><p>当老年代空间不足时，从GC Roots开始，标记老年代中的存活对象，使用标记-清除算法清除未标记的对象，再用整理算法将存活对象整理到内存的一端，避免内存碎片</p><p>Full GC 是对整个堆内存（包括新生代、老年代和元空间的垃圾回收：</p><p>触发条件：</p><ul><li><strong>老年代空间不足</strong>：当老年代无法容纳从新生代晋升的对象时，触发 Full GC。</li><li><strong>元空间空间不足</strong>：当元空间无法分配新的类元数据时，触发 Full GC。</li><li>**显式调用 System.gc()**：调用 <code>System.gc()</code> 可能触发 Full GC，但 JVM 不保证立即执行。</li></ul><p>过程：</p><ol><li>新生代回收<ul><li>执行 Minor GC，回收新生代中的垃圾</li></ul></li><li>老年代回收<ul><li>执行 Major GC，回收老年代中的垃圾</li></ul></li><li>元空间回收<ul><li>回收不再使用的类元数据</li></ul></li></ol><table><thead><tr><th><strong>特性</strong></th><th><strong>Minor GC</strong></th><th><strong>Major GC</strong></th><th><strong>Full GC</strong></th></tr></thead><tbody><tr><td><strong>回收区域</strong></td><td>新生代（Eden 区、Survivor 区）。</td><td>老年代。</td><td>整个堆内存（新生代、老年代）和元空间。</td></tr><tr><td><strong>触发条件</strong></td><td>Eden 区空间不足。</td><td>老年代空间不足。</td><td>老年代空间不足、元空间空间不足、显式调用 <code>System.gc()</code>。</td></tr><tr><td><strong>频率</strong></td><td>高，因为大多数对象的生命周期很短。</td><td>低，因为老年代的对象生命周期较长。</td><td>低，触发条件较为严格。</td></tr><tr><td><strong>速度</strong></td><td>快，采用复制算法。</td><td>慢，采用标记-清除或标记-整理算法。</td><td>最慢，需要处理整个堆内存和元空间。</td></tr><tr><td><strong>暂停时间</strong></td><td>短，对应用程序的影响较小。</td><td>较长，对应用程序的影响较大。</td><td>最长，对应用程序的影响最大。</td></tr></tbody></table><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>思考一下，有没有这样一种极端情况（正常情况下新生代的回收率是很高的，所以说不用太担心会经常出现这种问题），在一次GC后，新生代Eden区仍然存在大量的对象超出Survivor区的容量，那么该怎么办？</p><p>这时就需要用到空间分配担保机制了，可以把Survivor区无法容纳的对象直接送到老年代，让老年代进行分配担保</p><p>要是老年代也装不下新生代的数据呢？</p><p>这样的话，首先会判断一下<u>之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间</u></p><ul><li>如果小于，那么说明<strong>也许</strong>可以放得下</li><li>否则，会先来一次Full GC，进行一次大规模垃圾回收，尝试腾出空间，再次判断老年代是否有空间存放</li><li>要是还是装不下，抛出Out Of Memory异常</li></ul><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>JDK8之前，Hotspot虚拟机的方法区是永久代实现的。在JDK8之后不再使用永久代，而是采用了全新的元空间，元空间主要用于存储以下内容：</p><ol><li><strong>类的元数据</strong><ul><li>类的全限定名</li><li>类的父类、接口信息</li><li>类的字段、方法、字节码等</li></ul></li><li><strong>运行时常量池</strong><ul><li>字符串常量、数字常量等</li></ul></li><li><strong>方法区内容</strong></li></ol><p>元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。元空间中的类元数据在类卸载时会被垃圾回收，且垃圾回收效率比永久代更高</p><p><img src="/inori/4af053c8/jvm2.png" alt="jvm2"></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>这是一款单线程的垃圾收集器，也就是说，当开始进行垃圾回收时，需要暂停所有的线程，直到垃圾收集工作结束。它的新生代收集算法采用的是标记复制算法，老年代采用的是标记整理算法。</p><img src="/inori/4af053c8/serial.png" alt="serial" style="zoom:50%;"><p>这个收集器的缺点是当进入到垃圾回收阶段时，所有的用户线程必须等待GC线程完成工作</p><p>但是在用户的桌面应用场景中，内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的，所以，在客户端模式（一般用于一些桌面级图形化界面应用程序）下的新生代中，默认垃圾收集器至今依然是Serial收集器</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>这款垃圾收集器相当于是Serial收集器的多线程版本，它能够支持多线程垃圾收集</p><img src="/inori/4af053c8/parnew.png" alt="parnew" style="zoom:50%;"><p>除了多线程支持以外，其他内容基本与Serial收集器一致，目前某些JVM默认的服务端模式新生代收集器就是使用的ParNew收集器</p><h3 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge&#x2F;Parallel Old收集器"></a>Parallel Scavenge&#x2F;Parallel Old收集器</h3><p>与ParNew收集器不同的是，它会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间，这种自适应机制，能够很好地权衡当前机器的性能，根据性能选择最优方案</p><p>吞吐量&#x3D;应用程序运行时间&#x2F;总时间（应用程序运行时间 + 垃圾回收时间)×100%，目标是尽可能提高吞吐量，即让应用程序的运行时间占比最大化。</p><ul><li>垃圾回收器会监控应用程序的运行时间和垃圾回收时间。</li><li>如果垃圾回收时间占比超过目标值，垃圾回收器会调整垃圾回收的频率和每次回收的时间，以确保吞吐量目标</li><li>如果吞吐量低于目标值，垃圾回收器可能会减少垃圾回收的频率，延长每次垃圾回收的时间</li><li>如果吞吐量高于目标值，垃圾回收器可能会增加垃圾回收的频率，缩短每次垃圾回收的时间</li></ul><img src="/inori/4af053c8/parallel.png" alt="parallel" style="zoom:50%;"><p>目前JDK8采用的就是这种 Parallel Scavenge + Parallel Old的垃圾回收方案</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是HotSpot虚拟机中第一款真正意义上的并发（注意这里的并发和之前的并行是有区别的，并发可以理解为同时运行用户线程和GC线程，而并行可以理解为多条GC线程同时工作）收集器，它第一次实现了让垃圾收集线程与用户线程同时工作，他主要采用标记清除算法。</p><img src="/inori/4af053c8/cms.png" alt="cms" style="zoom:50%;"><p>它的垃圾回收分为4个阶段：</p><ul><li>初始标记（需要暂停用户线程）：这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象，速度比较快，不用担心会停顿太长时间</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与应用程序并发运行</li><li>重新标记（需要暂停用户线程）：修正并发标记期间因应用程序运行而导致的标记变化</li><li>并发清除：最后就可以直接将所有标记好的无用对象进行删除，因为这些对象程序中也用不到了，所以可以与用户线程并发运行</li><li>并发重置：重置CMS收集器的内部状态，为下一次垃圾回收做准备</li></ul><p>虽然它的优点非常之大，但是缺点也是显而易见的，我们之前说过，标记清除算法会产生大量的内存碎片，导致可用连续空间逐渐变少，长期这样下来，会有更高的概率触发Full GC，并且在与用户线程并发执行的情况下，也会占用一部分的系统资源，导致用户线程的运行速度一定程度上减慢</p><p>从JDK9开始，CMS收集器被标记为弃用（Deprecated），在JDK14中完全移除</p><h3 id="Garbage-First-G1-收集器"><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First (G1) 收集器"></a>Garbage First (G1) 收集器</h3><p>它是一款主要面向于服务端的垃圾收集器，并且在JDK9时，取代了JDK8默认的Parallel Scavenge + Parallel Old的回收方案</p><p>垃圾回收分为<code>Minor GC</code>、<code>Major GC </code>和<code>Full GC</code>，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而G1收集器绕过了这些，它将整个Java堆划分成多个大小相同的独立<code>Region</code>块，每个<code>Region</code>块的大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且都为2的N次幂。所有的<code>Region</code>大小相同，且在JVM的整个生命周期内不会发生改变，G1优先回收垃圾最多的区域</p><p>每一个<code>Region</code>都可以根据需要，自由决定扮演哪个角色（Eden、Survivor和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1收集器还存在一个<code>Humongous</code>区域，它专门用于存放大对象（一般认为大小超过了Region容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的</p><img src="/inori/4af053c8/g1.png" alt="g1" style="zoom:50%;"><p>回收过程与CMS大体类似，分为以下四个步骤：</p><ul><li>初始标记（暂停用户线程）：仅仅只是标记GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿</li><li>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行</li><li>最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象</li><li>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的</li></ul><img src="/inori/4af053c8/g1_process.png" alt="g1_process" style="zoom:50%;"><h2 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h2><p>在Java中，如果变量是一个对象类型的，那么它实际上存放的是对象的引用，但是如果是一个基本类型，那么存放的就是基本类型的值。平时代码中类似于<code>Object o = new Object()</code>这样的的引用类型，细分之后可以称为<code>强引用</code>。</p><p>当JVM内存空间不足时，JVM宁愿抛出OutOfMemoryError使程序异常终止，也不会靠随意回收具有强引用的存活对象来解决内存不足的问题</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用不像强引用那样不可回收，当JVM认为内存不足时，会去试图回收软引用指向的对象，即JVM会确保在抛出<code>OutOfMemoryError</code>之前，清理软引用指向的对象。如果内存充足，是不会轻易被回收的</p><p>可以通过以下方式来创建一个软引用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//强引用写法：Object obj = new Object();</span></span><br><span class="line">        <span class="comment">//软引用写法：</span></span><br><span class="line">        SoftReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        <span class="comment">//使用get方法就可以获取到软引用所指向的对象了</span></span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软引用还存在一个带队列的构造方法，软引用可以和一个引用队列联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用本身加入到与之关联的引用队列中</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用比软引用的生命周期还要短，在进行垃圾回收时，不管当前内存空间是否充足，都会回收它的内存</p><p>创建一个弱引用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法和软引用是差不多的，但是如果在这之前进行一次GC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动GC</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;软引用对象：&quot;</span>+softReference.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;弱引用对象：&quot;</span>+weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弱引用对象被回收了，而软引用对象没有被回收。同样的，它也支持ReferenceQueue，和软引用用法一致。</p><p><code>WeakHashMap</code>是一种类似于弱引用的HashMap类，如果Map中的Key没有其他引用那么此Map会自动丢弃此键值对：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        WeakHashMap&lt;Integer, String&gt; weakHashMap = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">        weakHashMap.put(a, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line"></span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当变量a的引用断开后，这时只有WeakHashMap本身对此对象存在引用，所以在GC之后，这个键值对就自动被舍弃了。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用相当于没有引用，随时都有可能会被回收。虚引用是最弱的一种引用类型，主要用于跟踪对象被垃圾回收的时机，通常用于实现更精细的资源管理或清理机制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个虚引用，指向 obj，并关联引用队列</span></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虚引用的 get() 方法始终返回 null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;PhantomRef.get(): &quot;</span> + phantomRef.get()); <span class="comment">// 输出 null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 obj 置为 null，使其成为垃圾</span></span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查引用队列</span></span><br><span class="line">        <span class="keyword">if</span> (queue.poll() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象已被回收，虚引用被加入队列&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象未被回收&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虚引用的 <code>get()</code> 方法始终返回 <code>null</code>，因此无法通过虚引用访问对象</li><li>当对象被垃圾回收时，虚引用会被加入到引用队列中</li><li>通过检查引用队列，可以确定对象是否已被回收</li></ul><h3 id="四种引用对象对比"><a href="#四种引用对象对比" class="headerlink" title="四种引用对象对比"></a>四种引用对象对比</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>强引用</strong></th><th><strong>软引用</strong></th><th><strong>弱引用</strong></th><th><strong>虚引用</strong></th></tr></thead><tbody><tr><td><strong>引用强度</strong></td><td>最强</td><td>较强</td><td>较弱</td><td>最弱</td></tr><tr><td><strong>回收时机</strong></td><td>不会被垃圾回收</td><td>内存不足时回收</td><td>下一次垃圾回收时回收</td><td>对象被回收后加入引用队列</td></tr><tr><td><strong><code>get()</code> 方法</strong></td><td>返回对象</td><td>返回对象（如果未被回收）</td><td>返回对象（如果未被回收）</td><td>始终返回 <code>null</code></td></tr><tr><td><strong>使用场景</strong></td><td>默认引用类型</td><td>缓存</td><td>缓存、监听器</td><td>对象回收的跟踪、资源管理</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/JVM/">JVM</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/4af053c8.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM概述与内存管理</title>
      <link>http://example.com/inori/a89a12f2.html</link>
      <guid>http://example.com/inori/a89a12f2.html</guid>
      <pubDate>Thu, 13 Mar 2025 02:19:28 GMT</pubDate>
      
      <description>JVM内存管理部分</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="JVM启动流程"><a href="#JVM启动流程" class="headerlink" title="JVM启动流程"></a>JVM启动流程</h1><p>虚拟机的启动入口位于<code>jdk/src/share/bin/java.c</code>的<code>JLI_Launch</code>函数，整个流程分为如下几个步骤：</p><ol><li>配置JVM装载环境</li><li>解析虚拟机参数</li><li>设置线程栈大小</li><li>执行JavaMain方法</li></ol><p><code>JLI_Launch</code>函数的定义，在入口点的参数有很多个，其中包括当前的完整版本名称、简短版本名称、运行参数、程序名称、启动器名称等：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">JLI_Launch</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv,              <span class="comment">/* main argc, argc */</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> jargc, <span class="type">const</span> <span class="type">char</span>** jargv,          <span class="comment">/* java args */</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> appclassc, <span class="type">const</span> <span class="type">char</span>** appclassv,  <span class="comment">/* app classpath */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* fullversion,                <span class="comment">/* full version defined */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* dotversion,                 <span class="comment">/* dot version defined */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* pname,                      <span class="comment">/* program name */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* lname,                      <span class="comment">/* launcher name */</span></span></span><br><span class="line"><span class="params">        jboolean javaargs,                      <span class="comment">/* JAVA_ARGS */</span></span></span><br><span class="line"><span class="params">        jboolean cpwildcard,                    <span class="comment">/* classpath wildcard */</span></span></span><br><span class="line"><span class="params">        jboolean javaw,                         <span class="comment">/* windows-only javaw */</span></span></span><br><span class="line"><span class="params">        jint     ergo_class                     <span class="comment">/* ergnomics policy */</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>首先会进行一些初始化操作以及Debug信息打印配置等：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InitLauncher(javaw);</span><br><span class="line">DumpState();</span><br><span class="line"><span class="keyword">if</span> (JLI_IsTraceLauncher()) &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Command line args:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc ; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    AddOption(<span class="string">&quot;-Dsun.java.launcher.diag=true&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着选择合适的JRE版本：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sure the specified version of the JRE is running.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are three things to note about the SelectVersion() routine:</span></span><br><span class="line"><span class="comment"> *  1) If the version running isn&#x27;t correct, this routine doesn&#x27;t</span></span><br><span class="line"><span class="comment"> *     return (either the correct version has been exec&#x27;d or an error</span></span><br><span class="line"><span class="comment"> *     was issued).</span></span><br><span class="line"><span class="comment"> *  2) Argc and Argv in this scope are *not* altered by this routine.</span></span><br><span class="line"><span class="comment"> *     It is the responsibility of subsequent code to ignore the</span></span><br><span class="line"><span class="comment"> *     arguments handled by this routine.</span></span><br><span class="line"><span class="comment"> *  3) As a side-effect, the variable &quot;main_class&quot; is guaranteed to</span></span><br><span class="line"><span class="comment"> *     be set (if it should ever be set).  This isn&#x27;t exactly the</span></span><br><span class="line"><span class="comment"> *     poster child for structured programming, but it is a small</span></span><br><span class="line"><span class="comment"> *     price to pay for not processing a jar file operand twice.</span></span><br><span class="line"><span class="comment"> *     (Note: This side effect has been disabled.  See comment on</span></span><br><span class="line"><span class="comment"> *     bugid 5030265 below.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SelectVersion(argc, argv, &amp;main_class);</span><br></pre></td></tr></table></figure><p>接着创建JVM执行环境，例如需要确定数据模型，是32位还是64位，以及jvm本身的一些配置在jvm.cfg文件中读取和解析：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CreateExecutionEnvironment(&amp;argc, &amp;argv,</span><br><span class="line">                               jrepath, <span class="keyword">sizeof</span>(jrepath),</span><br><span class="line">                               jvmpath, <span class="keyword">sizeof</span>(jvmpath),</span><br><span class="line">                               jvmcfg,  <span class="keyword">sizeof</span>(jvmcfg));</span><br></pre></td></tr></table></figure><p>此函数只在头文件中定义，具体的实现是根据不同平台而定的。接着会动态加载jvm.so这个共享库，并把jvm.so中的相关函数导出并且初始化，而启动JVM的函数也在其中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!LoadJavaVM(jvmpath, &amp;ifn)) &#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是对JVM进行初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);</span><br></pre></td></tr></table></figure><p>初始化后在新的线程中执行<code>JavaMain</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize the virtual machine */</span></span><br><span class="line">start = CounterGet();</span><br><span class="line"><span class="keyword">if</span> (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123;</span><br><span class="line">    JLI_ReportErrorMessage(JVM_ERROR1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步初始化虚拟机，如果报错直接退出。</p><p>接着加载主类，因为主类Java程序的入口点：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the application&#x27;s main class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See bugid 5030265.  The Main-Class name has already been parsed</span></span><br><span class="line"><span class="comment"> * from the manifest, but not parsed properly for UTF-8 support.</span></span><br><span class="line"><span class="comment"> * Hence the code here ignores the value previously extracted and</span></span><br><span class="line"><span class="comment"> * uses the pre-existing code to reextract the value.  This is</span></span><br><span class="line"><span class="comment"> * possibly an end of release cycle expedient.  However, it has</span></span><br><span class="line"><span class="comment"> * also been discovered that passing some character sets through</span></span><br><span class="line"><span class="comment"> * the environment has &quot;strange&quot; behavior on some variants of</span></span><br><span class="line"><span class="comment"> * Windows.  Hence, maybe the manifest parsing code local to the</span></span><br><span class="line"><span class="comment"> * launcher should never be enhanced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hence, future work should either:</span></span><br><span class="line"><span class="comment"> *     1)   Correct the local parsing code and verify that the</span></span><br><span class="line"><span class="comment"> *          Main-Class attribute gets properly passed through</span></span><br><span class="line"><span class="comment"> *          all environments,</span></span><br><span class="line"><span class="comment"> *     2)   Remove the vestages of maintaining main_class through</span></span><br><span class="line"><span class="comment"> *          the environment (and remove these comments).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method also correctly handles launching existing JavaFX</span></span><br><span class="line"><span class="comment"> * applications that may or may not have a Main-Class manifest entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mainClass = LoadMainClass(env, mode, what);</span><br></pre></td></tr></table></figure><p>某些没有主方法的Java程序比如JavaFX应用，会获取<code>ApplicationMainClass</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In some cases when launching an application that needs a helper, e.g., a</span></span><br><span class="line"><span class="comment"> * JavaFX application with no main method, the mainClass will not be the</span></span><br><span class="line"><span class="comment"> * applications own main class but rather a helper class. To keep things</span></span><br><span class="line"><span class="comment"> * consistent in the UI we need to track and report the application main class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appClass = GetApplicationClass(env);</span><br></pre></td></tr></table></figure><p>初始化完成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PostJVMInit uses the class name as the application name for GUI purposes,</span></span><br><span class="line"><span class="comment"> * for example, on OSX this sets the application name in the menu bar for</span></span><br><span class="line"><span class="comment"> * both SWT and JavaFX. So we&#x27;ll pass the actual application class here</span></span><br><span class="line"><span class="comment"> * instead of mainClass as that may be a launcher or helper class instead</span></span><br><span class="line"><span class="comment"> * of the application class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PostJVMInit(env, appClass, vm);</span><br></pre></td></tr></table></figure><p>获取主类中的主方法:       </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The LoadMainClass not only loads the main class, it will also ensure</span></span><br><span class="line"><span class="comment"> * that the main method&#x27;s signature is correct, therefore further checking</span></span><br><span class="line"><span class="comment"> * is not required. The main method is invoked here so that extraneous java</span></span><br><span class="line"><span class="comment"> * stacks are not in the application stack trace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, <span class="string">&quot;main&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br></pre></td></tr></table></figure><p>在字节码中<code>void main(String[] args)</code>表示为<code>([Ljava/lang/String;)V</code>。接着调用主方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Invoke main method. */</span></span><br><span class="line">(*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br></pre></td></tr></table></figure><p>调用后，Java程序开始运行，直到走到主方法的最后一行返回：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The launcher&#x27;s exit code (in the absence of calls to</span></span><br><span class="line"><span class="comment"> * System.exit) will be non-zero if main threw an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = (*env)-&gt;ExceptionOccurred(env) == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">LEAVE();</span><br></pre></td></tr></table></figure><p>在最后LEAVE函数中会销毁JVM。</p><p><img src="/inori/a89a12f2/jvm_launch.png" alt="jvm_launch"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>在C&#x2F;C++中，经常通过使用申请内存的方式来创建对象或是存放某些数据，但是这样也带来了一些额外的问题，要在何时释放这些内存，怎么才能使得内存的使用最高效？</p><p>比如通过C语言动态申请内存，并存放数据：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//动态申请4个int大小的内存空间</span></span><br><span class="line">    <span class="type">int</span>* memory = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//修改第一个int空间的值</span></span><br><span class="line">    memory[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//修改第二个int空间的值</span></span><br><span class="line">    memory[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//遍历内存区域中所有的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, memory[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放指针所指向的内存区域</span></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">    <span class="comment">//最后将指针赋值为NULL</span></span><br><span class="line">    memory = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，这种操作实际上是不允许的，Java只支持直接使用基本数据类型和对象类型，至于内存到底如何分配，并不是由我们来处理，而是JVM帮助我们进行控制，这样可以节省很多内存上的工作，虽然带来了很大的便利，但是，一旦出现内存问题，我们就无法像C&#x2F;C++那样对所管理的内存进行合理地处理，因为所有的内存操作都是由JVM在进行，只有了解了JVM的内存管理机制，才能够在出现内存相关问题时找到解决方案。</p><h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p>JVM对内存的管理采用的是分区治理，不同的内存区域有着各自的职责所在。</p><p><img src="/inori/a89a12f2/jvm_memory.png" alt="jvm_memory"></p><p>内存区域一共分为5个区域：方法区，堆，虚拟机栈，本地方法栈，程序计数器。其中方法区和堆是所有线程共享的区域，随着虚拟机的创建而创建，虚拟机的结束而销毁，而虚拟机栈、本地方法栈、程序计数器都是线程之间相互隔离的，每个线程都有一个自己的区域，并且线程启动时会自动创建，结束之后会自动销毁。内存划分完成之后，JVM执行引擎和本地库接口，也就是Java程序开始运行之后就会根据分区合理地使用对应区域的内存了。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>JVM中的程序计数器是当前线程所执行字节码的指令地址指示器。字节码解释器在工作时会根据程序计数器的值执行指令，并在执行完毕后更新程序计数器的值，以指向下一条即将执行的指令。</p><p>在Java的多线程环境中，每个线程都有独立的程序计数器。JVM通过线程调度机制（如操作系统的时间片轮转算法）切换线程的执行。当一个线程被切换出去时，它的程序计数器会记录当前执行的字节码指令地址；当该线程再次被调度执行时，JVM会根据程序计数器的值继续执行后续指令。</p><p>程序计数器只需要记录当前线程执行的字节码指令地址，因此它占用的内存非常小，通常是JVM内存结构中占用最少的部分。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈就是一个非常关键的部分，看名字就知道它是一个栈结构，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（其实就是栈里面的一个元素），栈帧中包括了当前方法的一些信息，比如局部变量表、操作数栈、动态链接、方法出口等。</p><img src="/inori/a89a12f2/vmstack.png" alt="vmstack" style="zoom:70%;"><ul><li>其中局部变量表就是方法中的局部变量，局部变量表在class文件中就已经定义好了</li><li>操作数栈就是之前字节码执行时使用到的栈结构</li><li>每个栈帧保存了一个可以指向当前方法所在类的运行时常量池，当前方法中如果需要调用其他方法的时候，能够从<strong>运行时常量池</strong>中找到对应的符号引用，然后将符号引用转换为直接引用，然后就能直接调用对应方法，这就是动态链接</li><li>方法出口，也就是方法该如何结束，是抛出异常还是正常返回。</li></ul><p>举个例子：              </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> a();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们的主方法执行后，会依次执行三个方法<code>a() -&gt; b() -&gt; c() -&gt; 返回</code></p><p>首先是<code>main</code>方法调用：</p><ul><li>局部变量表：<code>args</code>（<code>main</code> 方法的参数）</li><li>操作数栈：空</li><li>动态链接：指向 <code>main</code> 方法的引用</li><li>返回地址：无（<code>main</code> 方法是程序的入口）</li></ul><p>然后<code>main</code>方法调用<code>a()</code>：</p><ul><li>局部变量表：空（<code>a()</code> 无参数）</li><li>操作数栈：空</li><li>动态链接：指向 <code>a()</code> 方法的引用</li><li>返回地址：<code>main</code> 方法中调用 <code>a()</code> 的下一条指令</li><li>栈状态，由顶到底：<code>a(),main()</code></li></ul><p>…</p><p>到<code>c()</code>调用后：</p><p>栈帧</p><ul><li>局部变量表：<code>a = 10</code>，<code>b = 20</code></li><li>操作数栈：存储 <code>a + b</code> 的计算结果</li><li>动态链接：指向 <code>c()</code> 方法的引用</li><li>返回地址：<code>b()</code> 方法中调用 <code>c()</code> 的下一条指令</li><li>栈状态，由顶到底：<code>c(),b(),a(),main()</code></li></ul><p>然后按照栈弹出顺序返回，最后输出结果。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈作用差不多，用于支持Native方法（非 Java 方法，通常用 C&#x2F;C++ 实现）的执行</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是整个Java应用程序共享的区域，它用于存储所有的类信息、常量、静态变量、动态编译缓存等数据，可以大致分为两个部分，一个是类信息表，一个是运行时常量池</p><img src="/inori/a89a12f2/jvm_method.png" alt="jvm_method" style="zoom:67%;"><p>主要用于存储以下内容：</p><ol><li><strong>类信息</strong>：<ul><li>类的全限定名</li><li>类的直接父类的全限定名</li><li>类的修饰符（如 <code>public</code>、<code>abstract</code>、<code>final</code> 等）</li><li>类的接口信息</li></ul></li><li><strong>字段信息</strong>：<ul><li>字段的名称、类型、修饰符（如 <code>public</code>、<code>private</code>、<code>static</code> 等）</li></ul></li><li><strong>方法信息</strong>：<ul><li>方法的名称、返回类型、参数列表、修饰符（如 <code>public</code>、<code>static</code> 等）</li><li>方法的字节码（Bytecode）、操作数栈、局部变量表等</li></ul></li><li><strong>运行时常量池（Runtime Constant Pool）</strong>：<ul><li>存储编译期生成的字面量（如字符串、数字常量）和符号引用（如类、方法、字段的引用）</li><li>运行时常量池是方法区的一部分，每个类或接口都有自己的运行时常量池</li></ul></li><li><strong>静态变量（Static Variables）</strong>：<ul><li>类的静态变量（<code>static</code> 修饰的变量）存储在方法区中</li></ul></li><li><strong>类加载器引用</strong>：<ul><li>存储加载该类的类加载器的引用</li></ul></li><li><strong>方法代码</strong>：<ul><li>存储方法的字节码和相关的元数据</li></ul></li></ol><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是整个Java应用程序共享的区域，也是整个虚拟机最大的一块内存空间，此区域的职责就是存放和管理对象和数组，后续提到的垃圾回收机制也是主要作用于这一部分内存区域</p><h2 id="爆堆与爆栈"><a href="#爆堆与爆栈" class="headerlink" title="爆堆与爆栈"></a>爆堆与爆栈</h2><p>在Java程序运行时，内存容量不可能是无限制的，当我们的对象创建过多或是数组容量过大时，就会导致我们的堆内存不足以存放更多新的对象或是数组，这时就会出现错误，比如： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOverflowExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 不断创建对象，耗尽堆内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后JVM会抛出 <code>java.lang.OutOfMemoryError: Java heap space</code> 错误，也就是堆内存溢出错误。</p><p>当程序在栈内存中分配的栈帧过多，导致栈内存耗尽时，就会发生爆栈。栈内存用于存储方法调用的栈帧，包括局部变量、操作数栈、方法返回地址等，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        infiniteRecursion(); <span class="comment">// 无限递归，导致爆栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">infiniteRecursion</span><span class="params">()</span> &#123;</span><br><span class="line">        infiniteRecursion(); <span class="comment">// 递归调用自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后JVM会抛出<code>java.lang.StackOverflowError</code>错误。</p><table><thead><tr><th><strong>特性</strong></th><th><strong>爆堆（Heap Overflow）</strong></th><th><strong>爆栈（Stack Overflow）</strong></th></tr></thead><tbody><tr><td><strong>内存区域</strong></td><td>堆内存</td><td>栈内存</td></tr><tr><td><strong>存储内容</strong></td><td>对象实例、数组</td><td>方法调用的栈帧（局部变量、操作数栈、方法返回地址等）</td></tr><tr><td><strong>错误类型</strong></td><td><code>java.lang.OutOfMemoryError: Java heap space</code></td><td><code>java.lang.StackOverflowError</code></td></tr><tr><td><strong>常见原因</strong></td><td>内存泄漏、对象过多、堆内存设置过小</td><td>递归调用过深、栈内存设置过小</td></tr><tr><td><strong>解决方法</strong></td><td>检查内存泄漏、增加堆内存、优化代码</td><td>检查递归终止条件、增加栈内存、优化代码</td></tr></tbody></table><h2 id="申请堆外内存"><a href="#申请堆外内存" class="headerlink" title="申请堆外内存"></a>申请堆外内存</h2><p>除了堆内存可以存放对象数据以外，我们也可以申请堆外内存（直接内存），也就是不受JVM管控的内存区域，这部分区域的内存需要我们自行去申请和释放，实际上本质就是JVM通过C&#x2F;C++调用<code>malloc</code>函数申请的内存。直接内存会受到本机最大内存的限制，有可能抛出<code>OutOfMemoryError</code>异常</p><p>这里需要提到一个堆外内存操作类：<code>Unsafe</code>，这个类不让new，也没有直接获取方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">        sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, <span class="string">&quot;getUnsafe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Unsafe</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);   <span class="comment">//不是JDK的类，不让用。</span></span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过反射拿到Unsafe类之后，就可以开始申请堆外内存了，比如现在要申请一个int大小的内存空间，并在此空间中存放一个int类型的数据：                   </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">    <span class="comment">// 通过反射拿到Unsafe类</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请4字节大小的内存空间，并得到对应位置的地址</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">address</span> <span class="operator">=</span> unsafe.allocateMemory(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//在对应的地址上设定int的值</span></span><br><span class="line">    unsafe.putInt(address, <span class="number">6666666</span>);</span><br><span class="line">    <span class="comment">//获取对应地址上的Int型数值</span></span><br><span class="line">    System.out.println(unsafe.getInt(address));<span class="comment">// 输出666666</span></span><br><span class="line">    <span class="comment">//释放申请到的内容</span></span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于内存已经释放，这时数据就没了</span></span><br><span class="line">    System.out.println(unsafe.getInt(address));<span class="comment">// 野指针，输出随机数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/JVM/">JVM</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/a89a12f2.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>设计模式——行为型模式</title>
      <link>http://example.com/inori/ec6efbf1.html</link>
      <guid>http://example.com/inori/ec6efbf1.html</guid>
      <pubDate>Mon, 10 Mar 2025 05:41:47 GMT</pubDate>
      
      <description>设计模式中的行为型模式</description>
      
      
      
      <content:encoded><![CDATA[<p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式分为：</p><ul><li>模板方法模式</li><li>策略模式</li><li>命令模式</li><li>职责链模式</li><li>状态模式</li><li>观察者模式</li><li>中介者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li><li>解释器模式</li></ul><p>以上11种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式</p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器顾名思义，就是对语言进行解释，根据不同的语义来做不同的事情。笼统点来讲就是给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。</p><p>比如计算器就是根据输入的算式，去进行解析，并根据不同的运算符来不断进行计算。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当语言的文法较为简单，且执行效率不是关键问题时</li><li>当问题重复出现，且可以用一种简单的语言来进行表达时</li><li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候</li></ul><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在浏览器中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p><p>不过备忘录模式为了去保存对象的状态，会占用大量的资源，尤其是那种属性很多的对象，需要合理的使用才能保证程序稳定运行。</p><h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><p>模板方法模式可以定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但另外一些步骤的具体实现还未知，或者说另外一些步骤的实现与具体的环境相关，暂时还不能在这个类中实现。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BankClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">workProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.getNum();<span class="comment">//取号</span></span><br><span class="line">        <span class="built_in">this</span>.queue();<span class="comment">// 排队</span></span><br><span class="line">        <span class="built_in">this</span>.businessHandling();<span class="comment">// 具体业务办理</span></span><br><span class="line">        <span class="built_in">this</span>.evaluate();<span class="comment">// 工作人员评价</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取号都是一样的，直接在该类中写好逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;取号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;排队&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个人办理业务的逻辑和流程可能是不一样的，要在子类中实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">businessHandling</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evaluate</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对工作人员打分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonA</span> <span class="keyword">extends</span> <span class="title class_">BankClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">businessHandling</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;取钱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonB</span> <span class="keyword">extends</span> <span class="title class_">BankClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;存钱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//A来办理业务</span></span><br><span class="line">        <span class="type">AbstractBank</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonA</span>();</span><br><span class="line">        A.workProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//B来办理业务</span></span><br><span class="line">        <span class="type">AbstractBank</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonB</span>();</span><br><span class="line">        B.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：为防止恶意操作，一般模板方法都加上<code>final</code>关键字</p></blockquote><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，提高了代码阅读的难度</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制</li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p><p>举例，现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 numStart 及以上的所有天数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(numStart, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 numStart 到 numEnd 的天数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leave.getNum() &gt;= <span class="built_in">this</span>.numStart &amp;&amp; leave.getNum() &lt;= <span class="built_in">this</span>.numEnd) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line">            System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != <span class="built_in">this</span>.nextHandler) &#123;</span><br><span class="line">            <span class="built_in">this</span>.nextHandler.submit(leave);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无更高权限领导处理，流程终止&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//请假条</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导</span></span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><p>降低了对象之间的耦合度</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的if或者if···else语句</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用</li></ul><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理</p><p>举例，去餐厅点单时，顾客只需要把订单交给服务器，然后等待上菜即可，不用关心菜是如何做出来的，是谁做的，对于厨师也相同，只需要按照订单做菜即可，不需要关心是谁点的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;<span class="comment">//只需要定义一个统一的执行方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有接受者对象</span></span><br><span class="line">    <span class="keyword">private</span> SeniorChef receiver;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCommand</span><span class="params">(SeniorChef receiver, Order order)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">        <span class="built_in">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>  &#123;</span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的订单：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = order.getFoodDic().keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            receiver.makeFood(order.getFoodDic().get(key),key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);<span class="comment">//停顿一下 模拟做饭的过程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的饭弄好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">// 餐桌号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> diningTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来存储餐名并记录份数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDiningTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDiningTable</span><span class="params">(<span class="type">int</span> diningTable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.diningTable = diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">getFoodDic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foodDic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoodDic</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        foodDic.put(name,num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资深大厨类 是命令的Receiver</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeniorChef</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">(<span class="type">int</span> num,String foodName)</span> &#123;</span><br><span class="line">        System.out.println(num + <span class="string">&quot;份&quot;</span> + foodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Command&gt; commands;<span class="comment">//可以持有很多的命令对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Waitor</span><span class="params">()</span> &#123;</span><br><span class="line">        commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command cmd)</span>&#123;</span><br><span class="line">        commands.add(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发出命令 喊 订单来了，厨师开始执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderUp</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新订单来了.......&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; commands.size(); i++) &#123;</span><br><span class="line">            <span class="type">Command</span> <span class="variable">cmd</span> <span class="operator">=</span> commands.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">                cmd.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建2个order</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order1.setDiningTable(<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;西红柿鸡蛋面&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;小杯可乐&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order2.setDiningTable(<span class="number">3</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;尖椒肉丝盖饭&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;小杯雪碧&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建接收者</span></span><br><span class="line">        SeniorChef receiver=<span class="keyword">new</span> <span class="title class_">SeniorChef</span>();</span><br><span class="line">        <span class="comment">//将订单和接收者封装成命令对象</span></span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order1);</span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order2);</span><br><span class="line">        <span class="comment">//创建调用者 waitor</span></span><br><span class="line">        <span class="type">Waitor</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waitor</span>();</span><br><span class="line">        invoker.setCommand(cmd1);</span><br><span class="line">        invoker.setCommand(cmd2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将订单带到柜台 并向厨师喊 订单来了</span></span><br><span class="line">        invoker.orderUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，满足“开闭原则”，对扩展比较灵活</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复</li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类</li><li>系统结构更加复杂</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。</p><p>策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><p>举例，一家百货公司在定年度的促销活动。针对不同的节日推出不同的促销活动，由促销员将促销活动展示给客户</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义百货公司所有促销活动的共同接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体策略角色,每个节日具体的促销活动</span></span><br><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义环境角色，用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SalesMan</span> <span class="variable">salesMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SalesMan</span>(<span class="keyword">new</span> <span class="title class_">StrategyA</span>);</span><br><span class="line">        salesMan.salesManShow();<span class="comment">// 推销</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合开闭原则</p></li><li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想</p></li></ul><p><strong>缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量</li></ul><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为</li></ul><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</p><p>举例，定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现:-</p><p>定义迭代器接口，声明hasNext、next方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Student <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的迭代器类，重写所有的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">currentStudent</span> <span class="operator">=</span> list.get(position);</span><br><span class="line">        position ++;</span><br><span class="line">        <span class="keyword">return</span> currentStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的容器类，重写所有的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();  <span class="comment">// 学生列表</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.add(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentIteratorImpl</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足开闭原则要求</li></ul><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当需要为聚合对象提供多种遍历方式时</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时</li></ul><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式也叫做调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p><p>比如我们想要去外面租房，但是我们怎么知道哪里有可以租的房子呢？于是我们就会上各大租房APP上去找房源，同样的，如果我们现在有房子需要出租，我们也不知道谁会想要租房子，同样的我们也会把房子挂在租房APP上展示，而当我们去租房时或是出租时，就会有一个称为中介的人来跟我们对接，实际上就是一种中介者模式。</p><p>案例实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;   <span class="comment">//房产中介</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, User&gt; userMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();   <span class="comment">//在出售的房子需要存储一下</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String address, User user)</span>&#123;   <span class="comment">//出售房屋的人，需要告诉中介他的房屋在哪里</span></span><br><span class="line">        userMap.put(address, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(String address)</span>&#123;   <span class="comment">//通过此方法来看看有没有对应的房源</span></span><br><span class="line">        <span class="keyword">return</span> userMap.get(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户有两种角色，一种是租房者，一种是出租者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;   <span class="comment">//用户可以是出售房屋的一方，也可以是寻找房屋的一方</span></span><br><span class="line">    String name;</span><br><span class="line">    String tel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String tel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(String address, Mediator mediator)</span>&#123;   <span class="comment">//找房子的话，需要一个中介和你具体想找的地方</span></span><br><span class="line">        <span class="keyword">return</span> mediator.find(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot; (电话：&quot;</span>+tel+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：                   </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;10086&quot;</span>);   <span class="comment">//出租人</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小红&quot;</span>, <span class="string">&quot;10010&quot;</span>);   <span class="comment">//找房人</span></span><br><span class="line">    <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mediator</span>();   <span class="comment">// 中介</span></span><br><span class="line"></span><br><span class="line">    mediator.register(<span class="string">&quot;地址A&quot;</span>, user0);   <span class="comment">// 先把房子给中介挂上去</span></span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> user1.find(<span class="string">&quot;地址B&quot;</span>, mediator);  <span class="comment">//开始找房子</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line"></span><br><span class="line">    user = user1.find(<span class="string">&quot;地址A&quot;</span>, mediator);  <span class="comment">//开始找房子</span></span><br><span class="line">    System.out.println(user);   <span class="comment">//成功找到对应房源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中介者模式优化了原有的复杂多对多关系，而是将其简化为一对多的关系。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在Java中，一个对象的状态发生改变，可能就会影响到其他的对象，与之相关的对象可能也会联动的进行改变。还有我们之前遇到过的监听器机制，当具体的事件触发时，我们在一开始创建的监听器就可以执行相关的逻辑。可以使用观察者模式来实现这样的功能，当对象发生改变时，观察者能够立即观察到并进行一些联动操作。</p><p>观察者模式又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p>我们先定义一个观察者接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;   <span class="comment">//观察者接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;   <span class="comment">//当对象有更新时，会回调此方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来写一个支持观察者的实体类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Observer&gt; observerSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(Observer observer)</span> &#123;   <span class="comment">//添加观察者</span></span><br><span class="line">        observerSet.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123;   <span class="comment">//模拟对象进行修改</span></span><br><span class="line">        observerSet.forEach(Observer::update);   <span class="comment">//当对象发生修改时，会通知所有的观察者，并进行方法回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们就可以测试一下了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    subject.observe(() -&gt; System.out.println(<span class="string">&quot;我是一号观察者！&quot;</span>));</span><br><span class="line">    subject.observe(() -&gt; System.out.println(<span class="string">&quot;我是二号观察者！&quot;</span>));</span><br><span class="line">    subject.modify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就简单实现了一下观察者模式，JDK也提供了实现观察者模式相关的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;    <span class="comment">//java.util包下提供的观察者抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;   <span class="comment">//继承此抽象类表示支持观察者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对对象进行修改！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setChanged();    <span class="comment">//当对对象修改后，需要setChanged来设定为已修改状态</span></span><br><span class="line">        <span class="built_in">this</span>.notifyObservers(<span class="keyword">new</span> <span class="title class_">Date</span>());   <span class="comment">//使用notifyObservers方法来通知所有的观察者</span></span><br><span class="line">      <span class="comment">//注意只有已修改状态下通知观察者才会有效，并且可以给观察者传递参数，这里传递了一个时间对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    <span class="comment">// 添加subject为观察者</span></span><br><span class="line">    subject.addObserver((o, arg) -&gt; System.out.println(<span class="string">&quot;观察者1：监听到变化，并得到参数：&quot;</span> + arg));</span><br><span class="line">    subject.addObserver((o, arg) -&gt; System.out.println(<span class="string">&quot;观察者1：监听到变化，并得到参数：&quot;</span> + arg));</span><br><span class="line">    subject.addObserver((o, arg) -&gt; System.out.println(<span class="string">&quot;观察者1：监听到变化，并得到参数：&quot;</span> + arg));</span><br><span class="line">  <span class="comment">//注意这里的Observer是java.util包下提供的</span></span><br><span class="line">    subject.modify();   <span class="comment">//进行修改操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在标准大气压下，水在0度时会结冰变成固态，在0-100度之间时，会呈现液态，100度以上会变成气态，水这种物质在不同的温度下呈现出不同的状态，而Java中的对象，可能也会像这样存在很多种状态，甚至在不同的状态下会有不同的行为，就可以通过状态模式来实现。</p><p>状态模式可以对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><p>举例，假设有一个电灯开关，电灯有两种状态：开和关。按下开关时，电灯会根据当前状态切换行为：</p><p>如果电灯是“开”状态，按下开关后会关闭电灯。</p><p>如果电灯是“关”状态，按下开关后会打开电灯。</p><p>状态抽象类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>; <span class="comment">// 定义与状态相关的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体状态类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电灯已打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OffState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电灯已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电灯开关：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightSwitch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State currentState; <span class="comment">// 当前状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState = <span class="keyword">new</span> <span class="title class_">OffState</span>(); <span class="comment">// 初始状态为关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下开关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        currentState.handle(); <span class="comment">// 委托给当前状态处理</span></span><br><span class="line">        <span class="keyword">if</span> (currentState <span class="keyword">instanceof</span> OffState) &#123;</span><br><span class="line">            setState(<span class="keyword">new</span> <span class="title class_">OnState</span>()); <span class="comment">// 切换到开状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentState <span class="keyword">instanceof</span> OnState) &#123;</span><br><span class="line">            setState(<span class="keyword">new</span> <span class="title class_">OffState</span>()); <span class="comment">// 切换到关状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LightSwitch</span> <span class="variable">lightSwitch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightSwitch</span>();</span><br><span class="line">        lightSwitch.pressSwitch(); <span class="comment">// 打开电灯</span></span><br><span class="line">        lightSwitch.pressSwitch(); <span class="comment">// 关闭电灯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态模式更加强调当前的对象所处的状态，我们需要根据对象不同的状态决定其他的处理逻辑。</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p><p>举例，现在养宠物的人特别多，宠物分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p><p>创建抽象访问者接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建不同的具体访问者角色（主人和其他人），都需要实现 <code>Person</code>接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Owner</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Someone</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象节点——宠物：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义实现<code>Animal</code>接口的具体节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义对象结构，即主人的家：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal node : nodeList) &#123;</span><br><span class="line">            node.accept(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        nodeList.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Home</span> <span class="variable">home</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Home</span>();</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>();</span><br><span class="line">        home.action(owner);</span><br><span class="line"></span><br><span class="line">        <span class="type">Someone</span> <span class="variable">someone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Someone</span>();</span><br><span class="line">        home.action(someone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的访问者对于某一件事务的处理可能会不同。访问者模式把数据结构和作用于结构上的操作解耦，使得操作集合可相对自由地演化。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <category domain="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>http://example.com/inori/ec6efbf1.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>设计模式——结构型模式</title>
      <link>http://example.com/inori/6b3cc4f4.html</link>
      <guid>http://example.com/inori/6b3cc4f4.html</guid>
      <pubDate>Sat, 08 Mar 2025 10:58:02 GMT</pubDate>
      
      <description>设计模式中的结构型模式</description>
      
      
      
      <content:encoded><![CDATA[<p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下7种：</p><ul><li>代理模式</li><li>适配器模式</li><li>装饰者模式</li><li>桥接模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>火车站买票案例，如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。火车站是目标对象，代售点是代理对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代售点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object object;   <span class="comment">//这里需要保存一下被代理的对象，下面需要用到</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用代理对象的对应方法时会进入，需要编写如何进行代理</span></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//method是调用的代理对象的方法，args是实参数组</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(object, args);   <span class="comment">//在代理中调用被代理对象原本的方法</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(station);</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxy</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),    <span class="comment">//需要传入被代理的类的类加载器</span></span><br><span class="line">            station.getClass().getInterfaces(),    <span class="comment">//需要传入被代理的类的接口列表</span></span><br><span class="line">            handler);    <span class="comment">//最后传入我们实现的代理处理逻辑实现类</span></span><br><span class="line">    proxy.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>JDK提供的动态代理只能使用接口，如果换成我们一开始的抽象类就不可以了，这时我们可以使用一些第三方框架来实现更多方式的动态代理，比如Spring都在使用的CGLib框架，Maven依赖如下：                      </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于CGlib底层使用ASM框架进行字节码编辑，所以能够实现不仅仅局限于对接口的代理:          </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//火车站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation)enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o： 代理对象</span></span><br><span class="line"><span class="comment">            method： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();<span class="comment">// 代理对象的sell方法被调用时，CGLib会自动调用intercept方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂度</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>远程（Remote）代理</p><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节</p></li><li><p>防火墙（Firewall）代理</p><p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器</p></li><li><p>保护（Protect or Access）代理</p><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p></li></ul><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求了解现有组件库中的相关组件的内部结构。</p><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>想定场景：现有一台电脑只能读取SD卡，现在需要读取TF卡中的内容</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;sd card read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;tf card read msg : hello word tf card&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义适配器类（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>();</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式需要占用一个继承位，如果此时Target不是接口而是抽像类的话，由于Java不支持多继承，那么就无法实现了，且类适配器模式违背了合成复用原则。</p><p>类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>类适配器模式的代码，只需要修改适配器类（SDAdapterTF）和测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TFCard</span> <span class="variable">tfCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TFCardImpl</span>();</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将对象以组合的形式存放在<code>SDAdapterTF</code>中，通过存放的对象调用具体实现</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式的核心在于不改变一个对象本身功能的基础上，给对象添加额外的行为，并且它是通过组合的形式完成的，而不是传统的继承关系。</p><p>比如有一个普通的功能类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;   <span class="comment">//顶层抽象类，定义了一个test方法执行业务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;                     </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseImpl</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是业务方法&quot;</span>);   <span class="comment">//具体的业务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过现在的实现类太单调了，添加一点装饰上去：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;   <span class="comment">//装饰者需要将装饰目标组合到类中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Base base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Base base)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        base.test();    <span class="comment">//这里暂时还是使用目标的原本方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorImpl</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span>&#123;   <span class="comment">//装饰实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecoratorImpl</span><span class="params">(Base base)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;    <span class="comment">//对原本的方法进行装饰，我们可以在前后都去添加额外操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;装饰方法：我是操作前逻辑&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.test();</span><br><span class="line">        System.out.println(<span class="string">&quot;装饰方法：我是操作后逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就通过装饰模式对类的功能进行了扩展：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaseImpl</span>();</span><br><span class="line">    <span class="type">Decorator</span> <span class="variable">decorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecoratorImpl</span>(base);  <span class="comment">//将Base实现装饰一下</span></span><br><span class="line">    <span class="type">Decorator</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecoratorImpl</span>(decorator);  <span class="comment">//装饰者还可以嵌套</span></span><br><span class="line">    decorator.test();</span><br><span class="line">    outer.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了装饰模式</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系，可以发现有很多的类，假如再增加几个形状或再增加一种颜色，就需要创建更多的类。在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p><p>桥接模式可以将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><p>例如需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//视频文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//avi文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVIFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;avi视频文件：&quot;</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmvb文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">REVBBFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rmvb文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作系统版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;<span class="comment">// 桥接：通过组合连接视频文件格式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OperatingSystemVersion</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Windows</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mac版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mac</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OperatingSystem</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>(<span class="keyword">new</span> <span class="title class_">AVIFile</span>());</span><br><span class="line">        os.play(<span class="string">&quot;视频&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统</p><p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当一个类存在多个独立变化的维度，且这些维度都需要进行扩展时</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系</li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p>外观模式是“迪米特法则”的典型应用</p><p>举例，小明每次起床时都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来比较麻烦。所以小明买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//灯类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能音箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartAppliancesFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartAppliancesFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        airCondition = <span class="keyword">new</span> <span class="title class_">AirCondition</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(message.contains(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            on();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(message.contains(<span class="string">&quot;关闭&quot;</span>)) &#123;</span><br><span class="line">            off();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//起床后一键开电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床了&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//睡觉一键关电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建外观对象</span></span><br><span class="line">        <span class="type">SmartAppliancesFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartAppliancesFacade</span>();</span><br><span class="line">        <span class="comment">//客户端直接与外观对象进行交互</span></span><br><span class="line">        facade.say(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">        facade.say(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处：</strong></p><p>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类</p><p>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易</p><p><strong>缺点：</strong></p><p>不符合开闭原则，修改麻烦</p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性</li></ul><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式又名部分整体模式，用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次，它创建了对象组的树形结构。</p><p>实际上就是将多个组件进行组合，让用户可以对它们进行一致性处理。比如我们的文件夹，一个文件夹中可以有很多个子文件夹或是文件。像一个树形结构一样，有分支有叶子，组合模式可以对整个树形结构上的所有节点进行递归处理。</p><p>举例，使用文件和文件夹例子：                    </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先创建一个组件抽象，组件可以包含组件，组件有自己的业务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span>;    <span class="comment">//添加子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span>;   <span class="comment">//删除子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span>;   <span class="comment">//获取子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;   <span class="comment">//执行对应的业务方法，比如修改文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写两种实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;   <span class="comment">//目录可以包含多个文件或目录</span></span><br><span class="line"></span><br><span class="line">    List&lt;Component&gt; child = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();   <span class="comment">//这里我们使用List来存放目录中的子组件</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> child.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称修改成功！&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">        child.forEach(Component::test);   <span class="comment">//将继续调用所有子组件的test方法执行业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;   <span class="comment">//文件就相当于是树叶</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();   <span class="comment">//不支持这些操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称修改成功！&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>();   <span class="comment">//新建一个外层目录</span></span><br><span class="line">    <span class="type">Directory</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>();   <span class="comment">//新建一个内层目录</span></span><br><span class="line">    outer.addComponent(inner);</span><br><span class="line">    outer.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());   <span class="comment">//在内层目录和外层目录都添加点文件</span></span><br><span class="line">    inner.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());</span><br><span class="line">    inner.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());</span><br><span class="line">    outer.test();    <span class="comment">//开始文件名称修改操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享原模式"><a href="#享原模式" class="headerlink" title="享原模式"></a>享原模式</h2><p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><p>举例，比如现在有两个服务都需要使用数据库操作，实际上这个工具类没必要创建多个，这时就可以使用享元模式，让数据库类作为享元类，通过享元工厂来提供一个共享的数据库工具类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectDB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtilFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DBUtil</span> <span class="variable">UTIL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBUtil</span>();   <span class="comment">//享元对象被存放在工厂中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DBUtil <span class="title function_">getFlyweight</span><span class="params">()</span>&#123;   <span class="comment">//获取享元对象</span></span><br><span class="line">        <span class="keyword">return</span> UTIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要使用享元对象时，调用享元工厂类：                 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DBUtil</span> <span class="variable">util</span> <span class="operator">=</span> DBUtilFactory.getFlyweight();</span><br><span class="line">        util.selectDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <category domain="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>http://example.com/inori/6b3cc4f4.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
