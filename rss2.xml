<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>楪祈のBlog</title>
    <link>http://ltynote.cn/</link>
    
    <atom:link href="http://ltynote.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>星座になれたら。</description>
    <pubDate>Wed, 03 Sep 2025 06:56:20 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>手撕—LFU</title>
      <link>http://ltynote.cn/inori/4ba7ce49.html</link>
      <guid>http://ltynote.cn/inori/4ba7ce49.html</guid>
      <pubDate>Wed, 03 Sep 2025 05:43:02 GMT</pubDate>
      
      <description>面试专题——手撕</description>
      
      
      
      <content:encoded><![CDATA[<p>与LRU不同，LRU是根据访问顺序来淘汰，LFU是根据访问频率淘汰最少使用的节点</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用一个哈希表作为key到具体Node的映射，快速定位节点</p><p>再使用一个哈希表存储同使用频率的Node，同频率的节点按时间顺序存储，方便淘汰最早插入的</p><p>再使用一个minFreq变量，记录当前最小的频率</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;<span class="comment">// 节点类，记录当前kv和频率</span></span><br><span class="line">    <span class="type">int</span> key, value, freq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        freq = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity, minFreq;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt; keyMap;<span class="comment">// key对应节点的哈希表</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, LinkedHashSet&lt;Node&gt;&gt; freqMap;<span class="comment">// 频率对应节点集合的哈希表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.keyMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.freqMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新节点信息，把当前节点的使用频率+1，如果旧的频率列表空了，就维护minFreq+1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateNode</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">        LinkedHashSet&lt;Node&gt; nodes = freqMap.get(node.freq);</span><br><span class="line">        nodes.remove(node);</span><br><span class="line">        <span class="keyword">if</span>(nodes.isEmpty())&#123;</span><br><span class="line">            freqMap.remove(node.freq);</span><br><span class="line">            <span class="keyword">if</span>(minFreq == node.freq) minFreq ++;</span><br><span class="line">        &#125;</span><br><span class="line">        node.freq ++;</span><br><span class="line">        freqMap.computeIfAbsent(node.freq, k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;()).add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!keyMap.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> keyMap.get(key);</span><br><span class="line">        updateNode(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(capacity == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 与get类似</span></span><br><span class="line">        <span class="keyword">if</span>(keyMap.containsKey(key))&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> keyMap.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            updateNode(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 容量满了，就删一个频率最低，且加入时间最久的节点</span></span><br><span class="line">            <span class="keyword">if</span>(keyMap.size() &gt;= capacity)&#123;</span><br><span class="line">                LinkedHashSet&lt;Node&gt; nodes = freqMap.get(minFreq);</span><br><span class="line">                <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nodes.iterator().next();</span><br><span class="line">                nodes.remove(node);</span><br><span class="line">                <span class="keyword">if</span>(nodes.isEmpty()) freqMap.remove(minFreq);</span><br><span class="line">                keyMap.remove(node.key);</span><br><span class="line">            &#125;</span><br><span class="line">            minFreq = <span class="number">1</span>;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            keyMap.put(key, cur);</span><br><span class="line">            freqMap.computeIfAbsent(minFreq, k -&gt; <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;()).add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/4ba7ce49.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>手撕—实现JSON字符串解析</title>
      <link>http://ltynote.cn/inori/a6efffa.html</link>
      <guid>http://ltynote.cn/inori/a6efffa.html</guid>
      <pubDate>Fri, 15 Aug 2025 08:28:08 GMT</pubDate>
      
      <description>面试专题——手撕</description>
      
      
      
      <content:encoded><![CDATA[<p>来源：字节一面</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一个方法，找到json字符串的对应路径的值。我们假设json中没有复杂结构，只存在数字、字符串。</p><p>输入：一个Json格式的字符串和一个路径字符串</p><p>输出：对应路径的值</p><blockquote><p>例子：</p><p>输入：”{“a”:{“b”:1},”c”:1}”  “a.b”</p><p>输出：1</p></blockquote><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>分析：主要考字符串处理和递归，主要思路为将输入的字符串转化成哈希表，便于查找，然后递归进行哈希表键值对的插入，然后处理路径，一层一层找即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Object&gt; <span class="title function_">parseJson</span><span class="params">(String json)</span> &#123;</span><br><span class="line">        <span class="comment">// 字符串处理，去掉前后空格和大括号</span></span><br><span class="line">        json = json.trim();</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        json = json.substring(<span class="number">1</span>, json.length() - <span class="number">1</span>).trim();</span><br><span class="line">        <span class="keyword">if</span> (json.isEmpty()) <span class="keyword">return</span> map;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割键值对</span></span><br><span class="line">        List&lt;String&gt; pairs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">brace</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : json.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;&#123;&#x27;</span>) brace++;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>) brace--;</span><br><span class="line">            <span class="comment">// brace=0说明在最外层，遇到逗号才拆分</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;,&#x27;</span> &amp;&amp; brace == <span class="number">0</span>) &#123;</span><br><span class="line">                pairs.add(sb.toString().trim());</span><br><span class="line">                sb.setLength(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sb.isEmpty()) pairs.add(sb.toString().trim());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把每个键值对变成map映射</span></span><br><span class="line">        <span class="keyword">for</span> (String pair : pairs) &#123;</span><br><span class="line">            String[] kv = pair.split(<span class="string">&quot;:&quot;</span>, <span class="number">2</span>); <span class="comment">// 只在第一个冒号分割</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> kv[<span class="number">0</span>].trim().replaceAll(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> kv[<span class="number">1</span>].trim();</span><br><span class="line">            Object v;</span><br><span class="line">            <span class="keyword">if</span> (value.startsWith(<span class="string">&quot;&#123;&quot;</span>)) &#123;</span><br><span class="line">                v = parseJson(value); <span class="comment">// 递归解析</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.startsWith(<span class="string">&quot;\&quot;&quot;</span>) &amp;&amp; value.endsWith(<span class="string">&quot;\&quot;&quot;</span>)) &#123;</span><br><span class="line">                v = value.substring(<span class="number">1</span>, value.length() - <span class="number">1</span>);     <span class="comment">// 字符串</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v = Integer.parseInt(value); <span class="comment">// 假设都是数字</span></span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getValue</span><span class="params">(String json, String path)</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = parseJson(json);</span><br><span class="line">        <span class="comment">// 拆分路径</span></span><br><span class="line">        String[] keys = path.trim().split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cur</span> <span class="operator">=</span> map;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(cur <span class="keyword">instanceof</span> Map)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            cur = ((Map&lt;?, ?&gt;) cur).get(key);</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主函数读入字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> scanf.nextLine();</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> scanf.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;结果：&quot;</span> + getValue(json, path));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/a6efffa.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>手撕—带过期时间的LRU</title>
      <link>http://ltynote.cn/inori/17befa9.html</link>
      <guid>http://ltynote.cn/inori/17befa9.html</guid>
      <pubDate>Wed, 13 Aug 2025 06:38:59 GMT</pubDate>
      
      <description>面试专题——手撕</description>
      
      
      
      <content:encoded><![CDATA[<p>与传统的LRU类似，使用双向链表+哈希表来完成</p><ul><li><p>双向链表按照被使用顺序存储键值对，靠近头部的键值对是最近使用的，哈希表通过缓存数据的键映射到其在双向链表中的位置</p></li><li><p>对于get操作，首先判断key是否存在，如果key存在，再判断key是否过期，如未过期，则key对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值</p></li><li><p>对于put操作，首先清理所有过期的节点，再判断key是否存在，如果key不存在，使用key和value创建一个新的节点，在双向链表的头部添加该节点，并将key和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项。如果key存在，先通过哈希表定位，再将对应的节点的值更新为value，并将该节点移到双向链表的头部</p></li></ul><h2 id="以系统时间为基准"><a href="#以系统时间为基准" class="headerlink" title="以系统时间为基准"></a>以系统时间为基准</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkedList</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">long</span> expireTime;</span><br><span class="line">    DLinkedList pre;</span><br><span class="line">    DLinkedList next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLinkedList</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLinkedList</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">long</span> ttlMillis)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.expireTime = System.currentTimeMillis() + ttlMillis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpirableLRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cnt, capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedList head, tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedList&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExpirableLRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">DLinkedList</span>();</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">DLinkedList</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedList node)</span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        map.remove(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedList node)</span>&#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.next.pre = node;</span><br><span class="line">        map.put(node.key, node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedList node)</span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeTail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        <span class="keyword">if</span>(node != head)&#123;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isExpired</span><span class="params">(DLinkedList node)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() &gt; node.expireTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeExpiredNodes</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DLinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        <span class="keyword">while</span>(cur != head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isExpired(cur))&#123;</span><br><span class="line">                <span class="type">DLinkedList</span> <span class="variable">pre</span> <span class="operator">=</span> cur.pre;</span><br><span class="line">                removeNode(cur);</span><br><span class="line">                map.remove(cur.key);</span><br><span class="line">                cnt --;</span><br><span class="line">                cur = pre;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(isExpired(node))&#123;</span><br><span class="line">                removeNode(node);</span><br><span class="line">                cnt --;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">long</span> ttlMillis)</span>&#123;</span><br><span class="line">        removeExpiredNodes();</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            node.expireTime = System.currentTimeMillis() + ttlMillis;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedList</span>(key, value, ttlMillis);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; capacity)&#123;</span><br><span class="line">                removeTail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑过期时间"><a href="#逻辑过期时间" class="headerlink" title="逻辑过期时间"></a>逻辑过期时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> expireStep; <span class="comment">// 逻辑时间到期步数</span></span><br><span class="line">    DLinkedList pre, next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLinkedList</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">int</span> expireStep)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.expireStep = expireStep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpirableLRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentStep</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 逻辑时间步</span></span><br><span class="line">    <span class="keyword">private</span> DLinkedList head, tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedList&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StepLRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedList</span>(-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedList</span>(-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedList node)</span> &#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        map.remove(node.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedList node)</span> &#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        map.put(node.key, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedList node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        <span class="keyword">if</span> (node != head) &#123;</span><br><span class="line">            removeNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeExpiredNodes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        <span class="keyword">while</span> (cur != head) &#123;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">pre</span> <span class="operator">=</span> cur.pre;</span><br><span class="line">            <span class="keyword">if</span> (cur.expireStep &lt;= currentStep) &#123;</span><br><span class="line">                removeNode(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        currentStep++;</span><br><span class="line">        removeExpiredNodes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">int</span> ttlSteps)</span> &#123;</span><br><span class="line">        currentStep++;</span><br><span class="line">        removeExpiredNodes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            node.expireStep = currentStep + ttlSteps;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedList</span>(key, value, currentStep + ttlSteps);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; capacity) &#123;</span><br><span class="line">                removeTail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/17befa9.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>手撕—单例模式</title>
      <link>http://ltynote.cn/inori/c29b5d38.html</link>
      <guid>http://ltynote.cn/inori/c29b5d38.html</guid>
      <pubDate>Wed, 13 Aug 2025 06:16:41 GMT</pubDate>
      
      <description>面试专题——手撕</description>
      
      
      
      <content:encoded><![CDATA[<p>这里有两种实现方式，<strong>双重检查锁定(DCL)<strong>或</strong>静态内部类</strong></p><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// volatile保证可见性和禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Use getInstance() method to get the single instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查，避免不必要的同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查，确保只有一个实例被创建</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一次检查发现实例为null时，进入同步块，确保只有一个线程能进入创建实例的代码</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (SingletonHolder.INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Use getInstance() method to get the single instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM在类加载阶段会加锁，保证一个类只被加载一次，静态内部类<code>SingletonHolder</code>只有在被主动使用时才会加载，由JVM保证<code>INSTANCE</code>只被初始化一次</p><p>外部类加载时不会立即加载内部类，只有当调用<code>getInstance()</code>时才会触发<code>SingletonHolder</code>的加载</p>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/c29b5d38.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringSecurity基础入门</title>
      <link>http://ltynote.cn/inori/a774566a.html</link>
      <guid>http://ltynote.cn/inori/a774566a.html</guid>
      <pubDate>Tue, 22 Jul 2025 06:08:57 GMT</pubDate>
      
      <description>SpringSecurity</description>
      
      
      
      <content:encoded><![CDATA[<p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架</p><h2 id="SpringSecurity配置示例"><a href="#SpringSecurity配置示例" class="headerlink" title="SpringSecurity配置示例"></a>SpringSecurity配置示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .csrf(AbstractHttpConfigurer::disable) <span class="comment">// 关闭CSRF</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/register&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .formLogin(form -&gt; form</span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 自定义登录页</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/home&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">            )</span><br><span class="line">            .logout(LogoutConfigurer::permitAll);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟用户信息（可换为从数据库中读取）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username)) &#123;</span><br><span class="line">                <span class="keyword">return</span> User.withUsername(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                           .password(<span class="string">&quot;&#123;noop&#125;123456&quot;</span>) <span class="comment">// &#123;noop&#125;表示不加密</span></span><br><span class="line">                           .roles(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                           .build();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;User not found&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>认证</td><td>验证“你是谁”，例如用户名密码登录</td></tr><tr><td>授权</td><td>验证“你是否有权限做某件事”，如访问某个接口或资源</td></tr><tr><td>攻击防护</td><td>防止常见攻击：CSRF、Session Fixation、点击劫持、密码暴力破解等</td></tr><tr><td>会话管理</td><td>登录用户的session管控，限制登录次数，踢出旧会话等</td></tr><tr><td>Remember-Me</td><td>实现“记住我”功能</td></tr><tr><td>与第三方认证集成</td><td>支持OAuth2 &#x2F; JWT &#x2F; OpenID Connect 认证</td></tr><tr><td>安全拦截链</td><td>通过过滤器链实现请求安全控制</td></tr></tbody></table><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><code>SecurityFilterChain</code></td><td>安全过滤器链，是SpringSecurity的核心机制</td></tr><tr><td><code>AuthenticationManager</code></td><td>认证管理器，处理用户身份认证</td></tr><tr><td><code>UserDetailsService</code></td><td>用户数据获取接口，通常配合数据库实现</td></tr><tr><td><code>UserDetails</code></td><td>表示用户信息的接口（用户名、密码、权限）</td></tr><tr><td><code>GrantedAuthority</code></td><td>权限标识对象，通常是一个字符串</td></tr><tr><td><code>SecurityContextHolder</code></td><td>存储当前用户的认证信息（线程本地变量）</td></tr></tbody></table><h3 id="SecurityFilterChain"><a href="#SecurityFilterChain" class="headerlink" title="SecurityFilterChain"></a>SecurityFilterChain</h3><p>SpringSecurity的请求处理核心机制，是多个<code>Filter</code>的组合，每个请求都会通过这些过滤器进行处理，支持自定义过滤器链：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">        .formLogin(); <span class="comment">// 支持表单登录</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h3><p>接收<code>Authentication</code>对象，负责认证过程，默认使用 <code>ProviderManager</code> 实现，它委托多个<code>AuthenticationProvider</code>去完成具体认证，<code>AuthenticationProvider</code>用于执行真正的认证逻辑，内置的<code>DaoAuthenticationProvider</code>使用用户名 + 密码来做认证</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AuthenticationManager</span> <span class="variable">authManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderManager</span>(List.of(customProvider));</span><br></pre></td></tr></table></figure><h3 id="UserDetailsService-UserDetails"><a href="#UserDetailsService-UserDetails" class="headerlink" title="UserDetailsService + UserDetails"></a>UserDetailsService + UserDetails</h3><p><code>UserDetailsService</code>提供用户数据的服务，定义了如何根据用户名加载用户信息</p><p><code>UserDetails</code>是你返回的用户对象，必须包含用户名、密码、权限等字段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 假设从数据库查到了用户</span></span><br><span class="line">        <span class="keyword">return</span> User.builder()</span><br><span class="line">                .username(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GrantedAuthority"><a href="#GrantedAuthority" class="headerlink" title="GrantedAuthority"></a>GrantedAuthority</h3><p>表示当前用户所拥有的权限&#x2F;角色,SpringSecurity默认会将角色前缀加上<code>ROLE_</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GrantedAuthority</span> <span class="variable">authority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;ROLE_ADMIN&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h3><p>用于保存当前登录用户的认证信息（线程安全的ThreadLocal），可在任何地方获取当前用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> auth.getName();</span><br></pre></td></tr></table></figure><h3 id="注解权限控制"><a href="#注解权限控制" class="headerlink" title="注解权限控制"></a>注解权限控制</h3><p>需要启用@EnableMethodSecurity，常用注解：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)</code></td><td>方法执行前权限检查</td></tr><tr><td><code>@PostAuthorize</code></td><td>方法执行后权限检查</td></tr><tr><td><code>@Secured(&quot;ROLE_USER&quot;)</code></td><td>基于角色</td></tr><tr><td><code>@RolesAllowed(&quot;ADMIN&quot;)</code></td><td>JSR-250标准注解</td></tr></tbody></table><h3 id="Session会话管理"><a href="#Session会话管理" class="headerlink" title="Session会话管理"></a>Session会话管理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sessionManagement(session -&gt; session</span><br><span class="line">    .maximumSessions(<span class="number">1</span>)         <span class="comment">// 只允许一个登录会话</span></span><br><span class="line">    .maxSessionsPreventsLogin(<span class="literal">true</span>)) <span class="comment">// 后一个登录失败</span></span><br></pre></td></tr></table></figure><h3 id="与JWT结合"><a href="#与JWT结合" class="headerlink" title="与JWT结合"></a>与JWT结合</h3><p>jwt登录过滤器，用户登录时认证：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtLoginFilter</span> <span class="keyword">extends</span> <span class="title class_">UsernamePasswordAuthenticationFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JwtLoginFilter</span><span class="params">(AuthenticationManager authenticationManager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">        setFilterProcessesUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">// 登录路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">LoginRequest</span> <span class="variable">creds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().readValue(req.getInputStream(), LoginRequest.class);</span><br><span class="line">            <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(creds.getUsername(), creds.getPassword());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> authenticationManager.authenticate(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录成功后生成 JWT</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest req,</span></span><br><span class="line"><span class="params">                                            HttpServletResponse res,</span></span><br><span class="line"><span class="params">                                            FilterChain chain,</span></span><br><span class="line"><span class="params">                                            Authentication auth)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtils.generateToken(auth.getName());</span><br><span class="line">        res.addHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer &quot;</span> + token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jwt校验过滤器，解析请求头中 token：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                    HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (header != <span class="literal">null</span> &amp;&amp; header.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> header.replace(<span class="string">&quot;Bearer &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (JwtUtils.validateToken(token)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> JwtUtils.getUsernameFromToken(token);</span><br><span class="line">                <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authToken</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authToken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringSecurity测试"><a href="#SpringSecurity测试" class="headerlink" title="SpringSecurity测试"></a>SpringSecurity测试</h3><p><code>@WithMockUser</code>是SpringSecurity提供的一个测试注解，用于在单元测试或集成测试中模拟一个已认证的用户，使得测试环境下无需实际登录即可进行权限校验。</p><h4 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h4><p>在用Spring Boot+Spring Security开发应用时，我们常需要测试某些受保护的接口，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">adminPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不设置用户上下文，直接访问这个接口的测试方法会返回 <code>403 Forbidden</code>。这时候 <code>@WithMockUser</code> 就能派上用场</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;testuser&quot;, roles = &#123;&quot;ADMIN&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">adminPage_shouldReturnOk_forAdminUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解参数"><a href="#注解参数" class="headerlink" title="注解参数"></a>注解参数</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>username</code></td><td>模拟用户的用户名，默认是 “user”</td></tr><tr><td><code>password</code></td><td>模拟用户的密码（仅用于显示，无实际用途）</td></tr><tr><td><code>roles</code></td><td>角色，最终会自动加前缀 <code>&quot;ROLE_&quot;</code></td></tr><tr><td><code>authorities</code></td><td>权限，比 <code>roles</code> 更细粒度控制（不加前缀）</td></tr></tbody></table><ul><li><code>roles = &#123;&quot;ADMIN&quot;&#125;</code>实际注入的是<code>&quot;ROLE_ADMIN&quot;</code></li><li><code>roles</code>和<code>authorities</code>不能同时使用，只能用一个</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><code>@WithMockUser</code>是通过<code>SecurityContextHolder</code>注入一个<code>UsernamePasswordAuthenticationToken</code>到当前测试线程上下文中</li><li>在<code>MockMvc</code>执行测试时，Spring Security会自动从<code>SecurityContextHolder</code>中获取已设置的用户认证信息</li></ul><h2 id="执行流程（表单登录为例）"><a href="#执行流程（表单登录为例）" class="headerlink" title="执行流程（表单登录为例）"></a>执行流程（表单登录为例）</h2><ol><li>用户访问受保护资源 → 被过滤器拦截</li><li>若未登录，跳转到登录页面</li><li>用户提交用户名和密码</li><li><code>UsernamePasswordAuthenticationFilter</code>拦截登录请求</li><li>交给<code>AuthenticationManager</code>进行身份验证</li><li><code>UserDetailsService</code>加载用户信息并校验密码</li><li>验证成功，将认证信息存入<code>SecurityContextHolder</code></li><li>之后所有请求都带上用户身份，可以访问授权资源</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="过滤器和拦截器"><a href="#过滤器和拦截器" class="headerlink" title="过滤器和拦截器"></a>过滤器和拦截器</h3><table><thead><tr><th>项目</th><th>Filter（过滤器）</th><th>Interceptor（拦截器）</th></tr></thead><tbody><tr><td>所属规范</td><td>Servlet 规范（JavaEE）</td><td>Spring MVC 组件</td></tr><tr><td>作用范围</td><td>所有请求（包括静态资源、DispatcherServlet前）</td><td>Spring MVC 控制器处理的请求</td></tr><tr><td>执行位置</td><td>早于DispatcherServlet</td><td>DispatcherServlet之后，<strong>只拦截Controller请求</strong></td></tr><tr><td>应用场景</td><td>安全认证、请求日志、编码处理、权限校验（全局）</td><td>登录拦截、权限校验、业务预处理（Controller层面）</td></tr><tr><td>配置方式</td><td><code>@WebFilter</code>或<code>FilterRegistrationBean</code></td><td>实现<code>HandlerInterceptor</code>接口</td></tr><tr><td>执行顺序控制</td><td>通过<code>@Order</code>或<code>FilterChain</code>顺序控制</td><td><code>WebMvcConfigurer.addInterceptors()</code>顺序配置</td></tr></tbody></table><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">    ┌────────────────────────────┐</span><br><span class="line">    │      前端请求进入服务器       │</span><br><span class="line">    └────────────────────────────┘</span><br><span class="line">                  ↓</span><br><span class="line">   <span class="selector-attr">[Filter 1]</span> --&gt; 前置逻辑</span><br><span class="line">                  ↓</span><br><span class="line">   <span class="selector-attr">[Filter 2]</span> --&gt; 前置逻辑</span><br><span class="line">                  ↓</span><br><span class="line">┌──── DispatcherServlet (Spring MVC) ────┐</span><br><span class="line">│               ↓                        │</span><br><span class="line">│      <span class="selector-attr">[Interceptor 1]</span> <span class="built_in">preHandle</span>()       │</span><br><span class="line">│               ↓                        │</span><br><span class="line">│      <span class="selector-attr">[Interceptor 2]</span> <span class="built_in">preHandle</span>()       │</span><br><span class="line">│               ↓                        │</span><br><span class="line">│           Controller 方法              │</span><br><span class="line">│               ↑                        │</span><br><span class="line">│      <span class="selector-attr">[Interceptor 2]</span> <span class="built_in">postHandle</span>()      │</span><br><span class="line">│      <span class="selector-attr">[Interceptor 1]</span> <span class="built_in">postHandle</span>()      │</span><br><span class="line">└───────────────↑────────────────────────┘</span><br><span class="line">                  ↑</span><br><span class="line">   <span class="selector-attr">[Filter 2]</span> --&gt; 后置逻辑</span><br><span class="line">                  ↑</span><br><span class="line">   <span class="selector-attr">[Filter 1]</span> --&gt; 后置逻辑</span><br><span class="line">                  ↑</span><br><span class="line">        响应返回到客户端</span><br></pre></td></tr></table></figure><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><table><thead><tr><th>比较维度</th><th>Filter</th><th>Interceptor</th></tr></thead><tbody><tr><td>基于机制</td><td>Servlet API</td><td>Spring MVC 拦截器链</td></tr><tr><td>是否依赖 Spring</td><td>无需依赖 Spring，可用于非 Spring 项目</td><td>只适用于 Spring 环境</td></tr><tr><td>本质实现</td><td>继承 <code>javax.servlet.Filter</code> 接口</td><td>实现 <code>HandlerInterceptor</code> 接口</td></tr><tr><td>是否可拦截静态资源</td><td>是，能拦截所有HTTP请求</td><td>不能拦截静态资源</td></tr><tr><td>是否能拿到Controller方法信息</td><td>拿不到</td><td>拿得到（<code>HandlerMethod</code>）</td></tr><tr><td>适用粒度</td><td>适合系统层面拦截（如 XSS、防盗链、日志）</td><td>适合业务层面拦截（如用户登录、角色权限）</td></tr></tbody></table><h4 id="SpringSecurity是基于什么实现的"><a href="#SpringSecurity是基于什么实现的" class="headerlink" title="SpringSecurity是基于什么实现的"></a>SpringSecurity是基于什么实现的</h4><p>Spring Security是基于Servlet的Filter实现的</p><ul><li>Spring Security 的设计目标是“请求级安全防护”，要在DispatcherServlet之前就拦截请求，包括静态资源、API、文件上传、非法访问等</li><li>若等到拦截器阶段再处理，控制粒度太晚，系统容易被绕过</li></ul><h3 id="springsecurity有几种权限控制机制"><a href="#springsecurity有几种权限控制机制" class="headerlink" title="springsecurity有几种权限控制机制"></a>springsecurity有几种权限控制机制</h3><ul><li>基于URL的权限控制，根据请求的路径来控制访问权限</li><li>基于方法的权限控制（注解方式）：@PreAuthorize、@PostAuthorize、@Secured、@RolesAllowed等</li><li>基于注解表达式的权限控制（SpEL表达式）</li><li>基于权限标签的控制（结合前端Thymeleaf）</li></ul><h3 id="springsecurity有什么过滤器"><a href="#springsecurity有什么过滤器" class="headerlink" title="springsecurity有什么过滤器"></a>springsecurity有什么过滤器</h3><p>Spring Security的核心是一条由多个过滤器组成的过滤器链，常用的有</p><ul><li>WebAsyncManagerIntegrationFilter（将Security上下文与异步线程绑定）</li><li>SecurityContextPersistenceFilter（加载<code>SecurityContext</code>到<code>SecurityContextHolder</code>）</li><li>CorsFilter（处理跨域请求）</li><li>UsernamePasswordAuthenticationFilter（登录处理）</li><li>LogoutFilter（处理登出逻辑）</li><li>BearerTokenAuthenticationFilter（处理Bearer Token认证）</li><li>OAuth2LoginAuthenticationFilter（处理OAuth2登录）</li><li>SessionManagementFilter（管理 Session）</li><li>FilterSecurityInterceptor（授权过滤器）</li></ul>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/java/">java</category>
      
      
      <category domain="http://ltynote.cn/tags/java/">java</category>
      
      
      <comments>http://ltynote.cn/inori/a774566a.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JUnit与Mockito测试框架入门</title>
      <link>http://ltynote.cn/inori/a2118cb.html</link>
      <guid>http://ltynote.cn/inori/a2118cb.html</guid>
      <pubDate>Mon, 21 Jul 2025 02:02:43 GMT</pubDate>
      
      <description>Java单元测试</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>测试过程按照阶段划分可以分为：</p><ol><li><p>单元测试：对程序模块进行输出正确性检验</p></li><li><p>集成测试：在单元测试基础上，整合各个模块组成子系统，进行集成测试</p></li><li><p>系统测试：将整个交付所涉及的协作内容都纳入其中考虑，包含硬件、软件、接口、操作等等一系列作为一个整体，检验是否满足软件或需求说明</p></li><li><p>验收测试：在交付或者发布之前对所做的工作进行测试检验</p></li></ol><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试是阶段性测试的首要环节，也是白盒测试的一种，该内容的编写与实践可以前置在研发完成，研发在编写业务代码的时候就需要生成对应代码的单元测试。单元测试其实是针对软件中最小的测试单元来进行验证的。这里的单元就是指相关的功能子集，比如一个方法、一个类等。值得注意的是作为最低级别的测试活动，单元测试验证的对象仅限于当前测试内容，与程序其它部分内容相隔离</p><p>单元测试有以下特征：</p><ol><li><p>主要功能是证明编写的代码内容与期望输出一致</p></li><li><p>最小最低级的测试内容，保证程序基本组件正常</p></li><li><p>单元测试尽量不区分类与方法，主张以过程性的方法为测试单位</p></li><li><p>专注于测试一小块的代码，保证基础功能</p></li><li><p>剥离与外部接口、存储之间的依赖，使单元测试可控</p></li><li><p>任何时间任何顺序执行单元测试都需要是成功的</p></li></ol><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>JUnit是一个用于编写可重复测试的简单框架。它是用于单元测试框架的xUnit体系结构的一个实例</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><table><thead><tr><th align="left">名称</th><th align="left">功能作用</th></tr></thead><tbody><tr><td align="left">Assert</td><td align="left">断言方法集合</td></tr><tr><td align="left">TestCase</td><td align="left">表示一个测试案例</td></tr><tr><td align="left">TestSuite</td><td align="left">包含一组TestCase，构成一组测试</td></tr><tr><td align="left">TestResult</td><td align="left">收集测试结果</td></tr></tbody></table><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>JUnit的断言主要由<code>org.junit.jupiter.api.Assertions</code>提供</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>assertEquals(expected, actual)</td><td>判断两个值是否相等</td></tr><tr><td>assertNotEquals(expected, actual)</td><td>判断两个值是否不相等</td></tr><tr><td>assertTrue(condition)</td><td>判断一个条件是否为 true</td></tr><tr><td>assertFalse(condition)</td><td>判断一个条件是否为 false</td></tr><tr><td>assertNull(object)</td><td>判断对象是否为 null</td></tr><tr><td>assertNotNull(object)</td><td>判断对象是否不为 null</td></tr><tr><td>assertSame(expected, actual)</td><td>判断两个对象是否引用同一个实例</td></tr><tr><td>assertNotSame(expected, actual)</td><td>判断两个对象是否不是同一个实例</td></tr><tr><td>assertArrayEquals(expectedArray, actualArray)</td><td>判断两个数组内容是否完全相等</td></tr><tr><td>assertThrows(Exception.class, () -&gt; code)</td><td>断言某段代码抛出指定异常</td></tr><tr><td>fail(“message”)</td><td>强制让测试失败</td></tr></tbody></table><p>所有断言方法都可以添加第三个参数作为失败时的提示信息，便于定位错误：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertEquals(<span class="number">10</span>, result, <span class="string">&quot;计算结果不符合预期&quot;</span>);</span><br></pre></td></tr></table></figure><p>或者使用延迟消息构造：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertEquals(<span class="number">10</span>, result, () -&gt; <span class="string">&quot;result 应为 10，但实际是 &quot;</span> + result);</span><br></pre></td></tr></table></figure><p>这样只有当断言失败时才会调用lambda构造提示信息，提高性能</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>表示一个测试方法</td></tr><tr><td>@BeforeEach</td><td>每个测试方法执行前执行（类似 JUnit4 的 <code>@Before</code>）</td></tr><tr><td>@AfterEach</td><td>每个测试方法执行后执行</td></tr><tr><td>@BeforeAll</td><td>所有测试前执行一次（需为 static）</td></tr><tr><td>@AfterAll</td><td>所有测试后执行一次（需为 static）</td></tr><tr><td>@DisplayName</td><td>给测试用例起一个更可读的名字</td></tr><tr><td>@Disabled</td><td>暂时禁用某个测试方法</td></tr></tbody></table><h4 id="BeforeEach、BeforeAll、AfterEach、AfterAll的区别"><a href="#BeforeEach、BeforeAll、AfterEach、AfterAll的区别" class="headerlink" title="BeforeEach、BeforeAll、AfterEach、AfterAll的区别"></a>BeforeEach、BeforeAll、AfterEach、AfterAll的区别</h4><ul><li>BeforeEach是每个测试方法执行前执行一次，适合初始化测试对象</li><li>BeforeAll是只无论多少个测试方法，都只执行一次，适合加载公共资源</li><li>AfterEach是每个测试方法后执行一次，可以清理mock状态、删除临时文件、回滚测试数据</li><li>AfterAll是所有测试结束后执行一次，可以关闭数据库连接、删除全局缓存、输出整体测试报告、</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;== BeforeAll：初始化数据库连接池 ==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">beforeEach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-- BeforeEach：新建测试数据 --&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 test1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 test2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterEach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-- AfterEach：清理测试数据 --&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;== AfterAll：释放数据库连接池 ==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@BeforeEach&#x2F;@AfterEach和@Test一样，作用于每个测试用例，适合每个方法都需要初始化&#x2F;清理的场景</p><p>@BeforeAll&#x2F;@AfterAll是整个测试类级别的初始化&#x2F;清理，更适合执行前后全局配置资源或统计信息的处理</p><h2 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a>Mockito</h2><p>在实际开发中，我们常常需要测试某个类或方法的行为，但这些行为可能依赖于其他复杂的外部对象（如数据库、网络服务等）。为了隔离这些依赖，我们可以使用<strong>Mock</strong>对象（伪对象）。Mockito是一个用于创建mock对象的测试框架，适用于：</p><ul><li>模拟Service、DAO、远程调用等依赖</li><li>断言依赖对象的调用方式</li><li>编写真正“单元级”的测试，而不是集成测试</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Mock</td><td>模拟一个类的对象，只保留你关心的方法行为</td></tr><tr><td>Stub</td><td>给mock的方法设置固定返回值</td></tr><tr><td>Verify</td><td>验证某个方法是否被调用、调用次数、传参是否符合预期</td></tr><tr><td>Spy</td><td>真实对象的包装器，可部分mock，适用于部分逻辑保持原样</td></tr><tr><td>Injection</td><td>把mock对象注入到被测试类中，通常结合注解@InjectMocks使用</td></tr></tbody></table><h3 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li>@Mock：创建mock对象</li><li>@InjectMocks：自动将@Mock注入到被测试对象中</li><li>@Spy：创建spy对象（保留原逻辑，可选定mock部分）</li><li>@Captor：用于捕获方法调用的参数</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法&#x2F;语法</th><th>含义</th></tr></thead><tbody><tr><td>mock(Class.class)</td><td>创建一个mock对象</td></tr><tr><td>when(xxx).thenReturn(val)</td><td>设置方法返回值（stub）</td></tr><tr><td>verify(obj).method()</td><td>验证方法是否被调用</td></tr><tr><td>doReturn(x).when(obj).method()</td><td>用于spy中设置行为（避免调用真实方法）</td></tr><tr><td>doThrow(ex).when(obj).method()</td><td>设置方法抛出异常</td></tr><tr><td>any(), eq(x)</td><td>参数匹配器，用于模糊匹配参数</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设有如下业务逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用Mockito测试而不用真的访问数据库：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"><span class="keyword">import</span> com.project.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        MockitoAnnotations.openMocks(<span class="built_in">this</span>); <span class="comment">// 初始化 @Mock/@InjectMocks</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetUserById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Stub 返回值</span></span><br><span class="line">        when(userDao.findById(<span class="number">1</span>)).thenReturn(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        <span class="comment">// 调用测试方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">result</span> <span class="operator">=</span> userService.getUserById(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 验证调用和结果</span></span><br><span class="line">        verify(userDao).findById(<span class="number">1</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Alice&quot;</span>, result.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spy和Mock的区别"><a href="#Spy和Mock的区别" class="headerlink" title="Spy和Mock的区别"></a>Spy和Mock的区别</h4><table><thead><tr><th>对象类型</th><th>调用方法时行为</th><th>适用场景</th></tr></thead><tbody><tr><td><code>mock()</code></td><td>所有方法默认无效（返回默认值）</td><td>完全隔离依赖</td></tr><tr><td><code>spy()</code></td><td>保留原逻辑，部分方法可被stub</td><td>测试部分真实逻辑、或已有对象的包装</td></tr></tbody></table><h4 id="调用次数验证"><a href="#调用次数验证" class="headerlink" title="调用次数验证"></a>调用次数验证</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java复制编辑verify(userDao, times(2)).findById(1);</span><br><span class="line">verify(userDao, never()).delete(anyInt());</span><br><span class="line">verify(userDao, atLeastOnce()).findById(anyInt());</span><br></pre></td></tr></table></figure><h4 id="AAA原则"><a href="#AAA原则" class="headerlink" title="AAA原则"></a>AAA原则</h4><ol><li>Arrange：布置场景（mock&#x2F;stub）</li><li>Act：执行操作</li><li>Assert：断言结果 + verify行为</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLoginSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    when(authClient.verify(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;pass&quot;</span>)).thenReturn(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> loginService.login(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;pass&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    assertTrue(result);</span><br><span class="line">    verify(authClient).verify(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;pass&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-JUnit-Mockito结合使用示例"><a href="#Spring-Boot-JUnit-Mockito结合使用示例" class="headerlink" title="Spring Boot+JUnit+Mockito结合使用示例"></a>Spring Boot+JUnit+Mockito结合使用示例</h2><p>模拟一个用户注册服务的真实开发场景，进行测试</p><h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>有一个<code>UserService</code>类用于注册用户，它依赖于：</p><ul><li><code>UserDao</code>：用户数据库操作接口</li><li><code>EmailService</code>：注册成功后发送欢迎邮件</li></ul><p>现在要测试<code>UserService.register(user)</code>方法是否：</p><ol><li>成功保存用户</li><li>发送了邮件</li><li>对重复注册用户抛出异常</li></ol><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot Test，包含JUnit 5、AssertJ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Mockito Core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Mockito for JUnit 5 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>用户实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>UserDao接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    User <span class="title function_">findByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MailService接口（省略实现类）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao, MailService mailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">        <span class="built_in">this</span>.mailService = mailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (userDao.findByEmail(user.getEmail()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserAlreadyExistsException</span>(<span class="string">&quot;User already exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        userDao.insert(user);</span><br><span class="line">        mailService.sendWelcomeEmail(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUnit + Mockito测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User newUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        newUser = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        newUser.setEmail(<span class="string">&quot;test@example.com&quot;</span>);</span><br><span class="line">        newUser.setPassword(<span class="string">&quot;securePassword&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testRegisterSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 用户不存在</span></span><br><span class="line">        Mockito.when(userDao.findByEmail(newUser.getEmail())).thenReturn(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        userService.register(newUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证调用了保存方法</span></span><br><span class="line">        Mockito.verify(userDao).insert(newUser);</span><br><span class="line">        <span class="comment">// 验证发送了邮件</span></span><br><span class="line">        Mockito.verify(mailService).sendWelcomeEmail(newUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testRegister_UserAlreadyExists_ShouldThrowException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 用户已存在</span></span><br><span class="line">        Mockito.when(userDao.findByEmail(newUser.getEmail())).thenReturn(newUser);</span><br><span class="line"></span><br><span class="line">        Assertions.assertThrows(UserAlreadyExistsException.class, () -&gt; &#123;</span><br><span class="line">            userService.register(newUser);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证未保存</span></span><br><span class="line">        Mockito.verify(userDao, Mockito.never()).insert(Mockito.any());</span><br><span class="line">        <span class="comment">// 验证未发送邮件</span></span><br><span class="line">        Mockito.verify(mailService, Mockito.never()).sendWelcomeEmail(Mockito.any());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</category>
      
      
      <category domain="http://ltynote.cn/tags/java/">java</category>
      
      
      <comments>http://ltynote.cn/inori/a2118cb.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>OSS与优化基础入门</title>
      <link>http://ltynote.cn/inori/6b394c8.html</link>
      <guid>http://ltynote.cn/inori/6b394c8.html</guid>
      <pubDate>Sun, 20 Jul 2025 02:30:13 GMT</pubDate>
      
      <description>oss入门</description>
      
      
      
      <content:encoded><![CDATA[<p>OSS（Object Storage Service）是阿里云提供的海量、安全、低成本的云存储服务，用于存储和管理任意类型的文件（如图片、视频、文档等）</p><p>特点：</p><ul><li>无限容量：按需扩展，无需提前规划存储空间</li><li>高可靠性：数据多副本存储，保障持久性</li><li>低成本：按实际使用量付费，无闲置费用</li><li>高并发访问：支持CDN加速，适合大流量场景</li></ul><p>能解决什么问题？</p><ul><li>文件存储与管理：替代自建文件服务器，避免运维成本</li><li>静态资源托管：存储网站图片、视频等静态资源，提升加载速度</li><li>备份与归档：长期保存日志、数据库备份等冷数据</li><li>跨地域访问：结合CDN实现全球加速</li></ul><h2 id="OSS的组成"><a href="#OSS的组成" class="headerlink" title="OSS的组成"></a>OSS的组成</h2><p>OSS的存储结构相当于windows的盘符中，不创建文件夹，而是把所有文件都堆到一块</p><h3 id="Bucket-存储桶"><a href="#Bucket-存储桶" class="headerlink" title="Bucket (存储桶)"></a>Bucket (存储桶)</h3><p>在初始化oss容器时就需要指定，在OSS全局命名空间中必须有唯一名称，支持私有（只有Bucket拥有者可以读写，其他用户无权限）、公共读（Bucket拥有者可读写，匿名用户可读，知道对象URL即可下载）、公共读写（Bucket拥有者可读写，匿名用户可读写，可上传&#x2F;删除&#x2F;覆盖对象）三种ACL权限</p><ul><li>相当于文件系统中的”顶级目录”</li><li>是存储对象的容器</li><li>创建时可以指定区域(Region)，数据会物理存储在该区域</li><li>可以设置自动转换存储类型(标准→低频访问→归档)</li><li>可以设置自动过期删除规则</li></ul><h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object (对象)"></a>Object (对象)</h3><p>虽然OSS控制台显示类似目录的结构，但实际上OSS内部是扁平存储结构，目录是通过Object Key中的”&#x2F;“字符模拟的，即列出目录内容时，OSS服务端会做前缀匹配</p><ul><li>相当于文件系统中的”文件”</li><li>包含三个部分：<ul><li>Key (对象键&#x2F;文件名)</li><li>Data (数据内容)</li><li>Metadata (元数据)</li></ul></li></ul><h3 id="与Windows文件系统对比"><a href="#与Windows文件系统对比" class="headerlink" title="与Windows文件系统对比"></a>与Windows文件系统对比</h3><table><thead><tr><th align="center">特性</th><th align="center">阿里云 OSS</th><th align="center">Windows 文件系统</th></tr></thead><tbody><tr><td align="center"><strong>组织结构</strong></td><td align="center">扁平结构(只有Bucket和Object两级)</td><td align="center">树状结构(多级目录)</td></tr><tr><td align="center"><strong>目录概念</strong></td><td align="center">通过Key中的”&#x2F;“模拟目录(实际不存在真实目录)</td><td align="center">真实存在的目录结构</td></tr><tr><td align="center"><strong>访问方式</strong></td><td align="center">RESTful API、SDK、控制台</td><td align="center">文件系统API、资源管理器</td></tr><tr><td align="center"><strong>元数据</strong></td><td align="center">每个Object有独立的元数据</td><td align="center">文件属性与文件内容分离</td></tr><tr><td align="center"><strong>性能</strong></td><td align="center">高并发访问性能好</td><td align="center">单机文件系统性能有限</td></tr><tr><td align="center"><strong>扩展性</strong></td><td align="center">理论上无限扩展</td><td align="center">受单机存储容量限制</td></tr></tbody></table><h2 id="数据写入流程"><a href="#数据写入流程" class="headerlink" title="数据写入流程"></a>数据写入流程</h2><p>客户端调用oss的sdk，发送http请求到OSS网关中，前端服务器接收HTTP请求，对数据进行流式处理，然后路由到对应的bucket，写入Object</p><p>持久化过程中，oss会对写入的数据进行数据分块（默认4MB&#x2F;块），并行写入多个存储节点，还会有分层存储的逻辑，可以在oss控制台配置冷热数据逻辑：</p><ul><li>热数据：保留在SSD缓存层</li><li>温数据：存储在HDD层</li><li>冷数据：下沉到归档存储</li></ul><h2 id="上传速度优化"><a href="#上传速度优化" class="headerlink" title="上传速度优化"></a>上传速度优化</h2><p>OSS在单连接上传时，通常可达50-200Mbps，多线程并发上传时，最高可达5Gbps</p><p>对速度要求不是非常高时，可以使用单连接上传，配合线程池进行优化，在我的技术选型中，我使用了单连接+OkHttpClient进行吞吐优化</p><h3 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h3><p>OkHttpClient是一个高性能、支持HTTP&#x2F;HTTPS的Java网络请求客户端库，常用于：</p><ul><li>调用REST接口</li><li>发送文件或表单</li><li>下载文件&#x2F;数据流</li><li>和OSS等第三方云服务通信</li></ul><p>OkHttpClient本身是线程安全的，是一个连接复用+异步调度的客户端，它内部包含：</p><ul><li>连接池（ConnectionPool）：复用TCP连接，减少握手开销</li><li>调度器（Dispatcher）：管理请求队列和异步执行</li><li>线程池（ExecutorService）：用于调度异步任务，允许发起多个异步请求而不会阻塞主线程，并提高网络IO的吞吐量</li><li>失败重试：提升弱网稳定性</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>引入sdk依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>oss配合OkHttpClient使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>().newBuilder()</span><br><span class="line">    .dispatcher(<span class="keyword">new</span> <span class="title class_">Dispatcher</span>(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">10</span>,<span class="number">60L</span>,TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>(),Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>))))</span><br><span class="line">    .writeTimeout(<span class="number">30</span>, TimeUnit.MINUTES)</span><br><span class="line">    .readTimeout(<span class="number">30</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">uploadInnerFile</span><span class="params">(String url, String filePath, String bucketName, String objectName, String apiToken)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipartBody</span>.Builder()</span><br><span class="line">        .setType(MultipartBody.FORM)</span><br><span class="line">        .addFormDataPart(<span class="string">&quot;file&quot;</span>, UUID.randomUUID().toString(),</span><br><span class="line">            RequestBody.create(MediaType.parse(<span class="string">&quot;multipart/form-data&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(filePath)))</span><br><span class="line">        .addFormDataPart(<span class="string">&quot;objectName&quot;</span>,objectName)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .header(<span class="string">&quot;accessToken&quot;</span>,apiToken)</span><br><span class="line">        .header(<span class="string">&quot;bucketName&quot;</span>, bucketName)</span><br><span class="line">        .header(<span class="string">&quot;objectName&quot;</span>, objectName)</span><br><span class="line">        .url(url)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute(); <span class="comment">// 同步请求</span></span><br><span class="line">    <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/oss/">oss</category>
      
      
      <category domain="http://ltynote.cn/tags/oss/">oss</category>
      
      
      <comments>http://ltynote.cn/inori/6b394c8.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>面试问题汇总（持续更新中）</title>
      <link>http://ltynote.cn/inori/c92e9465.html</link>
      <guid>http://ltynote.cn/inori/c92e9465.html</guid>
      <pubDate>Thu, 05 Jun 2025 11:11:44 GMT</pubDate>
      
      <description>面试专题——八股篇</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="你项目中用到了哪些设计模式"><a href="#你项目中用到了哪些设计模式" class="headerlink" title="你项目中用到了哪些设计模式"></a>你项目中用到了哪些设计模式</h2><p>在线程池的创建，Zookeeper客户端的创建使用到的单例模式，避免重复创建</p><p>创建序列化器，编解码器用到了工厂模式，根据用户配置创建不同的序列化方式</p><p>在实现不同序列化方式的时候用到了策略模式，把不同序列化方式封装成一个策略，实现统一接口</p><p>小程序项目中使用注解+AOP实现权限控制，本质是基于代理方法在方法调用前做拦截，用到了代理模式</p><p>在RPC框架中注册中心监听节点变化用到了观察者模式</p><h2 id="Spring中用到了哪些设计模式"><a href="#Spring中用到了哪些设计模式" class="headerlink" title="Spring中用到了哪些设计模式"></a>Spring中用到了哪些设计模式</h2><p>Bean的创建是单例的，用到了单例模式</p><p>Bean的管理使用的BeanFactory，用到了工厂模式</p><p>Bean的注入用到了原型模式，每次注入新实例</p><p>通用逻辑的封装，比如JdbcTemplate，用到了模板方法模式</p><p>Spring事件监听机制用到了观察者模式</p><p>SpringMVC的拦截器、过滤器链用到了责任链模式</p><p>Bean的生命周期管理用到了状态模式</p><p>AOP用到了代理模式</p><p>SpringMVC的HandlerAdapter适配不同Controller用到了适配器模式</p><h2 id="ES的基本原理"><a href="#ES的基本原理" class="headerlink" title="ES的基本原理"></a>ES的基本原理</h2><p>ES中比较关键的概念有索引，相当于MySQL的表，文档，相当于表中的行，字段，相当于表中的列。然后还可以组成集群和分片。</p><p>ES内部的索引使用的倒排索引，原理就是把每个文档的内容进行分词，建立词对应文档ID列表的映射</p><p>当有新的文档写入时，ES首先会通过分词器做文本分析，建立倒排索引，再把数据写到主分片上，由主分片同步到副分片，写入不是立即可见的，默认一秒钟刷新一次</p><h2 id="Nacos如何避免读写冲突"><a href="#Nacos如何避免读写冲突" class="headerlink" title="Nacos如何避免读写冲突"></a>Nacos如何避免读写冲突</h2><p>Nacos主要通过两种机制来避免配置读写冲突。一是写时使用乐观锁机制，客户端提交配置时必须带上当前版本号，如果版本不一致则更新失败，避免写写冲突。二是通过Raft协议实现集群间的数据强一致，所有写请求必须通过Leader，读请求默认从本地读取，如果需要强一致也可以强制读Leader。Nacos客户端使用长轮询机制感知配置变更，确保读时的数据是最新的。</p><h2 id="为什么Kryo序列化方式的体积小"><a href="#为什么Kryo序列化方式的体积小" class="headerlink" title="为什么Kryo序列化方式的体积小"></a>为什么Kryo序列化方式的体积小</h2><p>Kryo直接将对象编码为二进制字节数组，没有像JSON那样的字符冗余，并且Kryo不使用Java的反射机制，而是提前注册类信息，序列化时不需要写类的全限定名，它还支持对象引用追踪，避免重复序列化同一个对象</p><h2 id="zk的一致性算法"><a href="#zk的一致性算法" class="headerlink" title="zk的一致性算法"></a>zk的一致性算法</h2><p>Zookeeper使用Zab协议来实现集群一致性。有领导选举和原子广播两个阶段。当集群初次启动或者Leader节点宕机时会进入领导选举阶段，主要是通过投票和对比事务ID来选择，原子广播阶段，所有写请求由Leader发起并生成事务，广播给所有的Follower，需被超过半数的Follower写入后才能提交，Leader再广播提交消息，确保所有节点以相同顺序应用事务，从而实现强一致性。</p><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>我在参与商城项目的时候有过JVM调优的经历，当时压测的时候频繁出现Full GC，我通过jstat分析内存使用情况，使用-Xms和-Xmx调整了堆的大小，用-Xmn扩大了新生代的大小，后面我还有使用jstack查看线程状态，检查是否有死锁的情况</p><h2 id="单机MySQL如果不做任何优化，最大可以承受多大并发"><a href="#单机MySQL如果不做任何优化，最大可以承受多大并发" class="headerlink" title="单机MySQL如果不做任何优化，最大可以承受多大并发"></a>单机MySQL如果不做任何优化，最大可以承受多大并发</h2><p>MySQL默认的最大连接数是151，也就是最多151个线程同时连接执行SQL，如果只是执行简单的查询，单机QPS大概5000左右，如果是频繁写入的话，TPS可能在1000上下</p><h2 id="如何发现和优化慢SQL"><a href="#如何发现和优化慢SQL" class="headerlink" title="如何发现和优化慢SQL"></a>如何发现和优化慢SQL</h2><p>开启数据库慢查询日志，使用<code>mysqldumpslow</code>汇总慢sql，发现慢sql语句之后，使用<code>explain</code>分析这条语句，主要关注是否用了全表扫描，keys是否走了索引，rows是否过大，然后针对常用的字段，使用最左前缀原则建立索引，同时也要避免select *查询，数据量大时，可以用<code>LIMIT</code>限制查询数量，使用分页时避免大偏移量分页，避免慢sql的话可以针对大数据量的表使用分库分表，也可以结合缓存，分担数据库压力</p><h2 id="Mysql的行锁什么时候会升级成表锁"><a href="#Mysql的行锁什么时候会升级成表锁" class="headerlink" title="Mysql的行锁什么时候会升级成表锁"></a>Mysql的行锁什么时候会升级成表锁</h2><ol><li>没有用到索引，或者索引失效</li></ol><p>InnoDB的行锁是基于索引实现的，如果执行语句没有走索引（全表扫描），那只能锁整张表</p><ol start="2"><li>范围查询导致锁范围过大</li></ol><p>当范围条件太宽，几乎要扫描大部分数据时，InnoDB可能会退化成表锁，减少锁的管理开销</p><ol start="3"><li>事务未提交，锁竞争严重</li></ol><p>长事务占用大量行锁时，可能导致其他事务阻塞，MySQL为了保证一致性，有可能会升级成表锁来避免锁资源耗尽</p><h2 id="RocketMQ和RabbitMQ的异同点，使用场景"><a href="#RocketMQ和RabbitMQ的异同点，使用场景" class="headerlink" title="RocketMQ和RabbitMQ的异同点，使用场景"></a>RocketMQ和RabbitMQ的异同点，使用场景</h2><p>RabbitMQ基于AMQP协议实现，消息存储在Broker上，采用push模式，消息主动推送给消费者，可靠性一般通过确认机制保证，部署简单，适合中小型系统</p><p>RocketMQ采用的分布式架构，消息存储在Broker集群，消息被分为多个Topic和Partition，不同分区可并行处理，支持顺序消息、分布式事务等特性，采用pull模式，消费者主动拉取消息，适合用于大规模、高吞吐量场景</p><h2 id="Unity中C-的生命周期"><a href="#Unity中C-的生命周期" class="headerlink" title="Unity中C#的生命周期"></a>Unity中C#的生命周期</h2><p>C#脚本的生命周期主要围绕<code>MonoBehaviour</code>类展开，首先是初始化阶段，可以使用Awake（最早被调用，仅执行一次），Start（在第一次 <code>Update</code> 前调用，仅执行一次）进行初始化，然后是运行阶段，使用update、fixedupdate，然后是渲染阶段，OnPreRender，OnRenderObject，OnPostRender，最后是销毁阶段，OnDisable</p><h2 id="Unity为什么需要协程"><a href="#Unity为什么需要协程" class="headerlink" title="Unity为什么需要协程"></a>Unity为什么需要协程</h2><ul><li>实现延时执行而不阻塞主线程：Unity是单线程的，而协程允许先等待一段时间后再执行后续代码</li><li>逐帧执行复杂操作，防止掉帧：当某个任务太重时（如大量计算、加载资源等），协程可以把任务分成多帧执行</li></ul><h2 id="SpringBoot相比于Spring有哪些优点"><a href="#SpringBoot相比于Spring有哪些优点" class="headerlink" title="SpringBoot相比于Spring有哪些优点"></a>SpringBoot相比于Spring有哪些优点</h2><ul><li>Spring需要XML或Java配置类进行配置，SpringBoot提供了自动化配置，大部分默认配置就能满足开发需求</li><li>SpringBoot内置了Tomcat容器，项目可以直接打包成jar运行，不需要部署到外部服务器</li><li>SpringBoot提供了多种starter依赖（如 <code>spring-boot-starter-web</code>、<code>starter-data-jpa</code>），解决了版本兼容与依赖整合的问题</li><li>SpringBoot提供了对主流中间件的默认整合，如Redis、RabbitMQ、MyBatis、Elasticsearch等，通过yml文件即可完成连接配置，无需手动创建Bean</li></ul><h2 id="SpringBoot项目中的分层架构，以及会用到的注解"><a href="#SpringBoot项目中的分层架构，以及会用到的注解" class="headerlink" title="SpringBoot项目中的分层架构，以及会用到的注解"></a>SpringBoot项目中的分层架构，以及会用到的注解</h2><ul><li>Controller层（处理请求，参数解析，返回响应）：@RestController、@Controller、@RequestMapping、@GetMapping、@ResponseBody、@RequestBody</li><li>Service 层（处理具体业务逻辑）：@Service、@Transactional</li><li>DAO层（与数据库交互）：@Mapper</li></ul><h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><ul><li>如何在Linux系统中查询所有运行的java项目：ps -ef | grep java</li><li>linux中查找文件：find -name “filename”</li><li>linux中查看端口号占用情况：netstat或ss -tunlp | grep 端口号</li><li>linux查看进程占用了哪个端口：lsof -p <PID> -i</PID></li></ul><h2 id="性能测试的指标"><a href="#性能测试的指标" class="headerlink" title="性能测试的指标"></a>性能测试的指标</h2><ul><li>响应类，比如响应时间、延迟、TPS、帧时间</li><li>资源占用类，比如CPU、内存、带宽和磁盘I&#x2F;O</li><li>稳定性和并发类，比如并发用户数、崩溃率、卡顿率、内存泄漏等</li></ul><p>实际测试中结合场景，比如副本战斗关注FPS与卡顿率，主界面关注内存占用和帧时间，PVP联网则重点看延迟和同步情况，服务器端则关注并发连接、TPS和崩溃率等。</p><h2 id="如何发现性能测试的瓶颈"><a href="#如何发现性能测试的瓶颈" class="headerlink" title="如何发现性能测试的瓶颈"></a>如何发现性能测试的瓶颈</h2><p>首先要明确测试的目标和场景，是为了找到响应慢的接口还是检查资源使用过高，可以重点关注CPU使用率、负载、内存的占用率、网络的吞吐量和延迟、磁盘的IO次数和数据库的查询耗时、连接数等，如果是接口响应慢可能是有慢SQL、或者出现远程的资源调用与加载比较慢，如果是高并发时崩溃，可能是数据库连接池出了问题，内存溢出，如果是频繁丢帧和卡顿，可能是机器配置不足或者优化没到位等等</p><h2 id="游戏中哪些地方需要性能测试"><a href="#游戏中哪些地方需要性能测试" class="headerlink" title="游戏中哪些地方需要性能测试"></a>游戏中哪些地方需要性能测试</h2><p>开放世界的流式加载，就是从一个地方跑到另一个地方不会产生卡顿和割裂感，玩家快速切换视角和缩放场景的时候的流畅度</p><p>城市场景和高密度对象共存的场景，对于NPC密集的地方，统计一下帧率和抖动的情况</p><p>战斗场景，对于放技能时特效的加载和多种角色技能共存时对于帧率和电脑或者手机负载的影响</p><p>资源的加载和切换，当使用传送功能的时候，资源加载的效率</p><p>长时间运行的稳定性，就是模拟多个小时不间断游戏，看看与刚进入游戏时对比，帧率和负载是否有比较大的变化</p><p>异常网络环境测试，对于弱网环境也可以测试一下</p><h2 id="Caffeine和Guava-Cache的区别"><a href="#Caffeine和Guava-Cache的区别" class="headerlink" title="Caffeine和Guava Cache的区别"></a>Caffeine和Guava Cache的区别</h2><ul><li>Guava和Caffeine底层都使用的ConcurrentHashMap来实现缓存</li><li>Guava在内存淘汰上用的LRU，支持基于时间和数据大小的回收策略，Caffeine使用的TinyLFU，与LRU相比锁竞争更少，命中率更高</li><li>在数据过期刷新上，Guava使用的阻塞式刷新方法，Caffeine是异步刷新</li></ul><h2 id="用户端程序崩溃，如何复现"><a href="#用户端程序崩溃，如何复现" class="headerlink" title="用户端程序崩溃，如何复现"></a>用户端程序崩溃，如何复现</h2><p>从用户或日志中获取尽可能完整的上下文信息，比如崩溃发生的设备型号、操作系统、内存情况，是否有崩溃弹窗&#x2F;错误码&#x2F;闪退提示，崩溃前执行了哪些操作，点击了哪个功能和崩溃时的网络状态（在线&#x2F;离线&#x2F;弱网），然后查看日志文件，搜集信息。然后在调试环境下，执行与用户相同的操作流程</p><h2 id="黑盒测试、白盒测试、灰盒测试"><a href="#黑盒测试、白盒测试、灰盒测试" class="headerlink" title="黑盒测试、白盒测试、灰盒测试"></a>黑盒测试、白盒测试、灰盒测试</h2><p>黑盒测试是不关注代码逻辑，只关注功能是否符合需求，从用户的视角测试系统的输入输出。主要测试软件或者游戏的一些功能是否符合规格，边界值处理是否正确，系统响应是否正确等等，常见的方法有等价类划分、边界值分析、错误推测法、场景法等</p><p>白盒测试是从开发者视角出发，测试代码的各个逻辑分支，条件和循环结构。常见的方法有语句覆盖、分支覆盖、条件覆盖、循环覆盖等</p><p>现在一般两者融合使用，就是部分了解系统内部逻辑，同时也关注一些功能表现，叫灰盒测试，主要测试一些业务流程是否合理，模块之间的接口是否生效，安全验证是否生效等</p><h2 id="JMeter的断言方式"><a href="#JMeter的断言方式" class="headerlink" title="JMeter的断言方式"></a>JMeter的断言方式</h2><p>最常用的是响应断言，用于检查响应的数据中是否包含某些字符串或者关键词，可以校验文本、状态码、响应头、响应数据等</p><p>JSON断言，校验JSON格式相应的数据结构或字段值</p><p>HTML断言，检查返回的HTML页面是否符合规范</p><p>大小断言和持续时间断言，判断响应的数据长度或者相应的时间是否符合预期</p><h2 id="如何做分布式压测"><a href="#如何做分布式压测" class="headerlink" title="如何做分布式压测"></a>如何做分布式压测</h2><p>单机压测并发有限，所以分布式压测一般采用<strong>Master&#x2F;Worker模式</strong></p><p>Master负责分发压测脚本和任务，Worker负责实际发压，执行请求并收集结果，最后由Master聚合并生成报告</p><p>常见方案有JMeter分布式或Locust，也可以自己搭建调度平台，统一脚本和结果展示</p><h2 id="xxl-job的架构和实现原理"><a href="#xxl-job的架构和实现原理" class="headerlink" title="xxl-job的架构和实现原理"></a>xxl-job的架构和实现原理</h2><p>xxl是一个分布式任务调度平台，主要分为调度中心和执行器，调度中心负责管理任务、选择调度策略、分发调度指令，支持任务配置和日志查询。执行器部署在业务中，接收调度中心下发的任务执行请求，并将执行结果回调给调度中心。两者通过Http通信</p><p>执行器启动时，会向调度中心进行注册，然后调度中心内部使用Quartz作为底层调度器，根据任务配置的CRON表达式触发调度，通过HTTP向执行器的任务API发送执行请求，执行器收到请求后，根据任务Handler名称找到对应的方法执行，执行器会将结果和执行日志推送到调度中心，在调度中心进行统一的任务监控</p><h2 id="xxl-job怎么保证每一个实例任务只调用一次"><a href="#xxl-job怎么保证每一个实例任务只调用一次" class="headerlink" title="xxl-job怎么保证每一个实例任务只调用一次"></a>xxl-job怎么保证每一个实例任务只调用一次</h2><p>调度中心自身可以做集群部署来提高可用性和任务执行效率，调度中心之间会通过数据库xxl_job_lock表的行锁机制保证，在同一时刻，一个任务只有一个调度中心节点会触发调度</p><p>如果需要任务多实例执行，可以用分片广播模式</p><h2 id="如果某个接口的响应时长变长，不符合预期，有什么优化思路"><a href="#如果某个接口的响应时长变长，不符合预期，有什么优化思路" class="headerlink" title="如果某个接口的响应时长变长，不符合预期，有什么优化思路"></a>如果某个接口的响应时长变长，不符合预期，有什么优化思路</h2><p>首先看一下接口层面的优化，是否是代码逻辑上有问题，有没有用到缓存，然后长耗时的任务可以放到消息队列或者异步执行。然后是服务层面的优化，看一下线程池有没有什么问题，锁的竞争，有没有造成死锁或者线程饥饿，IO优化，用多路复用。然后是数据库层面的优化，查询慢SQL，减少Join，添加索引，分库分表、读写分离和冷热数据分离。再是外部依赖优化，网络是否通常，请求第三方接口会不会遇到连接超时，降级和熔断策略的配置。最后是系统层面的优化，JVM调优或者Nginx负载均衡</p><h3 id="假如别人调你的接口，说接口超时了，但是排查发现接口没有问题，问题出在哪（客户端显示超时，但是服务端不超时"><a href="#假如别人调你的接口，说接口超时了，但是排查发现接口没有问题，问题出在哪（客户端显示超时，但是服务端不超时" class="headerlink" title="假如别人调你的接口，说接口超时了，但是排查发现接口没有问题，问题出在哪（客户端显示超时，但是服务端不超时)"></a>假如别人调你的接口，说接口超时了，但是排查发现接口没有问题，问题出在哪（客户端显示超时，但是服务端不超时)</h3><p>可能是客户端和服务端的超时配置不一致，可能客户端超时时间设置的过短。然后可能是网络问题，网络抖动、丢包、带宽不足，导致服务端返回的响应未能及时到达客户端，还可能是TCP层和HTTP的问题，TCP连接断开、HTTP长连接复用，某些请求排队太久</p><h2 id="Docker容器编排的作用"><a href="#Docker容器编排的作用" class="headerlink" title="Docker容器编排的作用"></a>Docker容器编排的作用</h2><p>容器编排的作用主要是为了解决大规模容器应用的管理问题，现在应用普遍都会在分布式环境下部署成几十上百个容器，人工管理比较困难。容器编排主要可以：</p><ul><li>管理容器的生命周期，自动创建、启动、停止、销毁容器，保证服务按照预期的副本数运行</li><li>多个容器实例运行时，自动注册和发现服务，提供内置的负载均衡，让流量在多个容器间均衡分配</li><li>提供对容器运行状态、性能指标的监控，集中化收集和管理容器日志</li></ul><p>核心作用就是“让成百上千的容器能够自动化、高可用、可扩展地运行”，常见的编排工具是Kubernetes</p><h3 id="K8S的架构"><a href="#K8S的架构" class="headerlink" title="K8S的架构"></a>K8S的架构</h3><p>本质上是一个主从架构，由控制平面和工作节点组成</p><p>控制平面负责整个集群的调度、管理和控制，主要包括：</p><ul><li>API Server：所有组件交互的唯一入口，接收 kubectl 命令、外部系统请求</li><li>etcd：分布式键值存储系统，存储整个集群的状态</li><li>Controller Manager：运行各种控制器，保证集群的目标状态和实际状态一致</li><li>Scheduler：负责 Pod 调度，即决定 Pod 应该运行在哪个 Node 上</li></ul><p>工作节点是Pod的运行载体，相当于集群里的工人：</p><ul><li>kubelet：负责与 API Server 通信，监控 Pod 的运行状态</li><li>kube-proxy：负责实现 Kubernetes Service 的流量转发与负载均衡</li></ul><h2 id="Docker网络模型"><a href="#Docker网络模型" class="headerlink" title="Docker网络模型"></a>Docker网络模型</h2><ul><li>bridge模式（默认）：每个容器分配一个独立的网络空间，Docker在宿主机上创建一个虚拟网桥（默认docker0）。启动容器时，会创建一对虚拟网卡，一端放到容器内作为<code>eth0</code>，另一端放到宿主机并挂在 <code>docker0</code> 上。容器之间通过 <code>docker0</code> 进行二层通信，出外网走宿主机 NAT</li><li>host模式：容器和宿主机共享网络空间，容器直接使用宿主机的网卡和端口，没有虚拟网桥，没有NAT，容易造成端口冲突</li><li>none 模式：容器只创建网络空间，但不做任何网络配置，需要自己手动配置</li></ul><h3 id="Docker容器虚拟网卡（veth-pair）收发包过程"><a href="#Docker容器虚拟网卡（veth-pair）收发包过程" class="headerlink" title="Docker容器虚拟网卡（veth pair）收发包过程"></a>Docker容器虚拟网卡（veth pair）收发包过程</h3><p>以bridge模式为例：容器内有一端虚拟网卡作为eth0，另一端在宿主机上挂在docker0。容器发包时，数据经过 veth → docker0 → 宿主机路由&#x2F;NAT → 物理网卡；外部访问容器则反过来，先到宿主机物理网卡 → DNAT → 容器 veth → 容器应用</p><h2 id="Nacos注册中心的架构"><a href="#Nacos注册中心的架构" class="headerlink" title="Nacos注册中心的架构"></a>Nacos注册中心的架构</h2><ul><li>在服务实例启动时，会把自己的信息注册到Nacos，客户端通过服务名拉取可用实例，实现服务发现</li><li>数据模型是基于服务命名空间、分组、集群的扁平化结构</li></ul><ul><li><p>Nacos支持主动心跳（客户端定期上报）和被动检测（Server发起TCP&#x2F;HTTP检测）</p></li><li><p>如果实例不可用，Nacos会自动剔除，保证服务列表的实时性</p></li><li><p>Nacos同时支持AP模式（默认，基于Distro协议，保证可用性和扩展性）和CP模式（基于Raft协议，保证一致性）</p></li><li><p>多台Nacos节点可以组成集群，通过MySQL存储元数据，保证数据持久化</p></li></ul><h2 id="java线程栈跟内核栈的对应关系"><a href="#java线程栈跟内核栈的对应关系" class="headerlink" title="java线程栈跟内核栈的对应关系"></a>java线程栈跟内核栈的对应关系</h2><p>每个Java线程是1:1映射到内核线程的，因此它既有JVM分配的Java栈（用户态，用来执行 Java 方法调用），也有操作系统分配的内核栈（内核态，用来处理系统调用和中断）</p><p>两者是独立的：执行普通Java代码用Java栈；执行系统调用时切换到内核栈</p><p>Java栈大小可通过<code>-Xss</code>设置，内核栈大小固定（Linux下通常 8KB&#x2F;16KB）</p><h2 id="怎么编写GC友好的代码"><a href="#怎么编写GC友好的代码" class="headerlink" title="怎么编写GC友好的代码"></a>怎么编写GC友好的代码</h2><ul><li>减少临时对象创建</li><li>避免大对象频繁分配</li><li>对频繁使用的对象进行缓存和复用</li><li>合理使用弱引用、软引用</li><li>避免内存泄露</li></ul><p>GC调优思路：先监控 → 分析 GC 日志 → 定位根因（配置&#x2F;代码） → 调整 JVM 参数 + 代码优化</p><h2 id="讲讲大模型中知识蒸馏是怎么做的"><a href="#讲讲大模型中知识蒸馏是怎么做的" class="headerlink" title="讲讲大模型中知识蒸馏是怎么做的"></a>讲讲大模型中知识蒸馏是怎么做的</h2><p>因为大模型的参数量非常大，推理开销很高，部署比较麻烦，所以要通过知识蒸馏，利用大模型作为教师，把知识迁移到小模型。</p><p>比较常用的方法有Soft Target蒸馏，通过温度Softmax平滑，小模型学概率分布而不是单一标签</p><p>Feature-based蒸馏，不仅蒸馏输出，还让小模型网络对齐教师的中间层特征</p><p>Response-based蒸馏，不止学分类概率，还学隐藏向量、排序得分等任务相关输出</p><p>自蒸馏，让大模型自己指导自己</p><h2 id="整体介绍一下你对于Agent、Workflow、RAG、MCP、A2A的理解"><a href="#整体介绍一下你对于Agent、Workflow、RAG、MCP、A2A的理解" class="headerlink" title="整体介绍一下你对于Agent、Workflow、RAG、MCP、A2A的理解"></a>整体介绍一下你对于Agent、Workflow、RAG、MCP、A2A的理解</h2><ul><li><p>Agent:一个能自主决策并执行任务的大模型实例，它结合了LLM的推理能力和工具调用能力</p></li><li><p>Workflow:任务编排的方式，把复杂目标拆解成多个步骤，形成有序的执行流程，Agent可以被放在Workflow的节点里，负责某个子任务，Workflow强调流程控制和可复现，Agent强调自主性</p></li><li><p>RAG：检索增强生成。LLM在生成前先去外部知识库检索相关信息，再把结果拼接到Prompt中作为上下文，LLM训练数据会过时，RAG能引入最新的外部知识</p></li><li><p>MCP：一种协议，帮助大模型在复杂系统中统一访问上下文、工具和数据源</p></li><li><p>A2A：Agent-to-Agent，让不同Agent负责不同能力，它们之间通过消息传递或协同协议沟通</p></li></ul><h3 id="讲一下RAG的流程"><a href="#讲一下RAG的流程" class="headerlink" title="讲一下RAG的流程"></a>讲一下RAG的流程</h3><p>接收用户请求，通过向量数据库或者传统索引，把用户问题转化为向量表示，与知识库中的文档向量进行相似度匹配，取Top-K的相关文档作为候选知识，然后将相关文档与问题一起拼接到Prompt中，最后大模型基于增强后的上下文生成回答，它的优势在于降低幻觉、快速更新知识</p><h2 id="大模型应用中prompt包含什么"><a href="#大模型应用中prompt包含什么" class="headerlink" title="大模型应用中prompt包含什么"></a>大模型应用中prompt包含什么</h2><p>prompt是模型理解任务的入口，主要包括：</p><ul><li>上下文信息：给模型提供必要的背景知识，让模型理解任务环境，输入的文本，与任务相关的文档，角色设定</li><li>指令：明确告诉模型要完成的任务或目标</li><li>约束条件：规定输出的格式、长度、风格等限制</li></ul><h2 id="你在之前的项目里做过哪些测试相关的工作"><a href="#你在之前的项目里做过哪些测试相关的工作" class="headerlink" title="你在之前的项目里做过哪些测试相关的工作"></a>你在之前的项目里做过哪些测试相关的工作</h2><p>在Unity中做过场景状态保存和回放，我觉得就是一种测试的思路，可以复现问题</p><p>还做过性能优化，使用Unity的LOD调整不同距离的建模精细度，多智能体训练时，按照职能分组训练，避免同时渲染多个摄像头管线</p><h2 id="如果让你开发一个性能测试平台，你会怎么设计"><a href="#如果让你开发一个性能测试平台，你会怎么设计" class="headerlink" title="如果让你开发一个性能测试平台，你会怎么设计"></a>如果让你开发一个性能测试平台，你会怎么设计</h2><p><strong>采集层</strong>：客户端采集帧率、CPU、内存；服务端采集 QPS、RT、错误率</p><p><strong>传输层</strong>：上报到日志&#x2F;监控系统（Kafka、MQ、ES）</p><p><strong>存储层</strong>：集中存储在数据库（MySQL&#x2F;InfluxDB&#x2F;ES）</p><p><strong>展示层</strong>：可视化（Grafana、前端大屏）</p><p><strong>告警层</strong>：超过阈值自动告警（钉钉&#x2F;飞书机器人）</p><h2 id="客户端卡顿，怎么排查"><a href="#客户端卡顿，怎么排查" class="headerlink" title="客户端卡顿，怎么排查"></a>客户端卡顿，怎么排查</h2><p>首先复现问题，确定是单机问题还是所有人都有问题</p><p>然后分层：</p><p><strong>渲染性能</strong>：材质、批处理</p><p><strong>逻辑性能</strong>：Update&#x2F;FixedUpdate 开销</p><p><strong>内存</strong>：GC频繁触发</p><p><strong>网络</strong>：延迟、丢包</p><h2 id="如果现在要让你开发一个自动化测试工具，你会考虑哪些功能"><a href="#如果现在要让你开发一个自动化测试工具，你会考虑哪些功能" class="headerlink" title="如果现在要让你开发一个自动化测试工具，你会考虑哪些功能"></a>如果现在要让你开发一个自动化测试工具，你会考虑哪些功能</h2><ul><li>脚本驱动自动化（模拟玩家行为）</li><li>数据采集（帧率、CPU、网络延迟）</li><li>兼容性测试（不同设备&#x2F;分辨率）</li><li>压测工具（模拟并发）</li><li>报告生成（错误日志、性能趋势）</li></ul><h2 id="把你做的性能优化思路，怎么迁移到一个游戏性能测试平台"><a href="#把你做的性能优化思路，怎么迁移到一个游戏性能测试平台" class="headerlink" title="把你做的性能优化思路，怎么迁移到一个游戏性能测试平台"></a>把你做的性能优化思路，怎么迁移到一个游戏性能测试平台</h2><ul><li>游戏测试时应该会生成很多日志（帧率、内存、GC、网络延迟）。可以借鉴分页+索引优化思路，用MongoDB存储性能指标，支持快速检索与分析</li><li>测试平台经常重复查询某些数据（历史测试结果、性能曲线），可以在平台层引入多级缓存方案（内存缓存 + Redis），减少后端数据库的压力</li><li>性能测试通常涉及批量脚本执行（跑不同地图&#x2F;角色&#x2F;场景），可以用消息队列解耦测试发起和执行，提升吞吐</li><li>测试过程中产生的性能日志&#x2F;崩溃日志，用消息队列异步写入存储，避免阻塞游戏运行</li><li>在无人艇项目里，我用过摄像机&#x2F;渲染优化来减轻GPU压力，类似的方式也能迁移到性能测试平台，比如在跑批量性能测试时降低渲染保真度，只采集关键性能指标</li></ul><h2 id="设计一个跨平台自动化兼容性测试平台，架构如何划分，关键指标和监控怎么做"><a href="#设计一个跨平台自动化兼容性测试平台，架构如何划分，关键指标和监控怎么做" class="headerlink" title="设计一个跨平台自动化兼容性测试平台，架构如何划分，关键指标和监控怎么做"></a>设计一个跨平台自动化兼容性测试平台，架构如何划分，关键指标和监控怎么做</h2><p>控制平面：用例管理、调度策略、任务编排、权限与版本管理（Web UI + API）</p><p>执行平面：Device Farm（真机 &#x2F; 模拟器 &#x2F; 云设备）、Runner Agent（分布式 Worker），每个Runner支持多种驱动（ADB &#x2F; XCUITest &#x2F; UIAutomator &#x2F; Unity Test Runner &#x2F; Python客户端）</p><p>采集与上报层：性能采集 Agent（嵌入客户端或通过系统 API），日志&#x2F;崩溃收集、帧率&#x2F;内存&#x2F;GPU&#x2F;耗电等时序数据。</p><p>消息&#x2F;队列层：MQ（Kafka&#x2F;Redis Stream）用于任务下发、日志上报与异步处理。</p><p>存储与索引层：时序数据库（Prometheus&#x2F;Influx）+ 日志搜索（es）+ 对象存储（崩溃包&#x2F;视频&#x2F;快照）</p><p>分析与报表层：告警、回放工具（自动构造可复现环境）</p><p>监控与运维：Grafana、健康检查、自动扩缩容模块</p><h2 id="hr面相关"><a href="#hr面相关" class="headerlink" title="hr面相关"></a>hr面相关</h2><h3 id="为什么选择我们公司"><a href="#为什么选择我们公司" class="headerlink" title="为什么选择我们公司"></a>为什么选择我们公司</h3><p>我认为贵公司身为一线互联网企业，技术栈和工程实践能力一定都非常成熟，我相信内部一定非常重视技术氛围。在这样一个重视技术、节奏高效的环境，我认为我的能力可以快速得到提升，而且贵公司应该也会有完善的新员工或实习生的培养流程，可以更好的进行线性成长。并且可以在真实项目中锻炼自己的工程能力。而且我了解贵公司在业务领域持续扩展，也有很强的发展潜力，我希望能在这样的平台上深入了解业务</p><h3 id="你对自己的职业规划是怎样的"><a href="#你对自己的职业规划是怎样的" class="headerlink" title="你对自己的职业规划是怎样的"></a>你对自己的职业规划是怎样的</h3><p>短期内，我希望能在本职岗位上打好基础，快速的了解所负责的基础业务和大体流程，在熟悉业务的同时提升自己对系统架构、质量保障的理解，同时也要重点看一下需求文档和开发文档，着重关注侧重点。中期来看，我希望自己不仅仅是执行需求，还能参与到平台的开发或质量体系建设中，在“懂技术又懂业务”的方向上深入发展，培养自己的产品意识和工程能力</p><h3 id="是否接受加班"><a href="#是否接受加班" class="headerlink" title="是否接受加班"></a>是否接受加班</h3><p>加班我是完全可以接受的。我理解研发和测试周期中有一些阶段确实需要投入更多，尤其是版本上线前或者新项目初期，我也愿意配合团队冲刺目标。</p><h3 id="你有没有其它公司的offer"><a href="#你有没有其它公司的offer" class="headerlink" title="你有没有其它公司的offer"></a>你有没有其它公司的offer</h3><p>之前收到过一些offer，不过我都拒绝掉了，目前有一些面试在进行中，也收到了部分反馈，但从技术氛围和业务来看，我个人更倾向于贵公司</p><h3 id="用几个词描述一下自己"><a href="#用几个词描述一下自己" class="headerlink" title="用几个词描述一下自己"></a>用几个词描述一下自己</h3><p>踏实、自驱、逻辑性强。我在项目中喜欢梳理问题和业务逻辑，有条理地分解任务，也习惯自己查资料解决问题；同时我也具备较强的执行力，能把任务落地</p><h3 id="最有成就感的一件事"><a href="#最有成就感的一件事" class="headerlink" title="最有成就感的一件事"></a>最有成就感的一件事</h3><p>是我在读研期间负责的一个国家自然科学基金项目，当时是从零开始写系统设计书，在一次次的项目对接中实现各种功能和交互的逻辑，并且最后的算法训练也是我来做的，期间遇到了项目开发冲突，需求推倒重做，智能体训练失败等问题，但是最终也是平稳交付。负责一个成功交付的项目让我很有成就感</p><h3 id="最成功的一次团队合作经历"><a href="#最成功的一次团队合作经历" class="headerlink" title="最成功的一次团队合作经历"></a>最成功的一次团队合作经历</h3><p>我在去年做一个导师的横向课题时，担任的是场景构建的角色和团队负责人之一，在项目初期，我们带领团队成员制定了一个详细的项目计划和时间表，明确了每个人的职责。然后我进行场景构建的时候，也会与进行具体逻辑开发的成员进行及时的沟通，说明场景的构建蓝图和可行的训练方案。然后我的任务完成之后，由于我也是负责人之一，我也会及时的跟进项目当前的进度。</p><p>在项目快收尾的时候，我们遇到了一个问题，就是强化学习智能体达不到合同中规定的性能要求，在进行增加训练轮次，修改奖励函数等补救措施之后依然不行，然后我决定重新构建一版场景，让智能体更容易探索，最终解决了这个问题，然后我们合作的项目也成功的结题了。</p><p>团队合作让我认识到成功的关键在于及时的沟通和协作，就是每个人不能只干完自己的事情就啥都不管了，也要力所能及的跟进到项目的整体中。</p><h3 id="为什么从上一家公司离职"><a href="#为什么从上一家公司离职" class="headerlink" title="为什么从上一家公司离职"></a>为什么从上一家公司离职</h3><p>我在那边主要负责停车平台的开发，用的技术栈比较固定，个人感觉成长空间有限。我在前公司锻炼了开发能力和项目协作经验，也积累了微服务、分布式系统的经验。接下来我希望能结合这些经验，进一步挑战更大规模的系统和更复杂的架构，因此寻找一下新的机会。</p>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/c92e9465.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>xxl-Job基础入门</title>
      <link>http://ltynote.cn/inori/226b10d6.html</link>
      <guid>http://ltynote.cn/inori/226b10d6.html</guid>
      <pubDate>Thu, 05 Jun 2025 10:32:24 GMT</pubDate>
      
      <description>xxl-job基础入门</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><p>我们可以思考一下下面业务场景的解决方案:</p><ul><li>某电商平台需要每天上午10点，下午3点，晚上8点发放一批优惠券</li><li>某银行系统需要在信用卡到期还款日的前三天进行短信提醒</li><li>某财务系统需要在每天凌晨0:10分结算前一天的财务数据，统计汇总</li></ul><p>以上场景就是任务调度所需要解决的问题</p><p><strong>任务调度是为了自动完成特定任务，在约定的特定时刻去执行任务的过程</strong></p><h3 id="为什么需要分布式调度"><a href="#为什么需要分布式调度" class="headerlink" title="为什么需要分布式调度"></a>为什么需要分布式调度</h3><p>使用Spring中提供的注解@Scheduled，也能实现调度的功能，在业务类中方法中贴上这个注解,然后在启动类上贴上<code>@EnableScheduling</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/20 * * * * ? &quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//doSomething   </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>但是这种方式：</p><ul><li>只能在一台机器上运行，如果程序或者系统出现异常就会导致功能不可用</li><li>在单机模式下，定时任务是没什么问题的。但当我们部署了多台服务，同时又每台服务又有定时任务时，若不进行合理的控制在同一时间，只有一个定时任务启动执行，定时执行的结果就可能存在混乱和错误了</li><li>原本1分钟内需要处理1万个订单，但是现在需要1分钟内处理10万个订单；原来一个统计需要1小时，现在业务方需要10分钟就统计出来。也许可以多线程、单机多进程处理。的确，多线程并行处理可以提高单位时间的处理效率，但是单机能力毕竟有限（主要是CPU、内存和磁盘），始终会有单机处理不过来的情况</li></ul><h2 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="XXL-Job"></a>XXL-Job</h2><p><a href="https://github.com/xuxueli/xxl-job">XXL-Job</a>是一个轻量级分布式任务调度平台, 其核心设计目标是开发迅速、学习简单、轻量级、易扩展</p><p><img src="/inori/226b10d6/framework.png"></p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p><p>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</p><p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性</p><h3 id="配置调度中心"><a href="#配置调度中心" class="headerlink" title="配置调度中心"></a>配置调度中心</h3><ol><li>下载xxl的源码后，有一个调度数据库初始化的SQL脚本，首先需要把这个脚本导入到数据库中</li><li>按照maven格式将源码导入到idea，使用maven进行编译后运行即可</li></ol><p><img src="/inori/226b10d6/structure.png"></p><ol start="3"><li>修改<code>xxl-job-admin</code>项目的配置文件<code>application.properties</code>,把数据库账号密码配置上</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### web</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/xxl-job-admin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### actuator</span></span><br><span class="line"><span class="attr">management.server.servlet.context-path</span>=<span class="string">/actuator</span></span><br><span class="line"><span class="attr">management.health.mail.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### resources</span></span><br><span class="line"><span class="attr">spring.mvc.servlet.load-on-startup</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">spring.mvc.static-path-pattern</span>=<span class="string">/static/**</span></span><br><span class="line"><span class="attr">spring.resources.static-locations</span>=<span class="string">classpath:/static/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### freemarker</span></span><br><span class="line"><span class="attr">spring.freemarker.templateLoaderPath</span>=<span class="string">classpath:/templates/</span></span><br><span class="line"><span class="attr">spring.freemarker.suffix</span>=<span class="string">.ftl</span></span><br><span class="line"><span class="attr">spring.freemarker.charset</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="attr">spring.freemarker.request-context-attribute</span>=<span class="string">request</span></span><br><span class="line"><span class="attr">spring.freemarker.settings.number_format</span>=<span class="string">0.##########</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### mybatis</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:/mybatis-mapper/*Mapper.xml</span></span><br><span class="line"><span class="comment">#mybatis.type-aliases-package=com.xxl.job.admin.core.model</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, datasource</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://IP地址:端口号/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### datasource-pool</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.idle-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.pool-name</span>=<span class="string">HikariCP</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.max-lifetime</span>=<span class="string">900000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-timeout</span>=<span class="string">10000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-test-query</span>=<span class="string">SELECT 1</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.validation-timeout</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, email</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">spring.mail.port</span>=<span class="string">25</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">xxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.from</span>=<span class="string">xxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.required</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, access token</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string">default_token</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)</span></span><br><span class="line"><span class="attr">xxl.job.i18n</span>=<span class="string">zh_CN</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## xxl-job, triggerpool max size</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.fast.max</span>=<span class="string">200</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.slow.max</span>=<span class="string">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, log retention days</span></span><br><span class="line"><span class="attr">xxl.job.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><ol start="4"><li>运行<code>XxlJobAdminApplication</code>程序，访问调度中心：<a href="http://localhost:8080/xxl-job-admin%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7">http://localhost:8080/xxl-job-admin，默认登录账号</a> “admin&#x2F;123456”</li></ol><h3 id="配置执行器"><a href="#配置执行器" class="headerlink" title="配置执行器"></a>配置执行器</h3><ol><li>添加Maven依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>执行器配置，在配置文件中添加配置</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span></span><br><span class="line"><span class="attr">xxl.job.admin.addresses</span>=<span class="string">http://127.0.0.1:8080/xxl-job-admin</span></span><br><span class="line"><span class="comment">### 执行器通讯TOKEN [选填]：非空时启用；</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string">default_token</span></span><br><span class="line"><span class="comment">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span></span><br><span class="line"><span class="attr">xxl.job.executor.appname</span>=<span class="string">xxl-job-executor-sample</span></span><br><span class="line"><span class="comment">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span></span><br><span class="line"><span class="attr">xxl.job.executor.address</span>=<span class="string"></span></span><br><span class="line"><span class="comment">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span></span><br><span class="line"><span class="attr">xxl.job.executor.ip</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span></span><br><span class="line"><span class="attr">xxl.job.executor.port</span>=<span class="string">9999</span></span><br><span class="line"><span class="comment">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logpath</span>=<span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line"><span class="comment">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建<code>XxlJobConfig</code>配置对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加任务处理类，交给Spring容器管理，在处理方法上贴上<code>@XxlJob</code>注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleXxlJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行定时任务,执行时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>登录调度中心,在任务管理中新增任务,配置内容如下：</p><p><img src="/inori/226b10d6/config1.png"></p><p>然后启动定时调度任务，回到管控台，就可以看到任务已经执行</p><h3 id="执行器集群"><a href="#执行器集群" class="headerlink" title="执行器集群"></a>执行器集群</h3><p>在IDEA中设置SpringBoot项目运行开启多个集群，启动两个SpringBoot程序,需要修改Tomcat端口和执行器端口</p><ul><li><p>Tomcat端口8090程序的命令行参数:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8090 -Dxxl.job.executor.port=9998</span><br></pre></td></tr></table></figure></li><li><p>Tomcat端口8091程序的命令行参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8091 -Dxxl.job.executor.port=9999</span><br></pre></td></tr></table></figure></li></ul><p>在任务管理中，修改路由策略，修改成<code>轮询</code></p><p><img src="/inori/226b10d6/config2.png"></p><p>重新启动,我们可以看到效果是,定时任务会在这两台机器中进行轮询的执行</p><h4 id="调度路由算法"><a href="#调度路由算法" class="headerlink" title="调度路由算法"></a>调度路由算法</h4><ol><li><p>FIRST（第一个）：固定选择第一个机器</p></li><li><p>LAST（最后一个）：固定选择最后一个机器</p></li><li><p>ROUND（轮询）：依次的选择在线的机器发起调度</p></li><li><p>RANDOM（随机）：随机选择在线的机器</p></li><li><p>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上</p></li><li><p>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举</p></li><li><p>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举</p></li><li><p>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度</p></li><li><p>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度</p></li><li><p>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务</p></li></ol><h3 id="分片功能"><a href="#分片功能" class="headerlink" title="分片功能"></a>分片功能</h3><p>需求:在指定节假日，需要给平台的所有用户去发送祝福的短信</p><h4 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h4><p>在数据库中导入<code>xxl_job_demo.sql</code>数据</p><h4 id="集成Druid-MyBatis"><a href="#集成Druid-MyBatis" class="headerlink" title="集成Druid&amp;MyBatis"></a>集成Druid&amp;MyBatis</h4><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加配置</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/xxl_job_demo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p><strong>添加实体类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMobilePlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">private</span> String username;<span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">private</span> String phone;<span class="comment">//手机号码</span></span><br><span class="line">    <span class="keyword">private</span> String info;<span class="comment">//备注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加Mapper处理类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务功能实现"><a href="#业务功能实现" class="headerlink" title="业务功能实现"></a>业务功能实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot;,处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟发送短信动作</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们的案例中有2000+条数据，如果不采取分片形式的话，任务只会在一台机器上执行，这样的话需要20+秒才能执行完任务</p><p>如果采取分片广播的形式的话，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数，可根据分片参数开发分片任务</p><p>获取分片参数方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可参考Sample示例执行器中的示例任务&quot;ShardingJobHandler&quot;了解试用 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line"><span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br></pre></td></tr></table></figure><p>通过这两个参数，我们可以通过求模取余的方式，分别查询，分别执行，这样的话就可以提高处理的速度</p><p>之前2000+条数据只在一台机器上执行需要20+秒才能完成任务，分片后，有两台机器可以共同完成2000+条数据，每台机器处理1000+条数据，这样的话只需要10+秒就能完成任务</p><h4 id="案例改造"><a href="#案例改造" class="headerlink" title="案例改造"></a>案例改造</h4><p><strong>Mapper增加查询方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan where mod(id,#&#123;shardingTotal&#125;)=#&#123;shardingIndex&#125;&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectByMod</span><span class="params">(<span class="meta">@Param(&quot;shardingIndex&quot;)</span> Integer shardingIndex,<span class="meta">@Param(&quot;shardingTotal&quot;)</span>Integer shardingTotal)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务类方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgShardingHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgShardingHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(shardTotal==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果没有分片就直接查询所有数据</span></span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectByMod(shardIndex,shardTotal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把路由策略改成分片广播即可实现分片功能</p><p><img src="/inori/226b10d6/demo.png"></p>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/xxl/">xxl</category>
      
      
      <category domain="http://ltynote.cn/tags/xxl/">xxl</category>
      
      
      <comments>http://ltynote.cn/inori/226b10d6.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>项目常见问题梳理（持续更新中）</title>
      <link>http://ltynote.cn/inori/b4ace844.html</link>
      <guid>http://ltynote.cn/inori/b4ace844.html</guid>
      <pubDate>Sat, 31 May 2025 08:17:54 GMT</pubDate>
      
      <description>面试专题——项目篇</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h1><h2 id="为什么要做RPC项目"><a href="#为什么要做RPC项目" class="headerlink" title="为什么要做RPC项目"></a>为什么要做RPC项目</h2><p>目前的应用大部分都是分布式或者微服务架构，通常各个模块之间都是通过rpc来进行调用的，所以我认为自己写一个rpc项目可以更加深入的理解rpc的原理</p><p>然后在写rpc项目的过程中，学会了对Zookeeper和netty的使用，也学会了通信协议设计、序列化算法、服务注册与发现、负载均衡策略的设计和使用。</p><h2 id="项目有什么难点，如何解决的"><a href="#项目有什么难点，如何解决的" class="headerlink" title="项目有什么难点，如何解决的"></a>项目有什么难点，如何解决的</h2><ol><li>关于通信协议的实现和切换模块，我希望客户端和服务端支持http，socket和netty传输协议，并且根据配置自动切换。我的解决方案是首先定义了统一的接口<code>RpcClient</code> 和 <code>RpcServer</code>，然后实现其协议子类比如<code>NettyRpcServer</code>和<code>HttpRpcServer</code>，利用Spring Boot的 <code>@ConditionalOnProperty</code>和<code>@ConditionalOnMissingBean</code> 机制，支持配置项自动装配对应的协议实现</li><li>关于负载均衡模块的实现，就是服务调用时如何在多个服务节点直接选择一个合适的目标节点。我的解决方案是定义一个统一的接口<code>LoadBalance</code>，在此基础上扩展成随机、轮询和一致性哈希三种方法，使用SPI的方式决定具体使用哪种策略，最后把LoadBalance注入到服务发现模块中，实现调用时选择</li><li>关于服务注册和发现模块的实现，我编写了一个注解<code>RpcService</code>，服务启动时会遍历所有使用了这个注解的Bean，然后将服务的接口全限定名和服务提供地址注册到注册中心，然后在Zookeeper层面会创建一个临时节点，表明这个服务被创建成功。然后在客户端通过代理类发起远程调用时，如果存在多个地址，就是用负载均衡模块选择一个，最后建立连接发起远程调用</li><li>还有就是Kryo序列化与多线程环境的兼容性。因为Kryo是线程不安全的，直接复用同一个实例会导致数据错乱。后来我通过ThreadLocal为每个线程分配独立的Kryo实例，避免了线程间冲突，同时保持了性能</li></ol><h2 id="为什么用Netty做网络通信"><a href="#为什么用Netty做网络通信" class="headerlink" title="为什么用Netty做网络通信"></a>为什么用Netty做网络通信</h2><p>因为相比于Java原生的Socket和Http更适合高性能和高并发的场景</p><ul><li>Netty的IO是异步非阻塞的，支持大量并发连接，吞吐量高</li><li>Netty使用线程复用、事件驱动机制，资源占用低，GC压力小</li><li>Netty内部提供粘包半包处理器，实现rpc协议更方便</li></ul><h2 id="http、socket、netty三种网络通信方式的区别"><a href="#http、socket、netty三种网络通信方式的区别" class="headerlink" title="http、socket、netty三种网络通信方式的区别"></a>http、socket、netty三种网络通信方式的区别</h2><ul><li>socket是传输层的协议，是操作系统提供的网络编程接口，只提供最基础的通信方式，可以是阻塞或者非阻塞的，需要自己实现编解码器和传输的逻辑</li><li>http是应用层的协议，基于请求-响应的模式，默认是短连接的，并且不支持双向通信，性能比较低，但是http被很多框架支持，使用比较方便</li><li>netty是一个基于NIO的网络通信框架，底层用到了socket，是异步非阻塞，基于事件驱动的，性能比较高，并且其中提供了粘包半包的处理器和对自定义协议的支持，扩展性比较好</li></ul><h2 id="JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别"><a href="#JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别" class="headerlink" title="JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别"></a>JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别</h2><ul><li>JDK是Java原生的序列化方式，不需要引入三方库，但是序列化后体积比较大，性能低，反序列化速度慢</li><li>Json的可读性比较强，支持跨语言调用，比较适合web接口，但是它占用空间比较大，而且不支持复杂的对象图</li><li>Protostuff是基于Protobuf的序列化方式，支持基础的Java Bean，可以跨语言，并且序列化后体积小，性能高，但是它序列化后不可读</li><li>Hession是一个二进制协议，支持序列化复杂对象，也可以跨语言支持，兼容性比较好</li><li>Kryo适合Java内部序列化，不支持跨语言，序列化性能非常高，默认要求类有无参构造器，而且kryo是线程不安全的</li></ul><h2 id="讲一下自定义协议"><a href="#讲一下自定义协议" class="headerlink" title="讲一下自定义协议"></a>讲一下自定义协议</h2><p>我在rpc项目中的自定义协议头有魔数（4byte，识别协议是否合法），版本号（1byte，兼容后续可能的更新），序列化算法（1byte，具体使用的序列化协议），消息类型（1byte，有请求、响应、心跳），消息状态（1byte，成功，失败，超时），消息序列号（4byte，每个请求的唯一id，处理多路复用的时候可以用到），消息长度（4byte）</p><h2 id="讲一下编解码器"><a href="#讲一下编解码器" class="headerlink" title="讲一下编解码器"></a>讲一下编解码器</h2><p>编码部分是出站处理，把RpcMessage编码成Bytebuf对象，先把自定义协议头写到bytebuf中，再把协议体经过序列化后填充到bytebuf中</p><p>解码部分分为粘包半包解码器和具体解码两部分，关于粘包半包处理我使用的是Netty的定长解码器，在解码器中我设定了偏移量和消息体长度值，因为我的协议有16字节，后4字节代表消息体长度，所以偏移量是12字节，长度是4字节，解码器就通过长度字段，得出body的长度，然后从TCP流中拼接出这条完整消息，或者如果多条消息被粘在一起，Netty会按每条消息长度拆分出多条消息。然后再是具体解码，先校验是否符合我自定义协议的格式，再解出具体消息体</p><h2 id="讲一下Netty心跳机制和Channel的连接复用"><a href="#讲一下Netty心跳机制和Channel的连接复用" class="headerlink" title="讲一下Netty心跳机制和Channel的连接复用"></a>讲一下Netty心跳机制和Channel的连接复用</h2><p>TCP是长连接，但不会自动告诉你对方是否断线，如果一端异常断开，另一端会长时间挂起资源，会造成一定的资源浪费，所以我使用了定期的心跳检测，确认连接是否存活。我使用了netty的IdleStateHandler来实现心跳检测，当检测到写空闲时自动发送一个心跳检测数据包</p><p>然后在rpc框架中，如果每发一次请求就新建TCP连接，就会导致大量Socket打开关闭，并且并发高时会造成端口耗尽的问题。我在项目中使用ConcurrentHashMap存放每个<code>IP+端口号</code>使用过的Channel，如果当前IP的端口再次发起rpc请求后，检测到之前的Channel还没关闭，就可以再次使用，避免重复连接服务端</p><p>然后是多路复用的实现，因为同一个服务可能会发出多个不同的rpc请求，我使用一个<code>ConcurrentHashMap</code>存放每个请求的等待结果区，key是协议头中的sequenceId，value是Netty的Promise（代表一个异步响应），当响应回来时，用sequenceId找到对应的Promise完成结果，就可以做到同一个连接处理多个不同的请求。</p><h2 id="注册中心为什么使用Zookeeper不用Nacos"><a href="#注册中心为什么使用Zookeeper不用Nacos" class="headerlink" title="注册中心为什么使用Zookeeper不用Nacos"></a>注册中心为什么使用Zookeeper不用Nacos</h2><p>我这个RPC框架作为一个独立项目，需要自己实现服务注册&#x2F;发现、监听机制、负载均衡等功能。</p><ul><li>项目对一致性的要求更高，服务注册、注销都是临时节点，Zookeeper会在连接断开时自动清理</li><li>Zookeeper支持监听机制，服务节点变化能即时通知客户端，便于实现本地缓存刷新，Nacos的监听更偏配置文件，服务变化通知粒度更粗一些</li><li>项目使用的是Netty和SpringBoot，整体较轻量，不需要配置中心功能</li><li>Nacos提供了配置中心和服务注册功能，对于微服务项目来说非常适合。但我的RPC框架更偏向于底层架构搭建和分布式通信机制学习，所以我更偏向选用Zookeeper，它更容易控制细节、简洁可定制</li></ul><h2 id="服务如何注册、客户端如何发现、服务如何下线"><a href="#服务如何注册、客户端如何发现、服务如何下线" class="headerlink" title="服务如何注册、客户端如何发现、服务如何下线"></a>服务如何注册、客户端如何发现、服务如何下线</h2><p>服务注册的逻辑在服务提供端，主要流程是服务启动时，连接到Zookeeper，创建持久结点，表示这个服务，然后在持久结点下面创建临时子节点，表示提供这个服务的IP地址和端口号，临时节点中会存数据，是Json格式的服务对象，有服务名，ip地址，端口号和版本号。注册成功后，Zookeeper会维持与该服务实例的心跳连接</p><p>服务发现的逻辑在服务调用端，主要流程是服务启动时连接到Zookeeper，发送rpc请求时，先根据服务名查找服务。如果客户端第一次查找该服务，会从Zookeeper拉取服务列表，构建本地缓存，并设置监听器，后续若服务变化，缓存会自动更新。不是第一次的话则直接调用缓存，然后使用负载均衡算法从服务列表中选一个可用实例，返回该实例信息用于客户端建立连接并发起请求</p><p>服务下线分为两种情况，第一种情况是服务主动下线，服务关闭时使用注销方法将服务从Zookeeper中删除，然后客户端因为配置了监听器，会自动更新缓存列表。第二种情况是服务异常下线，因为Zookeeper有心跳机制，当检测不到这个服务时，会认为这个服务已经停止了，删除这个服务</p><h2 id="介绍一下客户端调用、服务端响应的一个完整流程"><a href="#介绍一下客户端调用、服务端响应的一个完整流程" class="headerlink" title="介绍一下客户端调用、服务端响应的一个完整流程"></a>介绍一下客户端调用、服务端响应的一个完整流程</h2><p>客户端通过代理类发起服务调用，动态代理类会封装请求，客户端进行服务发现，然后使用负载均衡算法选择一个服务提供者发起网络通信请求，请求成功后，使用自定义协议将信息封装为消息头和消息体，并通过编码器和序列化器转成字节数组，将数据发送到目标Channel，服务端收到数据后，进行解码和反序列化，还原消息体，然后通过反射调用目标方法，获取返回结果，再封装消息，进行编码和序列化后将字节数组通过Channel发回到客户端中，然后客户端再进行解码和反序列化获得结果。</p><h2 id="如果zk中的服务节点退出了，服务还能访问吗，怎么做"><a href="#如果zk中的服务节点退出了，服务还能访问吗，怎么做" class="headerlink" title="如果zk中的服务节点退出了，服务还能访问吗，怎么做"></a>如果zk中的服务节点退出了，服务还能访问吗，怎么做</h2><p>如果Zookeeper中某个服务节点退出，它注册的临时节点会自动被删除。客户端如果还用旧地址调用，就会访问失败。为避免这个问题，我在客户端实现了本地服务地址缓存和动态监听机制，保证地址列表是实时更新的。客户端在读取服务地址的时候会注册监听器，一旦某个节点下线了，Zookeeper会提交一个事件给监听器，进而更新本地缓存。但是如果是一个客户端已经请求到这个服务节点了，但是此时这个节点宕机了，那么会出现请求失败的情况，关于这种情况，我配置了失败重试策略，请求发送失败时，使用负载均衡策略切换下一个地址重试</p><h2 id="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信"><a href="#如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信" class="headerlink" title="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信"></a>如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信</h2><p>如果一个服务正在被请求，此时直接下线可能会导致请求失败或连接中断。我采用的是优雅下线策略，先从注册中心摘除服务，但不会马上关闭进程，等待处理中的请求完成后再关闭服务进程，保证客户端本次调用能够完成（netty的EventLoopGroup.shutdownGracefully()）</p><h2 id="你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别"><a href="#你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别" class="headerlink" title="你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别"></a>你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别</h2><p>我做的这个RPC框架虽然不如Dubbo、gRPC功能全面，但胜在轻量级，更适合作为学习、定制型服务通信的基础框架。同时我也实现了一些Dubbo和gRPC中的重要特性，如服务注册、序列化、连接复用、自动注入等功能。</p><p>当然与成熟框架相比，我的RPC框架还存在一些后续可以升级的点：</p><ul><li>服务治理能力（如限流、熔断、降级）</li><li>跨语言支持</li><li>服务可观测性（如日志链路追踪）</li></ul><h2 id="实现一个RPC框架最主要看重哪些点"><a href="#实现一个RPC框架最主要看重哪些点" class="headerlink" title="实现一个RPC框架最主要看重哪些点"></a>实现一个RPC框架最主要看重哪些点</h2><ol><li>通信协议的设计，协议需要清晰的定义请求和响应结构，序列化格式和状态码等数据</li><li>编解码和序列化，编解码和序列化的效率应该要高，然后序列化后的数据体积应该小，看具体业务判断是否需要跨语言</li><li>网络通信性能，阻塞式或者异步式，是否支持连接池、长连接、心跳机制</li><li>服务注册与发现，负载均衡，是否具备故障感知能力</li><li>容错与高可用机制，是否支持失败重试，熔断和降级策略</li><li>还有易用性和可扩展性，是否支持注解，自动装配和可插拔机制</li></ol><h2 id="本地方法调用和远程过程调用有什么区别"><a href="#本地方法调用和远程过程调用有什么区别" class="headerlink" title="本地方法调用和远程过程调用有什么区别"></a>本地方法调用和远程过程调用有什么区别</h2><p>本地方法调用是程序内的方法直接调用，属于同一个进程内的方法调用，延迟很低，调用比较可靠，不需要中间件支持，但是代码的耦合度比较高</p><p>远程过程调用是调用远程服务器上提供的方法，属于不同进程或者不同机器上的方法调用，需要进行网络通信，所以有网络延迟，效率相对较低，也会有网络中断，超时等异常情况，需要中间件的支持，但是做到了服务之间的解耦合</p><h2 id="rpc如何支持服务的熔断和降级的"><a href="#rpc如何支持服务的熔断和降级的" class="headerlink" title="rpc如何支持服务的熔断和降级的"></a>rpc如何支持服务的熔断和降级的</h2><p>熔断是如果某个服务连续调用失败，系统就会临时阻止再发起请求，防止拖垮系统，可以在rpc中引入熔断器组件Sentinel，每个服务接口调用前先经过熔断器判断是否“断路”，统计失败率、超时数等动态判断是否进入熔断状态，还可以支持闭合-&gt;半开-&gt;打开的状态转换</p><p>降级是如果调用失败次数太多，系统就自动返回默认数据或走备用逻辑，可以编写Fallback方法，方法调用失败&#x2F;超时后，调用备用逻辑，返回默认值</p><h2 id="介绍一下一致性哈希算法"><a href="#介绍一下一致性哈希算法" class="headerlink" title="介绍一下一致性哈希算法"></a>介绍一下一致性哈希算法</h2><p>如果使用简单的哈希方式，当服务节点发生变化的时候，所有请求的分发都会大范围变化，这会导致缓存失效，影响系统效率。一致性哈希算法可以做到：节点数量变化时，尽量少地影响原有请求的分配规律，就是请求一致性和低扰动性。</p><p>一致性哈希算法把哈希空间想象成一个环，所有服务实例都通过哈希函数映射到这个环上某个位置，对服务的ip地址，端口号以及服务名称进行hash后对一个比较大的数进行取模，对数据key也进行hash，然后顺时针找到某一个node，就是这个key要存储的服务器。这样如果增加或者删除一台服务器的话，就只会影响部分数据。但是这样做，当节点比较少的时候会造成数据倾斜的问题，大部分数据会集中在某一个服务上。我的项目中使用了虚拟节点的解决方式，每个真实节点会映射为160个虚拟节点，通过MD5算法再生成多个哈希值，映射到哈希环上，对于请求来说，使用服务方法名加请求参数拼接后做MD5，再映射成哈希值，定位到哈希环上离它最近的服务节点，当服务列表变更时，重新构建哈希环，保证一致性，然后这个重建是不会造成大批量请求映射出错的，比如某个请求落到虚拟节点 A，服务列表变了，A 还在，请求还是到 A，如果A不在了，请求会顺时针走一点落到B。</p><h2 id="项目中哪些地方使用到了异步"><a href="#项目中哪些地方使用到了异步" class="headerlink" title="项目中哪些地方使用到了异步"></a>项目中哪些地方使用到了异步</h2><ul><li>Netty的核心通信是异步的，就是所有的IO操作都是异步非阻塞的</li><li>发送rpc请求是异步的，可以发送消息后立刻返回，监听发送是否成功</li><li>接收响应也是异步的，我在发生时生成了一个id，将future对象存到HashMap里，等收到响应后再异步完成这个future</li></ul><h2 id="RPC和Http通信的区别，各自的优缺点"><a href="#RPC和Http通信的区别，各自的优缺点" class="headerlink" title="RPC和Http通信的区别，各自的优缺点"></a>RPC和Http通信的区别，各自的优缺点</h2><p>RPC：可以基于TCP&#x2F;UDP，自定义高效二进制协议，更轻量，序列化高效，网络开销小，适合高并发、低延迟场景，内网通信为主，安全要求相对较低</p><p>HTTP：固定基于 HTTP&#x2F;HTTPS，基于 HTTP 报文，头部较重，性能相对差，延迟更高，API 接口调用，需构造 URL&#x2F;JSON，标准协议，跨语言、跨平台兼容性强，对公网暴露，必须支持鉴权、加密</p><h2 id="为什么app端都是http通信，内部服务器都是rpc通信"><a href="#为什么app端都是http通信，内部服务器都是rpc通信" class="headerlink" title="为什么app端都是http通信，内部服务器都是rpc通信"></a>为什么app端都是http通信，内部服务器都是rpc通信</h2><p>APP端：</p><ul><li>跨平台标准化：HTTP&#x2F;HTTPS是全球标准协议，任何客户端都能直接使用，不需要额外 SDK</li><li>安全性：HTTP&#x2F;HTTPS 有成熟的安全机制（TLS、证书认证）</li><li>调试和兼容性好：前端和外部开发者可以直接调用REST API</li><li>互联网开放性：公网环境复杂，HTTP是最佳选择</li></ul><p>内部服务：</p><ul><li>性能要求高：服务间调用频繁且量大，HTT的报文头和解析开销太大，而RPC的二进制协议序列化更快</li><li>强类型接口定义：RPC框架通常基于IDL（接口定义语言）生成服务代码，接口契约强约束，有利于多人协作</li><li>内部可控：内网中不需要标准化的开放协议，而是追求极致性能</li></ul><h1 id="小程序项目"><a href="#小程序项目" class="headerlink" title="小程序项目"></a>小程序项目</h1><h2 id="你用自定义注解实现了权限控制，讲讲具体是怎么做的"><a href="#你用自定义注解实现了权限控制，讲讲具体是怎么做的" class="headerlink" title="你用自定义注解实现了权限控制，讲讲具体是怎么做的"></a>你用自定义注解实现了权限控制，讲讲具体是怎么做的</h2><p>在这个小程序中，会涉及到三种角色：管理员root，活动发起者admin和活动参与者visitor，不同角色访问系统中接口的权限是不同的。</p><p>在项目中我使用JWT实现用户认证，用户登录后会签发Token，并将用户信息存入上下文，作为认证依据。</p><p>授权部分，我设计了一个自定义注解<code>@CheckPermission</code>来标记每个接口需要的具体权限，并结合AOP实现了权限切面。切面会在方法执行前解析注解，获取当前用户权限列表，进行匹配校验。如果用户具备权限，就放行接口，否则抛出无权限异常，交由全局异常处理器处理。</p><h2 id="用了三级缓存，讲一下细节"><a href="#用了三级缓存，讲一下细节" class="headerlink" title="用了三级缓存，讲一下细节"></a>用了三级缓存，讲一下细节</h2><p>我的项目中使用了Caffeine、Redis和MySQL结构来优化数据访问性能，本地缓存用于存储访问最频繁的数据，活动列表和当前登录用户信息。Redis作为二级缓存，用于存储访问过的活动详情、活动列表和用户信息，最后由数据库层面，存储全部数据</p><p>整体流程是用户访问数据时，先查本地缓存，未命中则查Redis，如果Redis也未命中再查数据库，并将结果同步回前两级缓存。</p><p>关于过期策略，活动信息在Caffeine中缓存5分钟左右，在Redis中缓存30分钟左右。</p><p>本地缓存层面，我使用了Caffeine的<code>CacheLoader</code>和<code>refreshAfterWrite</code>来预先加载数据避免本地的缓存穿透</p><h2 id="Caffeine-Redis的架构为何这样设计"><a href="#Caffeine-Redis的架构为何这样设计" class="headerlink" title="Caffeine + Redis的架构为何这样设计"></a>Caffeine + Redis的架构为何这样设计</h2><p>本地缓存：就近读取，单机内存命中延迟微秒级；抗Redis短暂抖动；缓解网络与反序列化开销</p><p>Redis：作为跨实例共享缓存源，承接绝大多数读流量，淘汰与过期可控</p><p>Cache是嵌入进程的，不需要网络，延迟很低，QPS很高</p><p>Redis受网络和序列化的影响，延迟稍微高一点，可横向扩展、可以持久化，并且是跨实例共享的、较大数据量、统一失效</p><h2 id="如果要求强一致性怎么办"><a href="#如果要求强一致性怎么办" class="headerlink" title="如果要求强一致性怎么办"></a>如果要求强一致性怎么办</h2><ol><li>放弃缓存：直接走数据库</li><li>缓存只读，写请求直达数据库，更新时立刻失效缓存</li><li>通过分布式锁 + 事务消息保证写库和删缓存的原子性</li></ol><h2 id="缓存穿透的解决方案中，先缓存了空值，后面DB有这条数据了怎么办"><a href="#缓存穿透的解决方案中，先缓存了空值，后面DB有这条数据了怎么办" class="headerlink" title="缓存穿透的解决方案中，先缓存了空值，后面DB有这条数据了怎么办"></a>缓存穿透的解决方案中，先缓存了空值，后面DB有这条数据了怎么办</h2><ul><li>负缓存短TTL：空值只活很短时间，天然自愈</li><li>写&#x2F;变更旁路失效：一旦该业务实体被新增&#x2F;回填，写DB后立刻失效对应Key</li><li>版本号&#x2F;逻辑时钟：值里带 <code>version</code>，读到本地&#x2F;Redis数据发现版本落后则强制回源</li></ul><h2 id="数据库表是怎么设计的"><a href="#数据库表是怎么设计的" class="headerlink" title="数据库表是怎么设计的"></a>数据库表是怎么设计的</h2><p>用户表，存放用户信息和用户的角色</p><p>活动表，存放已经发布的活动，活动的相关信息和发起人</p><p>活动报名表，表示活动id和用户id之间的关系</p><h2 id="如何部署项目，上线流程讲一下"><a href="#如何部署项目，上线流程讲一下" class="headerlink" title="如何部署项目，上线流程讲一下"></a>如何部署项目，上线流程讲一下</h2><p>预先在yaml文件中配置好生产环境参数，然后使用maven对项目进行打包，生成jar文件，传到服务器上，使用systemd后台运行项目，然后配置Nginx，将小程序API请求代理到SpringBoot项目端口，然后配置Nginx的ssl，让小程序支持HTTPS。</p><p>redis和mysql都部署在同一台服务器上，SpringBoot通过配置文件连接到redis和mysql</p><h2 id="活动报名如果高并发，怎么防止名额超限或重复提交"><a href="#活动报名如果高并发，怎么防止名额超限或重复提交" class="headerlink" title="活动报名如果高并发，怎么防止名额超限或重复提交"></a>活动报名如果高并发，怎么防止名额超限或重复提交</h2><p>我在每个活动创建的时候，会把名额写入redis中，使用<code>DECR</code>命令，用户报名前先<code>DECR</code>名额，如果减成功则允许报名，否则失败，因为<code>DECR</code>操作是Redis原子命令，天然支持并发控制，报名成功之后我使用redis创建一个活动名加上用户id的分布式锁，表示这个用户已经报名了这个活动，然后这个设置了一个过期时间，在过期时间内我会把这个报名数据写到数据库中，后续用户再重复报名时，因为redis层面的对应数据已经过期了，就会去查询数据库是否有他的信息，如果有再返回已报名的提示，用这个方式防止名额超限和重复报名</p><h2 id="三级缓存的缓存一致性怎么保证"><a href="#三级缓存的缓存一致性怎么保证" class="headerlink" title="三级缓存的缓存一致性怎么保证"></a>三级缓存的缓存一致性怎么保证</h2><p>读请求是如果访问的是用户信息和首页活动列表，那么会先查询本地缓存，在查询redis，最后查询数据库，然后把数据库返回的数据存到redis和本地缓存中</p><p>如果访问的不是这两个，就直接查询redis，没查到再查询数据库，再写会redis。</p><p>写请求的话，我使用的是先更新数据库，在删除缓存的策略。</p><h1 id="电商项目"><a href="#电商项目" class="headerlink" title="电商项目"></a>电商项目</h1><h2 id="说一下分布式事务"><a href="#说一下分布式事务" class="headerlink" title="说一下分布式事务"></a>说一下分布式事务</h2><p>由多个服务通过网络完成一个事务叫分布式事务。</p><p>首先根据CAP原理决定我们的需求，是要实现CP、还是要实现AP。</p><p>实现CP就是要实现强一致性，可以使用 Seata 框架基于AT、TCC模式去实现。</p><p>我们项目中大部分实现的是AP，使用本地消息表加任务调度完成分布式事务最终数据一致性。</p><h2 id="项目中哪里用到了分布式事务，如何解决的"><a href="#项目中哪里用到了分布式事务，如何解决的" class="headerlink" title="项目中哪里用到了分布式事务，如何解决的"></a>项目中哪里用到了分布式事务，如何解决的</h2><ol><li>发布商品，发布商品需要在商品服务的数据库表中记录，同时将商品信息同步到redis和ES</li></ol><ul><li>发布商品使用本地事务向商品表中写入商品数据，同时写入一条待处理的消息到本地消息表</li><li>提交本地事务之后，xxl的调度中心使用分片广播模式向执行器下发任务，开始扫描消息表，查询待处理的消息</li><li>根据消息内容，通过调用Redis和ES的接口完成数据同步</li><li>任务完成后删除消息表记录</li></ul><ol start="2"><li>用户下单，需要调用商品服务扣减库存，订单服务创建订单，用户服务添加购买记录</li></ol><ul><li>订单服务收到下单请求后，开启本地事务，生成订单记录，然后写入本地消息表，记录要通知商品服务和用户服务的消息，提交事务后，通过消息队列发送通知消息</li><li>商品服务和用户服务通过监听消息队列来处理库存的扣减和添加购买记录的逻辑</li><li>如果消息队列发送失败或者没有被消费，就会使用xxl作为定时任务调度器，每隔一段时间扫描本地消息表中的异常记录进行消息补发</li></ul><h2 id="如何进行分布式事务的回滚"><a href="#如何进行分布式事务的回滚" class="headerlink" title="如何进行分布式事务的回滚"></a>如何进行分布式事务的回滚</h2><p>我项目中采用的是一种基于本地消息表和补偿机制的最终一致性方案。没有使用传统的强一致性分布式事务框架，通过状态标记和异步处理来实现逻辑上的回滚</p><p>在整个业务流程中，每个关键操作都配合本地消息表记录执行状态。当某个服务执行失败时，首先在服务内部有失败重试机制，尽最大努力成功，如果重试后仍失败，会将失败消息记录转移到数据库中的事务失败表，并在消息表中更新状态字段，最后使用xxl定时扫描失败记录表，执行补偿逻辑，并且对于一致性要求比较强的场景，我还使用了消息队列进行即时的通知，xxl作为兜底</p><p>比如用户下单操作中，订单服务已经创建好订单了，但是后续商品扣减库存出了问题，现在想要回滚，那么首先商品服务会发送一条失败消息到消息队列中，并且将失败消息记录到数据库中，订单服务获取到之后，会修改订单表中的状态字段为失败，通过状态标记避免后续的处理</p><h2 id="除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路"><a href="#除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路" class="headerlink" title="除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路"></a>除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路</h2><ul><li>XA，两阶段提交，先准备资源，再统一提交或者回滚</li><li>TCC，把每个操作拆分成三部分，先预检查，再尝试获取资源，最后提交实际操作</li><li>SAGA，长事务补偿，将事务拆分为一系列子事务，每个子事务完成后立刻提交，如果后续事务失败，则按顺序调用每个子事务的补偿操作来回滚</li></ul><p>为什么我选择任务调度这种方式，因为我认为这个项目中主要以性能和并发为优先考虑，不适合xa和tcc，并且业务是允许最终一致性的，不是强一致性的，而且消息队列和xxl的方式比较好实现</p><h2 id="Elasticsearch是怎么使用的"><a href="#Elasticsearch是怎么使用的" class="headerlink" title="Elasticsearch是怎么使用的"></a>Elasticsearch是怎么使用的</h2><p>1）首先创建索引（相当于mysql的表），将商品信息添加到索引库，对商品信息进行分词，存储到索引库</p><p>2）在商品服务中编写商品搜索接口，调用es的rest接口根据关键字、商品分类信息进行搜索</p><h3 id="如何保证索引同步"><a href="#如何保证索引同步" class="headerlink" title="如何保证索引同步"></a>如何保证索引同步</h3><p>我项目是使用本地任务表加xxl-job任务调度进行索引同步</p><p>1）添加或修改或删除商品的同时向任务表插入一条记录，这条记录就记录了是修改了哪个商品</p><p>2）任务调度定时扫描任务表，根据任务表的内容对商品信息进行同步，如果添加了商品将商品添加到索引库，如果修改了商品就修改索引库的商品，如果是删除了商品将商品信息从索引库删除</p><h2 id="xxl-job的工作原理是什么"><a href="#xxl-job的工作原理是什么" class="headerlink" title="xxl-job的工作原理是什么"></a>xxl-job的工作原理是什么</h2><p>xxl由调度中心和执行器组成，在应用启动时，执行器会将自己注册到调度中心Admin，然后在Admin中配置定时任务，指定要调哪个Bean和方法，到达任务触发时间后，Admin通过HTTP请求调用对应的执行器，执行结果会通过回调上传给调度中心，如果失败还可以配置自动重试机制。并且如果有很多执行器，xxl还支持负载均衡策略和任务分片</p><p>在我的项目中，我主要使用xxl实现对本地消息表和失败记录表的定时扫描，还有对于优惠券和商品的限时抢购的时间预订功能</p><h2 id="如何保证任务不重复执行"><a href="#如何保证任务不重复执行" class="headerlink" title="如何保证任务不重复执行"></a>如何保证任务不重复执行</h2><p>主要有两种方式，一个是每个任务都会生成一个唯一的Id，业务层判断该任务是否已经执行过，还有每条待处理的消息记录在消息表中含有状态字段，调度器扫描任务时，通过状态判断是否执行过，避免重复触发</p><h2 id="未支付订单如何处理"><a href="#未支付订单如何处理" class="headerlink" title="未支付订单如何处理"></a>未支付订单如何处理</h2><p>在我的项目中使用RabbitMQ的死信队列机制处理未支付订单，用户提交订单之后，系统会向消息队列中发送一条消息，交换机配置为死信交换机，过期后，消息被路由到死信队列，然后执行取消订单，恢复库存的逻辑</p><h2 id="如何保证RabbitMQ的消息可靠性"><a href="#如何保证RabbitMQ的消息可靠性" class="headerlink" title="如何保证RabbitMQ的消息可靠性"></a>如何保证RabbitMQ的消息可靠性</h2><p>可靠性保证主要分为三部分，一个是生产者到消息队列的可靠性，这部分由消息确认机制保证，就是生产者发送消息后，会异步等待消息队列反馈ACK，一个是消息队列内部的可靠性，消息队列内部有持久化机制，可以将未消费消息保存到硬盘中，一个是消息队列到消费者的可靠性，这个与生产者类似，消费者接收到消息并且成功处理之后，会反馈给消息队列，然后消息队列才会把这条消息删除，如果处理失败或者一直没有处理会触发重试机制</p><h3 id="如何避免消息重复消费"><a href="#如何避免消息重复消费" class="headerlink" title="如何避免消息重复消费"></a>如何避免消息重复消费</h3><p>每个业务操作都有唯一ID，这个ID会随着消息一起发送到消息队列中，如果这个消息已经被消费了，就一定会在数据库中有记录，就算消费者后续反馈到消息队列的ack丢失，触发消息队列的重试机制了，消费者再次收到相同消息时也不会重复消费</p><h2 id="为什么选择RabbitMQ"><a href="#为什么选择RabbitMQ" class="headerlink" title="为什么选择RabbitMQ"></a>为什么选择RabbitMQ</h2><p>首先RabbitMQ支持可靠性传输机制，提供了持久化，ack确认机制，消息重试和死信机制，然后它提供了很多的消息路由类型（点对点路由、模糊匹配路由、广播路由），可以应对不同的业务场景</p><h2 id="项目使用Redis缓存了哪些数据"><a href="#项目使用Redis缓存了哪些数据" class="headerlink" title="项目使用Redis缓存了哪些数据"></a>项目使用Redis缓存了哪些数据</h2><p>缓存内容有商品详情、商品列表、用户信息等访问频率可能比较高的数据</p><p>使用的数据结构：</p><ul><li>String：商品详情</li><li>Hash：用户信息、购物车数据</li><li>List：排行榜、热门商品</li></ul><h2 id="如何保证Redis缓存一致性"><a href="#如何保证Redis缓存一致性" class="headerlink" title="如何保证Redis缓存一致性"></a>如何保证Redis缓存一致性</h2><p>对于正常读写场景，我采用的是先更新数据库，再删除缓存的方式，对于高并发写场景，我采用的是先更新缓存，再异步更新数据库的方式，高并发为了减轻数据库压力、提高写入性能，直接写缓存，再通过消息队列异步写数据库，确保最终一致</p><h2 id="优惠券秒杀部分怎么实现的"><a href="#优惠券秒杀部分怎么实现的" class="headerlink" title="优惠券秒杀部分怎么实现的"></a>优惠券秒杀部分怎么实现的</h2><p>秒杀的核心目标首先是保证优惠券不能超卖，同一用户不能重复领券。首先我会把券的库存预加载进Redis中，然后把校验用户身份和扣减库存这两步写到lua脚本里原子执行，然后如果redis返回成功，就会向消息队列中发一条更新数据库的消息，把优惠券写到用户信息中，这样既能流量削峰，也能保证幂等性。</p><h2 id="秒杀的核心瓶颈是什么"><a href="#秒杀的核心瓶颈是什么" class="headerlink" title="秒杀的核心瓶颈是什么"></a>秒杀的核心瓶颈是什么</h2><ul><li>高并发，瞬间就会有上万的用户访问同一个服务，可能会导致服务崩溃。可以使用令牌桶拦截多余请求，或者使用消息队列异步处理</li><li>库存超卖，多个用户并发抢购，有可能库存为0时仍被扣减。可以使用Redis+Lua脚本原子操作</li><li>数据库写入压力，秒杀成功时大量请求写入数据库。可以使用消息队列异步写入，或者分库分表缓解单表写入瓶颈</li><li>重复下单，在redis加一个用户id锁，然后在过期之前把优惠券持有情况写到数据库中，后续分布式锁过期了也可以保证幂等性</li></ul><h2 id="当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施"><a href="#当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施" class="headerlink" title="当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施"></a>当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施</h2><ul><li>首先可以在网关层限流，对IP限流，每个IP每秒不超过5次</li><li>然后可以在服务层限流，以用户id统计单位时间内的访问次数，超出阈值后进入冷却期，在一定时间内限制该用户的访问</li><li>然后在核心接口的访问使用令牌桶，用户抢到令牌才能继续请求</li></ul><h2 id="假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理"><a href="#假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理" class="headerlink" title="假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理"></a>假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理</h2><p>关于这一点，我采用了订单状态控制和幂等机制来确保流程正确性。我在设计订单支付功能时，订单表中有一个状态字段，支付成功只能从未支付转为已支付，退款只能从已支付状态进入。支付成功后立马发起退款，如果当前数据库的订单状态还没转换成未支付，说明当前的订单服务都还没执行完，就会拒绝退款，如果订单状态已经转换成已支付了，就会进入退款流程，然后把订单状态改为已退款，因为订单服务之后会走用户服务和商品服务，用户服务是一定会走的，因为用户曾经创建过这个订单，然后商品服务的话会执行恢复库存这样的操作</p><h2 id="订单失败如何给用户进行反馈的"><a href="#订单失败如何给用户进行反馈的" class="headerlink" title="订单失败如何给用户进行反馈的"></a>订单失败如何给用户进行反馈的</h2><p>用户下单请求是通过接口发起的，在Controller层会捕获所有异常情况，如果业务逻辑执行失败，后端会返回统一格式的失败响应结构，前端拿到响应后通过异常响应信息提示用户。在订单表中有一个状态字段，每个订单可能的到达的状态在字段中都有记录，无论哪一步失败，都会更新订单状态字段，保障用户能获取订单失败的原因</p><h2 id="当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做"><a href="#当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做" class="headerlink" title="当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做"></a>当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做</h2><p>首先将先将失败订单进行归类管理，为后续调度处理提供依据，比如超时未支付，扣库存失败等情况，每一类对应着不同的处理策略</p><p>然后为每个服务维护一张失败任务表，记录异常信息与状态字段，用xxl定时扫描任务表，使用分片广播模式将任务分发到多个执行器实例，每次任务执行前先通过订单状态字段判断是否已经处理保证幂等性，高并发场景下，也可结合分布式锁，确保订单只被一个任务执行，对处理失败的任务，支持自动重试机制，配置最大重试次数，失败次数超过阈值后自动转为人工处理，处理完成后更新订单状态，防止重复处理</p><h2 id="项目中的线程池使用什么方式创建的"><a href="#项目中的线程池使用什么方式创建的" class="headerlink" title="项目中的线程池使用什么方式创建的"></a>项目中的线程池使用什么方式创建的</h2><p>在项目中我使用的是Java原生的ThreadPoolExecutor，核心线程数我选择的是CPU核心数的两倍，最大线程数我用的核心线程数的两倍，非核心线程存活时间我设置的是一分钟，任务队列我用的有界数组队列，长度2000，拒绝策略使用的CallerRunsPolicy，当前线程执行任务。</p><h2 id="做微服务的意义是什么，耦合带来了什么问题，为什么要降低耦合，耦合高了有什么好处"><a href="#做微服务的意义是什么，耦合带来了什么问题，为什么要降低耦合，耦合高了有什么好处" class="headerlink" title="做微服务的意义是什么，耦合带来了什么问题，为什么要降低耦合，耦合高了有什么好处"></a>做微服务的意义是什么，耦合带来了什么问题，为什么要降低耦合，耦合高了有什么好处</h2><p>微服务的核心理念是将一个大而全的系统拆分为多个小而独立的服务，每个服务专注于一个业务功能，各服务之间通过API通信。</p><p>微服务可以降低模块之间的依赖，每个服务可以独立开发、测试、部署；然后如果某个服务出了故障，不一定影响全局，可以提高系统稳定性；多团队可并行开发，各自维护自己负责的服务；技术栈灵活，每个服务可以选用不同的技术；扩展性也好</p><p>耦合高了提高维护成本，改一个模块容易影响其他模块，容易引发连锁 Bug；扩展困难，无法对某个功能进行独立扩展，只能整体扩容，浪费资源；容错性比较差，一个模块崩了可能导致整个系统挂掉</p><p>耦合高了也有好处，单体应用性能高，逻辑直观，开发调试方便，高频调用时，方法级耦合比微服务高效</p><h1 id="国自然项目"><a href="#国自然项目" class="headerlink" title="国自然项目"></a>国自然项目</h1><h2 id="白天和夜晚的光照变化是怎么控制的"><a href="#白天和夜晚的光照变化是怎么控制的" class="headerlink" title="白天和夜晚的光照变化是怎么控制的"></a>白天和夜晚的光照变化是怎么控制的</h2><p>时间的变化主要是通过调整全局光照和天空盒参数实现的，把主光源作为太阳光源，绑定到脚本中，根据时间参数控制旋转角度和光照强度</p><p>Skybox使用支持昼夜渐变的材质（或者用两个不同的天空盒，通过插值过渡），颜色和曝光参数跟随时间变化</p><p>环境光在夜晚降低亮度，并增加微弱的蓝色调，让场景不至于完全漆黑</p><p>在夜晚阶段，还会动态启用海面反光的高光效果，模拟月光反射</p><h2 id="无人艇之间的交互逻辑和避障策略是怎样的"><a href="#无人艇之间的交互逻辑和避障策略是怎样的" class="headerlink" title="无人艇之间的交互逻辑和避障策略是怎样的"></a>无人艇之间的交互逻辑和避障策略是怎样的</h2><p>无人艇分为红方和蓝方，红方的任务是护送一艘大型舰艇，蓝方是接近并攻击，在逻辑上，每艘艇会周期性计算与目标和其他艇的距离与角度，根据博弈规则（保护优先、进攻优先等）决定下一步动作，信息是通过共享状态表实现的（集群队友的位置和速度）</p><p>针对静态障碍物的避障使用的Unity自带的NavMesh系统，动态的无人艇集群之间的避障使用的<code>Raycast</code>，根据探测距离设定危险等级，如果探测到最近距离小于安全阈值，就会微调航向角进行躲避</p><h2 id="你提到场景切换，状态是如何保存的"><a href="#你提到场景切换，状态是如何保存的" class="headerlink" title="你提到场景切换，状态是如何保存的"></a>你提到场景切换，状态是如何保存的</h2><p>我们在场景切换时主要会保存场景的本地状态，我是用一个脚本标记可保存的物体，保存时遍历这些物体，把 Prefab 名称、位置、旋转、缩放还有挂载的脚本等关键信息存成JSON文件。加载时再用这些数据实例化相应Prefab并恢复属性。</p><h3 id="为什么不用PlayerPrefs保存"><a href="#为什么不用PlayerPrefs保存" class="headerlink" title="为什么不用PlayerPrefs保存"></a>为什么不用PlayerPrefs保存</h3><p>PlayerPrefs更适合保存少量持久化设置，不适合频繁更新或存储复杂对象，序列化到内存或ScriptableObject性能更好。</p><h2 id="当前Unity项目与强化学习的集成点在哪"><a href="#当前Unity项目与强化学习的集成点在哪" class="headerlink" title="当前Unity项目与强化学习的集成点在哪"></a>当前Unity项目与强化学习的集成点在哪</h2><ul><li><p>Unity作为强化学习的环境端，负责渲染场景、模拟物理、生成状态信息，例如无人艇的位置信息、速度、任务完成进度，都会在Unity中实时计算</p></li><li><p>状态与动作交互是通过Unity与Python的通信接口传递数据，这里用的是ML-Agents的gRPC接口</p></li></ul><ul><li><p>Unity每一帧会将当前环境的状态向量打包传给RL端，RL算法根据策略网络输出动作，再传回Unity</p></li><li><p>奖励函数设计在Unity，在检测到回合结束条件时，会发出episode结束信号给RL端</p></li></ul><h1 id="RL项目"><a href="#RL项目" class="headerlink" title="RL项目"></a>RL项目</h1><h2 id="你怎么实现奖励与惩罚机制，Unity里怎么写这个逻辑"><a href="#你怎么实现奖励与惩罚机制，Unity里怎么写这个逻辑" class="headerlink" title="你怎么实现奖励与惩罚机制，Unity里怎么写这个逻辑"></a>你怎么实现奖励与惩罚机制，Unity里怎么写这个逻辑</h2><p>在Unity中，会给每个智能体挂载一个脚本，在其中维护当前步的奖励值，主要是基于事件驱动的方式计算奖励，比如：</p><ul><li>达成目标（寻路成功、穿越圆环）正奖励</li><li>碰撞障碍物或越界 负奖励</li><li>行动效率（节省时间&#x2F;距离）适度奖励或惩罚</li></ul><p>奖励值实时累加或反馈给强化学习算法</p><h2 id="Unity和Python是怎么通信的，用的什么方式"><a href="#Unity和Python是怎么通信的，用的什么方式" class="headerlink" title="Unity和Python是怎么通信的，用的什么方式"></a>Unity和Python是怎么通信的，用的什么方式</h2><p>主要通信方式是用ML-Agents提供的API，Unity作为环境端，将状态数据序列化后发送给Python端的RL算法，Python算法根据状态返回动作指令，再发送给Unity执行，通信通常是同步请求响应模式，确保每步动作对应环境状态</p><h2 id="那在Unity中如何定义结束条件"><a href="#那在Unity中如何定义结束条件" class="headerlink" title="那在Unity中如何定义结束条件"></a>那在Unity中如何定义结束条件</h2><p>结束条件通过检测特定事件触发，比如：</p><ul><li>智能体完成任务（到达目标点）</li><li>触发最大步数限制（训练回合结束）</li><li>智能体碰撞或越界（失败）</li></ul><p>C#脚本中实现回合结束函数，触发环境重置和奖励结算</p><h2 id="复杂场景是怎么设计的，有什么特殊优化点"><a href="#复杂场景是怎么设计的，有什么特殊优化点" class="headerlink" title="复杂场景是怎么设计的，有什么特殊优化点"></a>复杂场景是怎么设计的，有什么特殊优化点</h2><p>设计思路：</p><ul><li>利用Terrain工具构建地形，包括山地、沟壑、湖泊等，使用贴图和植被系统增强真实感</li><li>放置障碍物和地标，设计合理路径和盲区增加训练难度</li></ul><p>优化点：</p><ul><li>使用NavMesh做路径规划和避障，提升性能和准确性</li><li>按需加载场景资源，避免一次性加载过多导致卡顿</li></ul><h2 id="大量训练时Unity性能开销大吗，怎么优化的"><a href="#大量训练时Unity性能开销大吗，怎么优化的" class="headerlink" title="大量训练时Unity性能开销大吗，怎么优化的"></a>大量训练时Unity性能开销大吗，怎么优化的</h2><p>大规模训练时Unity的确会有比较大的性能开销，尤其是渲染和物理引擎的计算。主要做了几个优化：</p><ul><li>图形层面：关闭不必要的渲染，降低材质和阴影质量，大规模训练时更多依赖逻辑验证，而不是高保真画面</li><li>物理层面：降低物理帧率（Fixed Timestep）、简化碰撞体，减少计算量</li><li>场景层面：在必要时用Headless模式，只输出必要的数据给算法训练</li></ul><h2 id="如果要接入更多无人系统，项目架构要怎么扩展"><a href="#如果要接入更多无人系统，项目架构要怎么扩展" class="headerlink" title="如果要接入更多无人系统，项目架构要怎么扩展"></a>如果要接入更多无人系统，项目架构要怎么扩展</h2><p>我们的架构是基于智能体抽象的思路设计的</p><ul><li>任何无人系统（艇、车、机、潜航器）本质上都可以抽象为<strong>状态输入 + 动作输出</strong>的智能体。核心是统一接口</li><li>接入新系统时，只需要扩展它的运动学模型和传感器模型，而环境和训练接口保持不变</li><li>这样就能做到多类型无人系统的接入，而不会破坏现有架构</li></ul>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/b4ace844.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
