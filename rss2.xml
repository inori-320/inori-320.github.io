<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>楪祈のBlog</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>星座になれたら。</description>
    <pubDate>Sat, 11 May 2024 10:02:26 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>RabbitMQ基础入门</title>
      <link>http://example.com/inori/1567c610.html</link>
      <guid>http://example.com/inori/1567c610.html</guid>
      <pubDate>Sat, 11 May 2024 06:47:26 GMT</pubDate>
      
      <description>rabbitMQ入门</description>
      
      
      
      <content:encoded><![CDATA[<p>在微服务中，必然会涉及到服务之间的调用，基于OpenFeign的调用需要调用者发起请求后等待服务提供者执行业务返回结果后，才能执行后续的操作，即调用者在调用过程中处于阻塞状态，这种调用方式为<strong>同步调用</strong>。但在很多场景下，我们可能需要采用<strong>异步调用</strong>的方式，将与业务关系不大的微服务与主干业务剥离开，以提升整体效率。目前常见的实现方案就是基于MQ实现。</p><h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p>MQ即消息队列(MessageQueue)，目前比较常见的MQ有：</p><ul><li><p>ActiveMQ</p></li><li><p>RabbitMQ</p></li><li><p>RocketMQ</p></li><li><p>Kafka</p></li></ul><table><thead><tr><th></th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><p>综合考虑，<a href="https://www.rabbitmq.com/">RabbitMQ</a>更加均衡，这里对RabbitMQ进行学习。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用docker命令进行安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -e RABBITMQ_DEFAULT_USER=inori -e RABBITMQ_DEFAULT_PASS=123456 -v mq-plugins:/plugins --name mq --hostname mq -p 15672:15672 -p 5672:5672 --network test-net -d rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问<u>服务器地址:15672</u>即可看到管理控制台。在控制台中，可以进行创建和查看交换机、队列中的已有信息，发送消息等步骤，不过开发业务时，一般不会在控制台收发消息，而是基于编程的方式。</p><h3 id="RabbitMQ架构"><a href="#RabbitMQ架构" class="headerlink" title="RabbitMQ架构"></a>RabbitMQ架构</h3><p><img src="D:\Blog\source\img\rabbitmq_frame.png" alt="rabbitmq_frame"></p><ul><li>**<code>publisher</code>**：生产者，发送消息的一方</li><li>**<code>consumer</code>**：消费者，获取消息的一方</li><li>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列，没有存储功能</li><li>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue，不同的虚拟主机内的交换机和队列可以重名</li></ul><h2 id="WorkQueues模型"><a href="#WorkQueues模型" class="headerlink" title="WorkQueues模型"></a>WorkQueues模型</h2><p>WorkQueues模型就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong></p><p>适用场景：当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用此模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>WorkQueue默认的处理方式是消息平均分配给每个消费者，并没有考虑到消费者的处理能力，即没有充分利用每一个消费者的能力，这样显然是有问题的。</p><h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><p>在spring中进行配置，可以解决这个问题。添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>添加这个配置后，处理速度较快的消费者就可以处理更多的数据。</p><h2 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h2><p>在之前的测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：</p><p><img src="D:\Blog\source\img\add_exchange.png" alt="add_exchange"></p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p>交换机只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失</p><p>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><h3 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h3><p>可以理解为广播交换机。即当该交换机收到消息后，会转发给所有绑定到该交换机上的队列</p><p>1）可以有多个队列</p><p>2）每个队列都要绑定到Exchange</p><p>3）生产者发送的消息，只能发送到交换机</p><p>4）交换机把消息发送给绑定过的所有队列</p><p>5）订阅队列的消费者都能拿到消息</p><h3 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h3><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="D:\Blog\source\img\direct_exchange.png" alt="direct_exchange"></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code></li><li>消息的发送方在向Exchange发送消息时，也必须指定消息的<code>RoutingKey</code></li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的<code>Routing key</code>相同才会接收到消息</li></ul><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);<span class="comment">// 需要在参数中指定RoutingKey</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h3><p><code>Topic</code>类型与<code>Direct</code>类似，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。</p><p>只不过<code>Topic</code>类型可以让队列在绑定<code>BindingKey</code> 的时候使用通配符</p><p><code>BindingKey</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如：item.insert</p><p>通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.cpu.insert</code> 或者 <code>item.cpu</code></li><li><code>item.*</code>：只能匹配<code>item.cpu</code></li></ul><h2 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span> <span class="comment"># 虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/test</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><h3 id="简单消息的发送和接收"><a href="#简单消息的发送和接收" class="headerlink" title="简单消息的发送和接收"></a>简单消息的发送和接收</h3><p>消息发送：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用RabbitListener来声明要监听的队列信息，一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringAMQP声明队列和交换机"><a href="#SpringAMQP声明队列和交换机" class="headerlink" title="SpringAMQP声明队列和交换机"></a>SpringAMQP声明队列和交换机</h3><h4 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h4><p>SpringAMQP提供了一个Queue类，用来创建队列,还提供了一个Exchange接口，来表示所有不同类型的交换机，我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：</p><p><img src="D:\Blog\source\img\AMQPApi1.png" alt="AMQPApi1"></p><p>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：</p><p><img src="D:\Blog\source\img\AMQPApi2.png" alt="AMQPApi2"></p><h4 id="基于Bean声明Fanout示例"><a href="#基于Bean声明Fanout示例" class="headerlink" title="基于Bean声明Fanout示例"></a>基于Bean声明Fanout示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;test.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于注解声明"><a href="#基于注解声明" class="headerlink" title="基于注解声明"></a>基于注解声明</h4><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>例如声明Direct模式的交换机和队列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;test.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;test.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>Spring的消息发送代码接收的消息体是一个Object，而在数据传输时，它会把发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。而JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><h4 id="配置JSON转换器"><a href="#配置JSON转换器" class="headerlink" title="配置JSON转换器"></a>配置JSON转换器</h4><p>如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。如果没有则需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置消息转换器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转换器中添加的messageId可以便于将来做幂等性判断</p><h4 id="消费者接收Object"><a href="#消费者接收Object" class="headerlink" title="消费者接收Object"></a>消费者接收Object</h4><p>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Map&lt;String, Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到object.queue消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MQ消息的可靠性"><a href="#MQ消息的可靠性" class="headerlink" title="MQ消息的可靠性"></a>MQ消息的可靠性</h1><p>在大多数异步调用业务场景下，必须确保MQ消息的可靠性，即：消息应该至少被消费者处理1次</p><ul><li>我们该如何确保MQ消息的可靠性？</li><li>如果真的发送失败，有没有其它方案？</li></ul><h2 id="可靠性分析"><a href="#可靠性分析" class="headerlink" title="可靠性分析"></a>可靠性分析</h2><p>消息从发送者发送消息，到消费者处理消息，需要经过发送者发送消息到交换机，交换机转发消息到队列，队列发送到消费者，消费者消费数据。</p><p>其中每一步都可能导致消息丢失：</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：</p><ul><li>确保生产者一定把消息发送到MQ</li><li>确保MQ不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><h2 id="生产者的可靠性"><a href="#生产者的可靠性" class="headerlink" title="生产者的可靠性"></a>生产者的可靠性</h2><h3 id="生产者重试机制"><a href="#生产者重试机制" class="headerlink" title="生产者重试机制"></a>生产者重试机制</h3><p>SpringAMQP提供的消息发送时的重试机制。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。</p><p>修改<code>publisher</code>模块的<code>application.yaml</code>文件，添加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。</p><p>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h3 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h3><p>一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况。</p><p>不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：</p><ul><li>MQ内部处理消息的进程发生了异常</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code>，因此无法路由</li></ul><p>针对上述情况，RabbitMQ提供了生产者消息确认机制，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的<strong>回执</strong>。</p><p><img src="D:\Blog\source\img\mq_publisher_return.png" alt="mq_publisher_return"></p><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回Ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>其中<code>ack</code>和<code>nack</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于<strong>Publisher Return</strong>机制。</p><p>默认两种机制都是关闭状态，需要通过配置文件来开启。</p><h4 id="实现生产者确认"><a href="#实现生产者确认" class="headerlink" title="实现生产者确认"></a>实现生产者确认</h4><p>在publisher模块的<code>application.yaml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><p>一般我们推荐使用<code>correlated</code>，回调机制。</p><h4 id="定义ReturnCallback"><a href="#定义ReturnCallback" class="headerlink" title="定义ReturnCallback"></a>定义ReturnCallback</h4><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在publisher模块定义一个配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h4><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数：CorrelationData</p><p>这里的CorrelationData中包含两个核心的东西：</p><ul><li><code>id</code>：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的Future对象</li></ul><p>将来MQ的回执就会通过这个<code>Future</code>来返回，可以提前给<code>CorrelationData</code>中的<code>Future</code>添加回调函数来处理消息回执</p><p>新建一个测试，向系统自带的交换机发送消息，并且添加<code>ConfirmCallback</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">&quot;send message fail&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123; <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>开启生产者确认比较消耗MQ性能，一般不建议开启。而且大家思考一下触发确认的几种情况：</p><ul><li>路由失败：一般是因为RoutingKey错误导致，往往是编程导致</li><li>交换机名称错误：同样是编程错误导致</li><li>MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了。</li></ul><h2 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h2><p>消息到达MQ以后，如果MQ不能及时保存，也会导致消息丢失，所以MQ的可靠性也非常重要。</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化：在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数：设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</li><li>队列持久化：在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数</li><li>消息持久化：在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code></li></ul><p><strong>说明</strong>：在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。</p><p>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。</p><h3 id="LazyQueue"><a href="#LazyQueue" class="headerlink" title="LazyQueue"></a>LazyQueue</h3><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为称为<code>PageOut</code>。</p><p><code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从RabbitMQ的3.6版本开始，就增加了LazyQueues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。</p><h4 id="代码配置Lazy模式"><a href="#代码配置Lazy模式" class="headerlink" title="代码配置Lazy模式"></a>代码配置Lazy模式</h4><p>在利用SpringAMQP声明队列的时候，添加<code>x-queue-mod=lazy</code>参数可以设置队列为Lazy模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以基于注解来声明队列并设置为Lazy模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新已有队列为lazy模式"><a href="#更新已有队列为lazy模式" class="headerlink" title="更新已有队列为lazy模式"></a>更新已有队列为lazy模式</h4><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。</p><p>可以基于命令行设置policy：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues  </span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置：</p><p><img src="D:\Blog\source\img\lazyqueue_set_in_window.png" alt="lazyqueue_set_in_window"></p><h2 id="消费者的可靠性"><a href="#消费者的可靠性" class="headerlink" title="消费者的可靠性"></a>消费者的可靠性</h2><p>当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li></ul><p>一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。</p><h3 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h3><p>为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）即：当消费者处理消息结束后，向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>一般reject方式用的较少，除非是消息格式有问题。因此大多数情况下我们需要将消息处理的代码通过<code>try catch</code>机制捕获，消息处理成功时返回ack，处理失败时返回nack.</p><p>由于消息回执的处理代码比较统一，SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li>**<code>none</code>**：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。不建议使用</li><li>**<code>manual</code>**：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵（在当前业务中插入与当前业务无关的其他逻辑），但更灵活</li><li>**<code>auto</code>**：自动模式。SpringAMQP利用AOP对消息处理逻辑做了环绕增强，当业务正常执行时则自动返回<code>ack</code>.当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是<strong>业务异常</strong>，会自动返回<code>nack</code></li><li>如果是<strong>消息处理或校验异常</strong>，自动返回<code>reject</code></li></ul></li></ul><p>通过下面的配置可以修改SpringAMQP的ACK处理方式：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动模式</span></span><br></pre></td></tr></table></figure><h3 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h3><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。</p><p>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力，为了应对该情况，Spring提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列</p><p>修改consumer服务的application.yml文件，添加内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态，false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><ul><li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是<code>reject</code></li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃</li></ul><h3 id="失败处理策略"><a href="#失败处理策略" class="headerlink" title="失败处理策略"></a>失败处理策略</h3><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适</p><p>因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。默认就是这种方式 </li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较推荐的是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续集中处理</p><p>1）定义处理失败消息的交换机和队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）定义RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h3><p><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。</p><p>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。</p><p>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><h4 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h4><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。</p><p>以Jackson的消息转换器为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h4><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样，大体思路为在获取到MQ的消息后，先判断当前数据库中的数据的某些状态是否与要修改之前的数据的状态保持一致，若一致则修改。</p><p>相比较而言，消息ID的方案需要改造原有的数据库，所以更推荐使用业务判断的方案。</p><h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><p>在某些业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p><p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易</p><p>通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。</p><p>像这种在一段时间以后才执行的任务称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案是利用MQ的延迟消息。</p><p>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><h3 id="死信交换机和延迟消息"><a href="#死信交换机和延迟消息" class="headerlink" title="死信交换机和延迟消息"></a>死信交换机和延迟消息</h3><h4 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h4><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或<code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过**<code>dead-letter-exchange</code><strong>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为</strong>死信交换机**（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试的<code>RepublishMessageRecoverer</code>作用类似。</p><p>而最后一种场景，可以作为延迟消息的实现方式</p><h3 id="延迟消息-1"><a href="#延迟消息-1" class="headerlink" title="延迟消息"></a>延迟消息</h3><p>假设有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是<code>ttl.queue</code>没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>，而队列<code>direct.queue1</code>则与死信交换机绑定，RoutingKey是blue</p><p><img src="D:\Blog\source\img\mq_delayMessage.png" alt="mq_delayMessage"></p><ol><li>假如我们现在发送一条消息到<code>ttl.fanout</code>，RoutingKey为blue，并设置消息的有效期。尽管这里的<code>ttl.fanout</code>不需要RoutingKey，但是当消息变为死信并投递到死信交换机时，会沿用之前的RoutingKey，这样<code>hmall.direct</code>才能正确路由消息，消息肯定会被投递到<code>ttl.queue</code>之后，由于没有消费者，消息无人消费</li><li>5秒之后，消息的有效期到期，成为死信</li><li>死信被再次投递到死信交换机<code>hmall.direct</code>，并沿用之前的RoutingKey，也就是<code>blue</code></li><li>由于<code>direct.queue1</code>与<code>hmall.direct</code>绑定的key是blue，因此最终消息被成功路由到<code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code>绑定， 也就能成功消费消息了。但此时已经是5秒钟以后了</li></ol><p>也就是说，publisher发送了一条消息，但最终consumer在5秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><p><strong>注意：</strong></p><p>RabbitMQ的消息过期是基于追溯方式来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。</p><p>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此设置的TTL时间不一定准确。</p><h3 id="DelayExchange插件"><a href="#DelayExchange插件" class="headerlink" title="DelayExchange插件"></a>DelayExchange插件</h3><p>基于死信队列虽然可以实现延迟消息，但是太麻烦。因此RabbitMQ社区提供了一个<a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">延迟消息插件</a>来实现相同的效果。</p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">插件下载</a>后，因为mq是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p>插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，我们上传插件到该目录下。</p><p>接下来执行命令，安装插件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><h4 id="声明延迟交换机"><a href="#声明延迟交换机" class="headerlink" title="声明延迟交换机"></a>声明延迟交换机</h4><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于<code>@Bean</code>的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送延迟消息"><a href="#发送延迟消息" class="headerlink" title="发送延迟消息"></a>发送延迟消息</h4><p>必须通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。</p><p>因此不建议设置延迟时间过长的延迟消息</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/rabbitMQ/">rabbitMQ</category>
      
      
      <category domain="http://example.com/tags/rabbitMQ/">rabbitMQ</category>
      
      
      <comments>http://example.com/inori/1567c610.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java基础入门（五）</title>
      <link>http://example.com/inori/4a863c41.html</link>
      <guid>http://example.com/inori/4a863c41.html</guid>
      <pubDate>Sun, 28 Apr 2024 06:59:04 GMT</pubDate>
      
      <description>java基础入门</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Java新特性介绍（9-17）"><a href="#Java新特性介绍（9-17）" class="headerlink" title="Java新特性介绍（9~17）"></a>Java新特性介绍（9~17）</h1><h2 id="Java-9新特性"><a href="#Java-9新特性" class="headerlink" title="Java 9新特性"></a>Java 9新特性</h2><p>Java9的主要特性有JShell、接口的private方法等。</p><h3 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h3><p>Java 9为提供一种交互式编程工具JShell，类似于Python的Shell，安装java并完成环境配置后，只需要输入<code>jshell</code>命令即可开启交互式编程</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Users\71947&gt;jshell</span><br><span class="line">|  欢迎使用 JShell -- 版本 17.0.9</span><br><span class="line">|  要大致了解该版本, 请键入: /help intro</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int a = 10</span></span><br><span class="line">a ==&gt; 10</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int b = 15</span></span><br><span class="line">b ==&gt; 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int c = a + b</span></span><br><span class="line">c ==&gt; 25</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">public int max(int a, int b)&#123;</span></span><br><span class="line">   ...&gt;     return a &gt;= b ? a : b;</span><br><span class="line">   ...&gt; &#125;</span><br><span class="line">|  已创建 方法 max(int,int)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">int d = max(a, b)</span></span><br><span class="line">d ==&gt; 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">/vars</span></span><br><span class="line">|    int a = 10</span><br><span class="line">|    int b = 15</span><br><span class="line">|    int c = 25</span><br><span class="line">|    int d = 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">jshell&gt; </span><span class="language-bash">/exit</span></span><br><span class="line">|  再见</span><br></pre></td></tr></table></figure><p>更多口令可以通过输入<code>/help</code>了解</p><h3 id="在接口内定义private方法"><a href="#在接口内定义private方法" class="headerlink" title="在接口内定义private方法"></a>在接口内定义private方法</h3><p>在Jdk8中，接口中方法支持添加<code>default</code>关键字来默认实现方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java9中，接口中可以存在私有方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        System.out.println(<span class="string">&quot;默认实现&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.inner();   <span class="comment">//接口中方法的默认实现可以直接调用接口中的私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inner</span><span class="params">()</span>&#123;   <span class="comment">//声明一个私有方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;私有方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有方法和默认方法一样，要提供方法体，并且此方法只能被接口中的其他私有方法或是默认实现调用</p><h3 id="集合类新增工厂方法"><a href="#集合类新增工厂方法" class="headerlink" title="集合类新增工厂方法"></a>集合类新增工厂方法</h3><p>如果我们想要快速创建一个Map：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;AAA&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    map.put(<span class="string">&quot;BBB&quot;</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java 9之后，可以通过<code>of</code>方法快速创建：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; map = Map.of(<span class="string">&quot;AAA&quot;</span>, <span class="number">1</span>, <span class="string">&quot;BBB&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>通过这种方式创建的Map和通过Arrays创建的List类似，无法进行修改。</u></p><p>除了Map之外，其他的集合类都有相应的<code>of</code>方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = Set.of(<span class="string">&quot;A&quot;</span>， <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    List&lt;String&gt; list = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改进的Stream"><a href="#改进的Stream" class="headerlink" title="改进的Stream"></a>改进的Stream</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)   <span class="comment">//将一些元素封装到Stream中</span></span><br><span class="line">        .filter(s -&gt; s.equals(<span class="string">&quot;B&quot;</span>))   <span class="comment">//通过过滤器过滤</span></span><br><span class="line">        .distinct()   <span class="comment">//去重</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stream在Java9得到了进一步的增强：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.of(<span class="literal">null</span>)   <span class="comment">//如果传入null会报错</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Stream.ofNullable(<span class="literal">null</span>) <span class="comment">//使用新增的ofNullable方法，不会报错</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过迭代快速生成一组数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, i -&gt; i &lt; <span class="number">20</span>, i -&gt; i + <span class="number">1</span>)  <span class="comment">//快速生成一组0~19的int数据，中间可以添加一个断言，表示什么时候结束生成</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stream还新增了对数据的截断操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .takeWhile(i -&gt; i &lt; <span class="number">10</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dropWhile和takeWhile相反，满足条件的才会通过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, i -&gt; i + <span class="number">1</span>)</span><br><span class="line">        .limit(<span class="number">20</span>)</span><br><span class="line">        .dropWhile(i -&gt; i &lt; <span class="number">10</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-10新特性"><a href="#Java-10新特性" class="headerlink" title="Java 10新特性"></a>Java 10新特性</h2><p>Java 10的改变不是很多，比较突出的是局部变量类型推断</p><h3 id="局部变量类型推断var"><a href="#局部变量类型推断var" class="headerlink" title="局部变量类型推断var"></a>局部变量类型推断var</h3><p>在Java10中，可以使用自动类型推断：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// String a = &quot;Hello World!&quot;;   //之前定义变量必须指定类型</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;   <span class="comment">//现在使用var关键字来自动进行类型推断，因为完全可以从后面的值来判断是什么类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>var</code>关键字必须位于有初始值设定的变量上,且仅适用于局部变量，没办法在其他地方使用</p><h2 id="Java-11新特性"><a href="#Java-11新特性" class="headerlink" title="Java 11新特性"></a>Java 11新特性</h2><p>Java 11中比较关键的是用于Lambda的形参局部变量语法。</p><h3 id="用于Lambda的形参局部变量语法"><a href="#用于Lambda的形参局部变量语法" class="headerlink" title="用于Lambda的形参局部变量语法"></a>用于Lambda的形参局部变量语法</h3><p>在Java 11中支持了在Lambda中使用<code>var</code>关键字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; consumer = (<span class="keyword">var</span> str) -&gt; &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="针对于String类的方法增强"><a href="#针对于String类的方法增强" class="headerlink" title="针对于String类的方法增强"></a>针对于String类的方法增强</h3><p>在Java 11为String新增一些更加方便的操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;A\nB\nD&quot;</span>;</span><br><span class="line">    System.out.println(str.isBlank());    <span class="comment">//isBlank方法用于判断是否字符串为空或者是仅包含空格</span></span><br><span class="line">    str.lines()   <span class="comment">//根据字符串中的\n换行符进行切割，分为多个字符串，并转换为Stream进行操作</span></span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以快速地进行空格去除操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot; A B C D &quot;</span>;</span><br><span class="line">    System.out.println(str.strip());   <span class="comment">//去除首尾空格</span></span><br><span class="line">    System.out.println(str.stripLeading());  <span class="comment">//去除首部空格</span></span><br><span class="line">    System.out.println(str.stripTrailing());   <span class="comment">//去除尾部空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-12-16-新特性"><a href="#Java-12-16-新特性" class="headerlink" title="Java 12~16 新特性"></a>Java 12~16 新特性</h2><p>Java12-16并非长期支持版本，很多特性都是实验性的功能。</p><h3 id="改进的switch语法"><a href="#改进的switch语法" class="headerlink" title="改进的switch语法"></a>改进的switch语法</h3><p>Java 12中引入改进的switch语法，之前的switch写法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">grade</span><span class="params">(<span class="type">int</span> score)</span>&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">switch</span> (score) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            res =  <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            res = <span class="string">&quot;良好&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            res = <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            res = <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用新特性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">grade</span><span class="params">(<span class="type">int</span> score)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">switch</span> (score) &#123;   <span class="comment">//增强版switch语法</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>, <span class="number">9</span> -&gt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>, <span class="number">7</span> -&gt; <span class="string">&quot;良好&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span> -&gt; <span class="string">&quot;及格&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种全新的switch语法称为<code>switch表达式</code>，具体语法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> ...</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="string">&quot;不及格&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>case后添加匹配值，匹配值可以存在多个，需要使用逗号隔开，使用 -&gt; 来返回如果匹配此case语句的结果</li><li>根据不同的分支，可以存在多个case</li></ul><p>那么如果我们并不是能够马上返回，而是需要做点什么其他的工作才能返回结果呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">var</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">case</span> [匹配值, ...] -&gt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; &#123;   <span class="comment">//使用花括号来将整套逻辑括起来</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">yield</span>  <span class="string">&quot;不及格&quot;</span>;  <span class="comment">//注意处理完成后使用yield关键字返回最终结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="文本块"><a href="#文本块" class="headerlink" title="文本块"></a>文本块</h3><p>Java 13引入文本块，通过三引号将字符串括起来，在其中不需要使用转义字符</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                weriodfghhj</span></span><br><span class="line"><span class="string">                fgghjkkkkwjdjwid</span></span><br><span class="line"><span class="string">                &lt;h1&gt;</span></span><br><span class="line"><span class="string">                &lt;div class=&quot;a&quot; id=&quot;b&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">             &quot;&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新instanceof语法"><a href="#新instanceof语法" class="headerlink" title="新instanceof语法"></a>新instanceof语法</h3><p>我们之前要重写一个类的equals方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">            <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) obj;</span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前一直都是采用这种先判断类型，然后类型转换，最后才能使用的方式，但instanceof加强之后，可以直接将student替换为模式变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Student student) &#123;</span><br><span class="line">            <span class="keyword">return</span> student.name.equals(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-17新特性"><a href="#Java-17新特性" class="headerlink" title="Java 17新特性"></a>Java 17新特性</h2><h3 id="密封类型"><a href="#密封类型" class="headerlink" title="密封类型"></a>密封类型</h3><p>在Java中，可以通过继承（extends关键字）来实现类的能力复用、扩展与增强。但有的时候，可能并不是所有的类我们都希望能够被继承。所以，我们需要对继承关系有一些限制的控制手段，而密封类的作用就是<strong>限制类的继承</strong>。</p><p>实际上在之前我们如果不希望别人继承我们的类，可以直接添加<code>final</code>关键字：<code>public final class A&#123;&#125;</code></p><p>这样有一个缺点，如果添加了<code>final</code>关键字，那么无论是谁，包括我们自己也是没办法实现继承的，但是现在我们有一个需求，只允许我们自己写的类继承A，但是不允许别人写的类继承A，就可以使用密封类型来实现这个功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">permits</span> B&#123;&#125;   <span class="comment">//在class关键字前添加sealed关键字，表示此类为密封类型，permits后面跟上允许继承的类型，多个子类使用逗号隔开</span></span><br></pre></td></tr></table></figure><p>密封类型有以下要求：</p><ul><li>可以基于普通类、抽象类、接口，也可以是继承自其他接抽象类的子类或是实现其他接口的类等。</li><li>必须有子类继承，且不能是匿名内部类或是lambda的形式。</li><li><code>sealed</code>写在原来<code>final</code>的位置，但是不能和<code>final</code>、<code>non-sealed</code>关键字同时出现，只能选择其一。</li><li>继承的子类必须显式标记为<code>final</code>、<code>sealed</code>或是<code>non-sealed</code>类型。</li></ul><p>标准的声明格式为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> [<span class="keyword">abstract</span>] [class/interface] 类名 [extends 父类] [implements 接口, ...] <span class="keyword">permits</span> [子类, ...]&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类格式为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> [<span class="keyword">final</span>/<span class="keyword">sealed</span>/<span class="keyword">non-sealed</span>] class 子类 extends 父类 &#123;   <span class="comment">//必须继承自父类</span></span><br><span class="line"><span class="comment">//final类型：任何类不能再继承当前类</span></span><br><span class="line">  <span class="comment">//sealed类型：同父类，需要指定由哪些类继承</span></span><br><span class="line">  <span class="comment">//non-sealed类型：解封，重新开放为普通类，任何类都可以继承</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过反射来获取类是否为密封类型：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Class&lt;A&gt; a = A.class;</span><br><span class="line">    System.out.println(a.isSealed());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/4a863c41.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java基础入门（四）</title>
      <link>http://example.com/inori/2518f906.html</link>
      <guid>http://example.com/inori/2518f906.html</guid>
      <pubDate>Fri, 26 Apr 2024 03:52:53 GMT</pubDate>
      
      <description>java基础入门</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h2><p>Java8中经常使用的有Lambda表达式、Stream流、日期与时间API</p><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><ol><li>无参数和返回值的Lambda</li></ol><p>需要启动一个线程去完成某些任务时，通常会通过Runnable接口来定义任务内容，使用Thread类启动线程。</p><p>传统写法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() (</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(<span class="string">&quot;新线程任务执行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lambda是一个<strong>匿名函数</strong>，可以理解为一段可以传递的代码。使用Java8的写法，上述写法可以重写为:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(<span class="string">&quot;新线程任务执行&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lambda表达式可以简化匿名内部类的使用，使语法更加简洁。</p><ol start="2"><li>有参数和返回值的Lambda</li></ol><p>当需要对一个对象集合进行排序时，传统写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Person&gt; persons;<span class="comment">// 假设里面已经有很多数据</span></span><br><span class="line">        Collections.sort(persons, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getAge() - o2.getAge();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Lambda后的写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Person&gt; persons;<span class="comment">// 假设里面已经有很多数据</span></span><br><span class="line">        Collections.sort(persons, (o1, o2) -&gt; &#123;o1.getAge() - o2.getAge()&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda标准格式"><a href="#Lambda标准格式" class="headerlink" title="Lambda标准格式"></a>Lambda标准格式</h4><p>Lambda由3部分组成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(参数类型 参数名称) -&gt; &#123;</span><br><span class="line">代码体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda省略格式"><a href="#Lambda省略格式" class="headerlink" title="Lambda省略格式"></a>Lambda省略格式</h4><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li><p>小括号内参数的类型可以省略</p></li><li><p>如果小括号内<strong>有且仅有一个参数</strong>，则小括号可以省略</p></li><li><p>如果大括号内<strong>有且仅有一个语句</strong>，可以同时省略大括号、return关键字及语句分号</p></li></ol><h4 id="使用Lambda的前提"><a href="#使用Lambda的前提" class="headerlink" title="使用Lambda的前提"></a>使用Lambda的前提</h4><p>Lambda表达式不是随便使用的，使用时有几个条件要特别注意：</p><ol><li><p>方法的参数或局部变量类型必须为接口才能使用Lambda</p></li><li><p>接口中有且仅有一个抽象方法</p></li></ol><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口在Java中是指：<strong>有且仅有一个抽象方法的接口</strong>。</p><p>函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导。</p><h5 id="FunctionalInterface注解"><a href="#FunctionalInterface注解" class="headerlink" title="FunctionalInterface注解"></a>FunctionalInterface注解</h5><p>与<code>@Override</code>注解的作用类似，Java8中专门为函数式接口引入了一个新的注解：<code>@FunctionalInterface</code>。该注解可用于一个接口的定义上：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Operator</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。不过，即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口，使用起来都一样。</p><h5 id="常用的函数式接口"><a href="#常用的函数式接口" class="headerlink" title="常用的函数式接口"></a>常用的函数式接口</h5><p>Lambda表达式的前提是需要有函数式接口。而Lambda使用时不关心接口名，抽象方法名，只关心抽象方法的参数列表和返回值类型。因此为了让我们使用Lambda方便，JDK提供了大量常用的函数式接口。</p><ol><li>Supplier接口</li></ol><p>java.util.function.Supplier<T>接口，它意味着”供给”,对应的Lambda表达式需要“<strong>对外提供</strong>”一个符合泛型类型的对象数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Consumer接口</li></ol><p><strong>消费</strong>一个数据，其数据类型由泛型参数决定。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>Function接口</li></ol><p>java.util.function.Function&lt;T,R&gt;接口用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件。有参数有返回值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> R <span class="title function_">apply</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>Predicate接口</li></ol><p>java.util.function.Predicate<T> 接口用于做判断,返回boolean类型的值，有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>如果在Lambda中所指定的功能，已经有其他方法存在相同方案，则没有必要再写重复逻辑，可以直接“引用”过去</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n: arr) &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        printMax(Test::getMax);<span class="comment">// 方法引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMax</span><span class="params">(Consumer&lt;<span class="type">int</span>[]&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        consumer.accept(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法引用的格式"><a href="#方法引用的格式" class="headerlink" title="方法引用的格式"></a>方法引用的格式</h5><p><strong>符号表示</strong>：<code>::</code></p><p><strong>符号说明</strong>: 双冒号为方法引用运算符，而它所在的表达式被称为<strong>方法引用</strong></p><p><strong>应用场景</strong>: 如果Lambda所要实现的方案, 已经有其他方法存在相同方案，那么则可以使用方法引用</p><h5 id="常用引用方式"><a href="#常用引用方式" class="headerlink" title="常用引用方式"></a>常用引用方式</h5><p>方法引用在JDK8中使用方式相当灵活，有以下几种形式：</p><ol><li><p><code>instanceName::methodName</code> 对象::方法名</p></li><li><p><code>ClassName::staticMethodName</code> 类名::静态方法</p></li><li><p><code>ClassName::methodName</code> 类名::普通方法</p></li><li><p><code>ClassName::new</code> 类名::new 调用的构造器</p></li><li><p><code>TypeName[]::new String[]::new</code> 调用数组的构造器</p></li></ol><h5 id="常用格式解析"><a href="#常用格式解析" class="headerlink" title="常用格式解析"></a>常用格式解析</h5><ol><li>对象::方法名</li></ol><p>这是最常见的一种用法，与上例相同。如果一个类中已经存在了一个成员方法，则可以通过对象名引用成员方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    Supplier&lt;Long&gt; supp = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> now.getTime();</span><br><span class="line">&#125;;</span><br><span class="line">    System.out.println(supp.get());</span><br><span class="line">    </span><br><span class="line">    Supplier&lt;Long&gt; supp2 = now::getTime;</span><br><span class="line">    System.out.println(supp2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法引用的注意事项</p><ul><li><p>被引用的方法，参数要和接口中抽象方法的参数一样</p></li><li><p>当接口抽象方法有返回值时，被引用的方法也必须有返回值</p></li></ul><ol start="2"><li>类名::静态方法</li></ol><p>由于在<code>java.lang.System</code>类中已经存在了静态方法<code>currentTimeMillis</code>，要通过Lambda来调用该方法时,可以使用方法引用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Supplier&lt;Long&gt; supp = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">&#125;;</span><br><span class="line">    System.out.println(supp.get());</span><br><span class="line">    </span><br><span class="line">    Supplier&lt;Long&gt; supp2 = System::currentTimeMillis;</span><br><span class="line">    System.out.println(supp2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>类名::普通方法</li></ol><p>由于构造器的名称与类名完全一样。所以构造器引用使用类名称::new的格式表示。</p><p>首先是一个Person类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, Integer age)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用这个函数式接口，可以通过方法引用传递：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Supplier&lt;Person&gt; sup = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line">    </span><br><span class="line">    Supplier&lt;Person&gt; sup2 = Person::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">    </span><br><span class="line">    BiFunction&lt;String, Integer, Person&gt; fun2 = Person::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(fun2.apply(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>类名::new调用的构造器</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Function&lt;Integer, String[]&gt; fun = (len) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[len];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    String[] arr1 = fun.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(arr1 + <span class="string">&quot;, &quot;</span> + arr1.length);</span><br><span class="line">    </span><br><span class="line">    Function&lt;Integer, String[]&gt; fun2 = String[]::<span class="keyword">new</span>;</span><br><span class="line">    String[] arr2 = fun.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(arr2 + <span class="string">&quot;, &quot;</span> + arr2.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p>Stream流式思想类似于工厂车间的“<strong>生产流水线</strong>”，Stream流不是一种数据结构，不保存数据，而是对数据进行加工处理。Stream可以看作是流水线上的一个工序。在流水线上，通过多个工序让一个原材料加工成一个商品。</p><p>Stream API能让我们快速完成许多复杂的操作，如筛选、切片、映射、查找、去除重复，统计，匹配和归约。</p><h3 id="获取Stream流"><a href="#获取Stream流" class="headerlink" title="获取Stream流"></a>获取Stream流</h3><h4 id="根据Collection获取流"><a href="#根据Collection获取流" class="headerlink" title="根据Collection获取流"></a>根据Collection获取流</h4><p><code>java.util.Collection</code>接口中加入了default stream方法用来获取流，所以其所有实现类均可获取流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span> &#123;</span><br><span class="line">    <span class="keyword">default</span> Stream&lt;E&gt; <span class="title function_">stream</span><span class="params">()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 集合获取流</span></span><br><span class="line">        <span class="comment">// Collection接口中的方法: default Stream&lt;E&gt; stream() 获取流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream2 = set.stream();</span><br><span class="line">        Vector&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; stream3 = vector.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map不是 Collection的子接口，所以获取对应的流需要分key、value或entry等情况：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Map获取流</span></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">        Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream中的静态方法of获取流"><a href="#Stream中的静态方法of获取流" class="headerlink" title="Stream中的静态方法of获取流"></a>Stream中的静态方法of获取流</h4><p>由于数组对象不可能添加默认方法，所以 Stream 接口中提供了静态方法 of ，使用很简单：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Stream中的静态方法: static Stream of(T... values)</span></span><br><span class="line">        Stream&lt;String&gt; stream6 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream7 = Stream.of(arr);</span><br><span class="line">        Integer[] arr2 = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream8 = Stream.of(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream常用方法"><a href="#Stream常用方法" class="headerlink" title="Stream常用方法"></a>Stream常用方法</h3><ul><li><p><strong>终结方法</strong>：返回值类型不再是 Stream 类型的方法，不再支持链式调用。</p></li><li><p><strong>非终结方法</strong>：返回值类型仍然是 Stream 类型的方法，支持链式调用。</p></li></ul><table><thead><tr><th><strong>方法名</strong></th><th><strong>方法作用</strong></th><th><strong>返回值类型</strong></th><th><strong>方法种类</strong></th></tr></thead><tbody><tr><td>count</td><td>统计个数</td><td>long</td><td>终结</td></tr><tr><td>forEach</td><td>逐一处理</td><td>void</td><td>终结</td></tr><tr><td>filter</td><td>过滤</td><td>Stream</td><td>函数拼接</td></tr><tr><td>limit</td><td>取用前几个</td><td>Stream</td><td>函数拼接</td></tr><tr><td>skip</td><td>跳过前几个</td><td>Stream</td><td>函数拼接</td></tr><tr><td>map</td><td>映射</td><td>Stream</td><td>函数拼接</td></tr><tr><td>concat</td><td>组合</td><td>Stream</td><td>函数拼接</td></tr></tbody></table><p>注意：</p><ol><li><p>Stream只能操作一次</p></li><li><p>Stream方法返回的是新的流</p></li><li><p>Stream不调用终结方法，中间的操作不会执行</p></li></ol><h4 id="count方法"><a href="#count方法" class="headerlink" title="count方法"></a>count方法</h4><p>count方法可以统计其中的元素个数，该方法返回一个long值代表元素个数。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCount</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    System.out.println(one.stream().count());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forEach方法"><a href="#forEach方法" class="headerlink" title="forEach方法"></a>forEach方法</h4><p>forEach用来遍历流中的数据，该方法接收一个Consumer接口函数，会将每一个流元素交给该函数进行处理</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testForEach</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Filter方法"><a href="#Filter方法" class="headerlink" title="Filter方法"></a>Filter方法</h4><p>filter用于过滤数据，返回符合过滤条件的数据，可以将一个流转换成另一个子集流。需要接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFilter</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().filter(s -&gt; s.length() == <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="limit方法"><a href="#limit方法" class="headerlink" title="limit方法"></a>limit方法</h4><p>limit方法可以对流进行截取，只取用前n个。参数是一个long型，如果集合当前长度大于参数则进行截取。否则不进行操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLimit</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="skip方法"><a href="#skip方法" class="headerlink" title="skip方法"></a>skip方法</h4><p>如果希望跳过前几个元素，可以使用skip方法获取一个截取之后的新流。如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSkip</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; one = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Collections.addAll(one, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>);</span><br><span class="line">    one.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h4><p>map方法可以将流中的元素映射到另一个流中，该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMap</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; original = Stream.of(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;33&quot;</span>);</span><br><span class="line">    Stream&lt;Integer&gt; result = original.map(Integer::parseInt);</span><br><span class="line">    result.forEach(s -&gt; System.out.println(s + <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="distinct方法"><a href="#distinct方法" class="headerlink" title="distinct方法"></a>distinct方法</h4><p>distinct方法可以去除重复数据。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDistinct</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream.of(<span class="number">22</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">33</span>)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h4><p>如果需要判断数据是否匹配指定的条件，可以使用 Match 相关方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Stream.of(<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// .allMatch(e -&gt; e &gt; 0); // allMatch: 元素是否全部满足条件</span></span><br><span class="line">    <span class="comment">// .anyMatch(e -&gt; e &gt; 5); // anyMatch: 元素是否任意有一个满足条件</span></span><br><span class="line">    .noneMatch(e -&gt; e &lt; <span class="number">0</span>); <span class="comment">// noneMatch: 元素是否全部不满足条件</span></span><br><span class="line">    System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="concat方法"><a href="#concat方法" class="headerlink" title="concat方法"></a>concat方法</h4><p>有两个流需要合并成为一个流，可以使用 Stream 接口的静态方法 concat</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testContact</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; streamA = Stream.of(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; streamB = Stream.of(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    Stream&lt;String&gt; result = Stream.concat(streamA, streamB);</span><br><span class="line">    result.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream流中的结果到集合中"><a href="#Stream流中的结果到集合中" class="headerlink" title="Stream流中的结果到集合中"></a>Stream流中的结果到集合中</h4><p>Stream流提供collect方法，其参数需要一个java.util.stream.Collector&lt;T, A, R&gt;接口对象来指定收集到哪种集合中。java.util.stream.Collectors类提供一些方法，可以作为Collector接口的实例：</p><p><code>public static &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</code>：转换为 List 集合。</p><p><code>public static &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</code>：转换为 Set 集合</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStreamToCollection</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    <span class="comment">// List&lt;String&gt; list = stream.collect(Collectors.toList());</span></span><br><span class="line">    <span class="comment">// Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span></span><br><span class="line">    ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">    HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stream流中的结果到数组中"><a href="#Stream流中的结果到数组中" class="headerlink" title="Stream流中的结果到数组中"></a>Stream流中的结果到数组中</h4><p>Stream提供toArray方法来将结果放到一个数组中，返回值类型为Object[]</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStreamToArray</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    String[] strings = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : strings) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对流中数据进行拼接"><a href="#对流中数据进行拼接" class="headerlink" title="对流中数据进行拼接"></a>对流中数据进行拼接</h4><p>Collectors.joining会根据指定的连接符，将所有元素连接成一个字符串。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJoining</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream&lt;Student&gt; studentStream = Stream.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a&quot;</span>, <span class="number">52</span>, <span class="number">95</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;b&quot;</span>, <span class="number">56</span>, <span class="number">88</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;c&quot;</span>, <span class="number">56</span>, <span class="number">99</span>),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d&quot;</span>, <span class="number">52</span>, <span class="number">77</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> studentStream</span><br><span class="line">        .map(Student::getName)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">&quot;&gt;_&lt;&quot;</span>, <span class="string">&quot;^_^&quot;</span>, <span class="string">&quot;^v^&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行的Stream流"><a href="#并行的Stream流" class="headerlink" title="并行的Stream流"></a>并行的Stream流</h3><p>parallelStream是一个并行执行的流。它通过默认的ForkJoinPool，可能提高多线程任务的速度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testgetParallelStream</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 直接获取并行的流</span></span><br><span class="line">    Stream&lt;Integer&gt; stream1 = list.parallelStream();</span><br><span class="line">    <span class="comment">// 将串行流转成并行流</span></span><br><span class="line">    Stream&lt;Integer&gt; stream2 = list.stream().parallel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并行操作代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test0Parallel</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line">        .parallel() <span class="comment">// 将流转成并发流,Stream处理的时候将才去</span></span><br><span class="line">        .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;, s = &quot;</span> + s);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">    .count();</span><br><span class="line">    System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h2><p>Optional是一个没有子类的工具类，是一个可以为null的容器对象。它的作用主要就是为了解决避免Null检查，防止NullPointerException。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>创建方式：</p><p><code>Optional.of(T t)</code>: 创建一个Optional实例</p><p><code>Optional.empty()</code>: 创建一个空的Optional实例</p><p><code>Optional.ofNullable(T t)</code>:若t不为null,创建Optional实例,否则创建空实例</p><p>常用方法：</p><p><code>isPresent()</code>: 判断是否包含值,包含值返回true，不包含值返回false</p><p><code>get()</code>: 如果Optional有值则将其返回，否则抛出NoSuchElementException</p><p><code>orElse(T t)</code>: 如果调用对象包含值，返回该值，否则返回参数t</p><p><code>orElseGet(Supplier s)</code>:如果调用对象包含值，返回该值，否则返回s获取的值</p><p><code>map(Function f)</code>: 如果有值对其处理，并返回处理后的Optional，否则返回Optional.empty()</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    Optional&lt;String&gt; userName = Optional.empty();</span><br><span class="line">    <span class="keyword">if</span> (userNameO.isPresent()) &#123;</span><br><span class="line">        <span class="comment">// get() : 如果Optional有值则将其返回，否则抛出NoSuchElementException。</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> userName.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名为:&quot;</span> + name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;用户名不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日期和时间API"><a href="#日期和时间API" class="headerlink" title="日期和时间API"></a>日期和时间API</h2><p>JDK 8中增加了一套全新的日期时间API，这套API设计合理，是线程安全的。新的日期及时间API位于<code>java.time</code>包中，下面是一些关键类。</p><p><code>LocalDate</code>：表示日期，包含年月日，格式为 2019-10-16</p><p><code>LocalTime</code>：表示时间，包含时分秒，格式为 16:38:54.158549300</p><p><code>LocalDateTime</code>：表示日期时间，包含年月日，时分秒，格式为 2018-09-06T15:33:56.750</p><p><code>DateTimeFormatter</code>：日期时间格式化类。</p><p><code>Instant</code>：时间戳，表示一个特定的时间瞬间。</p><p><code>Duration</code>：用于计算2个时间(LocalTime，时分秒)的距离</p><p><code>Period</code>：用于计算2个日期(LocalDate，年月日)的距离</p><p><code>ZonedDateTime</code>：包含时区的时间</p><p>LocalDate、LocalTime、LocalDateTime类的实例是不可变的对象，分别表示使用 ISO-8601 日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建指定日期</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">fj</span> <span class="operator">=</span> LocalDate.of(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;fj = &quot;</span> + fj); <span class="comment">// 1985-09-23</span></span><br><span class="line">    <span class="comment">// 得到当前日期</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">nowDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;nowDate = &quot;</span> + nowDate);</span><br><span class="line">    <span class="comment">// 获取日期信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;年: &quot;</span> + nowDate.getYear());</span><br><span class="line">    System.out.println(<span class="string">&quot;月: &quot;</span> + nowDate.getMonthValue());</span><br><span class="line">    System.out.println(<span class="string">&quot;日: &quot;</span> + nowDate.getDayOfMonth());</span><br><span class="line">    System.out.println(<span class="string">&quot;星期: &quot;</span> + nowDate.getDayOfWeek());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 得到指定的时间</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>,<span class="number">15</span>, <span class="number">28</span>, <span class="number">129_900_000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;time = &quot;</span> + time);</span><br><span class="line">    <span class="comment">// 得到当前时间</span></span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">nowTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;nowTime = &quot;</span> + nowTime);</span><br><span class="line">    <span class="comment">// 获取时间信息</span></span><br><span class="line">    System.out.println(<span class="string">&quot;小时: &quot;</span> + nowTime.getHour());</span><br><span class="line">    System.out.println(<span class="string">&quot;分钟: &quot;</span> + nowTime.getMinute());</span><br><span class="line">    System.out.println(<span class="string">&quot;秒: &quot;</span> + nowTime.getSecond());</span><br><span class="line">    System.out.println(<span class="string">&quot;纳秒: &quot;</span> + nowTime.getNano());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">fj</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">1970</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;fj = &quot;</span> + fj);</span><br><span class="line">    <span class="comment">// 得到当前日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;now = &quot;</span> + now);</span><br><span class="line">    System.out.println(now.getYear());</span><br><span class="line">    System.out.println(now.getMonthValue());</span><br><span class="line">    System.out.println(now.getDayOfMonth());</span><br><span class="line">    System.out.println(now.getHour());</span><br><span class="line">System.out.println(now.getMinute());</span><br><span class="line">System.out.println(now.getSecond());</span><br><span class="line">System.out.println(now.getNano());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对日期时间的修改，对已存在的LocalDate对象，创建它的修改版，最简单的方式是使用withAttribute方法。withAttribute方法会创建对象的一个副本，并按照需要修改它的属性。以下所有的方法都返回了一个修改属性的对象，他们不会影响原来的对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LocalDateTime类: 对日期时间的修改</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    System.out.println(<span class="string">&quot;now = &quot;</span> + now);</span><br><span class="line">    <span class="comment">// 修改日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">setYear</span> <span class="operator">=</span> now.withYear(<span class="number">2077</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改年份: &quot;</span> + setYear);</span><br><span class="line">    System.out.println(<span class="string">&quot;now == setYear: &quot;</span> + (now == setYear));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改月份: &quot;</span> + now.withMonth(<span class="number">6</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改小时: &quot;</span> + now.withHour(<span class="number">9</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;修改分钟: &quot;</span> + now.withMinute(<span class="number">11</span>));</span><br><span class="line">    <span class="comment">// 再当前对象的基础上加上或减去指定的时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> now.plusDays(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;5天后: &quot;</span> + localDateTime);</span><br><span class="line">    System.out.println(<span class="string">&quot;now == localDateTime: &quot;</span> + (now == localDateTime));</span><br><span class="line">    System.out.println(<span class="string">&quot;10年后: &quot;</span> + now.plusYears(<span class="number">10</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;20月后: &quot;</span> + now.plusMonths(<span class="number">20</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;20年前: &quot;</span> + now.minusYears(<span class="number">20</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;5月前: &quot;</span> + now.minusMonths(<span class="number">5</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;100天前: &quot;</span> + now.minusDays(<span class="number">100</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日期的比较</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test06</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在JDK8中，LocalDate类中使用isBefore()、isAfter()、equals()方法来比较两个日期，可直接进行比较。</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">    System.out.println(now.isBefore(date)); <span class="comment">// false</span></span><br><span class="line">    System.out.println(now.isAfter(date)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间格式化与解析"><a href="#时间格式化与解析" class="headerlink" title="时间格式化与解析"></a>时间格式化与解析</h3><p>通过<code>java.time.format.DateTimeFormatter</code>类可以进行日期时间解析与格式化。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 得到当前日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="comment">// 将日期时间格式化为字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> now.format(formatter);</span><br><span class="line">    System.out.println(<span class="string">&quot;format = &quot;</span> + format);</span><br><span class="line">    <span class="comment">// 将字符串解析为日期时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">parse</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;1970-01-01 12:12:12&quot;</span>, formatter);</span><br><span class="line">    System.out.println(<span class="string">&quot;parse = &quot;</span> + parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/2518f906.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MongoDB基础入门</title>
      <link>http://example.com/inori/623bd2ca.html</link>
      <guid>http://example.com/inori/623bd2ca.html</guid>
      <pubDate>Thu, 25 Apr 2024 07:06:45 GMT</pubDate>
      
      <description>MongoDB入门</description>
      
      
      
      <content:encoded><![CDATA[<p>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB是介于<strong>关系数据库</strong>和<strong>非关系数据库</strong>之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</p><p>Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>MongoDB相较于传统的关系型数据库，可应对“三高“需求</p><ul><li>High performance：对数据库高并发读写的需求</li><li>Huge Storage：对海量数据的高效率存储和访问的需求</li><li>High Scalability &amp;&amp; High Availability：对数据库的高可扩展性和高可用性的需求</li></ul><h3 id="什么时候选择MongoDB"><a href="#什么时候选择MongoDB" class="headerlink" title="什么时候选择MongoDB"></a>什么时候选择MongoDB</h3><ul><li>新应用，需求会变，数据模型无法确定，想快速迭代开发</li><li>应用需要2000-3000以上的读写QPS（更高也可以）</li><li>应用需要TB甚至PB级别数据存储</li><li>应用要求存储的数据不丢失</li><li>应用需要99.999%高可用</li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><table><thead><tr><th>SQL术语&#x2F;概念</th><th>MongoDB术语&#x2F;概念</th><th>说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表&#x2F;集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行&#x2F;文档</td></tr><tr><td>column</td><td>field</td><td>数据字段&#x2F;域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>primary key</td><td>primary key</td><td>主键</td></tr></tbody></table><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>MongoDB的最小存储单位是文档(document)对象。数据在MongoDB中以BSON（Binary-JSON）文档的格式存储在磁盘上。</p><p>BSON（Binary Serialized Document Format）是一种类json的一种二进制形式的存储格式，简称Binary JSON。BSON和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。</p><p>BSON采用了类似于C语言结构体的名称、对表示方法，支持内嵌的文档对象和数组对象，具有轻量性、可遍历性、高效性的三个特点，可以有效描述非结构化数据和结构化数据。这种格式的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p><p>Bson中，除了基本的JSON类型：string,integer,boolean,double,null,array和object，mongo还使用了特殊的数据类型。这些类型包括date,object id,binary data,regular expression和code。</p><h2 id="MongoDB优点"><a href="#MongoDB优点" class="headerlink" title="MongoDB优点"></a>MongoDB优点</h2><ol><li>高性能</li></ol><p>​MongoDB提供高性能的数据持久性。特别是对嵌入式数据模型的支持减少了数据库系统上I&#x2F;O活动。索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。</p><ol start="2"><li><p>高可用性<br>MongoDB的复制工具称为副本集（replica set），它可提供自动故障转移和数据冗余</p></li><li><p>高扩展性<br>MongoDB提供了水平可扩展性作为其核心功能的一部分。分片将数据分布在一组集群的机器上。（海量数据存储，服务能力水平扩展）</p><p>从3.4开始，MoηgoDB支持基于片键创建数据区域。在一个平衡的集群中， MongoDB将一个区域所覆盖的读写只定向到该区域内的那些片。</p></li><li><p>丰富的查询支持<br>MongoDB支持丰富的査询语言，支持读和写操作（CRUD），比如数据聚合、文本搜索和地理空间查询等</p></li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>需要用到的时候可以查阅<a href="https://www.mongodb.com/zh-cn/docs/manual/core/indexes/create-index/">MongoDB官方文档</a>，在此列举常用命令</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p><code>mongosh</code>:打开一个连接到本地实例的MongoShell。所有其他命令都需要在mongosh中执行</p><p><code>show databases\show dbs</code>:显示当前MongoDB实例中的所有数据库</p><p><code>use &lt;dbname&gt;</code>:切换到dbname数据库</p><p><code>cls</code>: 清屏</p><p><code>show collections</code>: 显示数据库中的所有集合</p><p><code>db.dropDatabase()</code>:删除当前数据库</p><p><code>exit</code>: 退出</p><h3 id="创建、插入"><a href="#创建、插入" class="headerlink" title="创建、插入"></a>创建、插入</h3><p><code>insertOne</code>:在集合中插入一个新的文档，如果集合存在，那么直接插入数据。如果集合不存在，那么会隐式创建。</p><ul><li><code>db.test.insertOne(&#123;name: &quot;Jack&quot;, age: 18&#125;)</code>:向test数据库中插入一条数据</li></ul><p><code>insertMany</code>:批量插入文档</p><h4 id="快速插入"><a href="#快速插入" class="headerlink" title="快速插入"></a>快速插入</h4><p>由于<code>mongodb</code>底层使用<code>JS</code>引擎实现的，所以支持部分<code>Js</code>语法。因此可以写<code>for</code>循环</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">for (var i=1; i&lt;=10; i++) &#123; db.c2.insertOne(&#123;uanme: &quot;a&quot;+i, age: i&#125;) &#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>delectOne</code>:删除满足条件的第一个文档</p><p><code>delectMany</code>:删除满足条件的所有文档</p><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p><code>updateOne</code>:更新满足条件的第一个文档</p><p><code>updateMany</code>:更新满足条件的所有文档</p><p><code>replaceone</code>:替换满足条件的第一个文档</p><p><code>save</code>:通过传入的文档替换已有文档或插入一个新的文档</p><p><code>$set</code>:只更新文档中$set指定的字段</p><ul><li><code>db.test.update(&#123;name:&quot;Jack&quot;&#125;,&#123;$set:&#123;uname:&quot;Candy&quot;&#125;&#125;)</code>:把jack改成Candy</li></ul><p><code>$inc</code>:用于递增&#x2F;递减文档中指定字段值的操作符</p><p><code>$rename</code>:更新某个字段的名称</p><p><code>$unset</code>:删除一个字段</p><p><code>$push</code>:将值加入一个数组中，不会判断是否有重复的值</p><p><code>$pull</code>:将值从一个数组中移除</p><p><code>$addToSet</code>:将值加入一个数组中，如果数组中有重复的值则不会加入</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><code>find</code>:查询所有文档</p><p><code>find(&lt;filterObject&gt;)</code>:查询所有满足参数对象<code>&lt;filterObject&gt;</code>中指定过滤条件的数据</p><ul><li><code>db.test.find(&#123;age: 18&#125;)</code>:查询所有年龄为18岁的文档</li></ul><p><code>db.find(&lt;filterObject&gt;, &lt;selectObject&gt;)</code>:查询所有满足参数对象<code>&lt;filterObject&gt;</code>中指定过滤条件的数据，并且只返回或者不返回<code>&lt;selectObject&gt;</code>中指定的字段</p><ul><li><code>db.test.find(&#123;&#125;, &#123;name:1&#125;)</code>:只看name列</li><li><code>db.test.find(&#123;&#125;, &#123;name:0&#125;)</code>:除了name列都看</li></ul><p><code>findOne</code>:与find用法相同，但是只返回1条</p><p><code>countDocuments</code>:返回满足条件的记录的数量</p><p><code>sort</code>:使用给定的字段按照升序或降序排序</p><ul><li><code>db.test.find().sort(&#123;age:1&#125;)</code>:按照年龄升序排序（传入-1是降序排序）</li></ul><p><code>limit</code>:限定只返回给定数量的文档</p><ul><li><code>db.test.find().limit(1)</code>:只返回一条数据</li></ul><p><code>skip</code>:从头开始跳过给定数值的文档</p><ul><li><code>db.test.find().limit(x).skip(y*x)</code>:实现翻页效果，一页x个内容，翻y页</li></ul><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p><code>$sum</code>:计算总和</p><p><code>$avg</code>:计算平均值</p><p><code>$min</code>:计算最小值</p><p><code>$max</code>:计算最大值</p><p><code>$first</code>:获取第一个文档数据</p><p><code>$last</code>:获取最后一个文档数据</p><h3 id="过滤条件"><a href="#过滤条件" class="headerlink" title="过滤条件"></a>过滤条件</h3><p><code>$eq</code>:等于</p><p><code>$ne</code>:不等于</p><p><code>$gt\$get</code>:大于\大于等于</p><ul><li><code>db.c1.find(&#123;age:&#123;$gt:5&#125;&#125;)</code>:查询age大于5的数据</li></ul><p><code>$lt\$lte</code>:小于\小于等于</p><p><code>$in</code>:值在指定列表中就返回文档</p><ul><li><code>db.c2.find(&#123;age:&#123;$in:[5,8,10]&#125;&#125;)</code>:查询年龄是5,8,10的数据</li></ul><p><code>$nin</code>:值不在指定列表中就返回文档</p><p><code>$and</code>:检查复数条件是否均为真，可以理解为“并且”</p><ul><li><code>db.test.find(&#123;$and:[&#123;age:&#123;$gte:10&#125;&#125;, &#123;age:&#123;$lte:20&#125;&#125;&#125;]&#125;)</code>:返回年龄在10-20岁之间的文档</li></ul><p><code>$or</code>:检查复试条件是否有一个为真，可以理解为“或者”</p><p><code>$not</code>:逻辑区取反</p><p><code>$exists</code>:检查一个字段是否存在</p><p><code>$expr</code>:在不同的字段中作比较</p><h2 id="Java中操作MongoDB"><a href="#Java中操作MongoDB" class="headerlink" title="Java中操作MongoDB"></a>Java中操作MongoDB</h2><p>首先需要导入mongodb驱动包</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mongodb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mongo-java-driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建链接对象"><a href="#创建链接对象" class="headerlink" title="创建链接对象"></a>创建链接对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MongoClient mongoclient= <span class="keyword">new</span> <span class="title class_">MongoClient</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">27017</span>);</span><br></pre></td></tr></table></figure><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取库对象，参数为库名</span></span><br><span class="line"><span class="type">MongoDatabase</span> <span class="variable">db</span> <span class="operator">=</span> mongoclient.getDatabase(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//获取当前库对象的所有集合名的迭代器</span></span><br><span class="line">MongoIterable&lt;String&gt; list = db.getlistCollectionNames();</span><br><span class="line"><span class="keyword">for</span>(String str:list)&#123;</span><br><span class="line">    System.out.println(str);<span class="comment">//获取所有表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取集合对象，参数为集合名</span></span><br><span class="line">MongoCollention&lt;Document&gt; collection = db.getCollection(<span class="string">&quot;student&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="对数据库进行增删改查"><a href="#对数据库进行增删改查" class="headerlink" title="对数据库进行增删改查"></a>对数据库进行增删改查</h3><h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取集合对象</span></span><br><span class="line">MongoCollection&lt;Document&gt; collection = db.getCollection(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">//新增时创建一个Docuement对象，以键值对的形式传入内容</span></span><br><span class="line"><span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Document</span>();</span><br><span class="line">document.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">document.put(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span><br><span class="line">document.put(<span class="string">&quot;sex&quot;</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="comment">//添加一条数据，没有返回值</span></span><br><span class="line">collection.insertOne(document);</span><br><span class="line"><span class="comment">//新增多条数据,传入一个document集合</span></span><br><span class="line">collection.insertMany(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="Filter类"><a href="#Filter类" class="headerlink" title="Filter类"></a>Filter类</h4><p>删除，修改，查询时传入的筛选条件，比如<code>Bson eq = Filters.eq(&quot;name&quot;,&quot;张三&quot;);</code></p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Filters.eq()</td><td>等值</td></tr><tr><td>Filters.gt()</td><td>大于指定值(gte大于等于)</td></tr><tr><td>Filters.lt()</td><td>小于指定值(lte小于等于)</td></tr><tr><td>Filters.ne()</td><td>不等于指定</td></tr><tr><td>Filters.nin()</td><td>不等于数组中的值</td></tr><tr><td>Filters.and()</td><td>传入多个Bson对象，and连接</td></tr><tr><td>Filters.regex()</td><td>模糊查询</td></tr><tr><td>Filters.exists()</td><td>存在改字段</td></tr></tbody></table><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件</span></span><br><span class="line"><span class="type">Bson</span> <span class="variable">eq</span> <span class="operator">=</span> Filters.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//删除一条符合的</span></span><br><span class="line"><span class="type">DeleteResult</span> <span class="variable">deleteOne</span> <span class="operator">=</span> collection.deleteOne(eq);</span><br><span class="line"><span class="comment">//删除 所有符合条件的</span></span><br><span class="line"><span class="type">DeleteResult</span> <span class="variable">deleteMany</span> <span class="operator">=</span> collection.deleteMany(eq);</span><br></pre></td></tr></table></figure><p>修改的返回值内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AcknowledgedDeleteResult&#123;deletedCount=<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p><code>deletedCount</code>:被删除的文档数</p><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改条件</span></span><br><span class="line"><span class="type">Bson</span> <span class="variable">eq</span> <span class="operator">=</span> Filters.eq(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//修改匹配到的第一条</span></span><br><span class="line"><span class="type">UpdateResult</span> <span class="variable">updateOne</span> <span class="operator">=</span> collection.updateOne(</span><br><span class="line">    eq, <span class="keyword">new</span> <span class="title class_">Document</span>(<span class="string">&quot;$set&quot;</span>,<span class="keyword">new</span> <span class="title class_">Document</span>(<span class="string">&quot;age&quot;</span>,<span class="number">50</span>)));</span><br><span class="line"><span class="comment">//修改匹配的多条</span></span><br><span class="line">collection.updateMany(eq, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>修改的返回值内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AcknowledgedUpdateResult&#123;matchedCount=<span class="number">0</span>, modifiedCount=<span class="number">0</span>, upsertedId=<span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure><p><code>matchedCount</code>:代表匹配到的文档数</p><p><code>modifiedCount</code>:代表被修改的文档数</p><p><code>upsertedId</code>:代表修改的文档id(主键)</p><h4 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无条件全查</span></span><br><span class="line">FindIterable&lt;Document&gt; find = collection.find();</span><br><span class="line"><span class="comment">//带条件查询</span></span><br><span class="line"><span class="type">Bson</span> <span class="variable">eq</span> <span class="operator">=</span> Filters.regex(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张&quot;</span>);</span><br><span class="line">FindIterable&lt;Document&gt; find = collection.find(eq);</span><br></pre></td></tr></table></figure><p>查询的结果集映射,这种解析方式我们必须知道文档中的各个字段名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询</span></span><br><span class="line">FindIterable&lt;Document&gt; find = collection.find();</span><br><span class="line"><span class="comment">//创建一个实体类集合准备接收结果</span></span><br><span class="line">List&lt;Student&gt; slist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line"><span class="comment">//获取结果集迭代器对象</span></span><br><span class="line">MongoCursor&lt;Document&gt; iterator = find.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Document</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">s.setSname(next.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">s.setSex(next.getString(<span class="string">&quot;sex&quot;</span>));</span><br><span class="line">s.setAge(next.getInteger(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">    <span class="comment">//将结果添加至实体类集合</span></span><br><span class="line">slist.add(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mongoclient.close();</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/mongodb/">mongodb</category>
      
      
      <category domain="http://example.com/tags/mongodb/">mongodb</category>
      
      
      <comments>http://example.com/inori/623bd2ca.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Docker的基本使用</title>
      <link>http://example.com/inori/ca4a993b.html</link>
      <guid>http://example.com/inori/ca4a993b.html</guid>
      <pubDate>Wed, 24 Apr 2024 03:47:21 GMT</pubDate>
      
      <description>Docker常用命令</description>
      
      
      
      <content:encoded><![CDATA[<p>Docker使用Google推出的Go语言进行开发实现，基于Linux内核的cgroup，namespace，以及AUFS类的Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</p><p>Docker在容器的基础上进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得Docker技术比虚拟机技术更为轻便、快捷。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像：一个特殊的文件系统"><a href="#镜像：一个特殊的文件系统" class="headerlink" title="镜像：一个特殊的文件系统"></a><strong>镜像：一个特殊的文件系统</strong></h3><p>操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。</p><p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</p><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>Docker设计时，就将其设计为分层存储的架构，镜像实际是由多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。</p><p>在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。</p><p>因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p><h3 id="容器：镜像运行时的实体"><a href="#容器：镜像运行时的实体" class="headerlink" title="容器：镜像运行时的实体"></a><strong>容器：镜像运行时的实体</strong></h3><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据 ，容器存储层要保持无状态化。</p><p>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， 使用数据卷后，容器可以随意删除、重新start，数据不会丢失。</p><h3 id="仓库：集中存放镜像文件的地方"><a href="#仓库：集中存放镜像文件的地方" class="headerlink" title="仓库：集中存放镜像文件的地方"></a><strong>仓库：集中存放镜像文件的地方</strong></h3><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</p><p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>所以说，镜像仓库是 Docker 用来集中存放镜像文件的地方，类似于我们之前常用的代码仓库。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。</p><p>我们可以通过&lt;仓库名&gt;:&lt;标签&gt;的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p><p>这里补充一下 Docker Registry 公开服务和私有 Docker Registry 的概念：</p><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。</p><p>一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的<a href="https://hub.docker.com/">Docker Hub</a>，这也是默认的Registry，并拥有大量的高质量的镜像。</p><p>在国内访问可能会比较慢，国内也有一些云服务商提供类似于Docker Hub的公开服务。</p><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。</p><p>开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 Docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><p><img src="D:\Blog\source\img\img_con.png" alt="img_con"></p><h2 id="初步配置Docker"><a href="#初步配置Docker" class="headerlink" title="初步配置Docker"></a>初步配置Docker</h2><h3 id="设置开机自启"><a href="#设置开机自启" class="headerlink" title="设置开机自启"></a>设置开机自启</h3><p>默认情况下，每次重启虚拟机我们都需要手动启动Docker和Docker中的容器。通过命令可以实现开机自启：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker容器开机自启</span></span><br><span class="line">docker update <span class="literal">--restart</span>=always [容器名/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p>给常用Docker命令起别名，方便访问：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br></pre></td></tr></table></figure><p>执行命令使修改生效</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p><img src="D:\Blog\source\img\docker_control.png" alt="docker_control"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    <span class="number">605</span>c77e624dd   <span class="number">16</span> months ago   <span class="number">141</span>MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步，创建并允许Nginx容器</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第5步，查看运行中容器</span></span><br><span class="line">docker <span class="built_in">ps</span></span><br><span class="line"><span class="comment"># 也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第8步，查看所有容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第9步，再次启动nginx容器</span></span><br><span class="line">docker <span class="built_in">start</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第10步，再次查看容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br><span class="line"><span class="comment"># 或者，可以进入MySQL</span></span><br><span class="line">docker exec <span class="literal">-it</span> mysql mysql <span class="literal">-uroot</span> <span class="literal">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第13步，删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br><span class="line"><span class="comment"># 发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> nginx</span><br></pre></td></tr></table></figure><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p>数据卷（volume）是一个虚拟目录，是<strong>容器内</strong>目录与<strong>宿主机</strong>目录之间映射的桥梁。</p><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     <span class="number">29524</span>ff09715htrhfhthfhta2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-04-24T09:50:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html</span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br></pre></td></tr></table></figure><h3 id="挂载本地目录或文件"><a href="#挂载本地目录或文件" class="headerlink" title="挂载本地目录或文件"></a>挂载本地目录或文件</h3><p>数据卷的目录结构较深，去操作数据卷目录会不太方便。在很多情况下会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><p>本地目录或文件必须以 <code>/</code> 或 <code>./</code>开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。</p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>如果想要部署我们自己的项目，需要将其打包为一个镜像。</p><p>打包镜像分成如下步骤：</p><ul><li>准备Linux运行环境</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。记录镜像结构的文件就称为<a href="https://docs.docker.com/engine/reference/builder/"><strong>Dockerfile</strong></a></p><h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>通常在其他人提供好的基础镜像之上制作镜像</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>当Dockerfile文件写好以后，就可以利用命令来构建镜像</p><p>首先将本地打包好的jar包和Dockerfile传入linux服务器，然后执行命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/image</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><p><code>docker build </code>: 构建一个docker镜像</p></li><li><p><code>-t demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</p></li><li><p><code>.</code> : 指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：</p></li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接指定Dockerfile目录</span></span><br><span class="line">docker build -t docker-demo:1.0 /root/image</span><br></pre></td></tr></table></figure><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>项目往往需要访问其它各种中间件，例如MySQL、Redis等。但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p><p>所以，我们必须借助于<a href="https://docs.docker.com/engine/reference/commandline/network/">docker的网络功能</a>来解决这个问题</p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   demo      bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了demo以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect demo mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect demo <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><h2 id="DockerCompose"><a href="#DockerCompose" class="headerlink" title="DockerCompose"></a>DockerCompose</h2><p>只是部署一个简单的java项目，会包含以下3个容器：</p><ul><li>MySQL</li><li>Nginx</li><li>Java项目</li></ul><p>而稍微复杂的项目，其中还会有各种各样的其它中间件，需要部署的东西远不止3个。如果还像之前那样手动的逐一部署，就太麻烦了</p><p>DockerCompose就可以帮助我们实现<strong>多个相互关联的Docker容器的快速部署</strong>。它允许用户通过一个单独的docker-compose.yml模板文件（YAML格式）来定义一组相关联的应用容器。</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><a href="https://docs.docker.com/compose/compose-file/compose-file-v3/">docker-compose.yml文件的基本语法</a></p><p>docker-compose文件中可以定义多个相互关联的应用容器，每一个应用容器被称为一个服务（service）。由于service就是在定义某个应用的运行时参数，因此与<code>docker run</code>参数很相似。</p><p>举例来说，用docker run部署MySQL的命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  -v ./mysql/data:/var/lib/mysql \</span><br><span class="line">  -v ./mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">  -v ./mysql/init:/docker-entrypoint-initdb.d \</span><br><span class="line">  --network demo</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>如果用<code>docker-compose.yml</code>文件来定义，就是这样：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">new</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">new:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo</span></span><br></pre></td></tr></table></figure><p>对比如下：</p><table><thead><tr><th align="left"><strong>docker run 参数</strong></th><th align="left"><strong>docker compose 指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">–name</td><td align="left">container_name</td><td align="left">容器名称</td></tr><tr><td align="left">-p</td><td align="left">ports</td><td align="left">端口映射</td></tr><tr><td align="left">-e</td><td align="left">environment</td><td align="left">环境变量</td></tr><tr><td align="left">-v</td><td align="left">volumes</td><td align="left">数据卷配置</td></tr><tr><td align="left">–network</td><td align="left">networks</td><td align="left">网络</td></tr></tbody></table><h3 id="项目部署示例"><a href="#项目部署示例" class="headerlink" title="项目部署示例"></a>项目部署示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="number">123</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/conf:/etc/mysql/conf.d&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/data:/var/lib/mysql&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./mysql/init:/docker-entrypoint-initdb.d&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line">  <span class="attr">project:</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:8080&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="attr">nginx:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:18080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:18081&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/nginx.conf:/etc/nginx/nginx.conf&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./nginx/html:/usr/share/nginx/html&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">project</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">demo</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">demo:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">net</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-基础命令"><a href="#3-3-2-基础命令" class="headerlink" title="3.3.2.基础命令"></a>3.3.2.基础命令</h3><p>编写好docker-compose.yml文件，就可以<a href="https://docs.docker.com/compose/reference/">部署项目</a>了</p><p>基本语法：<code>docker compose [OPTIONS] [COMMAND]</code></p><p>OPTIONS和COMMAND都是可选参数，比较常见的有：</p><table><thead><tr><th align="left"><strong>类型</strong></th><th align="left"><strong>参数或指令</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Options</td><td align="left">-f</td><td align="left">指定compose文件的路径和名称</td></tr><tr><td align="left">-p</td><td align="left">指定project名称。project就是当前compose文件中设置的多个service的集合，是逻辑概念</td><td align="left"></td></tr><tr><td align="left">Commands</td><td align="left">up</td><td align="left">创建并启动所有service容器</td></tr><tr><td align="left">down</td><td align="left">停止并移除所有容器、网络</td><td align="left"></td></tr><tr><td align="left">ps</td><td align="left">列出所有启动的容器</td><td align="left"></td></tr><tr><td align="left">logs</td><td align="left">查看指定容器的日志</td><td align="left"></td></tr><tr><td align="left">stop</td><td align="left">停止容器</td><td align="left"></td></tr><tr><td align="left">start</td><td align="left">启动容器</td><td align="left"></td></tr><tr><td align="left">restart</td><td align="left">重启容器</td><td align="left"></td></tr><tr><td align="left">top</td><td align="left">查看运行的进程</td><td align="left"></td></tr><tr><td align="left">exec</td><td align="left">在指定的运行中容器中执行命令</td><td align="left"></td></tr></tbody></table><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.进入root目录</span></span><br><span class="line"><span class="built_in">cd</span> /root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除旧容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -qa)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.删除镜像</span></span><br><span class="line">docker rmi demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.清空MySQL数据</span></span><br><span class="line"><span class="built_in">rm</span> -rf mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.启动</span></span><br><span class="line">docker compose up -d</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">[+] Building 15.5s (8/8) FINISHED</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                    0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 358B                                                    0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                         0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/openjdk:11.0-jre-buster             15.4s</span><br><span class="line"> =&gt; [1/3] FROM docker.io/library/openjdk:11.0-jre-buster@sha256:3546a17e6fb4ff4fa681c3  0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                       0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 98B                                                        0.0s</span><br><span class="line"> =&gt; CACHED [2/3] RUN <span class="built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span>   0.0s</span><br><span class="line"> =&gt; CACHED [3/3] COPY demo-service.jar /app.jar                                         0.0s</span><br><span class="line"> =&gt; exporting to image                                                                  0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                 0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:32eebee16acde22550232f2eb80c69d2ce813ed099640e4cfed2193f71  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/root                                                 0.0s</span><br><span class="line">[+] Running 4/4</span><br><span class="line"> ✔ Network net      Created                                                             0.2s</span><br><span class="line"> ✔ Container mysql  Started                                                             0.5s</span><br><span class="line"> ✔ Container demo   Started                                                             0.9s</span><br><span class="line"> ✔ Container nginx  Started                                                             1.5s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.查看镜像</span></span><br><span class="line">docker compose images</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.查看容器</span></span><br><span class="line">docker compose ps</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/docker/">docker</category>
      
      
      <category domain="http://example.com/tags/docker/">docker</category>
      
      
      <comments>http://example.com/inori/ca4a993b.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis进阶篇</title>
      <link>http://example.com/inori/a9e82450.html</link>
      <guid>http://example.com/inori/a9e82450.html</guid>
      <pubDate>Tue, 16 Apr 2024 12:16:39 GMT</pubDate>
      
      <description>redis入门</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用</p><p><strong>浏览器缓存</strong>：主要是存在于浏览器端的缓存</p><p><strong>应用层缓存：</strong>可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存</p><p><strong>数据库缓存：</strong>在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中</p><p><strong>CPU缓存：</strong>当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存</p><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p>缓存更新是redis为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向redis插入太多数据，此时就可能会导致缓存中的数据过多，所以redis会对部分数据进行更新，或者把他叫为淘汰更合适。</p><p><strong>内存淘汰：</strong>redis自动进行，当redis内存达到设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)</p><p><strong>超时剔除：</strong>给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便继续使用缓存</p><p><strong>主动更新：</strong>手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题</p><p><img src="D:\Blog\source\img\redis_cacheUpdate.png" alt="redis_cacheUpdate"></p><h3 id="数据库缓存不一致解决方案"><a href="#数据库缓存不一致解决方案" class="headerlink" title="数据库缓存不一致解决方案"></a>数据库缓存不一致解决方案</h3><p>由于缓存的数据源来自于数据库,而数据库的数据是会发生变化的,因此,如果当数据库中数据发生变化,而缓存却没有同步,此时就会有一致性问题存在,其后果是:</p><p>用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,有如下几种方案</p><p>Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案</p><p>Read&#x2F;Write Through Pattern: 由系统本身完成，数据库与缓存的问题交由系统本身去处理</p><p>Write Behind Caching Pattern：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致</p><h3 id="缓存穿透问题的解决思路"><a href="#缓存穿透问题的解决思路" class="headerlink" title="缓存穿透问题的解决思路"></a>缓存穿透问题的解决思路</h3><p><strong>缓存穿透</strong>：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p>常见的解决方案有两种：</p><ul><li>缓存空对象<ul><li>优点：实现简单，维护方便</li><li>缺点：<ul><li>额外的内存消耗</li><li>可能造成短期的不一致</li></ul></li></ul></li><li>布隆过滤<ul><li>优点：内存占用较少，没有多余key</li><li>缺点：<ul><li>实现复杂</li><li>存在误判可能</li></ul></li></ul></li></ul><p><strong>缓存空对象思路分析：</strong>当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了</p><p><strong>布隆过滤：</strong>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器使用的是哈希思想，而哈希思想可能存在哈希冲突</p><h3 id="缓存雪崩问题及解决思路"><a href="#缓存雪崩问题及解决思路" class="headerlink" title="缓存雪崩问题及解决思路"></a>缓存雪崩问题及解决思路</h3><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p><p>解决方案：</p><ul><li>给不同的Key的TTL添加随机值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h3 id="缓存击穿问题及解决思路"><a href="#缓存击穿问题及解决思路" class="headerlink" title="缓存击穿问题及解决思路"></a>缓存击穿问题及解决思路</h3><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>常见的解决方案有两种：</p><ul><li>互斥锁</li><li>逻辑过期</li></ul><p>逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大</p><p>解决方案一、使用锁来解决：</p><p>因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。</p><p>假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。</p><p>解决方案二、逻辑过期方案</p><p>方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。</p><p>我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。</p><p><img src="D:\Blog\source\img\redisThrough.png" alt="redisThrough"></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路</p><h3 id="分布式锁应该满足的条件"><a href="#分布式锁应该满足的条件" class="headerlink" title="分布式锁应该满足的条件"></a>分布式锁应该满足的条件</h3><ul><li>可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li><li>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</li><li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li><li>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全也是程序中必不可少的一环</li></ul><h3 id="常见的分布式锁"><a href="#常见的分布式锁" class="headerlink" title="常见的分布式锁"></a>常见的分布式锁</h3><p><img src="D:\Blog\source\img\common_lock.png" alt="common_lock"></p><p>基于Redis的分布式锁实现思路：</p><ul><li>利用set nx ex获取锁，并设置过期时间，保存线程标示</li><li>释放锁时先判断线程标示是否与自己一致，一致则删除锁<ul><li>特性：<ul><li>利用set nx满足互斥性</li><li>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</li><li>利用Redis集群保证高可用和高并发特性</li></ul></li></ul></li></ul><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><h4 id="Redisson简介"><a href="#Redisson简介" class="headerlink" title="Redisson简介"></a>Redisson简介</h4><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p>Redission提供了分布式锁的多种多样的功能</p><p><img src="D:\Blog\source\img\redisson_type.png" alt="redisson_type"></p><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><p>引入依赖：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置Redisson客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://IP地址:端口号&quot;</span>)</span><br><span class="line">            .setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Redission的分布式锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redission可重入锁原理"><a href="#redission可重入锁原理" class="headerlink" title="redission可重入锁原理"></a>redission可重入锁原理</h3><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0时，表示当前这把锁没有被人持有。</p><p>在redission中也支持支持可重入锁</p><p>在分布式锁中，采用hash结构用来存储锁，其中大key表示表示这把锁是否存在，小key表示当前这把锁被哪个线程持有，分析一下当前的这个lua表达式:</p><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                  <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">              <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span></span><br></pre></td></tr></table></figure><p>此处一共有3个参数：</p><p><strong>KEYS[1]：锁名称</strong></p><p><strong>ARGV[1]：锁失效时间</strong></p><p><strong>ARGV[2]：id + “:” + threadId；锁的小key</strong></p><p>exists: 判断数据是否存在</p><p>name：是lock是否存在,如果&#x3D;&#x3D;0，就表示当前这把锁不存在</p><p>redis.call(‘hset’, KEYS[1], ARGV[2], 1);此时他就开始往redis里边去写数据 ，写成一个hash结构</p><p>Lock{</p><p>​    id + <strong>“:”</strong> + threadId :  1</p><p>}</p><p>如果当前这把锁存在，则第一个条件不满足，再判断</p><p>redis.call(‘hexists’, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1</p><p>此时需要通过大key+小key判断当前这把锁是否是属于自己的，如果是自己的，则进行</p><p>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1)</p><p>将当前这个锁的value进行+1</p><p>redis.call(‘pexpire’, KEYS[1], ARGV[1]); 然后再对其设置过期时间，如果以上两个条件都不满足，则表示当前这把锁抢锁失败，最后返回pttl，即为当前这把锁的失效时间</p><p>他会去判断当前这个方法的返回值是否为null，如果是null，则对应则前两个if对应的条件，退出抢锁逻辑，如果返回的不是null，即走了第三个分支，在源码处会进行while(true)的自旋抢锁。</p><p><img src="D:\Blog\source\img\getLock.png" alt="getLock"></p><h3 id="锁重试和WatchDog机制"><a href="#锁重试和WatchDog机制" class="headerlink" title="锁重试和WatchDog机制"></a>锁重试和WatchDog机制</h3><p>抢锁过程中，获得当前线程，通过tryAcquire进行抢锁，该抢锁逻辑和之前逻辑相同</p><p>1、先判断当前这把锁是否存在，如果不存在，插入一把锁，返回null</p><p>2、判断当前这把锁是否是属于当前线程，如果是，则返回null</p><p>所以如果返回是null，则代表着当前该线程已经抢锁完毕，或者可重入完毕，但是如果以上两个条件都不满足，则进入到第三个条件，返回的是锁的失效时间，存在一个while(true) 进行tryAcquire抢锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line"><span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line"><span class="comment">// lock acquired</span></span><br><span class="line"><span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来会有一个条件分支，因为lock方法有重载方法，一个是带参数，一个是不带参数，如果带带参数传入的值是-1，如果传入参数，则leaseTime是他本身，所以如果传入了参数，此时leaseTime !&#x3D; -1则会进去抢锁，抢锁的逻辑就是之前说的那三个逻辑</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) <span class="keyword">return</span> tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_LONG);</span><br></pre></td></tr></table></figure><p>如果是没有传入时间，则此时也会进行抢锁，而且抢锁时间是默认看门狗时间<code>commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout()</code></p><p><code>ttlRemainingFuture.onComplete((ttlRemaining, e)</code>相当于对以上抢锁进行了监听，也就是说当上边抢锁完毕后，此方法会被调用，具体调用的逻辑就是去后台开启一个线程，进行续约逻辑，也就是看门狗线程</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RFuture&lt;Long&gt; ttlRemainingFuture = tryLockInnerAsync(waitTime,</span><br><span class="line">                                        commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(),</span><br><span class="line">                                        TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_LONG);</span><br><span class="line">ttlRemainingFuture.onComplete((ttlRemaining, e) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock acquired</span></span><br><span class="line">    <span class="keyword">if</span> (ttlRemaining == <span class="literal">null</span>) &#123;</span><br><span class="line">        scheduleExpirationRenewal(threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> ttlRemainingFuture;</span><br></pre></td></tr></table></figure><p>此逻辑就是续约逻辑，注意看commandExecutor.getConnectionManager().newTimeout（）方法Method(<strong>new</strong> TimerTask(){}, 参数2, 参数3)</p><p>指的是：通过参数2，参数3 去描述什么时候去做参数1的事情，现在的情况是：10s之后去做参数一的事情</p><p>因为锁的失效时间是30s，当10s之后，此时这个timeTask 就触发了，他就去进行续约，把当前这把锁续约成30s，如果操作成功，那么此时就会递归调用自己，再重新设置一个timeTask()，于是再过10s后又再设置一个timerTask，完成不停的续约</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">renewExpiration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ExpirationEntry</span> <span class="variable">ee</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">Timeout</span> <span class="variable">task</span> <span class="operator">=</span> commandExecutor.getConnectionManager().newTimeout(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="type">ExpirationEntry</span> <span class="variable">ent</span> <span class="operator">=</span> EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">            <span class="keyword">if</span> (ent == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">threadId</span> <span class="operator">=</span> ent.getFirstThreadId();</span><br><span class="line">            <span class="keyword">if</span> (threadId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">            future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                    <span class="comment">// reschedule itself</span></span><br><span class="line">                    renewExpiration();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MutiLock原理"><a href="#MutiLock原理" class="headerlink" title="MutiLock原理"></a>MutiLock原理</h3><p>为了提高redis的可用性，我们会搭建集群或者主从，现在以主从为例</p><p>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设在主机还没有来得及把数据写入到从机去的时候，此时主机宕机，哨兵会发现主机宕机，并且选举一个slave变成master，而此时新的master中实际上并没有锁信息，此时锁信息就已经丢掉了。</p><p>为了解决这个问题，redission提出来了MutiLock锁，使用这把锁就不使用主从了，每个节点的地位都是一样的， 这把锁加锁的逻辑需要写入到每一个主丛节点上，只有所有的服务器都写入成功，此时才是加锁成功，假设现在某个节点挂了，那么他去获得锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性。</p><p><img src="D:\Blog\source\img\mutilock_1.png" alt="mutilock_1"></p><p>当我们去设置了多个锁时，redission会将多个锁添加到一个集合中，然后用while循环去不停去尝试拿锁，但是会有一个总共的加锁时间，这个时间是用需要加锁的个数 * 1500ms ，假设有3个锁，那么时间就是4500ms，假设在这4500ms内，所有的锁都加锁成功，那么此时才算是加锁成功，如果在4500ms有线程加锁失败，则会再次去进行重试</p><p><img src="D:\Blog\source\img\mutilock_2.png" alt="mutilock_2"></p><h2 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h2><p>消息队列的字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>使用队列的好处在于 <strong>解耦：</strong>生产者不必等待消费者，生产出来的东西可以直接放到队列中，消费者也不必等待生产者，直接从队列中获得所需的消息，二者异步执行，增加效率。</p><h3 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a>基于List实现消息队列</h3><p><strong>基于List结构模拟消息队列</strong></p><p>消息队列（Message Queue），字面意思就是存放消息的队列。而Redis的list数据结构是一个双向链表，很容易模拟出队列效果。</p><p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。<br>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。<br>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h3 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。</p><p> SUBSCRIBE channel [channel] ：订阅一个或多个频道<br> PUBLISH channel msg ：向一个频道发送消息<br> PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道<br>优点：</p><ul><li>采用发布订阅模型，支持多生产、多消费</li></ul><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream是Redis 5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列。</p><p>发送消息的命令：</p><p><img src="D:\Blog\source\img\stream_1.png" alt="stream_1"></p><p>例如：</p><p><code>XADD user * name jack age 18</code>:创建名为users的队列，并向其中发送一个消息，内容为{name&#x3D;jack,age&#x3D;18},使用Redis自动生成ID</p><p>读取消息的方式之一：XREAD</p><p><img src="D:\Blog\source\img\stream_xread.png" alt="stream_xread"></p><p>例如，使用XREAD读取第一个消息：<code>XREAD COUNT 1 STREAMS users 0</code></p><p>XREAD阻塞方式，读取最新的消息：<code>XREAD COUNT 1 BLOCK 1000 STREAMS user $</code></p><p>可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">// 尝试读取队列中的消息，最多阻塞2秒</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> redis.execute(<span class="string">&quot;XREAD COUNT 1 BLOCK 2000 STREAMS user $&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(msg == <span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    handleMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：当我们指定起始ID为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现漏读消息的问题</p><p>STREAM类型消息队列的XREAD命令特点：</p><ul><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有消息漏读的风险</li></ul><h3 id="消费者组"><a href="#消费者组" class="headerlink" title="消费者组"></a>消费者组</h3><p>消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p><p><img src="D:\Blog\source\img\user_group.png" alt="user_group"></p><p>创建消费者组：<code>XGROUP CREATE key gruopName ID [MKSTREAM]</code><br>key：队列名称<br>groupName：消费者组名称<br>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息<br>MKSTREAM：队列不存在时自动创建队列<br>其它常见命令：</p><p> <strong>删除指定的消费者组</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DESTORY key groupName</span><br></pre></td></tr></table></figure><p> <strong>给指定的消费者组添加消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p> <strong>删除消费者组中的指定消费者</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure><p>从消费者组读取消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><ul><li>group：消费组名称</li><li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li><li>count：本次查询的最大数量</li><li>BLOCK milliseconds：当没有消息时最长等待时间</li><li>NOACK：无需手动ACK，获取到消息后自动确认</li><li>STREAMS key：指定队列名称</li><li>ID：获取消息的起始ID：</li></ul><p>“&gt;”：从下一个未消费的消息开始<br>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</p><p>STREAM类型消息队列的XREADGROUP命令特点：</p><ul><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读的风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ul><h2 id="GEO数据结构的基本用法"><a href="#GEO数据结构的基本用法" class="headerlink" title="GEO数据结构的基本用法"></a>GEO数据结构的基本用法</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本中加入了对GEO的支持，允许存储地理坐标信息，根据经纬度来检索数据。</p><p>常见的命令有：</p><ul><li>GEOADD：添加一个地理空间信息，包含：经度（longitude）、纬度（latitude）、值（member）</li></ul><p><code>GEOADD key longitude latitude member [longitude latitude member ...]</code></p><ul><li>GEODIST：计算指定的两个点之间的距离并返回</li></ul><p><code>GEODIST key member1 member2 [m|km|ft|mi]</code></p><ul><li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li></ul><p><code>GEOHASH key member [member ...]</code></p><ul><li>GEOPOS：返回指定member的坐标</li></ul><p><code>GEOPOS key member [member ...]</code></p><ul><li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回。(已废弃)</li></ul><p><code>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</code></p><ul><li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形。</li></ul><p><code>GEOSEARCH key [FROMMEMBER member] [FROMCOORD longitude latitude] [BYRADIUS radius unit] [BYBOX width height unit] [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count] [STORE key] [STOREDIST key]</code></p><p>其中，<code>key</code>是指定的键，可选的查询参数包括：</p><p>​<code>FROMMEMBER member</code>：从指定的位置成员开始搜索。</p><p>​<code>FROMCOORD longitude latitude</code>：从指定的经度和纬度开始搜索。</p><p>​<code>BYRADIUS radius unit</code>：根据半径进行搜索。</p><p>​<code>BYBOX width height unit</code>：根据矩形区域进行搜索。</p><p>​<code>WITHCOORD</code>：返回位置的经度和纬度。</p><p>​<code>WITHDIST</code>：返回位置与查询点的距离。</p><p>​<code>ASC|DESC</code>：按距离升序或降序排序。</p><p>​<code>COUNT count</code>：返回最多指定数量的结果。</p><p>​<code>STORE key</code>：将结果存储到指定的键中。</p><p>​<code>STOREDIST key</code>：将结果存储到指定的键中，并同时存储位置与查询点的距离。</p><ul><li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以把结果存储到一个新的key中。</li></ul><p><code>GEOSEARCHSTORE destkey key [FROMMEMBER member] [FROMCOORD longitude latitude] [BYRADIUS radius unit] [BYBOX width height unit] [WITHCOORD] [WITHDIST] [ASC|DESC] [COUNT count] [STOREDIST key]</code></p><h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>Bitmap并不是实际的数据类型，而是定义在String类型上的一个面向字节操作的集合。因为字符串是二进制安全的块，他们的最大长度是512M，最适合设置成2^32个不同字节。Bitmap的最大优势之一在存储信息时极其节约空间。</p><p>BitMap的操作命令有：</p><ul><li>SETBIT：向指定位置（offset）存入一个0或1</li><li>GETBIT：获取指定位置（offset）的bit值</li><li>BITCOUNT：统计BitMap中值为1的bit位的数量</li><li>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中的指定位置（offset）的值</li><li>BITFIELD_RO ：获取BitMap中bit数组，并以十进制形式返回</li><li>BITOP：将多个BitMap的结果做位运算（与 、或、异或）</li><li>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/redis/">redis</category>
      
      
      <category domain="http://example.com/tags/redis/">redis</category>
      
      
      <comments>http://example.com/inori/a9e82450.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git入门</title>
      <link>http://example.com/inori/8e7db504.html</link>
      <guid>http://example.com/inori/8e7db504.html</guid>
      <pubDate>Wed, 10 Apr 2024 07:23:21 GMT</pubDate>
      
      <description>Git常用命令</description>
      
      
      
      <content:encoded><![CDATA[<p>Git是一个分布式的版本控制系统，可以管理应用开发版本，同样可以作为部署工具使用。</p><p>常用的git平台：<a href="https://github.com/">GitHub</a>、<a href="https://gitee.com/">Gitee</a>、<a href="https://gitlab.com/">GitLab</a>等</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>工作区：仓库的目录。工作区是独立于各个分支的。</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本。</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>git config --global user.name xxx</code>：设置全局用户名，信息记录在<del>&#x2F;.gitconfig文件中<br><code>git config --global user.email xxx@xxx.com</code>：设置全局邮箱地址，信息记录在</del>&#x2F;.gitconfig文件中<br><code>git init</code>：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中<br><code>git add XX</code>：将XX文件添加到暂存区</p><ul><li><code>git add .</code>：将所有待加入暂存区的文件加入暂存区</li></ul><p><code>git rm --cached XX</code>：将文件从仓库索引目录中删掉<br><code>git commit -m &quot;备注信息&quot;</code>：将暂存区的内容提交到当前分支<br><code>git status</code>：查看仓库状态<br><code>git diff XX</code>：查看XX文件相对于暂存区修改了哪些内容<br><code>git log</code>：查看当前分支的所有版本<br><code>git reflog</code>：查看HEAD指针的移动历史（包括被回滚的版本）<br><code>git reset --hard HEAD^ 或 git reset --hard HEAD~</code>：将代码库回滚到上一个版本</p><ul><li><code>git reset --hard HEAD^^</code>：往上回滚两次，以此类推</li><li><code>git reset --hard HEAD~100</code>：往上回滚100个版本</li><li><code>git reset --hard 版本号</code>：回滚到某一特定版本</li></ul><p><code>git checkout — XX或git restore XX</code>：将XX文件尚未加入暂存区的修改全部撤销<br><code>git remote add origin git@git.acwing.com:xxx/XXX.git</code>：将本地仓库关联到远程仓库<br><code>git push -u (第一次需要-u以后不需要)</code>：将当前分支推送到远程仓库</p><ul><li><code>git push origin branch_name</code>：将本地的某个分支推送到远程仓库</li></ul><p><code>git clone git@git.acwing.com:xxx/XXX.git</code>：将远程仓库XXX下载到当前目录下<br><code>git checkout -b branch_name</code>：创建并切换到branch_name这个分支<br><code>git branch</code>：查看所有分支和当前所处分支<br><code>git checkout branch_name</code>：切换到branch_name这个分支<br><code>git merge branch_name</code>：将分支branch_name合并到当前分支上<br><code>git branch -d branch_name</code>：删除本地仓库的branch_name分支<br><code>git branch branch_name</code>：创建新分支<br><code>git push --set-upstream origin branch_name</code>：设置本地的branch_name分支对应远程仓库的branch_name分支<br><code>git push -d origin branch_name</code>：删除远程仓库的branch_name分支<br><code>git pull</code>：将远程仓库的当前分支与本地仓库的当前分支合并</p><ul><li><code>git pull origin branch_name</code>：将远程仓库的branch_name分支与本地仓库的当前分支合并</li></ul><p><code>git branch --set-upstream-to=origin/branch_name1 branch_name2</code>：将远程的branch_name1分支与本地的branch_name2分支对应<br><code>git checkout -t origin/branch_name</code>: 将远程的branch_name分支拉取到本地<br><code>git stash</code>：将工作区和暂存区中尚未提交的修改存入栈中<br><code>git stash apply</code>：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素<br><code>git stash drop</code>：删除栈顶存储的修改<br><code>git stash pop</code>：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素<br><code>git stash list</code>：查看栈中所有元素</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/git/">git</category>
      
      
      <category domain="http://example.com/tags/git/">git</category>
      
      
      <comments>http://example.com/inori/8e7db504.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux基础</title>
      <link>http://example.com/inori/a4a81253.html</link>
      <guid>http://example.com/inori/a4a81253.html</guid>
      <pubDate>Wed, 10 Apr 2024 07:23:05 GMT</pubDate>
      
      <description>Linux</description>
      
      
      
      <content:encoded><![CDATA[<p>转载自<a href="https://www.acwing.com/activity/content/57/">AcWing——Linux基础课</a></p><h2 id="文件操作常用命令"><a href="#文件操作常用命令" class="headerlink" title="文件操作常用命令"></a>文件操作常用命令</h2><ul><li><p>ctrl c: 取消命令，并且换行</p></li><li><p>ctrl u: 清空本行命令</p></li><li><p>tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</p></li><li><p>ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</p></li><li><p>pwd: 显示当前路径</p></li><li><p>cd XXX: 进入XXX目录下, cd .. 返回上层目录</p></li><li><p>cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如..&#x2F;dir_c&#x2F;a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</p></li><li><p>mkdir XXX: 创建目录XXX</p></li><li><p>rm XXX: 删除普通文件</p><ul><li>rm XXX -r: 删除文件夹</li></ul></li><li><p>mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令</p></li><li><p>touch XXX: 创建一个文件</p></li><li><p>cat XXX: 展示文件XXX中的内容</p></li><li><p>复制文本</p><ul><li><p>windows&#x2F;Linux下：Ctrl + insert</p></li><li><p>Mac下：command + c</p></li></ul></li><li><p>粘贴文本</p><ul><li><p>windows&#x2F;Linux下：Shift + insert</p></li><li><p>Mac下：command + v</p></li></ul></li></ul><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><ul><li><p>功能</p><ul><li><p>分屏</p></li><li><p>允许断开Terminal连接后，继续运行进程</p></li></ul></li><li><p>结构：</p><ul><li>一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane</li><li>操作（魔改后）：<ul><li>tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</li><li>按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。</li><li>按下Ctrl + a后手指松开，然后按”（注意是双引号”）：将当前pane上下平分成两个pane。</li><li>Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</li><li>鼠标点击可以选pane。</li><li>按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。</li><li>鼠标拖动pane之间的分割线，可以调整分割线的位置。</li><li>按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。</li><li>按下ctrl + a后手指松开，然后按z：将当前pane全屏&#x2F;取消全屏。</li><li>按下ctrl + a后手指松开，然后按d：挂起当前session。</li><li>tmux a：打开之前挂起的session。</li><li>按下ctrl + a后手指松开，然后按s：选择其它session。<br>方向键 —— 上：选择上一项 session&#x2F;window&#x2F;pane<br>方向键 —— 下：选择下一项 session&#x2F;window&#x2F;pane<br>方向键 —— 右：展开当前项 session&#x2F;window<br>方向键 —— 左：闭合当前项 session&#x2F;window</li><li>按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。</li><li>按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。</li><li>按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。</li><li>鼠标滚轮：翻阅当前pane内的内容。</li><li>在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</li><li>tmux中复制&#x2F;粘贴文本的通用方式：<br> 1. 按下Ctrl + a后松开手指，然后按[<br>      2. 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板<br>      3. 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</li></ul></li></ul></li></ul><h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><ul><li>功能：<ul><li>命令行模式下的文本编辑器。</li><li>根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</li><li>使用方式：vim filename<ul><li>如果已有该文件，则打开它。</li><li>如果没有该文件，则打开个一个新的文件，并命名为filename</li></ul></li></ul></li><li>模式：<ul><li>一般命令模式<ul><li>默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</li><li>编辑模式<br>   在一般命令模式里按下i，会进入编辑模式。<br>   按下ESC会退出编辑模式，返回到一般命令模式。</li><li>命令行模式<br>   在一般命令模式里按下:&#x2F;?三个字母中的任意一个，会进入命令行模式。命令行在最下面。<br>   可以查找、替换、保存、退出、配置编辑器等。</li></ul></li></ul></li><li>操作：<ul><li>i和a：进入编辑模式</li><li>ESC：进入一般命令模式<ul><li>h 或 左箭头键：光标向左移动一个字符</li><li>j 或 向下箭头：光标向下移动一个字符</li><li>k 或 向上箭头：光标向上移动一个字符</li><li>l 或 向右箭头：光标向右移动一个字符</li><li>n<Space>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</li><li>0 或 功能键[Home]：光标移动到本行开头</li><li><code>$ 或 功能键[End]</code>：光标移动到本行末尾</li><li>G：光标移动到最后一行</li><li>:n 或 nG：n为数字，光标移动到第n行</li><li>gg：光标移动到第一行，相当于1G</li><li>n<Enter>：n为数字，光标向下移动n行</li><li>&#x2F;word：向光标之下寻找第一个值为word的字符串。</li><li>?word：向光标之上寻找第一个值为word的字符串。</li><li>n：重复前一个查找操作</li><li>N：反向重复前一个查找操作</li><li>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</li><li>:1,$s&#x2F;word1&#x2F;word2&#x2F;g：将全文的word1替换为word2<br>        (20) :1,$s&#x2F;word1&#x2F;word2&#x2F;gc：将全文的word1替换为word2，且在替换前要求用户确认。</li><li>v：选中文本</li><li>d：删除选中的文本</li><li>dd: 删除当前行</li><li>y：复制选中的文本</li><li>yy: 复制当前行</li><li>p: 将复制的数据在光标的下一行&#x2F;下一个位置粘贴</li><li>u：撤销</li><li>Ctrl + r：取消撤销</li><li>大于号 &gt;：将选中的文本整体向右缩进一次</li><li>小于号 &lt;：将选中的文本整体向左缩进一次</li><li>:w 保存</li><li>:w! 强制保存</li><li>:q 退出</li><li>:q! 强制退出</li><li>:wq 保存并退出</li><li>:set paste 设置成粘贴模式，取消代码自动缩进</li><li>:set nopaste 取消粘贴模式，开启代码自动缩进</li><li>:set nu 显示行号</li><li>:set nonu 隐藏行号</li><li>gg&#x3D;G：将全文代码格式化</li><li>:noh 关闭查找关键词高亮</li><li>Ctrl + q：当vim卡死时，可以取消当前正在执行的命令</li></ul></li></ul></li><li>异常处理：<ul><li>每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。</li><li>如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<ol><li>找到正在打开该文件的程序，并退出</li><li>直接删掉该swp文件</li></ol></li></ul></li></ul><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ul><li>远程登录服务器：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname</span><br></pre></td></tr></table></figure><p>user: 用户名<br>hostname: IP地址或域名</p><ul><li>第一次登录时会提示：</li></ul><blockquote><p> The authenticity of host ‘123.57.47.211 (123.57.47.211)’ can’t be established.<br>ECDSA key fingerprint is SHA256:iy237yysfCe013&#x2F;l+kpDGfEG9xxHxm0dnxnAbJTPpG8.<br>Are you sure you want to continue connecting (yes&#x2F;no&#x2F;[fingerprint])?</p></blockquote><p>输入yes，然后回车即可。<br>这样会将该服务器的信息记录在~&#x2F;.ssh&#x2F;known_hosts文件中。</p><p>然后输入密码即可登录到远程服务器中。</p><p>默认登录端口号为22。如果想登录某一特定端口：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh user@hostname -p 22</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>创建文件 ~&#x2F;.ssh&#x2F;config。</p><p>然后在文件中输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host myserver1</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br><span class="line"></span><br><span class="line">Host myserver2</span><br><span class="line">    HostName IP地址或域名</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure><p>之后再使用服务器时，可以直接使用别名myserver1、myserver2。</p><h3 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h3><p>创建密钥：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>执行结束后，~&#x2F;.ssh&#x2F;目录下会多两个文件：</p><ol><li>id_rsa：私钥</li><li>id_rsa.pub：公钥</li></ol><p>之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。</p><p>例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~&#x2F;.ssh&#x2F;authorized_keys文件里即可。</p><p>也可以使用如下命令一键添加公钥：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-copy-id myserver</span><br></pre></td></tr></table></figure><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>命令格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh user@hostname command</span><br></pre></td></tr></table></figure><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道类似于文件重定向，可以将前一个命令的stdout重定向到下一个命令的stdin。</p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li><p>管道命令仅处理<code>stdout</code>，会忽略<code>stderr</code></p></li><li><p>管道右边的命令必须能接受<code>stdin</code></p></li><li><p>多个管道命令可以串联</p></li><li><p>与文件重定向的区别</p></li><li><p>文件重定向左边为命令，右边为文件。</p></li><li><p>管道左右两边均为命令，左边有stdout，右边有stdin。</p></li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>统计当前目录下所有python文件的总行数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name &#x27;*.py&#x27; | xargs cat | wc -l</span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>Linux系统中会用很多环境变量来记录配置信息。<br>环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><p>列出当前环境下的所有环境变量：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">env  # 显示当前用户的变量</span><br><span class="line">set  # 显示当前shell的变量，包括当前用户的变量;</span><br><span class="line">export  # 显示当前导出成用户变量的shell变量</span><br></pre></td></tr></table></figure><p>输出某个环境变量的值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>为了将对环境变量的修改应用到未来所有环境下，可以将修改命令放到<del>&#x2F;.bashrc文件中。<br>修改完</del>&#x2F;.bashrc文件后，记得执行source ~&#x2F;.bashrc，来将修改应用到当前的bash环境下。</p><p>为何将修改命令放到~&#x2F;.bashrc，就可以确保修改会影响未来所有的环境呢？</p><ul><li>每次启动bash，都会先执行~&#x2F;.bashrc。</li><li>每次ssh登陆远程服务器，都会启动一个bash命令行给我们。</li><li>每次tmux新开一个pane，都会启动一个bash命令行给我们。</li><li>所以未来所有新开的环境都会加载我们修改的内容。</li></ul><h3 id="常见环境变量"><a href="#常见环境变量" class="headerlink" title="常见环境变量"></a>常见环境变量</h3><ol><li>HOME：用户的家目录。</li><li>PATH：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。</li><li>LD_LIBRARY_PATH：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。</li><li>C_INCLUDE_PATH：C语言的头文件路径，内容是以冒号分隔的路径列表。</li><li>CPLUS_INCLUDE_PATH：CPP的头文件路径，内容是以冒号分隔的路径列表。</li><li>PYTHONPATH：Python导入包的路径，内容是以冒号分隔的路径列表。</li><li>JAVA_HOME：jdk的安装目录。</li><li>CLASSPATH：存放Java导入类的路径，内容是以冒号分隔的路径列表。</li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="系统状况"><a href="#系统状况" class="headerlink" title="系统状况"></a>系统状况</h3><ol><li><p>top：查看所有进程的信息（Linux的任务管理器）</p><ul><li>打开后，输入M：按使用内存排序</li><li>打开后，输入P：按使用CPU排序</li><li>打开后，输入q：退出</li></ul></li><li><p>df -h：查看硬盘使用情况</p></li><li><p>free -h：查看内存使用情况</p></li><li><p>du -sh：查看当前目录占用的硬盘空间</p></li><li><p>ps aux：查看所有进程</p></li><li><p>kill -9 pid：杀死编号为pid的进程</p><ul><li>传递某个具体的信号：<code>kill -s SIGTERM pid</code></li></ul></li><li><p>netstat -nt：查看所有网络连接</p></li><li><p>w：列出当前登陆的用户</p></li><li><p>ping <code>某url</code>：检查是否连网</p></li></ol><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li>chmod：修改文件权限<ul><li>chmod +x xxx：给xxx添加可执行权限</li><li>chmod -x xxx：去掉xxx的可执行权限</li><li>chmod 777 xxx：将xxx的权限改成777</li><li>chmod 777 xxx -R：递归修改整个文件夹的权限</li></ul></li></ul><h3 id="文件检索"><a href="#文件检索" class="headerlink" title="文件检索"></a>文件检索</h3><ol><li><p>find &#x2F;path&#x2F;to&#x2F;directory&#x2F; -name ‘<em>.py’：搜索某个文件路径下的所有</em>.py文件</p></li><li><p>grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。</p></li><li><p>wc：统计行数、单词数、字节数</p><ul><li>既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；</li><li>wc -l：统计行数</li><li>wc -w：统计单词数</li><li>wc -c：统计字节数</li></ul></li><li><p>tree：展示当前目录的文件结构</p><ul><li>tree &#x2F;path&#x2F;to&#x2F;directory&#x2F;：展示某个目录的文件结构</li><li>tree -a：展示隐藏文件</li></ul></li><li><p>ag xxx：搜索当前目录下的所有文件，检索xxx字符串</p></li><li><p>cut：分割一行内容</p><ul><li>从stdin中读入多行数据</li><li><code>echo $PATH | cut -d &#39;:&#39; -f 3,5</code>：输出PATH用:分割后第3、5列数据</li><li><code>echo $PATH | cut -d &#39;:&#39; -f 3-5</code>：输出PATH用:分割后第3-5列数据</li><li><code>echo $PATH | cut -c 3,5</code>：输出PATH的第3、5个字符</li><li><code>echo $PATH | cut -c 3-5</code>：输出PATH的第3-5个字符</li></ul></li><li><p>sort：将每行内容按字典序排序</p><ul><li><p>可以从stdin中读取多行数据</p></li><li><p>可以从命令行参数中读取文件名列表</p></li></ul></li><li><p>xargs：将stdin中的数据用空格或回车分割成命令行参数</p><ul><li>find . -name ‘*.py’ | xargs cat | wc -l：统计当前目录下所有python文件的总行数</li></ul></li></ol><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><ol><li><p>more：浏览文件内容</p><ul><li><p>回车：下一行</p></li><li><p>空格：下一页</p></li><li><p>b：上一页</p></li><li><p>q：退出</p></li></ul></li><li><p>less：与more类似，功能更全</p><ul><li>回车：下一行</li><li>y：上一行</li><li>Page Down：下一页</li><li>Page Up：上一页</li><li>q：退出</li></ul></li><li><p>head -3 xxx：展示xxx的前3行内容，同时支持从stdin读入内容</p></li><li><p>ail -3 xxx：展示xxx末尾3行内容，同时支持从stdin读入内容</p></li></ol><h3 id="用户相关"><a href="#用户相关" class="headerlink" title="用户相关"></a>用户相关</h3><p><code>history</code>：展示当前用户的历史操作。内容存放在~&#x2F;.bash_history中</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ol><li>md5sum：计算md5哈希值<ul><li>可以从stdin读入内容</li><li>可以在命令行参数中传入文件名列表</li></ul></li><li>time command：统计command命令的执行时间</li><li>ipython3：交互式python3环境。可以当做计算器，或者批量管理文件<ul><li><code>! echo &quot;Hello World&quot;</code>：!表示执行shell脚本</li></ul></li><li>watch -n 0.1 command：每0.1秒执行一次command命令</li><li>tar：压缩文件<ul><li>tar -zcvf xxx.tar.gz &#x2F;path&#x2F;to&#x2F;file&#x2F;*：压缩</li><li>tar -zxvf xxx.tar.gz：解压缩</li></ul></li><li>diff xxx yyy：查找文件xxx与yyy的不同点</li></ol><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><ul><li>sudo command：以root身份执行command命令</li><li>apt-get install xxx：安装软件</li><li>pip install xxx –user –upgrade：安装python包</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Linux/">Linux</category>
      
      
      <category domain="http://example.com/tags/Linux/">Linux</category>
      
      
      <comments>http://example.com/inori/a4a81253.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis入门篇</title>
      <link>http://example.com/inori/8660e5c0.html</link>
      <guid>http://example.com/inori/8660e5c0.html</guid>
      <pubDate>Fri, 05 Apr 2024 08:40:29 GMT</pubDate>
      
      <description>redis入门</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://www.redis.net.cn/">Redis</a>是一个基于<strong>内存</strong>的<u>key-value</u>结构NoSql数据库。相比于常规的数据库，Redis</p><ul><li>基于内存存储，读写性能高</li><li>适合存储热点数据（热点商品、资讯、新闻）和在短时间内有大量访问的数据</li><li>应用广泛</li></ul><h2 id="Redis启动"><a href="#Redis启动" class="headerlink" title="Redis启动"></a>Redis启动</h2><p>安装好Redis并配置好环境变量之后，在cmd中使用<code>redis-server</code>启动redis，Redis服务默认端口号为6379。</p><p>使用命令<code>redis-cli</code>连接客户端，默认连接的是本地的redis服务，并且使用默认6379端口。也可以通过指定如下参数连接：-h ip地址-p 端口号 -a 密码（如果有）</p><p>也可以使用<a href="https://github.com/qishibo/AnotherRedisDesktopManager">Another-Redis-Desktop-Manager</a>图形化工具连接和管理Redis</p><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><p>Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：</p><ul><li>字符串(string)：普通字符串，Redis中最简单的数据类型</li><li>哈希(hash)：类似于Java中的HashMap结构</li><li>列表(list)：按照插入顺序排序，可以有重复元素，类似于Java中的LinkedList</li><li>集合(set)：无序集合，没有重复元素，类似于Java中的HashSet</li><li>有序集合(zset)：集合中每个元素关联一个分数（score），根据分数升序排序，没有重复元素</li></ul><h2 id="Redis操作命令"><a href="#Redis操作命令" class="headerlink" title="Redis操作命令"></a>Redis操作命令</h2><h3 id="字符串操作命令"><a href="#字符串操作命令" class="headerlink" title="字符串操作命令"></a>字符串操作命令</h3><ul><li><code>SET key value</code>：设置指定key的值</li><li><code>GET key</code>：获取指定key的值</li><li><code>SETEX key seconds value</code>：设置指定key的值，并将 key 的过期时间设为 seconds 秒</li><li><code>SETNX key value</code>：只有在 key 不存在时设置 key 的值</li></ul><h3 id="哈希操作命令"><a href="#哈希操作命令" class="headerlink" title="哈希操作命令"></a>哈希操作命令</h3><ul><li><code>HSET key field value</code>：将哈希表 key 中的字段 field 的值设为 value</li><li><code>HGET key field</code>：获取存储在哈希表中指定字段的值</li><li><code>HDEL key field</code>：删除存储在哈希表中的指定字段</li><li><code>HKEYS key</code>：获取哈希表中所有字段</li><li><code>HVALS key</code>：获取哈希表中所有值</li></ul><h3 id="列表操作命令"><a href="#列表操作命令" class="headerlink" title="列表操作命令"></a>列表操作命令</h3><ul><li><code>LPUSH key value1 [value2]</code>：将一个或多个值插入到列表头部(左边)</li><li><code>LRANGE key start stop</code>：获取列表指定范围内的元素</li><li><code>RPOP key</code>：移除并获取列表最后一个元素(右边)</li><li><code>LLEN key</code>：获取列表长度</li></ul><h3 id="集合操作命令"><a href="#集合操作命令" class="headerlink" title="集合操作命令"></a>集合操作命令</h3><ul><li><code>SADD key member1 [member2]</code>：向集合添加一个或多个成员</li><li><code>SMEMBERS key</code>：返回集合中的所有成员</li><li><code>SCARD key</code>：获取集合的成员数</li><li><code>SINTER key1 [key2]</code>：返回给定所有集合的交集</li><li><code>SUNION key1 [key2]</code>：返回所有给定集合的并集</li><li><code>SREM key member1 [member2]</code>：删除集合中一个或多个成员</li></ul><h3 id="有序集合操作命令"><a href="#有序集合操作命令" class="headerlink" title="有序集合操作命令"></a>有序集合操作命令</h3><ul><li><code>ZADD key score1 member1 [score2 member2]</code>：向有序集合添加一个或多个成员</li><li><code>ZRANGE key start stop [WITHSCORES]</code>：通过索引区间返回有序集合中指定区间内的成员</li><li><code>ZINCRBY key increment member</code>：有序集合中对指定成员的分数加上增量increment</li><li><code>ZREM key member [member ...]</code>：移除有序集合中的一个或多个成员</li></ul><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li><code>KEYS pattern</code>：查找所有符合给定模式(pattern)的key </li><li><code>EXISTS key</code>：检查给定key是否存在</li><li><code>TYPE key</code>：返回key所储存的值的类型</li><li><code>DEL key</code>：该命令用于在key存在时删除 key</li></ul><h2 id="在Java中操作Redis"><a href="#在Java中操作Redis" class="headerlink" title="在Java中操作Redis"></a>在Java中操作Redis</h2><p>Redis的Java客户端很多，常用的有：<u>Jedis</u>、<u>Lettuce</u>、<u><strong>Spring Data Redis</strong></u></p><p>其中Spring Data Redis是Spring的一部分，对Redis底层开发包进行了高度封装。在Spring项目中，可以使用Spring Data Redis来简化操作。</p><h3 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h3><ol><li>导入Spring Data Redis的maven坐标</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置Redis数据源</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">$&#123;lty.redis.host&#125;</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">$&#123;lty.redis.port&#125;</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">$&#123;lty.redis.database&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>编写配置类，创建RedisTemplate对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        <span class="type">RedisTemplate</span> <span class="variable">redisTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>();</span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer将key序列化，避免乱码</span></span><br><span class="line">        redisTemplate.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>通过RedisTemplate对象操作Redis</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DishService dishService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;DishVO&gt;&gt; <span class="title function_">test</span><span class="params">(Long categoryId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish_&quot;</span> + categoryId;</span><br><span class="line">        List&lt;DishVO&gt; list = (List&lt;DishVO&gt;) redisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="keyword">if</span>(list != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// redis中存在数据，直接返回</span></span><br><span class="line">            <span class="keyword">return</span> Result.success(list);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 否则从数据库中查数据</span></span><br><span class="line">        <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dish</span>();</span><br><span class="line">        dish.setCategoryId(categoryId);</span><br><span class="line">        dish.setStatus(StatusConstant.ENABLE);</span><br><span class="line">        list = dishService.listWithFlavor(dish);</span><br><span class="line">        <span class="comment">// 查出来的数据加入到redis中</span></span><br><span class="line">        redisTemplate.opsForValue().set(key, list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Data-Redis使用方式"><a href="#Spring-Data-Redis使用方式" class="headerlink" title="Spring Data Redis使用方式"></a>Spring Data Redis使用方式</h2><p>RedisTemplate针对大量api进行了归类封装,将同一数据类型的操作封装为对应的Operation接口，具体分类如下：</p><ul><li>ValueOperations：string类型数据操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：hash类型的数据操作</li><li>ListOperations：list类型的数据操作</li></ul><h3 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h3><p><code>set void set(K key, V value)</code>：添加获取数据</p><p><code>set void set(K key, V value, long timeout, TimeUnit unit)</code>：设置数据有效期</p><blockquote><p>TimeUnit.DAYS          &#x2F;&#x2F;天<br>TimeUnit.HOURS         &#x2F;&#x2F;小时<br>TimeUnit.MINUTES       &#x2F;&#x2F;分钟<br>TimeUnit.SECONDS       &#x2F;&#x2F;秒<br>TimeUnit.MILLISECONDS  &#x2F;&#x2F;毫秒</p></blockquote><p><code>set void set(K key, V value, long offset)</code>:根据key设置value指定下标字符</p><p><code>get V get(Object key)</code>:Get操作</p><p><code>getAndSet V getAndSet(K key, V value)</code>:设置键的字符串值并返回其旧值</p><p><code>append Integer append(K key, String value)</code>:根据key拼接value的值，如果被拼接的key没值则为空字符串</p><p><code>size Long size(K key)</code>:根据key获取value的长度</p><h3 id="List操作"><a href="#List操作" class="headerlink" title="List操作"></a>List操作</h3><p><code>Long size(K key)</code>:返回存储在键中的列表的长度。如果键不存在，则将其解释为空列表，并返回0。当key存储的值不是列表时返回错误。</p><p><code>Long leftPush(K key, V value)</code>:（从左边插入）将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。</p><p><code>Long leftPushAll(K key, V... values)</code>:（从左边插入）批量把一个数组插入到列表中</p><p><code>Long rightPush(K key, V value)</code>:（从右边插入）将所有指定的值插入存储在键的列表的头部。如果键不存在，则在执行推送操作之前将其创建为空列表。（从右边插入）</p><p><code>Long rightPushAll(K key, V... values)</code>:（从右边插入）批量把一个数组插入到列表中</p><p><code>void set(K key, long index, V value)</code>:在列表中index的位置设置value值</p><p><code>Long remove(K key, long count, Object value)</code>:从存储在键中的列表中删除等于值的元素的第一个计数事件。</p><blockquote><p>计数参数以下列方式影响操作：<br>count&gt; 0：删除等于从头到尾移动的值的元素。<br>count &lt;0：删除等于从尾到头移动的值的元素。<br>count &#x3D; 0：删除等于value的所有元素。 </p></blockquote><p><code>V index(K key, long index)</code>:根据下标获取列表中的值，下标是从0开始的，-1为获取全部</p><p><code>V leftPop(K key)</code>:弹出最左边的元素</p><p><code>V rightPop(K key)</code>:弹出最右边的元素</p><h3 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h3><p><code>Long delete(H key, Object... hashKeys)</code>:删除给定的哈希hashKeys</p><p><code>Boolean hasKey(H key, Object hashKey)</code>:判断哈希hashKey是否存在</p><p><code>HV get(H key, Object hashKey)</code>:从键中的哈希获取给定hashKey的值</p><p><code>Set keys(H key)</code>:获取key所对应的散列表的key</p><p><code>Long size(H key)</code>:获取key所对应的散列表的大小个数</p><p><code>void putAll(H key, Map&lt;? extends HK, ? extends HV&gt; m)</code>:使用m中提供的多个散列字段设置到key对应的散列表中</p><p><code>void put(H key, HK hashKey, HV value)</code>:设置散列hashKey的值</p><p><code>List values(H key)</code>:获取整个哈希存储的值根据密钥</p><p><code>Map&lt;HK, HV&gt; entries(H key)</code>:获取整个哈希存储根据密钥</p><p><code>Cursor&lt;Map.Entry&lt;HK, HV&gt;&gt; scan(H key, ScanOptions options)</code>:使用Cursor在key的hash中迭代，相当于迭代器。</p><h3 id="Set操作"><a href="#Set操作" class="headerlink" title="Set操作"></a>Set操作</h3><p><code>Long add(K key, V... values)</code>:无序集合中添加元素，返回添加个数也可以直接在add里面添加多个值 如：template.opsForSet().add(“setTest”,”aaa”,”bbb”)</p><p><code>Long remove(K key, Object... values)</code>:移除集合中一个或多个成员</p><p><code>V pop(K key)</code>:移除并返回集合中的一个随机元素</p><p><code>Boolean move(K key, V value, K destKey)</code>:将 member 元素从 source 集合移动到 destination 集合</p><p><code>Long size(K key)</code>:无序集合的大小长度</p><p><code>et members(K key)</code>:返回集合中的所有成员</p><p><code>Cursor scan(K key, ScanOptions options)</code>:遍历set</p><h3 id="ZSet操作"><a href="#ZSet操作" class="headerlink" title="ZSet操作"></a>ZSet操作</h3><p><code>Boolean add(K key, V value, double score)</code>:新增一个有序集合，存在的话为false，不存在的话为true</p><p><code>Long add(K key, Set&lt;TypedTuple&gt; tuples)</code>:新增一个有序集合</p><p><code>Long remove(K key, Object... values)</code>:从有序集合中移除一个或者多个元素</p><p><code>Long rank(K key, Object o)</code>:返回有序集中指定成员的排名，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Set range(K key, long start, long end)</code>:通过索引区间返回有序集合成指定区间内的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Long count(K key, double min, double max)</code>:通过分数返回有序集合指定区间内的成员个数</p><p><code>Long size(K key)</code>:获取有序集合的成员数，内部调用的就是zCard方法</p><p><code>Double score(K key, Object o)</code>:获取指定成员的score值</p><p><code>Long removeRange(K key, long start, long end)</code>:移除指定索引位置的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p><p><code>Cursor&lt;TypedTuple&gt; scan(K key, ScanOptions options)</code>:遍历zset</p><h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><p>Spring Cache 是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。</p><p>它提供了一层抽象，底层可以切换不同的缓存实现，例如：</p><ul><li>EHCache</li><li>Caffeine</li><li>Redis</li></ul><p>需要引入Maven坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@EnableCaching</td><td align="center">开启缓存注解功能，通常加在启动类上</td></tr><tr><td align="center">@Cacheable(cacheNames&#x3D;”数据库名”,key&#x3D;”存储的键”)</td><td align="center">在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td align="center">@CachePut</td><td align="center">将方法的返回值放到缓存中</td></tr><tr><td align="center">@CacheEvict(cacheNames &#x3D; “数据库名”,[allEntries(是否全部删除) &#x3D; true],key &#x3D; “要删除的键”)</td><td align="center">将一条或多条数据从缓存中删除</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/redis/">redis</category>
      
      
      <category domain="http://example.com/tags/redis/">redis</category>
      
      
      <comments>http://example.com/inori/8660e5c0.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MyBatis-Plus</title>
      <link>http://example.com/inori/1276cc28.html</link>
      <guid>http://example.com/inori/1276cc28.html</guid>
      <pubDate>Wed, 27 Mar 2024 04:09:06 GMT</pubDate>
      
      <description>MyBatis</description>
      
      
      
      <content:encoded><![CDATA[<p><a href="https://baomidou.com/">MyBatis-Plus</a>是<a href="https://www.mybatis.org/mybatis-3/">MyBatis</a>的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生</p><p>特性：</p><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><p>支持数据库：</p><ul><li>MySQL，Oracle，DB2，H2，HSQL，SQLite，PostgreSQL，SQLServer，Phoenix，Gauss ，ClickHouse，Sybase，OceanBase，Firebird，Cubrid，Goldilocks，csiidb，informix，TDengine，redshift</li><li>达梦数据库，虚谷数据库，人大金仓数据库，南大通用(华库)数据库，南大通用数据库，神通数据库，瀚高数据库，优炫数据库</li></ul><h2 id="MyBatis-Plus核心功能"><a href="#MyBatis-Plus核心功能" class="headerlink" title="MyBatis-Plus核心功能"></a>MyBatis-Plus核心功能</h2><h3 id="基于Mapper接口CRUD"><a href="#基于Mapper接口CRUD" class="headerlink" title="基于Mapper接口CRUD"></a>基于Mapper接口CRUD</h3><blockquote><p>通用 CRUD 封装BaseMapper接口，<code>Mybatis-Plus</code>启动时自动解析实体表关系映射转换为 <code>Mybatis</code> 内部对象注入容器! 内部包含常见的单表操作！</p></blockquote><h4 id="Insert方法"><a href="#Insert方法" class="headerlink" title="Insert方法"></a>Insert方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入一条记录</span></span><br><span class="line"><span class="comment">// T 就是要插入的实体对象</span></span><br><span class="line"><span class="comment">// 默认主键生成策略为雪花算法（后面讲解）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>T</td><td>entity</td><td>实体对象</td></tr></tbody></table><h4 id="Delete方法"><a href="#Delete方法" class="headerlink" title="Delete方法"></a>Delete方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>Wrapper<T></td><td>wrapper</td><td>实体对象封装操作类（可以为 null）</td></tr><tr><td>Collection&lt;? extends Serializable&gt;</td><td>idList</td><td>主键 ID 列表(不能为 null 以及 empty)</td></tr><tr><td>Serializable</td><td>id</td><td>主键 ID</td></tr><tr><td>Map&lt;String, Object&gt;</td><td>columnMap</td><td>表字段 map 对象</td></tr></tbody></table><h4 id="Update方法"><a href="#Update方法" class="headerlink" title="Update方法"></a>Update方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T updateEntity, </span></span><br><span class="line"><span class="params"><span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 修改  主键属性必须值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>T</td><td>entity</td><td>实体对象 (set 条件值,可为 null)</td></tr><tr><td>Wrapper<T></td><td>updateWrapper</td><td>实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</td></tr></tbody></table><h4 id="Select方法"><a href="#Select方法" class="headerlink" title="Select方法"></a>Select方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询一条记录</span></span><br><span class="line">T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLLECTION)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(<span class="meta">@Param(Constants.COLUMN_MAP)</span> Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录。注意： 只返回第一个字段的值</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;T&gt; <span class="title function_">selectPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line">IPage&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMapsPage</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line">Integer <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br></pre></td></tr></table></figure><p>参数说明</p><table><thead><tr><th>类型</th><th>参数名</th><th>描述</th></tr></thead><tbody><tr><td>Serializable</td><td>id</td><td>主键 ID</td></tr><tr><td>Wrapper<T></td><td>queryWrapper</td><td>实体对象封装操作类（可以为 null）</td></tr><tr><td>Collection&lt;? extends Serializable&gt;</td><td>idList</td><td>主键 ID 列表(不能为 null 以及 empty)</td></tr><tr><td>Map&lt;String, Object&gt;</td><td>columnMap</td><td>表字段 map 对象</td></tr><tr><td>IPage<T></td><td>page</td><td>分页查询条件（可以为 RowBounds.DEFAULT）</td></tr></tbody></table><h4 id="自定义和多表映射"><a href="#自定义和多表映射" class="headerlink" title="自定义和多表映射"></a>自定义和多表映射</h4><p>mybatis-plus的默认mapperxml位置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> <span class="comment"># mybatis-plus的配置</span></span><br><span class="line"><span class="comment"># 默认位置 private String[] mapperLocations = new String[]&#123;&quot;classpath*:/mapper/**/*.xml&quot;&#125;;    </span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:/mapper/*.xml</span></span><br></pre></td></tr></table></figure><p>自定义mapper方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正常自定义方法！</span></span><br><span class="line"><span class="comment">//可以使用注解@Select或者mapper.xml实现</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于mapper.xml实现：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="string">&quot;https://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- namespace = 接口的全限定符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> &gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基于Service接口CRUD"><a href="#基于Service接口CRUD" class="headerlink" title="基于Service接口CRUD"></a>基于Service接口CRUD</h3><p>通用 Service CRUD 封装<a href="https://gitee.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-extension/src/main/java/com/baomidou/mybatisplus/extension/service/IService.java">IService (opens new window)</a>接口，进一步封装 CRUD 采用 <code>get 查询单行</code> <code>remove 删除</code> <code>list 查询集合</code> <code>page 分页</code> 前缀命名方式区分 <code>Mapper</code> 层避免混淆，</p><h4 id="对比Mapper接口CRUD区别："><a href="#对比Mapper接口CRUD区别：" class="headerlink" title="对比Mapper接口CRUD区别："></a>对比Mapper接口CRUD区别：</h4><ul><li>service添加了批量方法</li><li>service层的方法自动添加事务</li></ul><h4 id="使用Iservice接口方式"><a href="#使用Iservice接口方式" class="headerlink" title="使用Iservice接口方式"></a>使用Iservice接口方式</h4><p>接口继承IService接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类继承ServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper,User&gt; <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CRUD方法介绍"><a href="#CRUD方法介绍" class="headerlink" title="CRUD方法介绍"></a>CRUD方法介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">保存：</span><br><span class="line"><span class="comment">// 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 插入（批量）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">修改或者保存：</span><br><span class="line"><span class="comment">// TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 批量修改插入</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">移除：</span><br><span class="line"><span class="comment">// 根据 queryWrapper 设置的条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 删除</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">更新：</span><br><span class="line"><span class="comment">// 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 whereWrapper 条件，更新记录</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T updateEntity, Wrapper&lt;T&gt; whereWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 ID 选择修改</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span>;</span><br><span class="line"><span class="comment">// 根据ID 批量更新</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">数量： </span><br><span class="line"><span class="comment">// 查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">查询：</span><br><span class="line"><span class="comment">// 根据 ID 查询</span></span><br><span class="line">T <span class="title function_">getById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录。结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper，查询一条记录</span></span><br><span class="line">&lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line">集合：</span><br><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询（根据ID 批量查询）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"><span class="comment">// 查询（根据 columnMap 条件）</span></span><br><span class="line">Collection&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span>;</span><br><span class="line"><span class="comment">// 查询所有列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">// 查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"><span class="comment">// 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line">&lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分页查询实现"><a href="#分页查询实现" class="headerlink" title="分页查询实现"></a>分页查询实现</h3><ol><li>导入分页插件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>(DbType.MYSQL));</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用分页查询</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置分页参数</span></span><br><span class="line">    Page&lt;User&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    userMapper.selectPage(page, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//获取分页数据</span></span><br><span class="line">    List&lt;User&gt; list = page.getRecords();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">&quot;当前页：&quot;</span>+page.getCurrent());</span><br><span class="line">    System.out.println(<span class="string">&quot;每页显示的条数：&quot;</span>+page.getSize());</span><br><span class="line">    System.out.println(<span class="string">&quot;总记录数：&quot;</span>+page.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;总页数：&quot;</span>+page.getPages());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有上一页：&quot;</span>+page.hasPrevious());</span><br><span class="line">    System.out.println(<span class="string">&quot;是否有下一页：&quot;</span>+page.hasNext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义的mapper方法使用分页</li></ol><p>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入参数携带Ipage接口</span></span><br><span class="line"><span class="comment">//返回结果为IPage</span></span><br><span class="line">IPage&lt;User&gt; <span class="title function_">selectPageVo</span><span class="params">(IPage&lt;?&gt; page, Integer id)</span>;</span><br></pre></td></tr></table></figure><p>接口实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectPageVo&quot;</span> resultType=<span class="string">&quot;xxx.xxx.xxx.User&quot;</span>&gt;</span><br><span class="line">SELECT * FROM user WHERE id &gt; #&#123;id&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    userMapper.selectPageVo(page,<span class="number">2</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> page.getCurrent();</span><br><span class="line">    System.out.println(<span class="string">&quot;current = &quot;</span> + current);</span><br><span class="line">    <span class="type">long</span> <span class="variable">pages</span> <span class="operator">=</span> page.getPages();</span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + pages);</span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> page.getTotal();</span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + total);</span><br><span class="line">    <span class="type">List</span> <span class="variable">records</span> <span class="operator">=</span> page.getRecords();</span><br><span class="line">    System.out.println(<span class="string">&quot;records = &quot;</span> + records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件构造器使用"><a href="#条件构造器使用" class="headerlink" title="条件构造器使用"></a>条件构造器使用</h3><h4 id="条件构造器作用"><a href="#条件构造器作用" class="headerlink" title="条件构造器作用"></a>条件构造器作用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>); <span class="comment">// 添加等于条件</span></span><br><span class="line">queryWrapper.ne(<span class="string">&quot;age&quot;</span>, <span class="number">30</span>); <span class="comment">// 添加不等于条件</span></span><br><span class="line">queryWrapper.like(<span class="string">&quot;email&quot;</span>, <span class="string">&quot;@gmail.com&quot;</span>); <span class="comment">// 添加模糊匹配条件</span></span><br><span class="line">等同于： </span><br><span class="line">delete from user <span class="type">where</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;John&quot;</span> and age != <span class="number">30</span></span><br><span class="line">and email like <span class="string">&quot;%@gmail.com%&quot;</span></span><br><span class="line"><span class="comment">// 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure><p>使用MyBatis-Plus的条件构造器，你可以构建灵活、高效的查询条件，而不需要手动编写复杂的 SQL 语句。它提供了许多方法来支持各种条件操作符，并且可以通过链式调用来组合多个条件。这样可以简化查询的编写过程，并提高开发效率。</p><h4 id="条件构造器继承结构"><a href="#条件构造器继承结构" class="headerlink" title="条件构造器继承结构"></a>条件构造器继承结构</h4><p>Wrapper：条件构造抽象类，最顶端父类</p><ul><li>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件</li><li>QueryWrapper ： 查询&#x2F;删除条件封装</li><li>UpdateWrapper ： 修改条件封装</li><li>AbstractLambdaWrapper ： 使用Lambda 语法</li><li>LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper</li><li>LambdaUpdateWrapper ： Lambda 更新封装Wrapper</li></ul><h4 id="基于QueryWrapper-组装条件"><a href="#基于QueryWrapper-组装条件" class="headerlink" title="基于QueryWrapper 组装条件"></a>基于QueryWrapper 组装条件</h4><p>组装查询条件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息</span></span><br><span class="line"><span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (username LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    .between(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line">    .isNotNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    List&lt;User&gt; list = userMapper.selectList(queryWrapper);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装排序条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//按年龄降序查询用户，如果年龄相同则按id升序排列</span></span><br><span class="line"><span class="comment">//SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper</span><br><span class="line">    .orderByDesc(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">    .orderByAsc(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装删除条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//删除email为空的用户</span></span><br><span class="line"><span class="comment">//DELETE FROM t_user WHERE (email IS NULL)</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="comment">//条件构造器也可以构建删除语句的条件</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.delete(queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and和or关键字使用(修改)：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span> &#123;</span><br><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将年龄大于20并且用户名中包含有a或邮箱为null的用户信息修改</span></span><br><span class="line"><span class="comment">//UPDATE t_user SET age=?, email=? WHERE username LIKE ? AND age &gt; ? OR email IS NULL)</span></span><br><span class="line">    queryWrapper</span><br><span class="line">    .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">    .gt(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    .or()</span><br><span class="line">    .isNull(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(user, queryWrapper);</span><br><span class="line">    System.out.println(<span class="string">&quot;受影响的行数：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指定列映射查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//查询用户信息的username和age字段</span></span><br><span class="line"><span class="comment">//SELECT username,age FROM t_user</span></span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;age&quot;</span>);</span><br><span class="line">    <span class="comment">//selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);</span><br><span class="line">    maps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>condition判断组织条件:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//判断条件拼接</span></span><br><span class="line">    <span class="comment">//当name不为null拼接等于, age &gt; 1 拼接等于判断</span></span><br><span class="line">    <span class="comment">//方案1: 手动判断</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isEmpty(name))&#123;</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (age &gt; <span class="number">1</span>)&#123;</span><br><span class="line">    queryWrapper.eq(<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方案2: 拼接condition判断</span></span><br><span class="line">    <span class="comment">//每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!</span></span><br><span class="line">    <span class="comment">//eq(condition,列名,值)</span></span><br><span class="line">    queryWrapper.eq(!StringUtils.isEmpty(name),<span class="string">&quot;name&quot;</span>,name)</span><br><span class="line">    .eq(age&gt;<span class="number">1</span>,<span class="string">&quot;age&quot;</span>,age);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于UpdateWrapper组装条件"><a href="#基于UpdateWrapper组装条件" class="headerlink" title="基于UpdateWrapper组装条件"></a>基于UpdateWrapper组装条件</h4><p>使用queryWrapper + 实体类形式可以实现修改，但是无法将列值修改为null值！</p><p>使用updateWrapper:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将id = 3 的email设置为null, age = 18</span></span><br><span class="line">updateWrapper.eq(<span class="string">&quot;id&quot;</span>,<span class="number">3</span>)</span><br><span class="line">.set(<span class="string">&quot;email&quot;</span>,<span class="literal">null</span>)  <span class="comment">// set 指定列和结果</span></span><br><span class="line">.set(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"><span class="comment">//如果使用updateWrapper 实体对象写null即可!</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用updateWrapper可以随意设置列的值！！</p><h4 id="基于LambdaQueryWrapper组装条件"><a href="#基于LambdaQueryWrapper组装条件" class="headerlink" title="基于LambdaQueryWrapper组装条件"></a>基于LambdaQueryWrapper组装条件</h4><ol><li><strong>LambdaQueryWrapper对比QueryWrapper优势</strong></li></ol><p>QueryWrapper 示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">queryWrapper.eq(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;John&quot;</span>)</span><br><span class="line">.ge(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line">.orderByDesc(<span class="string">&quot;create_time&quot;</span>)</span><br><span class="line">.last(<span class="string">&quot;limit 10&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure><p>LambdaQueryWrapper 示例代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">lambdaQueryWrapper.eq(User::getName, <span class="string">&quot;John&quot;</span>)</span><br><span class="line">.ge(User::getAge, <span class="number">18</span>)</span><br><span class="line">.orderByDesc(User::getCreateTime)</span><br><span class="line">.last(<span class="string">&quot;limit 10&quot;</span>);</span><br><span class="line">List&lt;User&gt; userList = userMapper.selectList(lambdaQueryWrapper);</span><br></pre></td></tr></table></figure><p>从上面的代码对比可以看出，相比于 QueryWrapper，LambdaQueryWrapper 使用了实体类的属性引用（例如 <code>User::getName</code>、<code>User::getAge</code>），而不是字符串来表示字段名，这提高了代码的可读性和可维护性。</p><ol start="2"><li><strong>lambda表达式</strong></li></ol><p>Lambda 表达式是 Java 8 引入的一种函数式编程特性，它提供了一种更简洁、更直观的方式来表示匿名函数或函数式接口的实现。Lambda 表达式可以用于简化代码，提高代码的可读性和可维护性。</p><p>Lambda 表达式的语法可以分为以下几个部分：</p><ul><li><strong>参数列表：</strong> 参数列表用小括号 <code>()</code> 括起来，可以指定零个或多个参数。如果没有参数，可以省略小括号；如果只有一个参数，可以省略小括号。</li></ul><p>示例：<code>(a, b)</code>, <code>x -&gt;</code>, <code>() -&gt;</code></p><ul><li><strong>箭头符号：</strong> 箭头符号 <code>-&gt;</code> 分割参数列表和 Lambda 表达式的主体部分。</li></ul><p>示例：<code>-&gt;</code></p><ul><li><strong>Lambda 表达式的主体：</strong> Lambda 表达式的主体部分可以是一个表达式或一个代码块。如果是一个表达式，可以省略 return 关键字；如果是多条语句的代码块，需要使用大括号 <code>&#123;&#125;</code> 括起来，并且需要明确指定 return 关键字。</li></ul><p>示例：</p><ul><li>单个表达式：<code>x -&gt; x * x</code></li><li>代码块：<code>(x, y) -&gt; &#123; int sum = x + y; return sum; &#125;</code></li></ul><p>Lambda 表达式的语法可以更具体地描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 表达式实现一个接口的方法</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Greeting</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始匿名内部类方式</span></span><br><span class="line"><span class="type">Greeting</span> <span class="variable">greeting</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Greeting</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a-&gt;System.out.println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lambda 表达式实现接口的方法</span></span><br><span class="line">greeting = () -&gt; System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out::println;</span><br><span class="line">() -&gt;  类.XXX(); -&gt; 类：：方法名</span><br><span class="line"><span class="comment">// 调用接口的方法</span></span><br><span class="line">greeting.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 方法引用:</strong></p><p>方法引用是 Java 8 中引入的一种语法特性，它提供了一种简洁的方式来直接引用已有的方法或构造函数。方法引用可以替代 Lambda 表达式，使代码更简洁、更易读。</p><p>Java 8 支持以下几种方法引用的形式：</p><ul><li><p><strong>静态方法引用：</strong> 引用静态方法，语法为 <code>类名::静态方法名</code>。</p></li><li><p><strong>实例方法引用：</strong> 引用实例方法，语法为 <code>实例对象::实例方法名</code>。</p></li><li><p><strong>对象方法引用：</strong> 引用特定对象的实例方法，语法为 <code>类名::实例方法名</code>。</p></li><li><p><strong>构造函数引用：</strong> 引用构造函数，语法为 <code>类名::new</code>。</p></li></ul><p>演示代码:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReferenceExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; names = Arrays.asList(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用 Lambda 表达式</span></span><br><span class="line">        names.forEach(name -&gt; System.out.println(name));</span><br><span class="line">        <span class="comment">// 使用方法引用</span></span><br><span class="line">        names.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. lambdaQueryWrapper使用案例:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">int</span>    <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//每个条件拼接方法都condition参数,这是一个比较运算,为true追加当前条件!</span></span><br><span class="line">    <span class="comment">//eq(condition,列名,值)</span></span><br><span class="line">    queryWrapper.eq(!StringUtils.isEmpty(name),<span class="string">&quot;name&quot;</span>,name)</span><br><span class="line">    .eq(age&gt;<span class="number">1</span>,<span class="string">&quot;age&quot;</span>,age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 使用lambdaQueryWrapper</span></span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; lambdaQueryWrapper = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//注意: 需要使用方法引用</span></span><br><span class="line">    <span class="comment">//技巧: 类名::方法名</span></span><br><span class="line">    lambdaQueryWrapper.eq(!StringUtils.isEmpty(name), User::getName,name);</span><br><span class="line">    List&lt;User&gt; users= userMapper.selectList(lambdaQueryWrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于LambdaUpdateWrapper组装条件"><a href="#基于LambdaUpdateWrapper组装条件" class="headerlink" title="基于LambdaUpdateWrapper组装条件"></a>基于LambdaUpdateWrapper组装条件</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//将id = 3 的email设置为null, age = 18</span></span><br><span class="line">updateWrapper.eq(<span class="string">&quot;id&quot;</span>,<span class="number">3</span>)</span><br><span class="line">.set(<span class="string">&quot;email&quot;</span>,<span class="literal">null</span>)  <span class="comment">// set 指定列和结果</span></span><br><span class="line">.set(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用lambdaUpdateWrapper</span></span><br><span class="line">LambdaUpdateWrapper&lt;User&gt; updateWrapper1 = <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>&lt;&gt;();</span><br><span class="line">updateWrapper1.eq(User::getId,<span class="number">3</span>)</span><br><span class="line">.set(User::getEmail,<span class="literal">null</span>)</span><br><span class="line">.set(User::getAge,<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果使用updateWrapper 实体对象写null即可!</span></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心注解使用"><a href="#核心注解使用" class="headerlink" title="核心注解使用"></a>核心注解使用</h3><ol><li>理解和介绍</li></ol><p>MyBatis-Plus是一个基于MyBatis框架的增强工具，提供了一系列简化和增强的功能，用于加快开发人员在使用MyBatis进行数据库访问时的效率。</p><p>MyBatis-Plus提供了一种基于注解的方式来定义和映射数据库操作，其中的注解起到了重要作用。</p><p>理解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;User&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口对应的方法为什么会自动触发 user表的crud呢？</p><p>默认情况下， 根据指定的&lt;实体类&gt;的名称对应数据库表名，属性名对应数据库的列名！</p><p>但是不是所有数据库的信息和实体类都完全映射！</p><p>例如： 表名 t_user  → 实体类 User 这时候就不对应了！</p><p>自定义映射关系就可以使用mybatis-plus提供的注解即可！<br>2. @TableName注解</p><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span> <span class="comment">//对应数据库表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊情况：如果表名和实体类名相同（忽略大小写）可以省略该注解！</p><p>其他解决方案：<a href="https://www.baomidou.com/pages/56bac0/#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">全局设置前缀</a></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span> <span class="comment"># mybatis-plus的配置</span></span><br><span class="line"><span class="attr">global-config:</span></span><br><span class="line"><span class="attr">db-config:</span></span><br><span class="line"><span class="attr">table-prefix:</span> <span class="string">sys_</span> <span class="comment"># 表名前缀字符串</span></span><br></pre></td></tr></table></figure><ol start="3"><li>@TableId 注解</li></ol><ul><li>描述：主键注解</li><li>使用位置：实体类主键字段</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@TableId(value=&quot;主键列名&quot;,type=主键策略)</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>类型</th><th>必须指定</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>主键字段名</td></tr><tr><td>type</td><td>Enum</td><td>否</td><td>IdType.NONE</td><td>指定主键类型</td></tr></tbody></table><p><a href="https://github.com/baomidou/mybatis-plus/blob/3.0/mybatis-plus-annotation/src/main/java/com/baomidou/mybatisplus/annotation/IdType.java">IdType</a>属性可选值：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>AUTO</td><td>数据库 ID 自增 (mysql配置主键自增长)</td></tr><tr><td>ASSIGN_ID（默认）</td><td>分配 ID(主键类型为 Number(Long )或 String)(since 3.3.0),使用接口<code>IdentifierGenerator</code>的方法<code>nextId</code>(默认实现类为<code>DefaultIdentifierGenerator</code>雪花算法)</td></tr></tbody></table><p>全局配置修改主键策略:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">configuration:</span><br><span class="line"># 配置MyBatis日志</span><br><span class="line">log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br><span class="line">global-config:</span><br><span class="line">db-config:</span><br><span class="line"># 配置MyBatis-Plus操作表的默认前缀</span><br><span class="line">table-prefix: t_</span><br><span class="line"># 配置MyBatis-Plus的主键策略</span><br><span class="line">id-type: auto</span><br></pre></td></tr></table></figure><p>在以下场景下，添加<code>@TableId</code>注解是必要的：</p><ol><li>实体类的字段与数据库表的主键字段不同名：如果实体类中的字段与数据库表的主键字段不一致，需要使用<code>@TableId</code>注解来指定实体类中表示主键的字段。</li><li>主键生成策略不是默认策略：如果需要使用除了默认主键生成策略以外的策略，也需要添加<code>@TableId</code>注解，并通过<code>value</code>属性指定生成策略。</li><li>雪花算法使用场景</li></ol><p>雪花算法（Snowflake Algorithm）是一种用于生成唯一ID的算法。它由Twitter公司提出，用于解决分布式系统中生成全局唯一ID的需求。</p><p>在传统的自增ID生成方式中，使用单点数据库生成ID会成为系统的瓶颈，而雪花算法通过在分布式系统中生成唯一ID，避免了单点故障和性能瓶颈的问题。</p><p>雪花算法生成的ID是一个64位的整数，由以下几个部分组成：</p><ol><li>时间戳：41位，精确到毫秒级，可以使用69年。</li><li>节点ID：10位，用于标识分布式系统中的不同节点。</li><li>序列号：12位，表示在同一毫秒内生成的不同ID的序号。</li></ol><p>通过将这三个部分组合在一起，雪花算法可以在分布式系统中生成全局唯一的ID，并保证ID的生成顺序性。</p><p>雪花算法的工作方式如下：</p><ol><li>当前时间戳从某一固定的起始时间开始计算，可以用于计算ID的时间部分。</li><li>节点ID是分布式系统中每个节点的唯一标识，可以通过配置或自动分配的方式获得。</li><li>序列号用于记录在同一毫秒内生成的不同ID的序号，从0开始自增，最多支持4096个ID生成。</li></ol><p>需要注意的是，雪花算法依赖于系统的时钟，需要确保系统时钟的准确性和单调性，否则可能会导致生成的ID不唯一或不符合预期的顺序。</p><p>雪花算法是一种简单但有效的生成唯一ID的算法，广泛应用于分布式系统中，如微服务架构、分布式数据库、分布式锁等场景，以满足全局唯一标识的需求。</p><p>雪花算法生成的数字,需要使用Long 或者 String类型主键<br>5. @TableField</p><p>描述：字段注解（非主键）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;sys_user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"><span class="meta">@TableId</span></span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="meta">@TableField(&quot;nickname&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MyBatis-Plus会自动开启驼峰命名风格映射</strong></p><h2 id="MyBatis-Plus高级扩展"><a href="#MyBatis-Plus高级扩展" class="headerlink" title="MyBatis-Plus高级扩展"></a>MyBatis-Plus高级扩展</h2><h3 id="逻辑删除实现"><a href="#逻辑删除实现" class="headerlink" title="逻辑删除实现"></a>逻辑删除实现</h3><p><strong>概念:</strong></p><p>逻辑删除，可以方便地实现对数据库记录的逻辑删除而不是物理删除。逻辑删除是指通过更改记录的状态或添加标记字段来模拟删除操作，从而保留了删除前的数据，便于后续的数据分析和恢复。</p><ul><li>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据</li><li>逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</li></ul><p><strong>逻辑删除实现:</strong></p><ol><li>数据库和实体类添加逻辑删除字段</li><li>表添加逻辑删除字段</li></ol><p>可以是一个布尔类型、整数类型或枚举类型。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span> <span class="keyword">ADD</span> deleted <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> ;  # <span class="type">int</span> 类型 <span class="number">1</span> 逻辑删除 <span class="number">0</span> 未逻辑删除</span><br></pre></td></tr></table></figure><ol start="2"><li>实体类添加逻辑删除属性</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line">public class <span class="keyword">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="variable">@TableId</span></span><br><span class="line">private <span class="type">Integer</span> id;</span><br><span class="line">private String name;</span><br><span class="line">private <span class="type">Integer</span> age;</span><br><span class="line">private String email;</span><br><span class="line"></span><br><span class="line"><span class="variable">@TableLogic</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>逻辑删除字段 <span class="type">int</span> mybatis<span class="operator">-</span>plus下,默认 逻辑删除值为<span class="number">1</span> 未逻辑删除 <span class="number">1</span> </span><br><span class="line">private <span class="type">Integer</span> deleted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>指定逻辑删除字段和属性值</li><li>单一指定</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line">public class <span class="keyword">User</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="variable">@TableId</span></span><br><span class="line">private <span class="type">Integer</span> id;</span><br><span class="line">private String name;</span><br><span class="line">private <span class="type">Integer</span> age;</span><br><span class="line">private String email;</span><br><span class="line"><span class="variable">@TableLogic</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>逻辑删除字段 <span class="type">int</span> mybatis<span class="operator">-</span>plus下,默认 逻辑删除值为<span class="number">1</span> 未逻辑删除 <span class="number">1</span> </span><br><span class="line">private <span class="type">Integer</span> deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>全局指定</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"><span class="attr">global-config:</span></span><br><span class="line"><span class="attr">db-config:</span></span><br><span class="line"><span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line"><span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line"><span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><h3 id="乐观锁实现"><a href="#乐观锁实现" class="headerlink" title="乐观锁实现"></a>乐观锁实现</h3><h4 id="悲观锁和乐观锁场景和介绍"><a href="#悲观锁和乐观锁场景和介绍" class="headerlink" title="悲观锁和乐观锁场景和介绍"></a>悲观锁和乐观锁场景和介绍</h4><p><strong>并发问题场景演示:</strong></p><p><img src="https://secure2.wostatic.cn/static/nWoVTstK7jnH8ida2Urujn/image.png?auth_key=1711513165-swYv5xUT1t4HAcN64ZBD7D-0-aa35481fb137c5a1fb50a1488ffff7bf"></p><p>​    </p><p>**解决思路: **</p><p>乐观锁和悲观锁是在并发编程中用于处理并发访问和资源竞争的两种不同的锁机制!!</p><p>悲观锁:<br>悲观锁的基本思想是，在整个数据访问过程中，将共享资源锁定，以确保其他线程或进程不能同时访问和修改该资源。悲观锁的核心思想是”先保护，再修改”。在悲观锁的应用中，线程在访问共享资源之前会获取到锁，并在整个操作过程中保持锁的状态，阻塞其他线程的访问。只有当前线程完成操作后，才会释放锁，让其他线程继续操作资源。这种锁机制可以确保资源独占性和数据的一致性，但是在高并发环境下，悲观锁的效率相对较低。</p><p>乐观锁:<br>乐观锁的基本思想是，认为并发冲突的概率较低，因此不需要提前加锁，而是在数据更新阶段进行冲突检测和处理。乐观锁的核心思想是”先修改，后校验”。在乐观锁的应用中，线程在读取共享资源时不会加锁，而是记录特定的版本信息。当线程准备更新资源时，会先检查该资源的版本信息是否与之前读取的版本信息一致，如果一致则执行更新操作，否则说明有其他线程修改了该资源，需要进行相应的冲突处理。乐观锁通过避免加锁操作，提高了系统的并发性能和吞吐量，但是在并发冲突较为频繁的情况下，乐观锁会导致较多的冲突处理和重试操作。</p><p>理解点: 悲观锁和乐观锁是两种解决并发数据问题的思路</p><p><strong>具体技术和方案:</strong></p><ol><li>乐观锁实现方案和技术：</li></ol><ul><li>版本号&#x2F;时间戳：为数据添加一个版本号或时间戳字段，每次更新数据时，比较当前版本号或时间戳与期望值是否一致，若一致则更新成功，否则表示数据已被修改，需要进行冲突处理。</li><li>CAS（Compare-and-Swap）：使用原子操作比较当前值与旧值是否一致，若一致则进行更新操作，否则重新尝试。</li><li>无锁数据结构：采用无锁数据结构，如无锁队列、无锁哈希表等，通过使用原子操作实现并发安全。</li></ul><ol start="2"><li>悲观锁实现方案和技术：</li></ol><ul><li>锁机制：使用传统的锁机制，如互斥锁（Mutex Lock）或读写锁（Read-Write Lock）来保证对共享资源的独占访问。</li><li>数据库锁：在数据库层面使用行级锁或表级锁来控制并发访问。</li><li>信号量（Semaphore）：使用信号量来限制对资源的并发访问。</li></ul><p><strong>介绍版本号乐观锁技术的实现流程:</strong></p><ul><li>每条数据添加一个版本号字段version</li><li>取出记录时，获取当前 version</li><li>更新时，检查获取版本号是不是数据库当前最新版本号</li><li>如果是[证明没有人修改数据], 执行更新, set 数据更新 , version &#x3D; version+ 1 </li><li>如果 version 不对[证明有人已经修改了]，我们现在的其他记录就是失效数据!就更新失败</li></ul><h4 id="使用mybatis-plus数据使用乐观锁"><a href="#使用mybatis-plus数据使用乐观锁" class="headerlink" title="使用mybatis-plus数据使用乐观锁"></a>使用mybatis-plus数据使用乐观锁</h4><ol><li>添加版本号更新插件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乐观锁字段添加@Version注解</p><p>注意: 数据库也需要添加version字段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ALTER TABLE USER ADD VERSION INT DEFAULT <span class="number">1</span> ;  # <span class="type">int</span> 类型 乐观锁字段</span><br></pre></td></tr></table></figure><ul><li>支持的数据类型只有:int,Integer,long,Long,Date,Timestamp,LocalDateTime</li><li>仅支持 <code>updateById(id)</code> 与 <code>update(entity, wrapper)</code> 方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure><ol start="2"><li>正常更新使用即可</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//演示乐观锁生效场景</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//步骤1: 先查询,在更新 获取version数据</span></span><br><span class="line">    <span class="comment">//同时查询两条,但是version唯一,最后更新的失败</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span>  <span class="operator">=</span> userMapper.selectById(<span class="number">5</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span>  <span class="operator">=</span> userMapper.selectById(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    user1.setAge(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    userMapper.updateById(user);</span><br><span class="line">    <span class="comment">//乐观锁生效,失败!</span></span><br><span class="line">    userMapper.updateById(user1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防全表更新和删除实现"><a href="#防全表更新和删除实现" class="headerlink" title="防全表更新和删除实现"></a>防全表更新和删除实现</h3><p>针对 update 和 delete 语句 作用: 阻止恶意的全表更新删除</p><p>添加防止全表更新和删除拦截器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">    interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">BlockAttackInnerInterceptor</span>());</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试全部更新或者删除</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuick8</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;custom_name&quot;</span>);</span><br><span class="line">    user.setEmail(<span class="string">&quot;xxx@mail.com&quot;</span>);</span><br><span class="line">    <span class="comment">//Caused by: com.baomidou.mybatisplus.core.exceptions.MybatisPlusException: Prohibition of table update operation</span></span><br><span class="line">    <span class="comment">//全局更新,报错</span></span><br><span class="line">    userService.saveOrUpdate(user,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向工程和MybatisX插件"><a href="#逆向工程和MybatisX插件" class="headerlink" title="逆向工程和MybatisX插件"></a>逆向工程和MybatisX插件</h2><h3 id="ORM思维介绍"><a href="#ORM思维介绍" class="headerlink" title="ORM思维介绍"></a>ORM思维介绍</h3><p>ORM（Object-Relational Mapping，对象-关系映射）是一种将数据库和面向对象编程语言中的对象之间进行转换的技术。它将对象和关系数据库的概念进行映射，最后我们就可以通过方法调用进行数据库操作!!</p><p>最终<strong>可以使用面向对象思维进行数据库操作</strong></p><p><strong>ORM 框架通常有半自动和全自动两种方式</strong></p><ul><li>半自动 ORM 通常需要程序员手动编写 SQL 语句或者配置文件，将实体类和数据表进行映射，还需要手动将查询的结果集转换成实体对象。</li><li>全自动 ORM 则是将实体类和数据表进行自动映射，使用 API 进行数据库操作时，ORM 框架会自动执行 SQL 语句并将查询结果转换成实体对象，程序员无需再手动编写 SQL 语句和转换代码。</li></ul><p><strong>半自动和全自动 ORM 框架的区别：</strong></p><ol><li>映射方式：半自动 ORM 框架需要程序员手动指定实体类和数据表之间的映射关系，通常使用 XML 文件或注解方式来指定；全自动 ORM 框架则可以自动进行实体类和数据表的映射，无需手动干预。</li><li>查询方式：半自动 ORM 框架通常需要程序员手动编写 SQL 语句并将查询结果集转换成实体对象；全自动 ORM 框架可以自动组装 SQL 语句、执行查询操作，并将查询结果转换成实体对象。</li><li>性能：由于半自动 ORM 框架需要手动编写 SQL 语句，因此程序员必须对 SQL 语句和数据库的底层知识有一定的了解，才能编写高效的 SQL 语句；而全自动 ORM 框架通过自动优化生成的 SQL 语句来提高性能，程序员无需进行优化。</li><li>学习成本：半自动 ORM 框架需要程序员手动编写 SQL 语句和映射配置，要求程序员具备较高的数据库和 SQL 知识；全自动 ORM 框架可以自动生成 SQL 语句和映射配置，程序员无需了解过多的数据库和 SQL 知识。</li></ol><p>常见的半自动 ORM 框架包括 MyBatis 等；常见的全自动 ORM 框架包括 Hibernate、Spring Data JPA、MyBatis-Plus 等。</p><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>MyBatis 的逆向工程是一种自动化生成持久层代码和映射文件的工具，它可以根据数据库表结构和设置的参数生成对应的实体类、Mapper.xml 文件、Mapper 接口等代码文件，简化了开发者手动生成的过程。逆向工程使开发者可以快速地构建起 DAO 层，并快速上手进行业务开发。<br>MyBatis 的逆向工程有两种方式：通过 MyBatis Generator 插件实现和通过 Maven 插件实现。无论是哪种方式，逆向工程一般需要指定一些配置参数，例如数据库连接 URL、用户名、密码、要生成的表名、生成的文件路径等等。<br>总的来说，逆向工程为程序员提供了一种方便快捷的方式，能够快速地生成持久层代码和映射文件，是半自动 ORM 思维像全自动发展的过程，提高程序员的开发效率。</p><p>逆向工程只能生成单表crud的操作，多表查询依然需要自己编写！</p><h3 id="逆向工程插件MyBatisX使用"><a href="#逆向工程插件MyBatisX使用" class="headerlink" title="逆向工程插件MyBatisX使用"></a>逆向工程插件MyBatisX使用</h3><p>MyBatisX 是一个 MyBatis 的代码生成插件，可以通过简单的配置和操作快速生成 MyBatis Mapper、pojo 类和 Mapper.xml 文件。下面是使用 MyBatisX 插件实现逆向工程的步骤：</p><ol><li>安装插件：</li></ol><p>在 IntelliJ IDEA 中打开插件市场，搜索 MyBatisX 并安装。<br>2. 使用 IntelliJ IDEA连接数据库</p><ul><li><p>连接数据库</p></li><li><p>逆向工程使用</p></li></ul><p><img src="https://secure2.wostatic.cn/static/s6LMYQtxCLAQ86ScJS5Kam/image.png?auth_key=1711513456-irs5D2suoMaDcbvLMLPAvw-0-6770defa442ddcfaf7713d246a720652"></p><p>逆向工程案例使用,自动生成单表的crud方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> 针对表【user】的数据库操作Mapper</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insert</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertSelective</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line">User <span class="title function_">selectByPrimaryKey</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateByPrimaryKeySelective</span><span class="params">(User record)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateByPrimaryKey</span><span class="params">(User record)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/1276cc28.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
