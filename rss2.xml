<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>楪祈のBlog</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>星座になれたら。</description>
    <pubDate>Sat, 08 Jun 2024 09:50:28 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>强化学习基础知识</title>
      <link>http://example.com/inori/64d6f53b.html</link>
      <guid>http://example.com/inori/64d6f53b.html</guid>
      <pubDate>Thu, 06 Jun 2024 08:06:57 GMT</pubDate>
      
      <description>ReinforceLearning基础知识</description>
      
      
      
      <content:encoded><![CDATA[<p>记录一些强化学习基础名词解释，理解的不深</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>强化学习（Reinforcement Learning，RL）是一种机器学习方法，旨在通过与环境的交互来学习如何采取行动以最大化累积奖励。与监督学习不同，强化学习没有预先标注的输入输出对，而是通过试错和从反馈中学习</p><p><code>Agent</code>：做出动作的角色，即智能体</p><p><code>state(状态)</code>：智能体当前所处的环境，包含环境当前的全部或部分信息，在玩游戏时，state就是当前的游戏画面，如果状态，动作，奖励等变量被观测到了，用s表示；没观测到就表示随机变量，用S表示</p><p><code>action(动作)</code>：智能体在每个时间步可以采取的操作</p><p><code>policy(决策)</code>：agent在当前做出的动作</p><p><code>policy function(策略函数)</code>：在某种state下，agent采取某种action的概率$\pi(s.a)$，函数值范围为[0,1]</p><p><code>Reward(奖励)</code>：是指采取动作后，环境给agent的奖励，它可能为正、负、0</p><p><code>state transition(状态转移)</code>：agent在某个状态采取某个动作后，可能发生的状态变化</p><p>强化学习是agent与环境互动的过程。我们观测到状态$s_t$，然后根据策略$\pi(a|s)$选择一个动作$a_t$并执行它，环境会给出一个新的状态$s_{t+1}$和奖励r</p><p><code>Return(回报)</code>：也叫做未来累计奖励，即$U_t&#x3D;R_t+R_{t+1}+R_{t+2}+…+R_n$</p><p>由于现在的奖励可能比未来的奖励更重要，所以定义<code>Discounted Return(折扣回报)</code>：$U_t&#x3D;R_t+\gamma R_{t+1}+\gamma^2 R_{t+2}+…+\gamma^n R_n$，$\gamma$意为折扣因子，是我们设定的超参数</p><p><code>Action-Value Function(动作值函数)</code>：用Q(s,a)表示，用于评估在给定状态s下采取某个动作a所能获得的累积奖励的期望值</p><p><code>State-Value Function(状态值函数)</code>：用V(s)表示，用于评估智能体在给定状态s下，从该状态开始到未来所能获得的累积奖励的期望值</p><p><code>Q值</code>：表示在状态s下采取动作a的return</p><p><code>model-based</code>：基于模型的方法涉及构建环境的模型，即尝试估计或学习环境的动态（状态转移概率和奖励函数）。这些方法可以在模型上进行规划，从而选择最佳行动。</p><p><code>model-free</code>：不直接构建环境的模型，而是通过与环境的交互来学习最优策略或价值函数，直接从经验中学习如何行动</p><p><code>policy-based</code>：利用策略梯度优化策略函数，来选择最优行动，直接学习映射状态到行动的策略函数。可以更自然地应用于连续动作空间问题。</p><p><code>value-based</code>：基于价值的方法对价值函数进行建模和优化。通过估计每个状态或状态-动作对的价值来选择最优行动。主要特点包括：</p><ul><li>优化价值函数：学习状态价值函数或动作价值函数。</li><li>间接确定策略：通过选择具有最大价值的动作来确定策略。</li><li>例子：Q-learning，SARSA，DQN</li></ul><h1 id="Value-Based-Reinforcement-Learning"><a href="#Value-Based-Reinforcement-Learning" class="headerlink" title="Value-Based Reinforcement Learning"></a>Value-Based Reinforcement Learning</h1><p>定义Optimal action-value function$Q^*(s_t,a_t)&#x3D;maxQ_\pi(s_t,a_t)$，$Q^*(s_t,a_t)$就是最优情况下的$U_t$</p><p>在价值学习中我们要训练的函数就是$Q(s_t,a_t)$，训练的目标是$Q^*(s_t,a_t)$，采取的最佳动作就是$a^*&#x3D;argmaxQ^*(s_t,a_t)$</p><h2 id="Temporal-Difference-Learning算法"><a href="#Temporal-Difference-Learning算法" class="headerlink" title="Temporal Difference Learning算法"></a>Temporal Difference Learning算法</h2><p>时序差分算法的思想为用局部基于真实观测的数据来更新全局预测的数据，因为它的可信度大于完全基于预测的数据</p><p>TD target：相比于当前估计来说更准确的估计，使用$V(s)←V(s)+α[r+γV(s^′)−V(s)]$更新</p><p>TD error：之前的估计与当前估计的损失值</p><h2 id="Deep-Q-Network"><a href="#Deep-Q-Network" class="headerlink" title="Deep Q Network"></a>Deep Q Network</h2><p>DQN是使用一个神经网络$Q(s,a;w)$来估计action-value function$Q(s,a)$，我们基于TD算法来训练这个神经网络，从而得到Optimal action-value function$Q^*(s_t,a_t)$的估计</p><p>由于$U_t&#x3D;R_t+\gamma R_{t+1}+\gamma^2 R_{t+2}+…+\gamma^n R_n&#x3D;R_t+\gamma U_{t+1}$</p><p>基于这种思想,做一下蒙特卡洛近似，得出DQN的更新公式为$Q(s_t,a_t;w)&#x3D;r_t+\gamma Q(s_{t+1},a_{t+1};w)$</p><p>Loss也与TD算法相似:$L_t&#x3D;\frac{1}{2}[Q(s_t,a_t;w)-y_t]^2 $</p><p>流程总结：</p><ul><li>从当前状态s中选择一个动作a</li><li>执行动作a，获得奖励r并转移到新状态s′</li><li>将经历（s,a,r,s′）存储到回放缓冲区</li><li>从回放缓冲区中随机抽取一个小批量样本</li><li>对每个样本，计算目标Q值(TD target)并更新Q网络参数</li><li>每隔一定步数，更新目标网络参数</li></ul><h1 id="Policy-Based-Reinforcement-Learning"><a href="#Policy-Based-Reinforcement-Learning" class="headerlink" title="Policy-Based Reinforcement Learning"></a>Policy-Based Reinforcement Learning</h1><h2 id="Policy-Function"><a href="#Policy-Function" class="headerlink" title="Policy Function"></a>Policy Function</h2><p>策略函数$π(a|s)$是一个概率密度函数，其输入是某个状态s，输出是在该状态下可能产生的动作a的概率值。假设在状态$s_t$下，Agent可能做出的动作$a_t$可能有n个，那么$π(a_t|s_t)$即输出一个n维向量，其元素对应每个可能做出动作at的概率值。有了这n个概率值，Agent就会在这个向量中做一次随机抽样并做出所得到的动作$a_i$</p><h2 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a>Policy Gradient</h2><p>定义状态值函数近似函数$V(s;\theta)&#x3D;\Sigma_a\pi(a|s;\theta)Q_\pi(s,a)$，其中$\theta$是神经网络中的参数。V可以评价状态s和策略网络$π(a|s_t;θ)$的好坏。若给定状态s，策略网络越好，那么V的值越大。因此，我们采用V关于$θ$的随机梯度上升的方法更新参数θ，即策略梯度就是函数V对$\theta$的导数</p><p>大致流程：</p><ul><li>观测状态s</li><li>根据策略函数$\pi$随机采样一个a</li><li>根据$Q(s_tr,a_t)$近似$q_t$</li><li>对策略网络求导</li><li>近似策略梯度$g(a_t,\theta_t)&#x3D;q_t*d_{\theta,t}$</li><li>更新策略网络参数</li></ul><p>那么我们如何估计动作价值函数Q？</p><p>这里有两种方法：</p><p><code>REINFORCE算法</code>：必须获取到一个完整的采样trajectory才能进行一次模型参数的更新，也就是蒙特卡罗方法（MC Method）来估计Q</p><p><code>Actor-Critic（AC）</code>：使用另一个神经网络来近似Qπ</p><h2 id="Actor-Critic-Method"><a href="#Actor-Critic-Method" class="headerlink" title="Actor-Critic Method"></a>Actor-Critic Method</h2><p>Actor-Critic方法，是策略学习和价值学习结合的一种方法</p><p>Actor是策略网络，用来控制Agent运动，可以看做“演员”</p><p>Critic是价值网络，用来给演员打分，可以看做“评论家”</p><h3 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h3><p>Actor网络的输入为状态s</p><p>价值网络中包含：卷积层，将画面变成特征向量；全连接层，将特征向量转变为相对于动作空间（Action Space）中元素个数对应的向量；再采用Softmax激活函数将其转换为一策略的概率密度</p><h3 id="Critic"><a href="#Critic" class="headerlink" title="Critic"></a>Critic</h3><p>Critic网络的输入为状态s和动作a</p><p>对于两个不同的输入，处理方法如下：</p><p>针对于状态s，从输入中提取特征，获得一个状态特征向量</p><p>针对于动作a，采用全连接层提取特征，获得一个动作特征向量</p><p>然后将两个特征向量进行concat，得到一个更高维的特征向量，再通过一个全连接层输出一个实数$q(s,a;w)$，即Critic对于Agent处于状态s下做出动作a的评价</p><h3 id="训练神经网络"><a href="#训练神经网络" class="headerlink" title="训练神经网络"></a>训练神经网络</h3><ul><li>观测状态s</li><li>根据策略函数$\pi$随机采样一个a</li><li>执行动作a，获取下一个状态$s_{t+1}$和奖励r</li><li>使用TD算法更新Critic网络的参数</li><li>使用策略梯度更新Actor的参数</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>观测旧状态$s_t$，用策略网络$\pi$计算概率分布，随机采样动作$a_t$</li><li>执行$a_t$，得到新状态$s_{t+1}$和奖励$r_t$</li><li>根据新状态，随机采样动作$a_{t+1}$(假想的动作，并不会真的做)</li><li>计算价值网络$q_t&#x3D;q(s_t,a_t;w_t)$和$q_{t+1}&#x3D;q(s_{t+1},a_{t+1};w_t)$</li><li>计算TD error：$\delta_t&#x3D;q_t-(r_t+\gamma q_{t+1})$</li><li>对Critic参数求导，更新其参数$w_{t+1}&#x3D;w_t-\alpha \delta_t d_{w,t}$</li><li>对Actor参数求导，更新其参数$\theta_{t+1}&#x3D;\theta_t-\beta q_t d_{\theta,t}$</li></ul><h1 id="Monte-Carlo方法"><a href="#Monte-Carlo方法" class="headerlink" title="Monte Carlo方法"></a>Monte Carlo方法</h1><p>蒙特卡洛是一类通过随机采样和统计分析来估计问题解的方法，在强化学习中用于评估策略和估计价值函数</p><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>随机采样</strong>：通过从可能的结果中随机采样，来估计某个数量的期望值或概率分布。</p><p><strong>经验回报</strong>：在每个episode中，通过累积获得的实际回报来估计状态或状态-动作对的价值。</p><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2><p><strong>生成轨迹</strong>：根据当前策略，从起始状态开始，生成多条轨迹，每条轨迹包含一系列状态、动作和奖励，直到达到终止状态</p><p><strong>计算回报</strong>：对每条轨迹，计算每个时间步Return</p><p><strong>更新价值估计</strong>：根据每个状态或状态-动作对的回报，更新价值函数或Q值函数</p><h1 id="Sarsa算法"><a href="#Sarsa算法" class="headerlink" title="Sarsa算法"></a>Sarsa算法</h1><p>SARSA（State-Action-Reward-State-Action）是一种基于TD方法的强化学习算法，用于学习状态-动作价值函数。SARSA是一个on-policy算法，直接使用当前策略选择的动作来更新Q值</p><h2 id="表格形式的Sarsa"><a href="#表格形式的Sarsa" class="headerlink" title="表格形式的Sarsa"></a>表格形式的Sarsa</h2><p>如果agent的状态和动作是有限的，那么可以画一个表格，一行对应一个状态$s_i$，一列对应一个动作$a_j$，那么表中的每个元素则对应着在该状态和该动作下的动作价值$Q_π(s_i,a_j)$。我们要做的就是用Sarsa算法去更新表格，每次更新一个元素。</p><p>当我们观测到一个四元组$（s_t,a_t,r_t,s_{t+1}）$，这样的一个四元组被称为transition。然后采用策略函数$π$去采样一个$a_{t+1}$，接着计算TD target $y_t&#x3D;r_t+\gamma Q(s_{t+1},a_{t+1})$，Q值可以直接通过查表获得。同时我们也能计算出TD error $δ_t$，然后利用$δ_t$更新$Q_π(st,at)$，其中α是学习率</p><h2 id="神经网络形式的Sarsa"><a href="#神经网络形式的Sarsa" class="headerlink" title="神经网络形式的Sarsa"></a>神经网络形式的Sarsa</h2><p>采用价值网络来近似$Q_π(s,a)$，记为$q(s,a;w)$。动作价值函数Qπ和价值网络q都与策略π有关，策略π的好坏会影响这两个函数</p><p>神经网络$q(s,a;w)$被称为价值网络，它的输入是一个状态s，输出是状态s下对应动作的价值。如果有n个动作，那么价值网络q就会输出一个n维向量，向量元素对应在状态s下，各动作a的价值</p><p>TD target就变成了$y_t&#x3D;r_t+\gamma q(s_{t+1},a_{t+1};w)$，TD error变成$δ_t&#x3D;q(s_t,a_t;w)-y_t$</p><p>然后计算Loss，求梯度，更新网络参数w即可</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Sarsa算法主要是用于学习动作价值函数$Q_π(s,a)$</p><ul><li>表格形式（直接学习Qπ）</li></ul><p>适合有限个状态和动作且数量不大的情况。通过一张表格记录每种状态和动作对应的$Q_π(s,a)$的值，通过采用TD算法更新表中Q值。</p><ul><li>神经网络形式（采用函数近似）</li></ul><p>这种形式并不是直接获取Q，而是通过价值网络q(s,a;w)来近似动作价值函数Q</p><h1 id="Q-Learning算法"><a href="#Q-Learning算法" class="headerlink" title="Q-Learning算法"></a>Q-Learning算法</h1><p>Q-Learning是用于学习最优动作价值函数$Q^*(s,a)$</p><p>TD target的更新函数为$y_t&#x3D;r_t+\gamma maxQ^*(s_{t+1},a)$，对Q*求最大化</p><p>其他部分与Sarsa相同，只是Sarsa算法是学习动作价值函数Qπ；而Q-Learning是学习最优动作价值函数Q*</p><h1 id="Experience-Replay"><a href="#Experience-Replay" class="headerlink" title="Experience Replay"></a>Experience Replay</h1><p>我们通常使用TD算法来训练DQN，回顾一下TD算法的步骤：</p><ul><li>Agent在t时刻观测到一个状态st并做出动作at</li><li>Agent与环境交互获得了一个新的状态st+1并且获得了一个奖励rt</li><li>得到TD Target yt</li><li>计算TD error δt</li></ul><p>我们的目标是让qt接近yt，即TD error δt尽量的小，因此TD算法就是寻找一个神经网络参数w使损失函数（Loss Function）L(w)尽可能的小</p><ul><li>采用梯度下降来使$w_t$不断逼近w*</li></ul><p>$（s_t,a_t,r_t,s_{t+1}）$是一个transition，可以认为是一条训练数据，传统算法在使用完该训练数据后就把它丢掉，不再使用，这种对于DQN的训练效果并不好</p><h2 id="Replay-Buffer"><a href="#Replay-Buffer" class="headerlink" title="Replay Buffer"></a>Replay Buffer</h2><p>我们在使用完一个transition时，会把一个transition放入一个队列里，这个队列被称之为回放缓冲区（Replay Buffer），它的容量是一个超参数n，Replay Buffer可以存储n条transitions。如果Replay Buffer满了，那么新来的transition会替代老的transition</p><h3 id="TD算法中经验回放"><a href="#TD算法中经验回放" class="headerlink" title="TD算法中经验回放"></a>TD算法中经验回放</h3><p>我们通过找到神经网络参数w来最小化损失函数Loss Function。</p><p>使用随机梯度下降（Stochastic Gradient Descent SGD）来最小化Loss Function：从buffer中随机抽取一批transition，计算TD error δi，再算出随机梯度gi，调整神经网络参数w</p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><h2 id="Prioritized-Experience-Replay"><a href="#Prioritized-Experience-Replay" class="headerlink" title="Prioritized Experience Replay"></a>Prioritized Experience Replay</h2><p>对于Agent而言，并不是所有的transition都同等重要，有些state较难遇见，统一抽样的话难以抽到，训练出的DQN对于数量较少的场景不熟悉，所以预测就会偏离TD Target，因此产生的TD error就比较大，即|δt|就大。正因为DQN不熟悉数量较少的场景，所以要让DQN给这些场景更高的优先级，让它更好的应对这样的场景。</p><p>优先经验回放的核心在于：使用非均匀抽样代替均匀抽样</p><p>这里有两种抽样方式：</p><ul><li>抽样概率pt正比于|δt|+ε：即TD error越大，被抽到的概率就越大</li><li>对|δt|排序：|δt|越大越靠前，容易被抽到</li></ul><h3 id="学习率调整"><a href="#学习率调整" class="headerlink" title="学习率调整"></a>学习率调整</h3><p>TD算法采用SGD来更新神经网络参数w，α是学习率，如果做均匀抽样，所有的transitions的学习率α都相同；如果做非均匀抽样，那么就要根据每个transition的重要性来调整学习率。</p><p>如果一个transition有一个较大的抽样概率pt，那么对这个transition的学习率就应该调小，可以采用如下圈出的方法来自适应调整学习率的因子：如果pt很大，那么学习率就会变小，学习率减小可以减小训练过程中的波动，提高收敛速度和精度，设置学习率为$\alpha(np_t)^{-\beta}$</p><h3 id="更新TD-Error"><a href="#更新TD-Error" class="headerlink" title="更新TD Error"></a>更新TD Error</h3><p>为了做优先经验回放，我们要对每一个transition标记上TD error δt。δt决定了这条transition的重要性，决定了它被抽样的概率。</p><p>如果一个transition刚刚被收集到，我们并不知道它的δt，那么我们就直接把它的δt设置为最大值，让它有最高的优先级。</p><p>每次从buffer中抽取一个transition，都要对它的δt进行一次更新</p><h2 id="缓解高估问题"><a href="#缓解高估问题" class="headerlink" title="缓解高估问题"></a>缓解高估问题</h2><p>由于DQN选择的是$maxQ^*(s_{t+1},a)$，而且原始的DQN使用Bootstrapping方式更新自己的参数，会导致严重的非均匀高估问题。</p><p>这里有两种方法用于缓解高估问题：</p><ul><li><p>使用目标网络（Target Network）</p></li><li><p>Double DQN</p></li></ul><h3 id="Target-Network"><a href="#Target-Network" class="headerlink" title="Target Network"></a>Target Network</h3><p>相比于DQN，Target Network是独立于DQN的。它与DQN有着相同的神经网络结构，但有不同的参数，记作w-。</p><p>我们使用Q(s,a;w)来控制Agent并且收集transition</p><p>使用Q(s,q;w-)来选择动作和计算TD target。</p><p>以前使用DQN来计算yt，用yt来更新DQN的参数。这会产生自举。现在我们使用Target Network，用Target Network来计算yt。这样就可以缓解高估问题。</p><h3 id="Double-DQN"><a href="#Double-DQN" class="headerlink" title="Double DQN"></a>Double DQN</h3><p>DDQN在选择动作时使用的是DQN原始的网络，在计算TD target时使用的是target network，这样相比原始DQN和target network可以更加缓解高估问题</p><h1 id="离散动作空间与连续动作空间"><a href="#离散动作空间与连续动作空间" class="headerlink" title="离散动作空间与连续动作空间"></a>离散动作空间与连续动作空间</h1><p>离散动作空间是一个集合，其中包含有限个动作。比如在玩2D横版过关游戏时，agent的动作空间只能是上下左右四种动作。对于动作空间是离散的agent可以使用传统的SARSA、DQN算法进行训练</p><p>连续动作空间就像是gym的摆杆子环境，或者机械臂控制，由于可以[0,360]度旋转，所以有无穷多种动作空间。对于连续的动作空间，可以使用离散化将连续动作空间变成离散的，但是对于自由度很高的agent，离散化的点就会很多，这会导致维度灾难，离散化只适合较小的连续动作空间</p><h2 id="Deterministic-Policy-Gradient"><a href="#Deterministic-Policy-Gradient" class="headerlink" title="Deterministic Policy Gradient"></a>Deterministic Policy Gradient</h2><p>DPG是策略梯度的变体，专门用于处理确定性策略。与传统的基于随机策略的策略梯度方法不同，DPG直接优化确定性策略，可以处理连续动作空间的问题。</p><p>在DPG中，策略$\mu(s; \theta)$是确定性的，即给定一个状态s，策略直接输出一个具体的动作a：$a &#x3D; \mu(s; \theta))$</p><p>DPG是属于AC方法，有一个策略网络，有一个价值网络</p><p>策略网络是一个确定性的网络，它的输入是状态s，它的输出不是概率分布，而是一个确定性的动作。只要给定状态s，那么对应的动作a就是一个具体的动作</p><p>价值网络有两个输入，一个是状态s一个是动作a，基于状态s，Critic对a进行打分。</p><h3 id="DPG的更新策略"><a href="#DPG的更新策略" class="headerlink" title="DPG的更新策略"></a>DPG的更新策略</h3><p>训练策略网络需要价值网络的帮忙，改善策略网络的参数θ以至于动作a可以依靠策略网络变得更好，而更新参数θ是要根据价值网络q(s,a;w)&#x3D;q(s,π(s;θ);w)的增加而决定的。</p><p>因而我们训练策略网络的目标是让价值网络q的输出变的更大。价值网络的输入是状态s,a，对于确定的状态，确定性策略网络会输出对应的动作a。</p><p>如果输入的状态s是固定的，Critic也是固定的，那么唯一会影响q（Critic的打分）的因素，就是Actor的参数θ。我们想要更新θ，让q变大，那么就可以求取q对θ的梯度，然后使用梯度上升来更新参数θ，这样就可以让价值q变大。这个梯度就叫做确定策略梯度DPG，它是价值q关于Actor参数θ的梯度</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/ReinforceLearning/">ReinforceLearning</category>
      
      
      <category domain="http://example.com/tags/ReinforceLearning/">ReinforceLearning</category>
      
      
      <comments>http://example.com/inori/64d6f53b.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>pytorch基础入门</title>
      <link>http://example.com/inori/8f832495.html</link>
      <guid>http://example.com/inori/8f832495.html</guid>
      <pubDate>Thu, 23 May 2024 08:30:34 GMT</pubDate>
      
      <description>pytorch入门</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="两个实用函数"><a href="#两个实用函数" class="headerlink" title="两个实用函数"></a>两个实用函数</h1><p>假如pytorch是一个大型工具箱，我们想查看工具箱中有什么工具，这时就可以使用<code>dir()</code>函数查看，如果我们想知道某一个工具是如何使用的，就可以使用<code>help()</code>函数查看</p><ul><li><code>dir()</code>：可以查看指定对象包含的全部内容，包括变量、方法、函数和类等。不仅包含可供我们调用的模块成员，还包含所有名称以双下划线“__”开头和结尾的“特殊”命名的私有成员，这些成员是在本模块中使用的，不能在类的外部调用。</li><li><code>help()</code>：查看指定对象（类型、模块、变量、方法等）的详细使用说明</li></ul><h1 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h1><p>在学习和使用pytorch时，要经常使用<a href="https://pytorch.org/docs/stable/index.html">官方文档</a>，里面有详细的使用说明</p><h2 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h2><h3 id="加载数据方法及label形式"><a href="#加载数据方法及label形式" class="headerlink" title="加载数据方法及label形式"></a>加载数据方法及label形式</h3><p>Pytorch中加载数据需要Dataset、Dataloader</p><ul><li>Dataset提供一种方式去获取每个数据及其对应的label和编号，以及总共有多少个数据</li><li>Dataloader为后面的网络提供不同的数据形式，可以将数据进行打包</li></ul><p>label形式</p><ul><li>文件夹名即为label。文件夹中存放若干条数据</li><li>一个文件夹存放数据，数据有编号，另一个文件夹存放数据对应编号的说明文本（txt），文本中有label</li><li>直接把label写在数据的名称上</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset</span><br></pre></td></tr></table></figure><h3 id="通过路径加载数据"><a href="#通过路径加载数据" class="headerlink" title="通过路径加载数据"></a>通过路径加载数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">img_path = <span class="string">&quot;数据路径/train/ants/0013035.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line">img.show()</span><br></pre></td></tr></table></figure><h3 id="python特殊方法补充"><a href="#python特殊方法补充" class="headerlink" title="python特殊方法补充"></a>python特殊方法补充</h3><p>Python中有很多特殊方法，这些特殊方法的命名都以双下划线 <code>__</code>开头和结尾，它们是Python中常用的特殊方法。通过定义这些方法，我们可以自定义对象的行为和操作，使得对象能够更好地适应我们的需求</p><ul><li><code>__init__(self[, args...])</code>: 构造函数，用于在创建对象时进行初始化。即Java中的构造器</li><li><code>__repr__(self)</code>: 用于定义对象的字符串表示形式，通常用于调试和记录日志</li><li><code>__str__(self)</code>: 用于定义对象的字符串表示形式，通常用于显示给终端用户。即Java中的toString</li><li><code>__len__(self)</code>: 用于返回对象的长度，通常在对像被视为序列或集合时使用</li><li><code>__getitem__(self, key)</code>: 用于实现索引操作，可以通过索引或切片访问对象中的元素</li><li><code>__setitem__(self, key, value)</code>: 用于实现索引赋值操作，可以通过索引或切片为对象中的元素赋值</li><li><code>__delitem__(self, key)</code>: 用于实现删除某个元素的操作，可以通过索引或切片删除对象中的元素</li><li><code>__contains__(self, item)</code>: 用于检查对象是否包含某个元素，可以通过 in 关键字使用</li><li><code>__enter__(self)</code>: 用于实现上下文管理器的进入操作，通常与 with 语句一起使用</li><li><code>__exit__(self, exc_type, exc_value, traceback)</code>: 用于实现上下文管理器的退出操作，通常与 with 语句一起使用</li><li><code>__call__(self[, args...])</code>: 用于使对象能够像函数一样被调用，通常在创建可调用的类时使用</li><li><code>__eq__(self, other)</code>: 用于定义对象相等的比较操作，可以通过 &#x3D;&#x3D; 运算符使用</li><li><code>__lt__(self, other)</code>: 用于定义对象小于的比较操作，可以通过 &lt; 运算符使用</li><li><code>__gt__(self, other)</code>: 用于定义对象大于的比较操作，可以通过 &gt; 运算符使用</li><li><code>__add__(self, other)</code>: 用于实现对象加法操作，可以通过 + 运算符使用</li><li><code>__sub__(self, other)</code>: 用于实现对象减法操作，可以通过 - 运算符使用</li><li><code>__mul__(self, other)</code>: 用于实现对象乘法操作，可以通过 * 运算符使用</li><li><code>__truediv__(self, other)</code>: 用于实现对象除法操作，可以通过 &#x2F; 运算符使用</li></ul><h3 id="Dataset加载数据示例"><a href="#Dataset加载数据示例" class="headerlink" title="Dataset加载数据示例"></a>Dataset加载数据示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset  </span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义数据集类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyData</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, root_dir, label_dir</span>):</span><br><span class="line">        self.root_dir = root_dir  <span class="comment"># 记录数据集根目录的路径</span></span><br><span class="line">        self.label_dir = label_dir  <span class="comment"># 记录数据集标签目录的名称</span></span><br><span class="line">        self.path = os.path.join(self.root_dir, self.label_dir)  <span class="comment"># os.path.join可将两个字符串拼接成一个完整路径，以获取数据集标签目录的完整路径</span></span><br><span class="line">        self.img_path = os.listdir(self.path)  <span class="comment"># os.listdir() 函数用于获取指定目录下的所有文件和文件夹的名称列表，以获取数据集标签目录下所有图像文件的路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):  <span class="comment"># 获取数据集中指定索引位置的数据项</span></span><br><span class="line">        img_name = self.img_path[idx]  <span class="comment"># 获取图像文件名</span></span><br><span class="line">        img_item_path = os.path.join(self.root_dir, self.label_dir, img_name)  <span class="comment"># 获取该图像文件的完整路径</span></span><br><span class="line">        img = Image.<span class="built_in">open</span>(img_item_path)  <span class="comment"># 打开图像文件</span></span><br><span class="line">        label = self.label_dir  <span class="comment"># 获取该图像文件所属的标签</span></span><br><span class="line">        <span class="keyword">return</span> img, label  <span class="comment"># 返回图像和标签</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.img_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root_dir = <span class="string">&quot;data/train&quot;</span>   <span class="comment"># 数据集根目录的路径</span></span><br><span class="line">ants_label_dir = <span class="string">&quot;ants&quot;</span>     <span class="comment"># 蚂蚁标签目录的名称</span></span><br><span class="line">bees_label_dir = <span class="string">&quot;bees&quot;</span>     <span class="comment"># 蜜蜂标签目录的名称</span></span><br><span class="line">ants_dataset = MyData(root_dir, ants_label_dir)  <span class="comment"># 创建蚂蚁数据集对象</span></span><br><span class="line">bees_dataset = MyData(root_dir, bees_label_dir)   <span class="comment"># 创建蜜蜂数据集对象</span></span><br><span class="line">train_dataset = ants_dataset + bees_dataset  <span class="comment"># 合并蚂蚁和蜜蜂数据集，得到训练集</span></span><br><span class="line">img, label = train_dataset[<span class="number">200</span>]  <span class="comment"># 自动调用__getitem__() 方法，获取训练集中第 200 个数据项的图像和标签 </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;label：&quot;</span>, label)   <span class="comment"># 查看该数据项的标签</span></span><br><span class="line">img.show()   </span><br></pre></td></tr></table></figure><h2 id="TensorBoard"><a href="#TensorBoard" class="headerlink" title="TensorBoard"></a>TensorBoard</h2><p>Tensorboad可以用来查看loss是否按照预想的变化，或者查看训练到某一步输出的图像是什么样</p><h3 id="Tensorboard使用示例"><a href="#Tensorboard使用示例" class="headerlink" title="Tensorboard使用示例"></a>Tensorboard使用示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)<span class="comment"># 创建一个 SummaryWriter 对象，指定日志存储目录为 &quot;logs&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">    <span class="comment"># 将 y=x 的函数值添加到 TensorBoard 中</span></span><br><span class="line">    writer.add_scalar(<span class="string">&quot;y=x&quot;</span>, i, i)</span><br><span class="line">writer.close()<span class="comment"># 关闭 SummaryWriter 对象</span></span><br></pre></td></tr></table></figure><p>运行完后会在当前目录下创建一个logs文件夹</p><p>在终端运行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tensorboard --logdir=logs --port=6007</span><br></pre></td></tr></table></figure><h2 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h2><p>Transforms当成工具箱的话，里面的class就是不同的工具。例如像totensor、resize这些工具。Transforms拿一些特定格式的图片，经过Transforms里面的工具，获得我们想要的结果</p><h3 id="transforms-Totensor"><a href="#transforms-Totensor" class="headerlink" title="transforms.Totensor"></a>transforms.Totensor</h3><p>Tensor包装了神经网络需要的一些属性，比如反向传播、梯度等属性</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;/bees/10870992_eebeeb3a12.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line">tensor_trans = transforms.ToTensor()  <span class="comment"># 创建 transforms.ToTensor类 的实例化对象</span></span><br><span class="line">tensor_img = tensor_trans(img)  <span class="comment"># 调用 transforms.ToTensor类的__call__方法   </span></span><br><span class="line"></span><br><span class="line">writer.add_image(<span class="string">&quot;Temsor_img&quot;</span>,tensor_img)</span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h3 id="transforms-Resize"><a href="#transforms-Resize" class="headerlink" title="transforms.Resize()"></a>transforms.Resize()</h3><p>调整图像的大小到指定的尺寸</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;data/Images/1.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图片转为totensor类型</span></span><br><span class="line">trans_totensor = transforms.ToTensor() </span><br><span class="line">img_tensor = trans_totensor(img)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># resize图片，PIL数据类型的 img -&gt; resize -&gt; PIL数据类型的 img_resize</span></span><br><span class="line">trans_resize = transforms.Resize((<span class="number">512</span>,<span class="number">512</span>))  <span class="comment"># 调整尺寸为512*512</span></span><br><span class="line">img_resize = trans_resize(img)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL 数据类型的 PIL -&gt; totensor -&gt; img_resize tensor</span></span><br><span class="line">img_resize = trans_totensor(img_resize)</span><br><span class="line"><span class="built_in">print</span>(img_resize.size()) </span><br></pre></td></tr></table></figure><h4 id="transforms-Compose"><a href="#transforms-Compose" class="headerlink" title="transforms.Compose"></a>transforms.Compose</h4><p>transforms.Compose 的作用是将多个数据预处理操作组合在一起，方便地对数据进行一次性处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">img_path = <span class="string">&quot;data/Images/1.jpg&quot;</span></span><br><span class="line">img = Image.<span class="built_in">open</span>(img_path)</span><br><span class="line"></span><br><span class="line">tensor_trans = transforms.ToTensor() </span><br><span class="line">img_tensor = tensor_trans(img)  </span><br><span class="line"></span><br><span class="line">trans_resize_2 = transforms.Resize(<span class="number">512</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># PIL —— resize -&gt; PIL ——  totensor -&gt; tensor</span></span><br><span class="line">trans_compose = transforms.Compose([trans_resize_2, trans_totensor]) <span class="comment"># Compose函数中前面一个参数的输出为后面一个参数的输入，即trans_resize_2输出了pil，作为trans_totensor的输入</span></span><br><span class="line">img_resize_2 = trans_compose(img)</span><br><span class="line"><span class="built_in">print</span>(img_resize_2.size()) </span><br></pre></td></tr></table></figure><h2 id="DataLoader"><a href="#DataLoader" class="headerlink" title="DataLoader"></a>DataLoader</h2><p>DataLoader可以将数据集进行批量处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备的测试数据集</span></span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor())    </span><br><span class="line"></span><br><span class="line"><span class="comment"># batch_size=4 使得 img0, target0 = dataset[0]、img1, target1 = dataset[1]、img2, target2 = dataset[2]、img3, target3 = dataset[3]，然后这四个数据作为Dataloader的一个返回      </span></span><br><span class="line">test_loader = DataLoader(dataset=test_data,batch_size=<span class="number">4</span>,shuffle=<span class="literal">True</span>,num_workers=<span class="number">0</span>,drop_last=<span class="literal">True</span>)      </span><br><span class="line"><span class="comment"># 用for循环取出DataLoader打包好的四个数据</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> test_loader:</span><br><span class="line">        imgs, targets = data <span class="comment"># 每个data都是由4张图片组成，imgs.size 为 [4,3,32,32]，四张32×32图片三通道，targets由四个标签组成             </span></span><br><span class="line">        writer.add_images(<span class="string">&quot;Epoch：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(epoch), imgs, step) <span class="comment"># 注意是images</span></span><br><span class="line">        step = step + <span class="number">1</span></span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><h3 id="nn-Module"><a href="#nn-Module" class="headerlink" title="nn.Module"></a>nn.Module</h3><p>orch.nn.Module是所有神经网络基本骨架，需要重写<code>__init__</code>和forward（前向传播）函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()  <span class="comment"># 继承</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):           <span class="comment"># 前向传播</span></span><br><span class="line">        output = <span class="built_in">input</span> + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line">    </span><br><span class="line">m = Module()</span><br><span class="line">x = torch.tensor(<span class="number">1.0</span>)  <span class="comment"># 创建一个值为 1.0 的tensor</span></span><br><span class="line">output = m(x)</span><br><span class="line"><span class="built_in">print</span>(output) <span class="comment"># 2</span></span><br></pre></td></tr></table></figure><h3 id="卷积函数"><a href="#卷积函数" class="headerlink" title="卷积函数"></a>卷积函数</h3><p>convolution卷积，conv2d表示二维</p><p>weight卷积核的大小，bias偏置，stride步长，padding填充，group是分组卷积，对不同的通道使用不同的卷积核，言外之意一般是对每个通道使用相同卷积核</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()</span><br><span class="line">        self.conv1 = Conv2d(in_channels=<span class="number">3</span>,out_channels=<span class="number">6</span>,kernel_size=<span class="number">3</span>,stride=<span class="number">1</span>,padding=<span class="number">0</span>) <span class="comment"># 彩色图像输入为3层，我们想让它的输出为6层，选3 * 3 的卷积                </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        x = self.conv1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">m = Module()</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    output = m(imgs)</span><br><span class="line">    <span class="built_in">print</span>(imgs.shape)   <span class="comment"># 输入为3通道32×32的64张图片</span></span><br><span class="line">    <span class="built_in">print</span>(output.shape) <span class="comment"># 输出为6通道30×30的64张图片</span></span><br></pre></td></tr></table></figure><h3 id="最大池化"><a href="#最大池化" class="headerlink" title="最大池化"></a>最大池化</h3><p>nn.MaxPool2d最大池化（下采样，最常用），nn.MaxUnpool2d（上采样），nn.AdaptiveMaxPool2d（自适应最大池化），ceil_mode&#x3D;True表示进位，默认为False，写论文会用到公式可以在官网查阅</p><p>最大池化的作用：保留输入的特征，同时把数据量减少，比如视频变720P</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn </span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> MaxPool2d</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()</span><br><span class="line">        self.maxpool = MaxPool2d(kernel_size=<span class="number">3</span>, ceil_mode=<span class="literal">True</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, <span class="built_in">input</span></span>):</span><br><span class="line">        output = self.maxpool(<span class="built_in">input</span>)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">m = Module()  <span class="comment"># 即调用forward()</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">    imgs, targets = data</span><br><span class="line">    writer.add_images(<span class="string">&quot;input&quot;</span>, imgs, step)</span><br><span class="line">    output = m(imgs)</span><br><span class="line">    writer.add_images(<span class="string">&quot;output&quot;</span>, output, step)</span><br><span class="line">    step = step + <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="非线性激活"><a href="#非线性激活" class="headerlink" title="非线性激活"></a>非线性激活</h3><p>作用：神经网络中引入非线性的特质，才能训练出符合各种特征的模型</p><p>nn.ReLU()小于0进行截断，大于0不变，nn.Sigmoid非线性缩放到[0,1]，1&#x2F;1+exp-x，inplace&#x3D;True表示把原来的值也改变（本来是通过返回值获取值）</p><h3 id="线性层及其它层"><a href="#线性层及其它层" class="headerlink" title="线性层及其它层"></a>线性层及其它层</h3><ul><li>Normalization Layers正则化层：加快神经网络的训练速度</li><li>Recurrent Layers用于文字识别，特定的网络结构，用的不多</li><li>Linear Layers：全连接层，用的较多</li><li>Dropout Layers随机将一些数设为0，防止过拟合</li><li>Distance Functions计算两个值之间的误差，常用余弦相似度</li><li>Loss Functions损失函数，常用值nn.MSELoss，nn.CrossEntropyLoss，nn.BCELoss，分布nn.NLLLoss，nn.KLDivLoss</li><li>torch.flatten()把输入展成一行，与reshape不同</li></ul><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><ul><li>Loss损失函数一方面计算实际输出和目标之间的差距</li><li>Loss损失函数另一方面为我们更新输出提供一定的依据(反向传播)</li></ul><p><strong>L1loss</strong>:差值的绝对值之和，再求平均值</p><p><strong>MSE</strong>:平方差</p><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p>梯度下降是一种优化算法，用于最小化损失函数（Loss Function）。神经网络的训练目标是通过不断调整网络的参数（即权重和偏置）来最小化损失函数的值。梯度下降算法通过计算损失函数相对于网络参数的梯度来指导参数更新的方向和步幅。</p><h3 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h3><p>反向传播是一种高效计算梯度的方法，适用于多层神经网络。反向传播算法通过链式法则（Chain Rule）逐层计算损失函数对每个参数的梯度。</p><p><strong>反向传播和梯度下降的关系</strong></p><ol><li><strong>目标一致</strong>：两者的目标都是通过调整神经网络的参数来最小化损失函数</li><li><strong>互补</strong>：反向传播计算损失函数对参数的梯度，而梯度下降利用这些梯度更新参数</li><li><strong>训练过程</strong>：在神经网络的训练过程中，反向传播和梯度下降是交替进行的。首先进行前向传播，计算损失并通过反向传播计算梯度，然后使用梯度下降更新参数</li></ol><h3 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h3><p>使用优化器时，首先需要optim.zero_grad()，把上一步的梯度清零，否则会累加，然后进行反向传播，再optimizer.step()，对weight参数进行更新</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.nn <span class="keyword">import</span> Conv2d, MaxPool2d, Flatten, Linear, Sequential</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"></span><br><span class="line">dataset = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>, train=<span class="literal">False</span>, transform=torchvision.transforms.ToTensor(),</span><br><span class="line">                                       download=<span class="literal">True</span>)</span><br><span class="line">dataloader = DataLoader(dataset, batch_size=<span class="number">64</span>, drop_last=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()</span><br><span class="line">        self.model1 = Sequential(</span><br><span class="line">            Conv2d(<span class="number">3</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">32</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Conv2d(<span class="number">32</span>, <span class="number">64</span>, <span class="number">5</span>, padding=<span class="number">2</span>),</span><br><span class="line">            MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            Flatten(),</span><br><span class="line">            Linear(<span class="number">1024</span>, <span class="number">64</span>),</span><br><span class="line">            Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loss = nn.CrossEntropyLoss()  <span class="comment"># 交叉熵</span></span><br><span class="line">m = Module()</span><br><span class="line">optim = torch.optim.SGD(tudui.parameters(), lr=<span class="number">0.01</span>)  <span class="comment"># 随机梯度下降优化器 lr为学习率,学习率太大不稳定,太小收敛慢</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化20轮</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> dataloader:</span><br><span class="line">        imgs, targets = data</span><br><span class="line">        outputs = m(imgs)</span><br><span class="line">        result_loss = loss(outputs, targets) <span class="comment"># 计算实际输出与目标输出的差距</span></span><br><span class="line">        optim.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">        result_loss.backward() <span class="comment"># 反向传播，计算损失函数的梯度</span></span><br><span class="line">        optim.step()   <span class="comment"># 根据梯度，对网络的参数进行调优</span></span><br><span class="line">        running_loss = running_loss + result_loss</span><br><span class="line">    <span class="built_in">print</span>(running_loss) <span class="comment"># 每轮误差的总和</span></span><br></pre></td></tr></table></figure><h3 id="train-和tudui-eval-方法"><a href="#train-和tudui-eval-方法" class="headerlink" title="train()和tudui.eval()方法"></a>train()和tudui.eval()方法</h3><p>分别用于训练步骤和测试步骤，对特定层起作用，最好可以在训练和评估之前加上这个方法</p><h2 id="网络模型的保存和读取"><a href="#网络模型的保存和读取" class="headerlink" title="网络模型的保存和读取"></a>网络模型的保存和读取</h2><p>使用<code>save</code>方法保存网络模型的结构和参数，<code>load</code>加载时候要把模型定义给复制过来</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleModel</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(SimpleModel, self).__init__()</span><br><span class="line">        self.fc = nn.Linear(<span class="number">10</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> self.fc(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">model = SimpleModel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存权重</span></span><br><span class="line">torch.save(model.state_dict(), <span class="string">&#x27;model_weights.pth&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载权重</span></span><br><span class="line">loaded_model = SimpleModel()</span><br><span class="line">loaded_model.load_state_dict(torch.load(<span class="string">&#x27;model_weights.pth&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保模型和加载的权重一致</span></span><br><span class="line">loaded_model.<span class="built_in">eval</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以继续使用加载的模型进行预测等操作</span></span><br></pre></td></tr></table></figure><h2 id="利用GPU训练"><a href="#利用GPU训练" class="headerlink" title="利用GPU训练"></a>利用GPU训练</h2><p>在程序之前定义:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后找到</p><ul><li>网络模型</li><li>数据（输入、标注）</li><li>损失函数</li></ul><p>后面加上<code>to(device)</code>即可转到GPU训练</p><h2 id="完整版实战"><a href="#完整版实战" class="headerlink" title="完整版实战"></a>完整版实战</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义训练的设备</span></span><br><span class="line">device = torch.device(<span class="string">&quot;cuda:0&quot;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&quot;cpu&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Module</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(Module, self).__init__()        </span><br><span class="line">        self.model1 = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">3</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),  <span class="comment"># 输入通道3，输出通道32，卷积核尺寸5×5，步长1，填充2    </span></span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">32</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Conv2d(<span class="number">32</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>),</span><br><span class="line">            nn.Flatten(),  <span class="comment"># 展平后变成 64*4*4 了</span></span><br><span class="line">            nn.Linear(<span class="number">64</span>*<span class="number">4</span>*<span class="number">4</span>,<span class="number">64</span>),</span><br><span class="line">            nn.Linear(<span class="number">64</span>,<span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.model1(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备数据集</span></span><br><span class="line">train_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">True</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line">test_data = torchvision.datasets.CIFAR10(<span class="string">&quot;./dataset&quot;</span>,train=<span class="literal">False</span>,transform=torchvision.transforms.ToTensor(),download=<span class="literal">True</span>)       </span><br><span class="line"></span><br><span class="line"><span class="comment"># length 长度</span></span><br><span class="line">train_data_size = <span class="built_in">len</span>(train_data)</span><br><span class="line">test_data_size = <span class="built_in">len</span>(test_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 Dataloader 来加载数据集</span></span><br><span class="line">train_dataloader = DataLoader(train_data, batch_size=<span class="number">64</span>)        </span><br><span class="line">test_dataloader = DataLoader(test_data, batch_size=<span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建网络模型</span></span><br><span class="line">m = Module() </span><br><span class="line">m = m.to(device) <span class="comment"># 也可以不赋值，直接m.to(device) </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 损失函数</span></span><br><span class="line">loss_fn = nn.CrossEntropyLoss() <span class="comment"># 交叉熵</span></span><br><span class="line">loss_fn = loss_fn.to(device)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化器</span></span><br><span class="line">learning = <span class="number">0.01</span></span><br><span class="line">optimizer = torch.optim.SGD(tudui.parameters(),learning)   <span class="comment"># 随机梯度下降优化器  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置网络的一些参数</span></span><br><span class="line"><span class="comment"># 记录训练的次数</span></span><br><span class="line">total_train_step = <span class="number">0</span></span><br><span class="line"><span class="comment"># 记录测试的次数</span></span><br><span class="line">total_test_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练的轮次</span></span><br><span class="line">epoch = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 tensorboard</span></span><br><span class="line">writer = SummaryWriter(<span class="string">&quot;logs&quot;</span>)</span><br><span class="line">start_time = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(epoch):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----第 &#123;&#125; 轮训练开始-----&quot;</span>.<span class="built_in">format</span>(i+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练步骤开始</span></span><br><span class="line">    tudui.train() <span class="comment"># 当网络中有dropout层、batchnorm层时，这些层能起作用</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_dataloader:</span><br><span class="line">        imgs, targets = data            </span><br><span class="line">        imgs = imgs.to(device)</span><br><span class="line">        targets = targets.to(device)</span><br><span class="line">        outputs = tudui(imgs)</span><br><span class="line">        loss = loss_fn(outputs, targets) <span class="comment"># 计算实际输出与目标输出的差距</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 优化器对模型调优</span></span><br><span class="line">        optimizer.zero_grad()  <span class="comment"># 梯度清零</span></span><br><span class="line">        loss.backward() <span class="comment"># 反向传播，计算损失函数的梯度</span></span><br><span class="line">        optimizer.step()   <span class="comment"># 根据梯度，对网络的参数进行调优</span></span><br><span class="line">        </span><br><span class="line">        total_train_step = total_train_step + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> total_train_step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            end_time = time.time()</span><br><span class="line">            <span class="built_in">print</span>(end_time - start_time) <span class="comment"># 运行训练一百次后的时间间隔</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;训练次数：&#123;&#125;，Loss：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_train_step,loss.item()))  <span class="comment"># 方式二：获得loss值</span></span><br><span class="line">            writer.add_scalar(<span class="string">&quot;train_loss&quot;</span>,loss.item(),total_train_step)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试步骤开始（每一轮训练后都查看在测试数据集上的loss情况）</span></span><br><span class="line">    tudui.<span class="built_in">eval</span>()  <span class="comment"># 当网络中有dropout层、batchnorm层时，这些层不能起作用</span></span><br><span class="line">    total_test_loss = <span class="number">0</span></span><br><span class="line">    total_accuracy = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():  <span class="comment"># 没有梯度了</span></span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> test_dataloader: <span class="comment"># 测试数据集提取数据</span></span><br><span class="line">            imgs, targets = data <span class="comment"># 数据放到cuda上</span></span><br><span class="line">            imgs = imgs.to(device) <span class="comment"># 也可以不赋值，直接 imgs.to(device)</span></span><br><span class="line">            targets = targets.to(device) <span class="comment"># 也可以不赋值，直接 targets.to(device)</span></span><br><span class="line">            outputs = tudui(imgs)</span><br><span class="line">            loss = loss_fn(outputs, targets) <span class="comment"># 仅data数据在网络模型上的损失</span></span><br><span class="line">            total_test_loss = total_test_loss + loss.item() <span class="comment"># 所有loss</span></span><br><span class="line">            accuracy = (outputs.argmax(<span class="number">1</span>) == targets).<span class="built_in">sum</span>()</span><br><span class="line">            total_accuracy = total_accuracy + accuracy</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的Loss：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_test_loss))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;整体测试集上的正确率：&#123;&#125;&quot;</span>.<span class="built_in">format</span>(total_accuracy/test_data_size))</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_loss&quot;</span>,total_test_loss,total_test_step)</span><br><span class="line">    writer.add_scalar(<span class="string">&quot;test_accuracy&quot;</span>,total_accuracy/test_data_size,total_test_step)  </span><br><span class="line">    total_test_step = total_test_step + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    torch.save(m, <span class="string">&quot;./model/m_&#123;&#125;.pth&quot;</span>.<span class="built_in">format</span>(i)) <span class="comment"># 保存每一轮训练后的结果</span></span><br><span class="line">    <span class="comment">#torch.save(m.state_dict(),&quot;m_&#123;&#125;.path&quot;.format(i)) # 保存方式二         </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;模型已保存&quot;</span>)</span><br><span class="line">    </span><br><span class="line">writer.close()</span><br></pre></td></tr></table></figure><p>**with torch.no_grad()**表示在训练数据集的同时进行验证，可以让之后的代码不影响目前的梯度</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/pytorch/">pytorch</category>
      
      
      <category domain="http://example.com/tags/pytorch/">pytorch</category>
      
      
      <comments>http://example.com/inori/8f832495.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>numpy常用api</title>
      <link>http://example.com/inori/e0d16fd2.html</link>
      <guid>http://example.com/inori/e0d16fd2.html</guid>
      <pubDate>Tue, 21 May 2024 11:18:34 GMT</pubDate>
      
      <description>numpy入门</description>
      
      
      
      <content:encoded><![CDATA[<p>NumPy，全称Numerical Python，是一个开源的Python库，它为Python提供了强大的多维数组对象和用于处理这些数组的函数。NumPy的核心是ndarray，它是一个高效的多维数组容器，用于存储和处理大规模的数据。NumPy还提供了许多数学函数，用于数组之间的操作，以及用于线性代数、傅立叶变换和随机数生成等功能。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><h3 id="ndarray"><a href="#ndarray" class="headerlink" title="ndarray"></a>ndarray</h3><p><code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, ndmin = 0)</code></p><p>上面的构造器接受以下参数：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">object</td><td align="left">返回一个数组或任何（嵌套）序列</td></tr><tr><td align="left">dtype</td><td align="left">数组的所需数据类型，可选</td></tr><tr><td align="left">copy</td><td align="left">可选，默认为<code>true</code>，对象是否被复制</td></tr><tr><td align="left">order</td><td align="left"><code>C</code>（按行）、<code>F</code>（按列）或<code>A</code>（任意，默认）</td></tr><tr><td align="left">subok</td><td align="left">默认情况下，返回的数组被强制为基类数组。 如果为<code>true</code>，则返回子类</td></tr><tr><td align="left">ndmin</td><td align="left">指定返回数组的最小维数</td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  </span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">c = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], ndmin =  <span class="number">2</span>) </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a = [1, 2, 3]</span></span><br><span class="line"><span class="string">b = [[1, 2] ,[3, 4]]</span></span><br><span class="line"><span class="string">c = [[1,2,3,4,5]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h3><p>创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组</p><p><code>numpy.empty(shape, dtype = float, order = &#39;C&#39;)</code></p><h3 id="zeros"><a href="#zeros" class="headerlink" title="zeros"></a>zeros</h3><p>创建指定大小的数组，数组元素以 0 来填充：</p><p><code>numpy.zeros(shape, dtype = float, order = &#39;C&#39;)</code></p><h3 id="ones"><a href="#ones" class="headerlink" title="ones"></a>ones</h3><p>创建指定形状的数组，数组元素以 1 来填充：</p><p><code>numpy.ones(shape, dtype = None, order = &#39;C&#39;)</code></p><h3 id="zeros-like"><a href="#zeros-like" class="headerlink" title="zeros_like"></a>zeros_like</h3><p>创建一个与给定数组具有相同形状的数组，数组元素以 0 来填充</p><p><code>numpy.zeros_like(a, dtype=None, order=&#39;K&#39;, subok=True, shape=None)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个 3x3 的二维数组</span></span><br><span class="line">arr = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个与 arr 形状相同的，所有元素都为 0 的数组</span></span><br><span class="line">zeros_arr = np.zeros_like(arr)</span><br><span class="line"><span class="built_in">print</span>(zeros_arr)</span><br></pre></td></tr></table></figure><h3 id="asarray"><a href="#asarray" class="headerlink" title="asarray"></a>asarray</h3><p>类似numpy.array，但参数只有三个</p><p><code>numpy.asarray(a, dtype = None, order = None)</code></p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line">a = np.asarray(x)  <span class="comment"># [1,2,3] </span></span><br><span class="line"></span><br><span class="line">x =  (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line">a = np.asarray(x) <span class="comment"># [1,2,3]</span></span><br><span class="line"></span><br><span class="line">x =  [(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>)] </span><br><span class="line">a = np.asarray(x) <span class="comment"># [1,2,3] </span></span><br></pre></td></tr></table></figure><h3 id="arange"><a href="#arange" class="headerlink" title="arange"></a>arange</h3><p>创建数值范围并返回ndarray对象</p><p><code>numpy.arange(start, stop, step, dtype)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">起始值，默认为<code>0</code></td></tr><tr><td align="left"><code>stop</code></td><td align="left">终止值（不包含）</td></tr><tr><td align="left"><code>step</code></td><td align="left">步长，默认为<code>1</code></td></tr><tr><td align="left"><code>dtype</code></td><td align="left">返回<code>ndarray</code>的数据类型，如果没有提供，则会使用输入数据的类型。</td></tr></tbody></table><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span>(x)<span class="comment"># [10  12  14  16  18]</span></span><br></pre></td></tr></table></figure><h3 id="linspace"><a href="#linspace" class="headerlink" title="linspace"></a>linspace</h3><p>用于创建一个一维数组，数组是一个等差数列构成的</p><p><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">序列的起始值</td></tr><tr><td align="left"><code>stop</code></td><td align="left">序列的终止值，如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td align="left"><code>num</code></td><td align="left">要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td align="left"><code>endpoint</code></td><td align="left">该值为<code>true</code>时，数列中包含<code>stop</code>值，反之不包含，默认是True</td></tr><tr><td align="left"><code>retstep</code></td><td align="left">如果为<code>true</code>时，生成的数组中会显示间距，反之不显示</td></tr><tr><td align="left"><code>dtype</code></td><td align="left">数据类型</td></tr></tbody></table><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 设置起始点为 1 ，终止点为 10，数列个数为 10</span></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># [ 1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]</span></span><br><span class="line"></span><br><span class="line">a = np.linspace(<span class="number">10</span>, <span class="number">20</span>,  <span class="number">5</span>, endpoint =  <span class="literal">False</span>)  </span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment"># [10. 12. 14. 16. 18.]</span></span><br></pre></td></tr></table></figure><h3 id="logspace"><a href="#logspace" class="headerlink" title="logspace"></a>logspace</h3><p>用于创建一个等比数列</p><p><code>np.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None)</code></p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>start</code></td><td align="left">序列的起始值为：$base^{start}$</td></tr><tr><td align="left"><code>stop</code></td><td align="left">序列的终止值为：$base^{stop}$。如果<code>endpoint</code>为<code>true</code>，该值包含于数列中</td></tr><tr><td align="left"><code>num</code></td><td align="left">要生成的等步长的样本数量，默认为<code>50</code></td></tr><tr><td align="left"><code>endpoint</code></td><td align="left">该值为 <code>true</code> 时，数列中中包含<code>stop</code>值，反之不包含，默认是<code>true</code></td></tr><tr><td align="left"><code>base</code></td><td align="left">对数 log 的底数，默认底数是 10</td></tr><tr><td align="left"><code>dtype</code></td><td align="left">数据类型</td></tr></tbody></table><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 默认底数是 10</span></span><br><span class="line">a = np.logspace(<span class="number">1.0</span>,  <span class="number">2.0</span>, num =  <span class="number">10</span>)  </span><br><span class="line"><span class="built_in">print</span> (a)<span class="comment"># [ 10. 12.91549665 16.68100537 21.5443469  27.82559402 35.93813664  46.41588834  59.94842503  77.42636827  100.]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对数的底数设置为 2 </span></span><br><span class="line">a = np.logspace(<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>,base=<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (a)<span class="comment"># [  1.   2.   4.   8.  16.  32.  64. 128. 256. 512.]</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>NumPy支持比Python更多种类的数值类型</p><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>bool_</code></td><td align="left">存储为一个字节的布尔值（真或假）</td></tr><tr><td align="left"><code>int_</code></td><td align="left">默认整数，相当于 C 的<code>long</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left"><code>intc</code></td><td align="left">相当于 C 的<code>int</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left"><code>intp</code></td><td align="left">用于索引的整数，相当于 C 的<code>size_t</code>，通常为<code>int32</code>或<code>int64</code></td></tr><tr><td align="left"><code>int8</code></td><td align="left">字节（-128 ~ 127）</td></tr><tr><td align="left"><code>int16</code></td><td align="left">16 位整数（-32768 ~ 32767）</td></tr><tr><td align="left"><code>int32</code></td><td align="left">32 位整数（-2147483648 ~ 2147483647）</td></tr><tr><td align="left"><code>int64</code></td><td align="left">64 位整数（-9223372036854775808 ~ 9223372036854775807）</td></tr><tr><td align="left"><code>uint8</code></td><td align="left">8 位无符号整数（0 ~ 255）</td></tr><tr><td align="left"><code>uint16</code></td><td align="left">16 位无符号整数（0 ~ 65535）</td></tr><tr><td align="left"><code>uint32</code></td><td align="left">32 位无符号整数（0 ~ 4294967295）</td></tr><tr><td align="left"><code>uint64</code></td><td align="left">64 位无符号整数（0 ~ 18446744073709551615）</td></tr><tr><td align="left"><code>float_</code></td><td align="left"><code>float64</code>的简写</td></tr><tr><td align="left"><code>float16</code></td><td align="left">半精度浮点：符号位，5 位指数，10 位尾数</td></tr><tr><td align="left"><code>float32</code></td><td align="left">单精度浮点：符号位，8 位指数，23 位尾数</td></tr><tr><td align="left"><code>float64</code></td><td align="left">双精度浮点：符号位，11 位指数，52 位尾数</td></tr><tr><td align="left"><code>complex_</code></td><td align="left"><code>complex128</code>的简写</td></tr><tr><td align="left"><code>complex64</code></td><td align="left">复数，由两个 32 位浮点表示（实部和虚部）</td></tr><tr><td align="left"><code>complex128</code></td><td align="left">复数，由两个 64 位浮点表示（实部和虚部）</td></tr></tbody></table><p>NumPy数字类型是<code>dtype</code>（数据类型）对象的实例，每个对象具有唯一的特征。这些类型可以是<code>np.bool_</code>，<code>np.float32</code>等。</p><p>数据类型对象描述了对应于数组的固定内存块的解释，取决于以下方面：</p><ul><li>数据类型（整数、浮点或者Python对象）</li><li>数据大小</li><li>字节序（小端或大端）</li><li>在结构化类型的情况下，字段的名称，每个字段的数据类型，和每个字段占用的内存块部分</li><li>如果数据类型是子序列，它的形状和数据类型</li></ul><p>字节顺序取决于数据类型的前缀<code>&lt;</code>或<code>&gt;</code>。 <code>&lt;</code>意味着编码是小端（最小有效字节存储在最小地址中）。 <code>&gt;</code>意味着编码是大端（最大有效字节存储在最小地址中）。</p><p><code>dtype</code>可由以下语法构造：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numpy.dtype(<span class="built_in">object</span>, align, copy)</span><br></pre></td></tr></table></figure><ul><li><code>Object</code>：被转换为数据类型的对象</li><li><code>align</code>：向字段添加间隔，填充字段使其类似结构体</li><li><code>copy</code>：生成<code>dtype</code>对象的新副本，如果为<code>false</code>，结果是内建数据类型对象的引用</li></ul><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 使用标量类型</span></span><br><span class="line">dt = np.dtype(np.int32)</span><br><span class="line"><span class="comment"># int8, int16, int32, int64 四种数据类型可以使用字符串 &#x27;i1&#x27;, &#x27;i2&#x27;,&#x27;i4&#x27;,&#x27;i8&#x27; 代替</span></span><br><span class="line">dt = np.dtype(<span class="string">&#x27;i4&#x27;</span>)</span><br><span class="line"><span class="comment"># 将数据类型应用于 ndarray 对象</span></span><br><span class="line">dt = np.dtype([(<span class="string">&#x27;age&#x27;</span>,np.int8)]) </span><br><span class="line">a = np.array([(<span class="number">10</span>,),(<span class="number">20</span>,),(<span class="number">30</span>,)], dtype = dt) </span><br><span class="line"></span><br><span class="line">student = np.dtype([(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;S20&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;marks&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)]) </span><br><span class="line">a = np.array([(<span class="string">&#x27;abc&#x27;</span>, <span class="number">21</span>, <span class="number">50</span>),(<span class="string">&#x27;xyz&#x27;</span>, <span class="number">18</span>, <span class="number">75</span>)], dtype = student) </span><br><span class="line"><span class="comment"># [(&#x27;abc&#x27;, 21, 50.0), (&#x27;xyz&#x27;, 18, 75.0)]</span></span><br></pre></td></tr></table></figure><h2 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h2><p>数组的维数称为秩（rank），秩就是轴的数量，一维数组的秩为1，二维数组的秩为2</p><p>在NumPy中，每一个线性的数组称为是一个轴（axis），也就是维度（dimensions）。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是NumPy中的轴，第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量秩，就是数组的维数。</p><p>很多时候可以声明axis。axis&#x3D;0，表示沿着第0轴进行操作，即对每一列进行操作；axis&#x3D;1，表示沿着第1轴进行操作，即对每一行进行操作</p><p>NumPy的数组中比较重要ndarray对象属性有：</p><table><thead><tr><th align="left">属性</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">ndarray.ndim</td><td align="left">秩，即轴的数量或维度的数量</td></tr><tr><td align="left">ndarray.shape</td><td align="left">数组的维度，对于矩阵，n行m列</td></tr><tr><td align="left">ndarray.size</td><td align="left">数组元素的总个数，相当于<code>.shape</code>中n*m的值</td></tr><tr><td align="left">ndarray.dtype</td><td align="left">元素类型</td></tr><tr><td align="left">ndarray.itemsize</td><td align="left">每个元素的大小，以字节为单位</td></tr><tr><td align="left">ndarray.flags</td><td align="left">内存信息</td></tr><tr><td align="left">ndarray.real</td><td align="left">实部</td></tr><tr><td align="left">ndarray.imag</td><td align="left">虚部</td></tr></tbody></table><h3 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">24</span>)  </span><br><span class="line"><span class="built_in">print</span> (a.ndim)<span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整大小</span></span><br><span class="line">b = a.reshape(<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span> (b.ndim)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span> (a.shape)<span class="comment"># (2, 3)</span></span><br><span class="line"><span class="comment"># 调整数组大小</span></span><br><span class="line">a.shape =  (<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span> (a)<span class="comment"># [[1 2],[3 4],[5 6]]</span></span><br></pre></td></tr></table></figure><h2 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h2><p>ndarray对象的内容可以通过索引或切片来访问和修改，与Python中list的切片操作一样。</p><p>ndarray数组可以基于0-n的下标进行索引，切片对象可以通过内置的slice函数，并设置start, stop及step参数进行，从原数组中切割出一个新数组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line">s = <span class="built_in">slice</span>(<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>)   <span class="comment"># 从索引 2 开始到索引 7 停止，间隔为2</span></span><br><span class="line"><span class="built_in">print</span> (a[s])<span class="comment"># [2  4  6]</span></span><br><span class="line"></span><br><span class="line">b = a[<span class="number">2</span>:<span class="number">7</span>:<span class="number">2</span>]   <span class="comment"># 从索引 2 开始到索引 7 停止，间隔为 2</span></span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment"># [2  4  6]</span></span><br></pre></td></tr></table></figure><p>多维数组同样适用上述索引提取方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment"># 从某个索引处开始切割</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;从数组索引 a[1:] 处开始切割&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">1</span>:])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    [[1 2 3]</span></span><br><span class="line"><span class="string">     [3 4 5]</span></span><br><span class="line"><span class="string">     [4 5 6]]</span></span><br><span class="line"><span class="string">    从数组索引 a[1:] 处开始切割</span></span><br><span class="line"><span class="string">    [[3 4 5]</span></span><br><span class="line"><span class="string">     [4 5 6]]</span></span><br><span class="line"><span class="string"> &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>切片还可以包括省略号<code>**…**</code>，如果在行位置使用省略号，它将返回包含行中元素的 ndarray。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])  </span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>])   <span class="comment"># 第2列元素</span></span><br><span class="line"><span class="built_in">print</span> (a[<span class="number">1</span>,...])   <span class="comment"># 第2行元素</span></span><br><span class="line"><span class="built_in">print</span> (a[...,<span class="number">1</span>:])  <span class="comment"># 第2列及剩下的所有元素</span></span><br></pre></td></tr></table></figure><ul><li><code>a[..., 1]</code> 的意思是：选择数组 <code>a</code> 的所有行，并选取每行的第2个元素（索引1处的元素）</li><li><code>a[1, ...]</code> 的意思是：选取数组 <code>a</code> 的第2行（索引1处的整行），并保留该行的所有列</li><li><code>...</code> 表示取所有剩余维度</li></ul><h3 id="高级索引"><a href="#高级索引" class="headerlink" title="高级索引"></a>高级索引</h3><h4 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h4><p>整数数组索引是指使用一个数组来访问另一个数组的元素。这个数组中的每个元素都是目标数组中某个维度上的索引值。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([[<span class="number">1</span>,  <span class="number">2</span>],  [<span class="number">3</span>,  <span class="number">4</span>],  [<span class="number">5</span>,  <span class="number">6</span>]]) </span><br><span class="line"><span class="comment"># 获取数组中 (0,0)、(1,1)和(2,0)位置处的元素</span></span><br><span class="line">y = x[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>],  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]  </span><br><span class="line"><span class="built_in">print</span> (y)</span><br></pre></td></tr></table></figure><p><code>x[[0, 1, 2], [0, 1, 0]]</code>的意思是：</p><ul><li>选取<code>x</code>中的元素，其行索引由第一个数组 <code>[0, 1, 2]</code> 指定</li><li>列索引由第二个数组 <code>[0, 1, 0]</code> 指定</li></ul><p>具体选取的元素为：</p><ul><li><code>x[0, 0]</code> -&gt; 第0行第0列的元素，值为1</li><li><code>x[1, 1]</code> -&gt; 第1行第1列的元素，值为4</li><li><code>x[2, 0]</code> -&gt; 第2行第0列的元素，值为5</li></ul><h4 id="布尔索引"><a href="#布尔索引" class="headerlink" title="布尔索引"></a>布尔索引</h4><p>可以通过一个布尔数组来索引目标数组，布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">x = np.array([[  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],[  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],[  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],[  <span class="number">9</span>,  <span class="number">10</span>,  <span class="number">11</span>]])  </span><br><span class="line"><span class="built_in">print</span> (x)</span><br><span class="line"><span class="comment"># 打印出大于5的元素  </span></span><br><span class="line"><span class="built_in">print</span>  (<span class="string">&#x27;大于 5 的元素是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (x[x &gt;  <span class="number">5</span>])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[ 0  1  2]</span></span><br><span class="line"><span class="string"> [ 3  4  5]</span></span><br><span class="line"><span class="string"> [ 6  7  8]</span></span><br><span class="line"><span class="string"> [ 9 10 11]]</span></span><br><span class="line"><span class="string">大于 5 的元素是：</span></span><br><span class="line"><span class="string">[ 6  7  8  9 10 11]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播(Broadcast)是numpy对不同形状(shape)的数组（a.shape !&#x3D; b.shape）进行数值计算的方式，对数组的算术运算通常在相应的元素上进行。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">           [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>],</span><br><span class="line">           [<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>],</span><br><span class="line">           [<span class="number">30</span>,<span class="number">30</span>,<span class="number">30</span>]])</span><br><span class="line">b = np.array([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(a + b)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[[ 0  1  2]</span></span><br><span class="line"><span class="string"> [10 11 12]</span></span><br><span class="line"><span class="string"> [20 21 22]</span></span><br><span class="line"><span class="string"> [30 31 32]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>3x3的二维数组与长为3的一维数组相加，等效于把一维数组在二维上重复3次再运算</p><h3 id="广播规则"><a href="#广播规则" class="headerlink" title="广播规则"></a>广播规则</h3><ul><li>让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加1补齐</li><li>输出数组的形状是输入数组形状的各个维度上的最大值</li><li>如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为1时，这个数组能够用来计算，否则出错</li><li>当输入数组的某个维度的长度为1时，沿着此维度运算时都用此维度上的第一组值</li></ul><p><strong>简单理解：</strong></p><p>对两个数组，分别比较他们的每一个维度（若其中一个数组没有当前维度则忽略），满足：</p><ul><li>数组拥有相同形状</li><li>当前维度的值相等</li><li>当前维度的值有一个是 1</li></ul><p>若条件不满足，抛出 <strong>“ValueError: frames are not aligned”</strong> 异常</p><h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><p>NumPy提供了很多统计函数，用于从数组中查找最小元素，最大元素，百分位标准差和方差等</p><h3 id="numpy-amin-和-numpy-amax"><a href="#numpy-amin-和-numpy-amax" class="headerlink" title="numpy.amin() 和 numpy.amax()"></a>numpy.amin() 和 numpy.amax()</h3><p>用于计算数组中的元素沿指定轴的最小值</p><p><code>numpy.(amin|amax)(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></p><ul><li><code>a</code>: 输入的数组，可以是一个NumPy数组或类似数组的对象</li><li><code>axis</code>: 可选参数，用于指定在哪个轴上计算最值。如果不提供此参数，则返回整个数组的最小值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴</li><li><code>out</code>: 可选参数，用于指定结果的存储位置</li><li><code>keepdims</code>: 可选参数，如果为True，将保持结果数组的维度数目与输入数组相同。如果为False（默认值），则会去除计算后维度为1的轴</li><li><code>initial</code>: 可选参数，用于指定一个初始值，然后在数组的元素上计算最值</li><li><code>where</code>: 可选参数，一个布尔数组，用于指定仅考虑满足条件的元素</li></ul><h3 id="numpy-ptp"><a href="#numpy-ptp" class="headerlink" title="numpy.ptp()"></a>numpy.ptp()</h3><p>计算数组中元素最大值与最小值的差（最大值 - 最小值）。</p><p><code>numpy.ptp(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)</code></p><ul><li><code>axis</code>: 可选参数，用于指定在哪个轴上计算峰值。如果不提供此参数，则返回整个数组的峰值。可以是一个整数表示轴的索引，也可以是一个元组表示多个轴</li><li><code>initial</code>: 可选参数，用于指定一个初始值，然后在数组的元素上计算峰值</li></ul><h3 id="numpy-percentile"><a href="#numpy-percentile" class="headerlink" title="numpy.percentile()"></a>numpy.percentile()</h3><p>百分位数是统计中使用的度量，表示小于这个值的观察值的百分比</p><p><code>numpy.percentile(a, q, axis)</code></p><ul><li>a: 输入数组</li><li>q: 要计算的百分位数，在0~100之间</li><li>axis: 沿着它计算百分位数的轴</li></ul><p><strong>百分位数：</strong></p><p>第p个百分位数是这样一个值，它使得至少有p%的数据项小于或等于这个值，且至少有(100-p)%的数据项大于或等于这个值</p><h3 id="numpy-median"><a href="#numpy-median" class="headerlink" title="numpy.median()"></a>numpy.median()</h3><p>用于计算数组a中元素的中位数（中值）</p><p><code>numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=&lt;no value&gt;)</code></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">3</span>,<span class="number">2</span>)  </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;我们的数组是：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line">wt = np.array([<span class="number">3</span>,<span class="number">5</span>])  </span><br><span class="line"><span class="built_in">print</span> (np.average(a, axis =  <span class="number">1</span>, weights = wt))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;修改后的数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (np.average(a, axis =  <span class="number">1</span>, weights = wt, returned =  <span class="literal">True</span>))</span><br></pre></td></tr></table></figure><h3 id="numpy-mean"><a href="#numpy-mean" class="headerlink" title="numpy.mean()"></a>numpy.mean()</h3><p>返回数组中元素的平均值，如果提供了轴，则沿其计算，算术平均值是沿轴的元素的总和除以元素的数量</p><p><code>numpy.mean(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)</code></p><h3 id="numpy-average"><a href="#numpy-average" class="headerlink" title="numpy.average()"></a>numpy.average()</h3><p>根据在另一个数组中给出的各自的权重计算数组中元素的加权平均值，该函数可以接受一个轴参数。如果没有指定轴，则数组会被展开</p><p><code>numpy.average(a, axis=None, weights=None, returned=False)</code></p><p>加权平均值即将各数值乘以相应的权数，然后加总求和得到总体值，再除以总的单位数</p><p>考虑数组[1,2,3,4]和相应的权重[4,3,2,1]，通过将相应元素的乘积相加，并将和除以权重的和，来计算加权平均值</p><p><code>加权平均值 = (1*4+2*3+3*2+4*1)/(4+3+2+1)</code></p><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><p>统计中的方差（样本方差）是每个样本值与全体样本值的平均数之差的平方的平均数</p><p><code>numpy.var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;, *, where=&lt;no value&gt;, mean=&lt;no value&gt;)</code></p><h3 id="标准差"><a href="#标准差" class="headerlink" title="标准差"></a>标准差</h3><p>标准差是一组数据平均值分散程度的一种度量。标准差是方差的算术平方根。</p><p><code>numpy.std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False)</code></p><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>NumPy 提供了标准的三角函数：sin()、cos()、tan()</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">0</span>,<span class="number">30</span>,<span class="number">45</span>,<span class="number">60</span>,<span class="number">90</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;含有正弦值的数组：&#x27;</span>)</span><br><span class="line">sin = np.sin(a*np.pi/<span class="number">180</span>)</span><br><span class="line"><span class="built_in">print</span>(sin)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;计算角度的反正弦，返回值以弧度为单位：&#x27;</span>)</span><br><span class="line">inv = np.arcsin(sin)</span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;通过转化为角度制来检查结果：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;arccos 和 arctan 函数行为类似：&#x27;</span>)</span><br><span class="line">cos = np.cos(a*np.pi/<span class="number">180</span>)  </span><br><span class="line"><span class="built_in">print</span>(cos)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;反余弦：&#x27;</span>)</span><br><span class="line">inv = np.arccos(cos)  </span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;角度制单位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;tan 函数：&#x27;</span>)</span><br><span class="line">tan = np.tan(a*np.pi/<span class="number">180</span>)  </span><br><span class="line"><span class="built_in">print</span>(tan)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;反正切：&#x27;</span>)</span><br><span class="line">inv = np.arctan(tan)  </span><br><span class="line"><span class="built_in">print</span>(inv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;角度制单位：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.degrees(inv))</span><br></pre></td></tr></table></figure><h3 id="舍入函数"><a href="#舍入函数" class="headerlink" title="舍入函数"></a>舍入函数</h3><p>返回指定数字的四舍五入值</p><p><code>numpy.around(a,decimals)</code></p><ul><li>a: 数组</li><li>decimals: 舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.array([<span class="number">1.0</span>,<span class="number">5.55</span>,  <span class="number">123</span>,  <span class="number">0.567</span>,  <span class="number">25.532</span>])  </span><br><span class="line"><span class="built_in">print</span>  (<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;舍入后：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (np.around(a))</span><br><span class="line"><span class="built_in">print</span> (np.around(a, decimals =  <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span> (np.around(a, decimals =  -<span class="number">1</span>))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">原数组：</span></span><br><span class="line"><span class="string">[  1.      5.55  123.      0.567  25.532]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">舍入后：</span></span><br><span class="line"><span class="string">[  1.   6. 123.   1.  26.]</span></span><br><span class="line"><span class="string">[  1.    5.6 123.    0.6  25.5]</span></span><br><span class="line"><span class="string">[  0.  10. 120.   0.  30.]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="矩阵库"><a href="#矩阵库" class="headerlink" title="矩阵库"></a>矩阵库</h2><p>NumPy 中包含了一个矩阵库 numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象</p><p>一个<code>m*n</code>的矩阵是一个由m行n列元素排列成的矩形阵列,矩阵里的元素可以是数字、符号或数学式。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;原数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;转置数组：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (a.T)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">原数组：</span></span><br><span class="line"><span class="string">[[ 0  1  2  3]</span></span><br><span class="line"><span class="string"> [ 4  5  6  7]</span></span><br><span class="line"><span class="string"> [ 8  9 10 11]]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">转置数组：</span></span><br><span class="line"><span class="string">[[ 0  4  8]</span></span><br><span class="line"><span class="string"> [ 1  5  9]</span></span><br><span class="line"><span class="string"> [ 2  6 10]</span></span><br><span class="line"><span class="string"> [ 3  7 11]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="matlib-empty"><a href="#matlib-empty" class="headerlink" title="matlib.empty()"></a>matlib.empty()</h3><p>返回一个新的矩阵，矩阵内的元素为未初始化的值:</p><p><code>numpy.matlib.empty(shape, dtype, order)</code></p><ul><li><strong>shape</strong>: 定义新矩阵形状的整数或整数元组</li><li><strong>Dtype</strong>: 可选，数据类型</li><li><strong>order</strong>: C（行序优先） 或者 F（列序优先）</li></ul><h3 id="matlib-zeros"><a href="#matlib-zeros" class="headerlink" title="matlib.zeros()"></a>matlib.zeros()</h3><p>创建一个以 0 填充的矩阵</p><h3 id="matlib-ones"><a href="#matlib-ones" class="headerlink" title="matlib.ones()"></a>matlib.ones()</h3><p>创建一个以 1 填充的矩阵</p><h3 id="matlib-eye"><a href="#matlib-eye" class="headerlink" title="matlib.eye()"></a>matlib.eye()</h3><p>返回一个矩阵，对角线元素为1，其他位置为零</p><p><code>numpy.matlib.eye(n, M,k, dtype)</code></p><ul><li><strong>n</strong>: 返回矩阵的行数</li><li><strong>M</strong>: 返回矩阵的列数，默认为 n</li><li><strong>k</strong>: 对角线的索引</li><li><strong>dtype</strong>: 数据类型</li></ul><h3 id="matlib-identity"><a href="#matlib-identity" class="headerlink" title="matlib.identity()"></a>matlib.identity()</h3><p>返回给定大小的单位矩阵</p><h3 id="matlib-rand"><a href="#matlib-rand" class="headerlink" title="matlib.rand()"></a>matlib.rand()</h3><p>创建一个给定大小的矩阵，数据是随机填充的</p><h2 id="numpy线性代数"><a href="#numpy线性代数" class="headerlink" title="numpy线性代数"></a>numpy线性代数</h2><p>NumPy 提供了线性代数函数库 <strong>linalg</strong>，该库包含了线性代数所需的所有功能</p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>dot</code></td><td align="left">两个数组的点积，即元素对应相乘。</td></tr><tr><td align="left"><code>vdot</code></td><td align="left">两个向量的点积</td></tr><tr><td align="left"><code>inner</code></td><td align="left">两个数组的内积</td></tr><tr><td align="left"><code>matmul</code></td><td align="left">两个数组的矩阵积</td></tr><tr><td align="left"><code>determinant</code></td><td align="left">数组的行列式</td></tr><tr><td align="left"><code>solve</code></td><td align="left">求解线性矩阵方程</td></tr><tr><td align="left"><code>inv</code></td><td align="left">计算矩阵的乘法逆矩阵</td></tr></tbody></table><h3 id="numpy-dot"><a href="#numpy-dot" class="headerlink" title="numpy.dot()"></a>numpy.dot()</h3><p>对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为向量点积)；</p><p>对于二维数组，计算的是两个数组的矩阵乘积；</p><p>对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是数组a的最后一维上的所有元素与数组b的倒数第二维上的所有元素的乘积和：<code>dot(a, b)[i,j,k,m] = sum(a[i,j,:] \* b[k,:,m])</code></p><p><code>numpy.dot(a, b, out=None) </code></p><ul><li><strong>a</strong>:ndarray 数组</li><li><strong>b</strong>:ndarray 数组</li><li><strong>out</strong>:ndarray, 可选，用来保存dot()的计算结果</li></ul><h3 id="numpy-vdot"><a href="#numpy-vdot" class="headerlink" title="numpy.vdot()"></a>numpy.vdot()</h3><p>计算两个向量的点积。 如果第一个参数是复数，那么它的共轭复数会用于计算。 如果参数是多维数组，它会被展开。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"> </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]) </span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]]) </span><br><span class="line"> </span><br><span class="line"><span class="comment"># vdot 将数组展开计算内积</span></span><br><span class="line"><span class="built_in">print</span> (np.vdot(a,b))</span><br><span class="line"><span class="comment"># 1*11 + 2*12 + 3*13 + 4*14 = 130</span></span><br></pre></td></tr></table></figure><h3 id="numpy-inner"><a href="#numpy-inner" class="headerlink" title="numpy.inner()"></a>numpy.inner()</h3><p>numpy.inner() 函数返回一维数组的向量内积。对于更高的维度，它返回最后一个轴上的和的乘积。</p><h3 id="numpy-matmul"><a href="#numpy-matmul" class="headerlink" title="numpy.matmul"></a>numpy.matmul</h3><p>返回两个数组的矩阵乘积。 </p><p>虽然它返回二维数组的正常乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。</p><p>另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法之后被去除。</p><p>对于二维数组，它就是矩阵乘法</p><h3 id="numpy-linalg-det"><a href="#numpy-linalg-det" class="headerlink" title="numpy.linalg.det()"></a>numpy.linalg.det()</h3><p>计算输入矩阵的行列式</p><h3 id="numpy-linalg-solve"><a href="#numpy-linalg-solve" class="headerlink" title="numpy.linalg.solve()"></a>numpy.linalg.solve()</h3><p>矩阵形式的线性方程的解。</p><p>考虑以下线性方程：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">x + y + z = 6</span><br><span class="line"></span><br><span class="line">2y + 5z = -4</span><br><span class="line"></span><br><span class="line">2x + 5y - z = 27</span><br></pre></td></tr></table></figure><p>可以使用矩阵表示为：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">1  1  1   x      6</span><br><span class="line">0  2  5   y  =  -4</span><br><span class="line">2  5 -1   z   27</span><br></pre></td></tr></table></figure><p>如果矩阵成为A、X和B，方程变为：<code>AX = B</code>或<code>X = A^(-1)B</code></p><h3 id="numpy-linalg-inv"><a href="#numpy-linalg-inv" class="headerlink" title="numpy.linalg.inv()"></a>numpy.linalg.inv()</h3><p>计算矩阵的逆矩阵。</p><p><strong>逆矩阵（inverse matrix）</strong>：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得：AB&#x3D;BA&#x3D;E，则我们称B是A的逆矩阵，而A则被称为可逆矩阵</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/numpy/">numpy</category>
      
      
      <category domain="http://example.com/tags/numpy/">numpy</category>
      
      
      <comments>http://example.com/inori/e0d16fd2.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>机器学习基础知识</title>
      <link>http://example.com/inori/54da7039.html</link>
      <guid>http://example.com/inori/54da7039.html</guid>
      <pubDate>Mon, 20 May 2024 06:27:45 GMT</pubDate>
      
      <description>MachineLearning基础入门</description>
      
      
      
      <content:encoded><![CDATA[<p>机器学习是人工智能的重要技术基础，涉及的内容十分广泛。由于我是以发强化学习方向论文为导向，所以机器学习部分知识点不做深入学习，了解为主，本文主要涵盖机器学习入门的基础知识。</p><p>机器学习的核心元素：<strong>数据、模型、算法</strong></p><p>机器学习工作流程一般为数据预处理（Processing）、模型学习（Learning）、模型评估（Evaluation）、新样本预测（Prediction）几个步骤</p><p><strong>数据预处理：</strong>输入（未处理的数据 + 标签）-&gt; 处理过程 -&gt;（特征处理+幅度缩放、特征选择、维度约减、采样）-&gt; 输出（测试集 + 训练集）</p><p><strong>模型学习：</strong>模型选择、交叉验证、结果评估、超参选择。</p><p><strong>模型评估：</strong>了解模型对于数据集测试的得分。</p><p><strong>新样本预测：</strong>预测测试集</p><h1 id="基本名词"><a href="#基本名词" class="headerlink" title="基本名词"></a>基本名词</h1><p><strong>示例&#x2F;样本：</strong>一条数据集中的一条数据</p><p><strong>属性&#x2F;特征：</strong>判断样本好坏的根据，如「色泽」「根蒂」</p><p><strong>属性空间&#x2F;样本空间&#x2F;输入空间X：</strong>由全部属性张成的空间</p><p><strong>特征向量：</strong>空间中每个点对应的一个坐标向量</p><p><strong>标记：</strong>关于示例结果的信息，如（（色泽&#x3D;青绿，根蒂&#x3D;蜷缩，敲声&#x3D;浊响），好瓜），其中「好瓜」称为标记</p><p><strong>分类：</strong>若要预测的是离散值，如「好瓜」，「坏瓜」，此类学习任务称为分类</p><p><strong>假设：</strong>学得模型对应了关于数据的某种潜在规律</p><p><strong>真相：</strong>潜在规律自身</p><p><strong>学习过程：</strong>是为了找出或逼近真相</p><p><strong>泛化能力：</strong>学得模型适用于新样本的能力。一般来说，训练样本越大，越有可能通过学习来获得具有强泛化能力的模型</p><p><strong>训练集</strong>：帮助训练模型，简单的说就是通过训练集的数据让确定拟合曲线的参数</p><p><strong>测试集</strong>：为了测试已经训练好的模型的精确度</p><p><strong>过拟合</strong>：模型在训练集上表现的很好，但是在交叉验证集合测试集上表现一般，也就是说模型对未知样本的预测表现一般，泛化能力较差</p><p><strong>经验误差</strong>：模型在训练集上的误差称为「经验误差」（Empirical Error），经验误差并不是越小越好，因为我们希望在新的没有见过的数据上，也能有好的预估结果</p><p><strong>偏差</strong>：模型拟合的偏差程度。给定无数套训练集而期望拟合出来的模型就是平均模型，偏差就是真实模型和平均模型的差异</p><p><strong>二分类</strong>：类别中只有两个类，是 or 否，且只有一个类别，即一个label为0或者1</p><h1 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h1><p>机器学习算法有：监督学习，无监督学习，半监督学习，强化学习</p><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>监督学习是从标记的训练数据中学习并建立模型，然后基于该模型预测未知的样本。其中，模型的输入是某个样本数据的特征，而函数的输出是与该样本相对应的标签。</p><p>常见的监督学习算法：回归分析、分类预测</p><ul><li>回归分析：线性回归，决策树，随机森林等</li><li>分类预测：逻辑回归，KNN，支持向量机，朴素贝叶斯等</li></ul><h3 id="KNN算法"><a href="#KNN算法" class="headerlink" title="KNN算法"></a>KNN算法</h3><p>KNN算法即K最近邻近算法。所谓K最近邻，就是k个最近的邻居的意思，说的是每个样本都可以用它最接近的k个邻居来代表。KNN的输入基于实例的学习（instance-based learning），没有显式的学习过程，也就是说没有训练阶段，数据集事先已有了分类和特征值，待收到新样本后直接进行处理，<strong>KNN通过测量不同特征值之间的距离进行分类</strong></p><p>思路：如果一个样本在特征空间中的k个最邻近的样本中的大多数属于某一个类别，则该样本也划分为这个类别。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别</p><h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><ol><li>计算测试数据与各个训练数据之间的距离</li><li>按照距离的递增关系进行排序</li><li>选取距离最小的K个点</li><li>确定前K个点所在类别的出现频率</li><li>返回前K个点中出现频率最高的类别作为测试数据的预测分类</li></ol><h4 id="K的取值"><a href="#K的取值" class="headerlink" title="K的取值"></a>K的取值</h4><p>K：临近数，即在预测目标点时取几个临近的点来预测。</p><p>K值得选取非常重要：</p><ul><li>如果K的取值过小，一旦有噪声存在将会对预测产生比较大影响，例如取K值为1时，一旦最近的一个点是噪声，那么就会出现偏差</li><li>如果K的取值过大，就相当于用较大邻域中的训练实例进行预测，学习的近似误差会增大。这时与输入目标点较远实例也会对预测起作用，使预测发生错误</li></ul><p>K的取值尽量要取<strong>奇数</strong>，以保证在计算结果最后会产生一个较多的类别，如果取偶数可能会产生相等的情况，不利于预测。</p><p>常用的方法是从k&#x3D;1开始，使用检验集估计分类器的误差率。重复该过程，每次K增值1，允许增加一个近邻。选取产生最小误差率的K。一般k的取值不超过20，上限是n的开方，随着数据集的增大，K的值也要增大</p><h3 id="朴素贝叶斯算法"><a href="#朴素贝叶斯算法" class="headerlink" title="朴素贝叶斯算法"></a>朴素贝叶斯算法</h3><p>朴素贝叶斯算法是一种基于概率论和统计学的算法。它的核心思想是概率，通过计算条件概率来预测或分类数据</p><h4 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h4><p>贝叶斯定理是朴素贝叶斯算法的核心，它是一个概率公式，用于计算一个事件的后验概率。根据贝叶斯定理，事件 A 的后验概率等于先验概率 P(A)，与另一个事件 B 发生的联合概率 P(B|A) 乘以一个正则因子，即：<br>$$<br>P(Y|X) &#x3D; \frac{P(X|Y)P(Y)}{P(X)}<br>（X：特征向量， Y：类别）<br>$$<br>**先验概率P(X)**：先验概率是指根据以往经验和分析得到的概率</p><p>**后验概率P(Y|X)**：事情已经发生，要求这件事情发生的原因是由某个因素引起的可能性的大小，后验分布P(Y|X)表示事件X已经发生的前提下，事件Y发生的概率，叫做事件X发生下事件Y的条件概率</p><p>**后验概率P(X|Y)**：在已知Y发生后X的条件概率，也由于知道Y的取值而被称为X的后验概率</p><h4 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h4><p>朴素贝叶斯算法是假设各个特征之间相互独立，也是朴素这词的意思，那么贝叶斯公式中的P(X|Y)可写成：<br>$$<br>P(X|Y)&#x3D;P(x_1|Y)P(x_2|Y)…P(x_n|Y)<br>$$<br>即朴素贝叶斯公式：<br>$$<br>P(Y|X) &#x3D; \frac{P(x_1|Y)P(x_2|Y)…P(x_n|Y)P(Y)}{P(X)}<br>$$</p><h4 id="贝叶斯算法"><a href="#贝叶斯算法" class="headerlink" title="贝叶斯算法"></a>贝叶斯算法</h4><p>贝叶斯方法源于决一个“逆概”问题：</p><p><strong>正向概率</strong>：假设袋子里面有N个白球，M个黑球，伸手进去摸一把，摸出黑球的概率是多大</p><p><strong>逆向概率</strong>：如果事先不知道袋子里面黑白球的比例，而是闭着眼睛摸出一个（或者几个）球，观察这些取出来的球的颜色之后，那么可以就此对袋子里面的黑白球的比例做出什么样的推测</p><p>什么是贝叶斯？</p><ul><li>现实世界本身就是不确定的，人类的观察能力是有局限性的</li><li>我们日常观察到的只是事物表明上的结果，因此我们需要提供一个猜测</li></ul><p>朴素贝叶斯算法的朴素：特征条件独立；贝叶斯：基于贝叶斯定理。属于监督学习的生成模型，实现监督，没有迭代，并有坚实的数学理论（即贝叶斯定理）作为支撑。在大量样本下会有较好的表现，不适用于输入向量的特征条件有关联的场景</p><p>朴素贝叶斯会单独考量每一维独立特征被分类的条件概率，进而综合这些概率并对其所在的特征向量做出分类预测。因此，朴素贝叶斯的基本数据假设是：各个维度上的特征被分类的条件概率之间是相互独立的。它经常被用于文本分类中，包括互联网新闻的分类，垃圾邮件的筛选</p><p>朴素贝叶斯的思想：对于给出的待分类项，求解在此项出现的条件下各个类别出现的概率，哪个最大，即认为此待分类项属于哪个类别</p><h3 id="决策树算法"><a href="#决策树算法" class="headerlink" title="决策树算法"></a>决策树算法</h3><p>决策树算法是一种逼近离散函数值的方法。它是一种典型的分类方法，首先对数据进行处理，利用归纳算法生成可读的规则和决策树，然后使用决策对新数据进行分析。本质上决策树是通过一系列规则对数据进行分类的过程，适用于类别和连续输入（特征）和输出（预测）变量。基于树的方法把特征空间划分成一系列矩形，然后给每一个矩形安置一个简单的模型（像一个常数）</p><p>决策树构造可以分两步进行：</p><ol><li>生成：由训练样本集生成决策树的过程。一般情况下，训练样本数据集是根据实际需要有历史的、有一定综合程度的，用于数据分析处理的数据集</li><li>剪枝：对上一阶段生成的决策树进行检验和校正，主要是用新的样本数据集（测试数据集）中的数据校验决策树生成过程中产生的初步规则，将那些影响预衡准确性的分枝剪除</li></ol><p>决策树学习的算法通常是一个递归地决策树学习的算法通常是一个递归地选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。包含特征选择、决策树的生成和决策树的剪枝过程。选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类的过程。包含特征选择、决策树的生成和决策树的剪枝过程。</p><p><strong>剪枝：</strong>将树变得更简单，从而使它具有更好的泛化能力。</p><p>步骤：去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。</p><p>决策树的生成对应模型的局部选择，决策树的剪枝对应于模型的全局选择。决策树的生成只考虑局部最优，决策树的剪枝则考虑全局最优。</p><p><strong>特征选择：</strong>如果特征数量很多，在决策树学习开始时对特征进行选择，只留下对训练数据有足够分类能力的特征</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ol><li>树以代表训练样本的单个结点开始</li><li>如果样本都在同一类．则该结点成为树叶，并用该类标记</li><li>否则，算法选择最有分类能力的属性作为决策树的当前结点</li><li>根据当前决策结点属性取值的不同，将训练样本数据集分为若干子集，每个取值形成一个分枝，有几个取值形成几个分枝。针对上一步得到的一个子集，重复进行先前步骤，递归形成每个划分样本上的决策树。一旦一个属性出现在一个结点上，就不必在该结点的任何后代考虑它</li><li>递归划分步骤仅当下列条件之一成立时停止：<ul><li>给定结点的所有样本属于同一类</li><li>没有剩余属性可以用来进一步划分样本．在这种情况下．使用多数表决，将给定的结点转换成树叶，并以样本中元组个数最多的类别作为类别标记，同时也可以存放该结点样本的类别分布</li><li>如果某一分枝tc，没有满足该分支中已有分类的样本，则以样本的多数类创建一个树叶</li></ul></li></ol><h3 id="SVM算法"><a href="#SVM算法" class="headerlink" title="SVM算法"></a>SVM算法</h3><p>SVM即支持向量机（support vector machine，SVM），支持向量机是一种二分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。支持向量机的学习算法是求解凸二次规划的最优化算法。基础的SVM算法是一个二分类算法，至于多分类任务，可以通过多次使用SVM进行解决</p><h4 id="线性可分"><a href="#线性可分" class="headerlink" title="线性可分"></a>线性可分</h4><p>对于一个数据集合可以画一条直线将两组数据点分开，这样的数据成为线性可分（linearly separable）</p><p><img src="D:\Blog\source\img\smv_linearly_separable.png" alt="smv_linearly_separable"></p><ul><li>分割超平面：将上述数据集分隔开来的直线成为分隔超平面。对于二维平面来说，分隔超平面就是一条直线。对于三维及三维以上的数据来说，分隔数据的是个平面，称为超平面，也就是分类的决策边界</li><li>间隔：点到分割面的距离，称为点相对于分割面的间隔。数据集所有点到分隔面的最小间隔的2倍，称为分类器或数据集的间隔。论文中提到的间隔多指这个间隔。SVM分类器就是要找最大的数据集间隔</li><li>支持向量：离分隔超平面最近的那些点</li></ul><p>SVM所做的工作就是找这样的超平面，能够将两个不同类别的样本划分开来，但是这种平面是不唯一的，即可能存在无数个超平面都可以将两种样本分开，那么我们如何才能确定一个分类效果最好的超平面呢？<br>对每一种可能的超平面，我们将它进行平移，直到它与空间中的样本向量相交。我们称这两个向量为支持向量，之后我们计算支持向量到该超平面的距离d，分类效果最好的超平面应该使d最大</p><p>支持向量机的核心思想：最大间隔化，最不受到噪声的干扰</p><h4 id="优缺点及应用场景"><a href="#优缺点及应用场景" class="headerlink" title="优缺点及应用场景"></a>优缺点及应用场景</h4><ol><li>SVM的优点：</li></ol><ul><li>高效的处理高维特征空间：SVM通过将数据映射到高维空间中，可以处理高维特征，并在低维空间中进行计算，从而有效地处理高维数据</li><li>适用于小样本数据集：SVM是一种基于边界的算法，它依赖于少数支持向量，因此对于小样本数据集具有较好的泛化能力</li><li>可以处理非线性问题：SVM使用核函数将输入数据映射到高维空间，从而可以解决非线性问题。常用的核函数包括线性核、多项式核和径向基函数（RBF）核</li><li>避免局部最优解：SVM的优化目标是最大化间隔，而不是仅仅最小化误分类点。这使得SVM在解决复杂问题时能够避免陷入局部最优解</li><li>对于噪声数据的鲁棒性：SVM通过使用支持向量来定义决策边界，这使得它对于噪声数据具有一定的鲁棒性</li></ul><ol start="2"><li>SVM的缺点：</li></ol><ul><li>对大规模数据集的计算开销较大：SVM的计算复杂度随着样本数量的增加而增加，特别是在大规模数据集上的训练时间较长</li><li>对于非线性问题选择合适的核函数和参数较为困难：在处理非线性问题时，选择适当的核函数和相应的参数需要一定的经验和领域知识</li><li>对缺失数据敏感：SVM在处理含有缺失数据的情况下表现不佳，因为它依赖于支持向量的定义</li><li>难以解释模型结果：SVM生成的模型通常是黑盒模型，难以直观地解释模型的决策过程和结果</li></ul><ol start="3"><li>SVM主要应用场景：</li></ol><ul><li>文本分类：如垃圾邮件分类、情感分析和文档分类等</li><li>图像识别：可用于图像分类、目标识别和人脸识别等任务。它可以通过提取图像的特征向量，并将其作为输入来训练SVM模型</li><li>金融领域：可用于信用评分、风险评估和股票市场预测等金融任务</li><li>医学诊断：可以应用于医学图像分析，如疾病检测、癌症诊断和医学影像分类等</li><li>视频分类：可以用于视频分类、行为识别和运动检测等任务，通过提取视频帧的特征并将其输入SVM模型进行分类</li><li>推荐系统：可以用于个性化推荐和用户分类等推荐系统任务，通过分析用户行为和特征来预测用户的兴趣和偏好</li></ul><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>逻辑回归虽然名字中带有回归，其实是分类模型，主要用于二分类问题，通过给定的n组数据（训练集）来训练模型，并在训练结束后对给定的一组或多组数据（测试集）进行分类。其中每一组数据都是由p个指标构成。</p><p>由于二分类问题分成两类，可以让其中一类标签为0，另一类为1。我们需要一个函数，对于输入的每一组数据，都能映射成0~1之间的数。并且如果函数值大于0.5，就判定属于1，否则属于0。而且函数中需要待定参数，通过利用样本训练，使得这个参数能够对训练集中的数据有很准确的预测。</p><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><p>逻辑回归的模型包含两个模块：线性部分和激活函数</p><p>线性部分的数学模型写为<code>h(x)=wx+b</code>，x表示样本的输入特征向量，w是权重，b是偏置</p><p>激活函数是sigmoid函数：<br>$$<br>\sigma(h(x))&#x3D; \frac{1}{1+e^{−h(x)}}<br>&#x3D; \frac{1}{1+e^{−(wx+b)}}<br>$$</p><p>这个函数的曲线是一条值域为(0,1)的曲线，当输入值趋近于无穷大时，输出结果会趋近于1，输入值趋近于无穷小时，输出结果会趋近于-1</p><p>逻辑回归不仅是一个二分类模型，也是一个线性分类模型，h(x)作为决策函数，通过判断样本落在决策函数的哪一边，区分出不同的类别</p><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>该类算法的输入样本不需要标记，而是自动地从样本中学习这种特征以实现预测。</p><p>常见的非监督学习算法：聚类和降维</p><ul><li>聚类：Kmeans、Apriori、DBSCAN等</li><li>降维：主成分分析(PCA)等</li></ul><h3 id="Kmeans算法"><a href="#Kmeans算法" class="headerlink" title="Kmeans算法"></a>Kmeans算法</h3><p>k均值聚类算法（k-means）是一种迭代求解的聚类分析算法，其步骤是，预将数据分为K组，则随机选取K个对象作为初始的聚类中心，然后计算每个对象与各个种子聚类中心之间的距离，把每个对象分配给距离它最近的聚类中心。聚类中心以及分配给它们的对象就代表一个聚类。每分配一个样本，聚类的聚类中心会根据聚类中现有的对象被重新计算。这个过程将不断重复直到满足某个终止条件。终止条件可以是没有（或最小数目）对象被重新分配给不同的聚类，没有（或最小数目）聚类中心再发生变化，误差平方和局部最小。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li>从N个数据文档（样本）随机选取K个数据文档作为质心（聚类中心）。</li><li>对每个数据文档测量其到每个质心的距离，并把它归到最近的质心的类。</li><li>重新计算已经得到的各个类的质心。</li><li>迭代2~3步直至新的质心与原质心相等或小于指定阈值，算法结束。 本文采用所有样本所属的质心都不再变化时，算法收敛。</li></ol><h1 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h1><p>每一个样本经过模型后会得到一个预测值，然后得到的预测值和真实值的差值就成为损失（损失值越小证明模型越成功），有许多不同种类的损失函数，这些函数<strong>本质上就是计算预测值和真实值的差距的一类型函数</strong>，经过库的封装形成了有具体名字的函数</p><p>输入的feature（或称为x）需要通过模型（model）预测出y，此过程称为向前传播（forward pass），而要将预测与真实值的差值减小需要更新模型中的参数，这个过程称为向后传播（backward pass），其中损失函数（lossfunction）就基于这两种传播之间，起到一种有点像<strong>承上启下</strong>的作用，<strong>承上指：接収模型的预测值，启下指：计算预测值和真实值的差值，为下面反向传播提供输入数据</strong></p><p>常用的损失函数有：均方误差(MSE)、平均绝对误差(MAE)、均方根误差(RMSE)、平均偏差误差(MBE)、Huber损失、最大似然损失(Likelihood Loss&#x2F;LHL)、二元交叉熵（BCE）、交叉熵（CE）、Kullback-Leibler 散度 (KLD)等</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MachineLearning/">MachineLearning</category>
      
      
      <category domain="http://example.com/tags/MachineLearning/">MachineLearning</category>
      
      
      <comments>http://example.com/inori/54da7039.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL运维篇</title>
      <link>http://example.com/inori/592cf81.html</link>
      <guid>http://example.com/inori/592cf81.html</guid>
      <pubDate>Fri, 17 May 2024 09:45:32 GMT</pubDate>
      
      <description>MySQL进阶篇</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志记录了当mysqld启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，应当首先查看此日志</p><p>该日志默认开启，默认存放目录<code>/var/log/</code>，默认的日志文件名为<code>mysqld.log</code>，查看日志位置:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_error%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><p>二进制日志（BINLOG）记录了所有的 DDL和 DML语句，不包括数据查询（SELECT、SHOW）语句</p><p>作用：</p><ul><li>灾难时的数据恢复</li><li>MySQL的主从复制</li></ul><p>在MySQL8中，默认二进制日志是开启的，查看日志参数：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>log_bin_basename</code>：当前数据库服务器的binlog日志的基础名称(前缀)，具体的binlog文件名需要在该basename的基础上加上编号(编号从000001开始)</li><li><code>log_bin_index</code>：binlog的索引文件，记录了当前服务器关联的binlog文件有哪些</li></ul><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><table><thead><tr><th>日志格式</th><th>含义</th></tr></thead><tbody><tr><td>STATEMENT</td><td>基于SQL语句的日志记录，记录SQL语句，对数据进行修改的SQL都会记录在日志文件中</td></tr><tr><td>ROW</td><td>基于行的日志记录，记录每一行的数据变更</td></tr><tr><td>MIXED</td><td>混合了STATEMENT和ROW两种格式，默认采用STATEMENT，在某些特殊情况下会自动切换为ROW进行记录</td></tr></tbody></table><p>可以使用命令查看格式：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_format%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果需要配置二进制日志的格式，要在<code>/etc/my.cnf</code>中配置<code>binlog_format</code>参数</p><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><p>由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具<code>mysqlbinlog</code>来查看，详情查看进阶篇中此部分</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志：</p><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>reset master</td><td>删除全部 binlog日志，删除之后，日志编号，将从<code>binlog.000001</code>重新开始</td></tr><tr><td>purge master logs to ‘binlog.*’</td><td>删除 * 编号之前的所有日志</td></tr><tr><td>purge master logs before ‘yyyy-mm-dd hh24:mi:ss’</td><td>删除日志为<code>yyyy-mm-dd hh24:mi:ss</code>之前产生的所有日志</td></tr></tbody></table><p>也可以在mysql的配置文件中配置二进制日志的过期时间，设置后二进制日志过期会自动删除:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%binlog_expire_logs_seconds%&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><p>查询日志中记录了客户端的所有操作语句。如果需要开启查询日志，可以修改MySQL的配置文件<code>/etc/my.cnf</code>文件，添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#该选项用来开启查询日志 ， 可选值：0或者1，0代表关闭，1代表开启</span><br><span class="line">general_log=1</span><br><span class="line">#设置日志的文件名，如果没有指定，默认的文件名为host_name.log</span><br><span class="line">general_log_file=mysql_query.log</span><br></pre></td></tr></table></figure><p>开启了查询日志之后，在MySQL的数据存放目录，也就是 <code>/var/lib/mysql/</code>目录下就会出现mysql_query.log文件。之后所有的客户端的增删改查操作都会记录在该日志文件之中，长时间运行后，日志文件将会非常大。</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过参数<code>long_query_time</code>设置值并且扫描记录数不小于<code>min_examined_row_limit</code>的所有的SQL语句的日志，默认未开启。<code>long_query_time</code>默认为10秒，最小为0，精度可以到微秒。</p><p>如果需要开启慢查询日志，需要在MySQL的配置文件<code>/etc/my.cnf</code>中配置如下参数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#慢查询日志</span><br><span class="line">slow_query_log=1</span><br><span class="line">#执行时间参数</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure><p>默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用<code>log_slow_admin_statements</code>和更改此行为<code>log_queries_not_using_indexes</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#记录执行较慢的管理语句</span><br><span class="line">log_slow_admin_statements = 1</span><br><span class="line">#记录执行较慢的未使用索引的语句</span><br><span class="line">log_queries_not_using_indexes = 1</span><br></pre></td></tr></table></figure><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行（重做），从而使得从库和主库的数据保持同步。</p><p>MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制，MySQL复制的优点主要包含以下三个方面：</p><ul><li>主库出现问题，可以快速切换到从库提供服务</li><li>实现读写分离，降低主库的访问压力</li><li>可以在从库中执行备份，以避免备份期间影响主库服务</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MySQL主从复制的核心为bin log，具体的过程如下：</p><p><img src="D:\Blog\source\img\mysql_master&slave.png" alt="mysql_master&amp;slave"></p><p>复制分成三步：</p><ol><li><p>Master主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中</p></li><li><p>从库读取主库的二进制日志文件Binlog，写入到从库的中继日志Relay Log</p></li><li><p>slave重做中继日志中的事件，将改变反映它自己的数据</p></li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="主库"><a href="#主库" class="headerlink" title="主库"></a>主库</h4><p>修改配置文件<code>/etc/my.cnf</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 232-1，默认为1</span><br><span class="line">server-id=1</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=0</span><br><span class="line">#忽略的数据, 指不需要同步的数据库</span><br><span class="line">#binlog-ignore-db=mysql</span><br><span class="line">#指定同步的数据库</span><br><span class="line">#binlog-do-db=db01</span><br></pre></td></tr></table></figure><p>重启mysql服务器后，登录并创建远程连接的账号，授予主从复制权限：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#创建itcast用户，并设置密码，该用户可在任意主机连接该MySQL服务</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">WITH</span> mysql_native_password <span class="keyword">BY</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br><span class="line">#为 <span class="string">&#x27;itcast&#x27;</span>@<span class="string">&#x27;%&#x27;</span> 用户分配主从复制权限</span><br><span class="line"><span class="keyword">GRANT</span> REPLICATION SLAVE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查看二进制坐标：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> master status;</span><br></pre></td></tr></table></figure><p>字段含义说明：</p><ul><li><code>file</code>:从哪个日志文件开始推送日志文件</li><li><code>position</code>:从哪个位置开始推送日志</li><li><code>binlog_ignore_db</code>:指定不需要同步的数据库</li></ul><h4 id="从库"><a href="#从库" class="headerlink" title="从库"></a>从库</h4><p>修改配置文件<code>/etc/my.cnf</code>:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#mysql 服务ID，保证整个集群环境中唯一，取值范围：1 – 2^32-1，和主库不一样即可</span><br><span class="line">server-id=2</span><br><span class="line">#是否只读,1 代表只读, 0 代表读写</span><br><span class="line">read-only=1</span><br></pre></td></tr></table></figure><p>重启mysql服务器后，登录设置主库配置：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CHANGE REPLICATION SOURCE <span class="keyword">TO</span> SOURCE_HOST<span class="operator">=</span><span class="string">&#x27;IP地址&#x27;</span>, SOURCE_USER<span class="operator">=</span><span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">SOURCE_PASSWORD<span class="operator">=</span><span class="string">&#x27;Root@123456&#x27;</span>, SOURCE_LOG_FILE<span class="operator">=</span><span class="string">&#x27;binlog.000004&#x27;</span>, SOURCE_LOG_POS<span class="operator">=</span><span class="number">663</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>含义</th><th>老版本参数</th></tr></thead><tbody><tr><td>SOURCE_HOST</td><td>主库IP地址</td><td>MASTER_HOST</td></tr><tr><td>SOURCE_USER</td><td>连接主库的用户名</td><td>MASTER_USER</td></tr><tr><td>SOURCE_PASSWORD</td><td>连接主库的密码</td><td>MASTER_PASSWORD</td></tr><tr><td>SOURCE_LOG_FILE</td><td>binlog日志文件名</td><td>MASTER_LOG_FILE</td></tr><tr><td>SOURCE_LOG_POS</td><td>binlog日志文件位置</td><td>MASTER_LOG_POS</td></tr></tbody></table><p>开启同步：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> replica;</span><br></pre></td></tr></table></figure><p>查看同步状态：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> replica status;</span><br></pre></td></tr></table></figure><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：</p><ul><li>IO瓶颈：热点数据太多，数据库缓存不足，产生大量磁盘IO，效率较低。请求数据太多，带宽不够，网络IO瓶颈</li><li>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈</li></ul><p>为了解决上述问题，需要对数据库进行分库分表处理</p><p>分库分表的中心思想都是将<strong>数据分散存储</strong>，使得单一数据库&#x2F;表的数据量变小来缓解单一数据库的性能问题，从而提升数据库性能</p><h3 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h3><p>分库分表的形式，主要是两种：垂直拆分和水平拆分。按照拆分粒度又分为分库和分表。</p><h4 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h4><p><strong>垂直分库</strong>：以表为依据，根据业务将不同表拆分到不同库中。</p><p>特点：</p><ul><li>每个库的表结构都不一样</li><li>每个库的数据也不一样</li><li>所有库的并集是全量数据</li></ul><p><strong>垂直分表</strong>：以字段为依据，根据字段属性将不同字段拆分到不同表中。</p><p>特点：</p><ul><li>每个表的结构都不一样</li><li>每个表的数据也不一样，一般通过一列（主键&#x2F;外键）关联</li><li>所有表的并集是全量数据</li></ul><h4 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h4><p><strong>水平分库</strong>：以字段为依据，按照一定策略，将一个库的数据拆分到多个库中</p><p>特点：</p><ul><li>每个库的表结构都一样</li><li>每个库的数据都不一样</li><li>所有库的并集是全量数据</li></ul><p><strong>水平分表</strong>：以字段为依据，按照一定策略，将一个表的数据拆分到多个表中</p><p>特点：</p><ul><li>每个表的表结构都一样</li><li>每个表的数据都不一样</li><li>所有表的并集是全量数据</li></ul><h3 id="实现技术"><a href="#实现技术" class="headerlink" title="实现技术"></a>实现技术</h3><ul><li>shardingJDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路由处理。需要自行编码配置实现，只支持java语言</li><li>MyCat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言</li></ul><h3 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h3><p>Mycat是开源的基于Java语言编写的MySQL数据库中间件。可以像使用mysql一样来使用mycat。开发人员只需要连接MyCat即可，而具体底层用到几台数据库，每一台数据库服务器里面存储了什么数据，都无需关心。具体的分库分表的策略，只需要在MyCat中配置即可。</p><p>在MyCat的整体结构中，分为两个部分：上面的逻辑结构、下面的物理结构</p><p><img src="D:\Blog\source\img\mysql_mycat.png" alt="mysql_mycat"></p><p>在MyCat的逻辑结构主要负责逻辑库、逻辑表、分片规则、分片节点等逻辑结构的处理，而具体的数据存储还是在物理结构，也就是数据库服务器中存储的</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><h5 id="schema-xml"><a href="#schema-xml" class="headerlink" title="schema.xml"></a>schema.xml</h5><p>配置逻辑库、逻辑表、数据节点、节点主机等相关信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mycat</span>:schema <span class="keyword">SYSTEM</span> <span class="string">&quot;schema.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;DB01&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;TB_ORDER&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2,dn3&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto-sharding-long&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn3&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址1:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址2:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost3&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址3:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要包含以下三组标签：</p><ul><li>schema标签</li><li>datanode标签</li><li>datahost标签</li></ul><h6 id="schema标签"><a href="#schema标签" class="headerlink" title="schema标签"></a>schema标签</h6><p>用于定义MyCat实例中的逻辑库,一个MyCat实例中,可以有多个逻辑库,可以通过schema标签来划分不同的逻辑库。MyCat中的逻辑库的概念，等同于MySQL中的database概念, 需要操作某个逻辑库下的表时, 也需要切换逻辑库(use xxx)。</p><p>核心属性：</p><ul><li>name：指定自定义的逻辑库库名</li><li>checkSQLschema：在SQL语句操作时指定了数据库名称，执行时是否自动去除；true：自动去除，false：不自动去除</li><li>sqlMaxLimit：如果未指定limit进行查询，列表查询模式查询多少条记录</li></ul><p><strong>table标签</strong></p><p>定义了MyCat中逻辑库schema下的逻辑表,所有需要拆分的表都需要在table标签中定义。核心属性：</p><ul><li>name：定义逻辑表表名，在该逻辑库下唯一</li><li>dataNode：定义逻辑表所属的dataNode，该属性需要与dataNode标签中name对应；多个dataNode逗号分隔</li><li>rule：分片规则的名字，分片规则名字是在rule.xml中定义的</li><li>primaryKey：逻辑表对应真实表的主键</li><li>type：逻辑表的类型，目前逻辑表只有全局表和普通表，如果未配置，就是普通表，全局表需要配置为global</li></ul><h6 id="datanode标签"><a href="#datanode标签" class="headerlink" title="datanode标签"></a>datanode标签</h6><p>核心属性：</p><ul><li>name：定义数据节点名称</li><li>dataHost：数据库实例主机名称，引用自 dataHost 标签中name属性</li><li>database：定义分片所属数据库</li></ul><h6 id="datahost标签"><a href="#datahost标签" class="headerlink" title="datahost标签"></a>datahost标签</h6><p>该标签在MyCat逻辑库中作为底层标签, 定义了具体的数据库实例、读写分离、心跳语句。核心属性：</p><ul><li>name：唯一标识，供上层标签使用</li><li>maxCon&#x2F;minCon：最大连接数&#x2F;最小连接数</li><li>balance：负载均衡策略，取值 0,1,2,3</li><li>writeType：写操作分发方式（0：写操作转发到第一个writeHost，第一个挂了，切换到第二个；1：写操作随机分发到配置的writeHost）</li><li>dbDriver：数据库驱动，支持 native、jdbc</li></ul><h5 id="rule-xml"><a href="#rule-xml" class="headerlink" title="rule.xml"></a>rule.xml</h5><p>rule.xml中定义所有拆分表的规则, 在使用过程中可以灵活的使用分片算法, 或者对同一个分片算法使用不同的参数, 它让分片过程可配置化。主要包含两类标签：tableRule、Function</p><h5 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h5><p>配置用户名、密码，以及用户的访问权限信息</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表级 DML 权限设置 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        &lt;privileges check=&quot;true&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;schema name=&quot;DB01&quot; dml=&quot;0110&quot; &gt;</span></span><br><span class="line"><span class="comment">                &lt;table name=&quot;TB_ORDER&quot; dml=&quot;1110&quot;&gt;&lt;/table&gt;# 对应IUSD为增改查删</span></span><br><span class="line"><span class="comment">            &lt;/schema&gt;</span></span><br><span class="line"><span class="comment">        &lt;/privileges&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>DB01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述的配置表示，定义了两个用户root和user，两个用户都可以访问DB01逻辑库，访问密码都是123456，但是root用户访问DB01逻辑库，既可以读，又可以写，但是user用户访问逻辑库是只读的</p><p>主要有两个标签：system、user</p><h6 id="system标签"><a href="#system标签" class="headerlink" title="system标签"></a>system标签</h6><p>主要配置MyCat中的系统配置信息，对应的系统配置项及其含义</p><table><thead><tr><th>属性</th><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>charset</td><td>utf8</td><td>设置Mycat的字符集, 字符集需要与MySQL的字符集保持一致</td></tr><tr><td>nonePasswordLogin</td><td>0,1</td><td>0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户</td></tr><tr><td>useSqlStat</td><td>0,1</td><td>开启SQL实时统计,1 为开启,0 为关闭；开启之后, MyCat会自动统计SQL语句的执行情况</td></tr><tr><td>useGlobleTableCheck</td><td>0,1</td><td>是否开启全局表的一致性检测。1为开启，0为关闭</td></tr><tr><td>sequnceHandlerType</td><td>0,1,2</td><td>用来指定Mycat全局序列类型，0 为本地文件，1 为数据库方式，2 为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试</td></tr><tr><td>idleTimeout</td><td>30</td><td>指定连接的空闲时间的超时长度;如果超时,将关闭资源并回收, 默认30分钟</td></tr><tr><td>serverPort</td><td>8066</td><td>定义MyCat的管理端口, 默认8066</td></tr><tr><td>managerPort</td><td>9066</td><td>定义MyCat的管理端口, 默认9066</td></tr><tr><td>sqlExecuteTimeout</td><td>300</td><td>执行SQL的超时时间, 如果SQL语句执行超时,将关闭连接; 默认300秒;</td></tr></tbody></table><h6 id="user标签"><a href="#user标签" class="headerlink" title="user标签"></a>user标签</h6><p>配置MyCat中的用户、访问密码，以及用户针对于逻辑库、逻辑表的权限信息</p><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><p>切换到Mycat的安装目录，执行指令启动Mycat：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动</span></span><br><span class="line">bin/mycat start</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">停止</span></span><br><span class="line">bin/mycat stop</span><br></pre></td></tr></table></figure><p>Mycat启动之后，占用端口号8066</p><h5 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h IP地址 <span class="operator">-</span>P <span class="number">8066</span> <span class="operator">-</span>uroot <span class="operator">-</span>p123456</span><br></pre></td></tr></table></figure><p>通过MySQL的指令来连接的MyCat，因为MyCat在底层实际上是模拟了MySQL的协议</p><h4 id="MyCat管理"><a href="#MyCat管理" class="headerlink" title="MyCat管理"></a>MyCat管理</h4><p>在MyCat中，当执行一条SQL语句时，MyCat需要进行SQL解析、分片分析、路由分析、读写分离分析等操作，最终经过一系列的分析决定将当前的SQL语句到底路由到那几个(或哪一个)节点数据库，数据库将数据执行完毕后，如果有返回的结果，则将结果返回给MyCat，最终还需要在MyCat中进行结果合并、聚合处理、排序处理、分页处理等操作，最终再将结果返回给客户端。</p><p><img src="D:\Blog\source\img\mysql_mycat_frame.png" alt="mysql_mycat_frame"></p><p>Mycat默认开通2个端口，可以在server.xml中进行修改。</p><ul><li>8066 数据访问端口，即进行 DML 和 DDL 操作。</li><li>9066 数据库管理端口，即 mycat 服务管理控制功能，用于管理mycat的整个集群状态</li></ul><p>连接MyCat的管理控制台：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h IP地址 <span class="operator">-</span>p <span class="number">9066</span> <span class="operator">-</span>uroot <span class="operator">-</span>p123456</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>show @@help</td><td>查看Mycat管理工具帮助文档</td></tr><tr><td>show @@version</td><td>查看Mycat的版本</td></tr><tr><td>reload @@config</td><td>重新加载Mycat的配置文件</td></tr><tr><td>show @@datasource</td><td>查看Mycat的数据源信息</td></tr><tr><td>show @@datanode</td><td>查看MyCat现有的分片节点信息</td></tr><tr><td>show @@threadpool</td><td>查看Mycat的线程池信息</td></tr><tr><td>show @@sql</td><td>查看执行的SQL</td></tr><tr><td>show @@sql.sum</td><td>查看执行的SQL统计</td></tr></tbody></table><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>读写分离,简单地说是把对数据库的读和写操作分开,以对应不同的数据库服务器。主数据库提供写操作，从数据库提供读操作，这样能有效地减轻单台数据库的压力。</p><p>通过MyCat可实现上述功能，不仅可以支持MySQL，也可以支持Oracle和SQL Server。</p><h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><p><img src="D:\Blog\source\img\mysql_1m1s.png" alt="mysql_1m1s"></p><p>MyCat控制后台数据库的读写分离和负载均衡由schema.xml文件datahost标签的balance属性控制。</p><p>schema.xml配置</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置逻辑库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;RW&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn7&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn7&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">database</span>=<span class="string">&quot;itcast&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p>writeHost代表的是写操作对应的数据库，readHost代表的是读操作对应的数据库。所以我们要想实现读写分离，就得配置writeHost关联的是主库，readHost关联的是从库。</p><p>而仅仅配置好了writeHost以及readHost还不能完成读写分离，还需要配置一个负责均衡的参数balance，取值有4种，具体含义如下：</p><table><thead><tr><th>参数值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>不开启读写分离机制,所有读操作都发送到当前可用的writeHost上</td></tr><tr><td>1</td><td>全部的readHost与备用的writeHost都参与select语句的负载均衡（主要针对于双主双从模式）</td></tr><tr><td>2</td><td>所有的读写操作都随机在writeHost,readHost上分发</td></tr><tr><td>3</td><td>所有的读请求随机分发到writeHost对应的readHost上执行,writeHost不负担读压力</td></tr></tbody></table><p>在一主一从模式的读写分离中，balance配置1或3都是可以完成读写分离的。</p><h3 id="双主双从"><a href="#双主双从" class="headerlink" title="双主双从"></a>双主双从</h3><p>一个主机Master1用于处理所有写请求，它的从机Slave1和另一台主机Master2还有它的从机Slave2负责所有读请求。当Master1主机宕机后，Master2主机负责写请求，Master1、Master2互为备机</p><p><img src="D:\Blog\source\img\mysql_2m2s.png" alt="mysql_2m2s"></p><p>schema.xml配置</p><p>配置逻辑库</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;RW2&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn7&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置数据节点</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn7&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>配置节点主机</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;dhost7&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span> <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;jdbc&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址1:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址2:3306? useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;master2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址3:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;slave2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;jdbc:mysql://IP地址4:3306?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=Asia/Shanghai<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;1234&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性说明：</p><ul><li><p>balance&#x3D;”1”：代表全部的readHost与stand by writeHost参与 select 语句的负载均衡，简单的说，当双主双从模式(M1 -&gt; S1，M2-&gt; S2，并且M1与M2互为主备)，正常情况下，M2,S1,S2都参与select语句的负载均衡</p></li><li><p>writeType</p><ul><li>0:写操作都转发到第1台writeHost, writeHost1挂了, 会切换到writeHost2上</li><li>1:所有的写操作都随机地发送到配置的writeHost上</li></ul></li><li><p>switchType</p><ul><li>-1:不自动切换</li><li>1:自动切换</li></ul></li></ul><p>user.xml配置：配置root用户可以访问到逻辑库RW2</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>SHOPPING,TEST,RW2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/MySQL/">MySQL</category>
      
      
      <comments>http://example.com/inori/592cf81.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ElasticSearch基础入门(二)</title>
      <link>http://example.com/inori/65068962.html</link>
      <guid>http://example.com/inori/65068962.html</guid>
      <pubDate>Sun, 12 May 2024 13:30:40 GMT</pubDate>
      
      <description>elasticsearch入门</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="DSL语句"><a href="#DSL语句" class="headerlink" title="DSL语句"></a>DSL语句</h1><p>DSL(Domain Specific Language)，中文翻译为特定领域语言，在这里代表ES中的查询语言。</p><p>Elasticsearch的查询可以分为两大类：</p><ul><li><strong>叶子查询（Leaf</strong> <strong>query</strong> <strong>clauses）</strong>：一般是在特定的字段里查询特定值，属于简单查询，很少单独使用。</li><li><strong>复合查询（Compound</strong> <strong>query</strong> <strong>clauses）</strong>：以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式。</li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>语法结构：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;查询类型&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="comment">// .. 查询条件</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>GET /索引库名/_search</code>：其中的<code>_search</code>是固定路径，不能修改</li></ul><p>以最简单的无条件查询为例，无条件查询的类型是：match_all，因此其查询语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>虽然是match_all，但是响应结果中并不会包含索引库中的所有文档，而是仅有10条。这是因为处于安全考虑，elasticsearch设置了默认的查询页数。</p><h2 id="叶子查询"><a href="#叶子查询" class="headerlink" title="叶子查询"></a>叶子查询</h2><p>叶子查询的类型也可以做进一步细分，详情可以查看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/query-dsl.html">官方文档</a></p><p>这里列举一些常见的：</p><ul><li><strong>全文检索查询（Full Text Queries）</strong>：利用分词器对用户输入搜索条件先分词，得到词条，然后再利用倒排索引搜索词条。例如：<ul><li><code>match</code>：</li><li><code>multi_match</code></li></ul></li><li><strong>精确查询（Term-level queries）</strong>：不对用户输入搜索条件分词，根据字段内容精确值匹配。但只能查找keyword、数值、日期、boolean类型的字段。例如：<ul><li><code>ids</code></li><li><code>term</code></li><li><code>range</code></li></ul></li><li><strong>地理坐标查询：</strong>用于搜索地理位置，搜索方式很多，例如：<ul><li><code>geo_bounding_box</code>：按矩形搜索</li><li><code>geo_distance</code>：按点和半径搜索</li></ul></li></ul><h2 id="全文检索查询"><a href="#全文检索查询" class="headerlink" title="全文检索查询"></a>全文检索查询</h2><p>全文检索的种类也很多，详情可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/full-text-queries.html">官方文档</a></p><p>以全文检索中的<code>match</code>为例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与<code>match</code>类似的还有<code>multi_match</code>，区别在于可以同时对多个字段搜索，而且多个字段都要满足，语法示例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;字段1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;字段2&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="精确查询"><a href="#精确查询" class="headerlink" title="精确查询"></a>精确查询</h3><p>精确查询，英文是<code>Term-level query</code>，顾名思义，词条级别的查询。也就是说不会对用户输入的搜索条件再分词，而是作为一个词条，与搜索的字段内容精确值匹配。因此推荐查找<code>keyword</code>、数值、日期、<code>boolean</code>类型的字段。例如：</p><ul><li>id</li><li>price</li><li>城市</li><li>地名</li><li>人名</li></ul><p>详情可以查看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/term-level-queries.html">官方文档</a></p><p>以<code>term</code>查询为例：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>range</code>查询：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>最小值<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>最大值<span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>range</code>是范围查询，对于范围筛选的关键字有：</p><ul><li><code>gte</code>：大于等于</li><li><code>gt</code>：大于</li><li><code>lte</code>：小于等于</li><li><code>lt</code>：小于</li></ul><h2 id="复合查询"><a href="#复合查询" class="headerlink" title="复合查询"></a>复合查询</h2><p>复合查询大致可以分为两类：</p><ul><li>第一类：基于逻辑运算组合叶子查询，实现组合条件，例如<ul><li>bool</li></ul></li><li>第二类：基于某种算法修改查询时的文档相关性算分，从而改变文档排名。例如：<ul><li>function_score</li><li>dis_max</li></ul></li></ul><p>其它复合查询及相关语法可以参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/compound-queries.html">官方文档</a></p><h3 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h3><p>bool查询，即布尔查询。就是利用逻辑运算来组合一个或多个查询子句的组合。bool查询支持的逻辑运算有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>bool查询的语法例如：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vivo&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小米&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span> <span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">10000</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与搜索关键字无关的查询尽量采用must_not或filter逻辑运算，避免参与相关性算分。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>elasticsearch默认是根据相关度算分（<code>_score</code>）来排序，但是也支持自定义方式对搜索结果排序。不过分词字段无法排序，能参与排序字段类型有：<code>keyword</code>类型、数值类型、地理坐标类型、日期类型等。</p><p>语法说明：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;排序字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;排序方式asc和desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。</p><h3 id="基础分页"><a href="#基础分页" class="headerlink" title="基础分页"></a>基础分页</h3><p>elasticsearch中通过修改<code>from</code>、<code>size</code>参数来控制要返回的分页结果：</p><ul><li><code>from</code>：从第几个文档开始</li><li><code>size</code>：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span>  <span class="comment">// 每页文档数量，默认10</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="深度分页"><a href="#深度分页" class="headerlink" title="深度分页"></a>深度分页</h3><p>elasticsearch的数据一般会采用分片存储，也就是把一个索引中的数据分成N份，存储到不同节点上。这种存储方式比较有利于数据扩展，但给分页带来了一些麻烦。</p><p>比如一个索引库中有100000条数据，分别存储到4个分片，每个分片25000条数据。现在每页查询10条，查询第99页。那么分页查询的条件如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">990</span><span class="punctuation">,</span> <span class="comment">// 从第990条开始查询</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 每页查询10条</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="string">&quot;asc&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>从语句来分析，要查询第990~1000名的数据。</p><p>从实现思路来分析，肯定是将所有数据排序，找出前1000名，截取其中的990~1000的部分。但问题来了，我们如何才能找到所有数据中的前1000名呢？</p><p>要知道每一片的数据都不一样，第1片上的第900-1000，在另1个节点上并不一定依然是900-1000名。所以我们只能在每一个分片上都找出排名前1000的数据，然后汇总到一起，重新排序，才能找出整个索引库中真正的前1000名，此时截取990-1000的数据即可。假如我们现在要查询的是第999页数据呢，是不是要找第9990~10000的数据，那岂不是需要把每个分片中的前10000名数据都查询出来，汇总在一起，在内存中排序？</p><p>由此可知，当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力。</p><p><strong>因此elasticsearch会禁止<code>from+ size </code>超过10000的请求。</strong></p><p>针对深度分页，elasticsearch提供了两种解决方案：</p><ul><li><code>search after</code>：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li><code>scroll</code>：原理将排序后的文档id形成快照，保存下来，基于快照做分页。官方已经不推荐使用。</li></ul><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/paginate-search-results.html">详情见文档</a></p><p>大多数情况下，我们采用普通分页就可以了。一般我们采用限制分页深度的方式即可，无需实现深度分页。</p><h2 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h2><p>实现高亮的思路为：</p><ul><li>用户输入搜索关键字搜索数据</li><li>服务端根据搜索关键字到elasticsearch搜索，并给搜索结果中的关键字词条添加<code>html</code>标签</li><li>前端提前给约定好的<code>html</code>标签添加<code>CSS</code>样式</li></ul><p>elasticsearch已经提供了给搜索关键字加标签的语法。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;搜索字段&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索关键字&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;高亮字段名称&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;em&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/em&gt;&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>搜索必须有查询条件，而且是全文检索类型的查询条件，例如<code>match</code></li><li>参与高亮的字段必须是<code>text</code>类型的字段</li><li>默认情况下参与高亮的字段要与搜索字段一致，除非添加：<code>required_field_match=false</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p><ul><li><code>query</code>：查询条件</li><li><code>from</code>和<code>size</code>：分页条件</li><li><code>sort</code>：排序条件</li><li><code>highlight</code>：高亮条件</li></ul><h1 id="RestClient查询"><a href="#RestClient查询" class="headerlink" title="RestClient查询"></a>RestClient查询</h1><p>查询的基本步骤如为：</p><p>1）创建<code>request</code>对象，这次是搜索，所以是<code>SearchRequest</code></p><p>2）准备请求参数，查询DSL对应的JSON参数</p><p>3）发起请求</p><p>4）解析响应，响应结果相对复杂，需要逐层解析</p><h2 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h2><p>之前说过，由于Elasticsearch对外暴露的接口都是Restful风格的接口，因此JavaAPI调用就是在发送Http请求。而我们核心要做的就是利用<strong>利用Java代码组织请求参数</strong>，<strong>解析响应结果</strong>。</p><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名 </p><p>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等 </p><ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个<code>match_all</code>查询的DSL</li></ul><p>第三步，利用<code>client.search()</code>发送请求，得到响应 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里关键的API有两个，一个是<code>request.source()</code>，它构建的就是DSL中的完整JSON参数。其中包含<code>query</code>、<code>sort</code>、<code>from</code>、<code>size</code>、<code>highlight</code>等所有功能</p><p><img src="D:\Blog\source\img\request_source.png" alt="request_source"></p><p>另一个是<code>QueryBuilders</code>，其中包含各种<strong>叶子查询</strong>、<strong>复合查询</strong></p><p><img src="D:\Blog\source\img\querybuilders.png" alt="querybuilders"></p><h3 id="解析响应结果"><a href="#解析响应结果" class="headerlink" title="解析响应结果"></a>解析响应结果</h3><p>在发送请求以后，得到了响应结果<code>SearchResponse</code>，这个类的结构与kibana中看到的响应结果JSON结构完全一致</p><p>解析<code>SearchResponse</code>的代码就是在解析这个JSON结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.遍历结果数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 3.得到_source，也就是原始json文档</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 4.反序列化并打印</span></span><br><span class="line">        <span class="type">ItemDoc</span> <span class="variable">item</span> <span class="operator">=</span> JSONUtil.toBean(source, ItemDoc.class);</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过<code>response.getHits()</code>获取，就是JSON中的最外层的<code>hits</code>，代表命中的结果 <ul><li><code>SearchHits.getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits.getHits()</code>：获取<code>SearchHit</code>数组，也就是文档数组 <ul><li><code>SearchHit.getSourceAsString()</code>：获取文档结果中的<code>_source</code>，也就是原始的<code>json</code>文档数据</li></ul></li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>文档搜索的基本步骤是：</p><ol><li>创建<code>SearchRequest</code>对象</li><li>准备<code>request.source()</code>，也就是DSL<ol><li><code>QueryBuilders</code>来构建查询条件</li><li>传入<code>request.source()</code> 的<code>query()</code>方法</li></ol></li><li>发送请求，得到结果</li><li>解析结果</li></ol><h2 id="叶子查询-1"><a href="#叶子查询-1" class="headerlink" title="叶子查询"></a>叶子查询</h2><p>所有的查询条件都是由QueryBuilders来构建的，叶子查询也不例外</p><p>例如<code>match</code>查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>range</code>查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRange</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">10000</span>).lte(<span class="number">30000</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>term</code>查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testTerm</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;华为&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复合查询-1"><a href="#复合查询-1" class="headerlink" title="复合查询"></a>复合查询</h2><p>复合查询也是由<code>QueryBuilders</code>来构建，我们以<code>bool</code>查询为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.准备bool查询</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">bool</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.关键字搜索</span></span><br><span class="line">    bool.must(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.3.品牌过滤</span></span><br><span class="line">    bool.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;德亚&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.4.价格过滤</span></span><br><span class="line">    bool.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">300</span>));</span><br><span class="line">    request.source().query(bool);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序和分页"><a href="#排序和分页" class="headerlink" title="排序和分页"></a>排序和分页</h2><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.搜索条件参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.排序参数</span></span><br><span class="line">    request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页参数</span></span><br><span class="line">    request.source().from((pageNo - <span class="number">1</span>) * pageSize).size(pageSize);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高亮-1"><a href="#高亮-1" class="headerlink" title="高亮"></a>高亮</h2><ul><li>条件同样是在<code>request.source()</code>中指定，高亮条件要基于<code>HighlightBuilder</code>来构造</li><li>高亮响应结果与搜索的文档结果不在一起，需要单独解析</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.query条件</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮条件</span></span><br><span class="line">    request.source().highlighter(</span><br><span class="line">            SearchSourceBuilder.highlight()</span><br><span class="line">                    .field(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                    .preTags(<span class="string">&quot;&lt;em&gt;&quot;</span>)</span><br><span class="line">                    .postTags(<span class="string">&quot;&lt;/em&gt;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果解析部分，文档解析不变，主要是高亮内容需要单独解析出来:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.遍历结果数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 3.得到_source，也就是原始json文档</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 4.反序列化</span></span><br><span class="line">        <span class="type">ItemDoc</span> <span class="variable">item</span> <span class="operator">=</span> JSONUtil.toBean(source, ItemDoc.class);</span><br><span class="line">        <span class="comment">// 5.获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; hfs = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isNotEmpty(hfs)) &#123;</span><br><span class="line">            <span class="comment">// 5.1.有高亮结果，获取name的高亮结果</span></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">hf</span> <span class="operator">=</span> hfs.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (hf != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 5.2.获取第一个高亮结果片段，就是商品名称的高亮值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">hfName</span> <span class="operator">=</span> hf.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                item.setName(hfName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第<code>3、4</code>步：从结果中获取<code>_source</code>。<code>hit.getSourceAsString()</code>，这部分是非高亮结果，json字符串。还需要反序列为<code>ItemDoc</code>对象</li><li>第<code>5</code>步：获取高亮结果。<code>hit.getHighlightFields()</code>，返回值是一个<code>Map</code>，key是高亮字段名称，值是<code>HighlightField</code>对象，代表高亮值</li><li>第<code>5.1</code>步：从<code>Map</code>中根据高亮字段名称，获取高亮字段值对象<code>HighlightField</code></li><li>第<code>5.2</code>步：从<code>HighlightField</code>中获取<code>Fragments</code>，并且转为字符串。这部分就是真正的高亮字符串了</li><li>最后：用高亮的结果替换<code>ItemDoc</code>中的非高亮结果</li></ul><h1 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h1><p>聚合（<code>aggregations</code>）可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><p>聚合常见的有三类：</p><ul><li>桶（<code>Bucket</code>）聚合：用来对文档做分组 <ul><li><code>TermAggregation</code>：按照文档字段值分组，例如按照品牌值分组</li><li><code>Date Histogram</code>：按照日期阶梯分组，例如一周为一组</li></ul></li><li>度量（<code>Metric</code>）聚合：用以计算一些值<ul><li><code>Avg</code>：求平均值</li><li><code>Max</code>：求最大值</li><li><code>Min</code>：求最小值</li><li><code>Stats</code>：同时求<code>max</code>、<code>min</code>、<code>avg</code>、<code>sum</code>等</li></ul></li><li>管道（<code>pipeline</code>）聚合：其它聚合的结果为基础做进一步运算</li></ul><p><strong>参加聚合的字段必须是keyword、日期、数值、布尔类型</strong></p><h2 id="DSL实现聚合"><a href="#DSL实现聚合" class="headerlink" title="DSL实现聚合"></a>DSL实现聚合</h2><h3 id="Bucket聚合"><a href="#Bucket聚合" class="headerlink" title="Bucket聚合"></a>Bucket聚合</h3><p>例如我们要统计所有商品中共有哪些商品分类，其实就是以分类（category）字段对数据分组。category值一样的放在同一组，属于<code>Bucket</code>聚合中的<code>Term</code>聚合。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;category_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;category&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>语法说明：</p><ul><li><code>size</code>：设置<code>size</code>为0，就是每页查0条，则结果中就不包含文档，只包含聚合</li><li><code>aggs</code>：定义聚合<ul><li><code>category_agg</code>：聚合名称，自定义，不能重复<ul><li><code>terms</code>：聚合的类型，按分类聚合，所以用<code>term</code><ul><li><code>field</code>：参与聚合的字段名称</li><li><code>size</code>：希望返回的聚合结果的最大数量</li></ul></li></ul></li></ul></li></ul><h3 id="带条件聚合"><a href="#带条件聚合" class="headerlink" title="带条件聚合"></a>带条件聚合</h3><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>例如，我想知道价格高于3000元的手机品牌有哪些，该怎么统计呢？</p><p>我们需要从需求中分析出搜索查询的条件和聚合的目标：</p><ul><li>搜索查询条件：<ul><li>价格高于3000</li><li>必须是手机</li></ul></li><li>聚合目标：统计的是品牌，肯定是对brand字段做term聚合</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">300000</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brand_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Metric聚合"><a href="#Metric聚合" class="headerlink" title="Metric聚合"></a>Metric聚合</h3><p>上节课，我们统计了价格高于3000的手机品牌，形成了一个个桶。现在我们需要对桶内的商品做运算，获取每个品牌价格的最小值、最大值、平均值。</p><p>这就要用到<code>Metric</code>聚合了，例如<code>stat</code>聚合，就可以同时获取<code>min</code>、<code>max</code>、<code>avg</code>等结果</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">300000</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brand_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;stats_meric&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到我们在<code>brand_agg</code>聚合的内部，我们新加了一个<code>aggs</code>参数。这个聚合就是<code>brand_agg</code>的子聚合，会对<code>brand_agg</code>形成的每个桶中的文档分别统计。</p><ul><li><code>stats_meric</code>：聚合名称<ul><li><code>stats</code>：聚合类型，stats是<code>metric</code>聚合的一种<ul><li><code>field</code>：聚合字段，这里选择<code>price</code>，统计价格</li></ul></li></ul></li></ul><p>由于stats是对brand_agg形成的每个品牌桶内文档分别做统计，因此每个品牌都会统计出自己的价格最小、最大、平均值。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>aggs代表聚合，与query同级，此时query的作用是？</p><ul><li>限定聚合的的文档范围</li></ul><p>聚合必须的三要素：</p><ul><li>聚合名称</li><li>聚合类型</li><li>聚合字段</li></ul><p>聚合可配置属性有：</p><ul><li>size：指定聚合结果数量</li><li>order：指定聚合结果排序方式</li><li>field：指定聚合字段</li></ul><h2 id="RestClient实现聚合"><a href="#RestClient实现聚合" class="headerlink" title="RestClient实现聚合"></a>RestClient实现聚合</h2><p>在DSL中，<code>aggs</code>聚合条件与<code>query</code>条件是同一级别，都属于查询JSON参数，因此依然是利用<code>request.source()</code>方法来设置。</p><p>聚合条件的要利用<code>AggregationBuilders</code>这个工具类来构造，聚合结果与搜索文档同一级别，需要单独获取和解析。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAgg</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">bool</span> <span class="operator">=</span> QueryBuilders.boolQuery()</span><br><span class="line">            .filter(QueryBuilders.termQuery(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;手机&quot;</span>))</span><br><span class="line">            .filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">3000</span>));</span><br><span class="line">    request.source().query(bool).size(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3.聚合参数</span></span><br><span class="line">    request.source().aggregation(</span><br><span class="line">            AggregationBuilders.terms(<span class="string">&quot;brand_agg&quot;</span>).field(<span class="string">&quot;brand&quot;</span>).size(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 4.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 5.解析聚合结果</span></span><br><span class="line">    <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">    <span class="comment">// 5.1.获取品牌聚合</span></span><br><span class="line">    <span class="type">Terms</span> <span class="variable">brandTerms</span> <span class="operator">=</span> aggregations.get(<span class="string">&quot;brand_agg&quot;</span>);</span><br><span class="line">    <span class="comment">// 5.2.获取聚合中的桶</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();</span><br><span class="line">    <span class="comment">// 5.3.遍历桶内数据</span></span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 5.4.获取桶内key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">brand</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">        System.out.print(<span class="string">&quot;brand = &quot;</span> + brand);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> bucket.getDocCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;; count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/elasticsearch/">elasticsearch</category>
      
      
      <category domain="http://example.com/tags/elasticsearch/">elasticsearch</category>
      
      
      <comments>http://example.com/inori/65068962.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringCloud微服务入门(二)</title>
      <link>http://example.com/inori/98835b85.html</link>
      <guid>http://example.com/inori/98835b85.html</guid>
      <pubDate>Sun, 12 May 2024 08:45:13 GMT</pubDate>
      
      <description>SpringCloud</description>
      
      
      
      <content:encoded><![CDATA[<p>在微服务远程调用的过程中，还存在几个问题需要解决。</p><p>首先是<strong>业务健壮性</strong>问题：</p><p>例如在之前的查询购物车列表业务中，购物车服务需要查询最新的商品信息，与购物车数据做对比，提醒用户。大家设想一下，如果商品服务查询时发生故障，查询购物车列表在调用商品服 务时，是不是也会异常？从而导致购物车查询失败。但从业务角度来说，为了提升用户体验，即便是商品查询失败，购物车列表也应该正确展示出来，哪怕是不包含最新的商品信息。</p><p>还有级联失败问题：</p><p>还是查询购物车的业务，假如商品服务业务并发较高，占用过多Tomcat连接。可能会导致商品服务的所有接口响应时间增加，延迟变高，甚至是长时间阻塞直至查询失败。</p><p>此时查询购物车业务需要查询并等待商品查询结果，从而导致查询购物车列表业务的响应时间也变长，甚至也阻塞直至无法访问。而此时如果查询购物车的请求较多，可能导致购物车服务的Tomcat连接占用较多，所有接口的响应时间都会增加，整个服务性能很差， 甚至不可用。</p><p>暂时无法在飞书文档外展示此内容</p><p>依次类推，整个微服务群中与购物车服务、商品服务等有调用关系的服务可能都会出现问题，最终导致整个集群不可用。</p><p>暂时无法在飞书文档外展示此内容</p><p>这就是级联失败问题，或者叫雪崩问题。</p><h1 id="微服务保护"><a href="#微服务保护" class="headerlink" title="微服务保护"></a>微服务保护</h1><p>保证服务运行的健壮性，避免级联失败导致的雪崩问题（整个微服务群中有调用关系的服务出现问题，最终导致整个集群不可用），就属于微服务保护</p><h2 id="服务保护方案"><a href="#服务保护方案" class="headerlink" title="服务保护方案"></a>服务保护方案</h2><p>微服务保护的方案有很多，比如：</p><ul><li>请求限流</li><li>线程隔离</li><li>服务熔断</li></ul><p>这些方案或多或少都会导致服务的体验上略有下降，比如请求限流，降低了并发上限；线程隔离，降低了可用资源数量；服务熔断，降低了服务的完整度，部分服务变的不可用或弱可用。因此这些方案都属于服务<strong>降级</strong>的方案。但通过这些方案，服务的健壮性得到了提升，</p><h3 id="请求限流"><a href="#请求限流" class="headerlink" title="请求限流"></a>请求限流</h3><p>服务故障最重要原因，就是并发太高。解决了这个问题，就能避免大部分故障。当然，接口的并发不是一直很高，而是突发的。因此请求限流，就是<strong>限制或控制</strong>接口访问的并发流量，避免服务因流量激增而出现故障。</p><p>请求限流往往会有一个限流器，数量高低起伏的并发请求曲线，经过限流器就变的非常平稳。</p><h3 id="线程隔离"><a href="#线程隔离" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>当一个业务接口响应时间长，而且并发高时，就可能耗尽服务器的线程资源，导致服务内的其它接口受到影响。所以必须把这种影响降低，或者缩减影响的范围，线程隔离正是解决这个问题的好办法。</p><p>其原理就是为了避免某个接口故障或压力过大导致整个服务不可用，限定每个接口可以使用的资源范围，也就是将其“隔离”起来。</p><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>线程隔离虽然避免了雪崩问题，但故障服务依然会拖慢服务调用方的接口响应速度，而且其故障可能会导致接下来要调用的其他服务也变得不可用。</p><p>所以要做两件事情：</p><ul><li><strong>编写服务降级逻辑</strong>：就是服务调用失败后的处理逻辑，根据业务场景，可以抛出异常，也可以返回友好提示或默认数据。</li><li><strong>异常统计和熔断</strong>：统计服务提供方的异常比例，当比例过高表明该接口会影响到其它服务，应该拒绝调用该接口，而是直接走降级逻辑。</li></ul><h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p><a href="https://sentinelguard.io/zh-cn/">Sentinel</a>是阿里巴巴开源的一款服务保护框架，目前已经加入SpringCloudAlibaba中</p><p>Sentinel 的使用可以分为两个部分:</p><ul><li><strong>核心库</strong>（Jar包）：不依赖任何框架&#x2F;库，能够运行于 ava8及以上的版本的运行时环境，同时对Dubbo&#x2F;Spring Cloud等框架也有较好的支持。在项目中引入依赖即可实现服务限流、隔离、熔断等功能。</li><li><strong>控制台</strong>（Dashboard）：Dashboard主要负责管理推送规则、监控、管理机器信息等。</li></ul><p>为了方便监控微服务，需要先把Sentinel的控制台搭建出来。</p><p>1）<a href="https://github.com/alibaba/Sentinel/releases">下载jar包</a></p><p>2）运行</p><p>将jar包放在任意非中文、不包含特殊字符的目录下,运行如下命令启动控制台：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar</span><br></pre></td></tr></table></figure><p>其它启动时可配置参数可参考<a href="https://github.com/alibaba/Sentinel/wiki/%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E9%A1%B9">官方文档</a></p><p>3）访问</p><p>访问<a href="http://localhost:8080/">http://localhost:8090</a>页面，就可以看到sentinel的控制台了，需要输入账号和密码，默认都是：sentinel，登录后，即可看到控制台，默认会监控sentinel-dashboard服务本身</p><h3 id="微服务整合"><a href="#微服务整合" class="headerlink" title="微服务整合"></a>微服务整合</h3><p>想要在微服务连接<code>sentinel-dashboard</code>控制台，步骤如下： </p><p>1）引入sentinel依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--sentinel--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）配置控制台</p><p>修改application.yaml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span> </span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br></pre></td></tr></table></figure><p>3）访问微服务任意端点</p><p>重启微服务，然后访问查询购物车接口，sentinel的客户端就会将服务访问的信息提交到<code>sentinel-dashboard</code>控制台。并展示出统计信息</p><p>点击簇点链路菜单，会看到下面的页面：</p><p><img src="D:\Blog\source\img\sentinel_service_control.png" alt="sentinel_service_control"></p><p>簇点链路，就是单机调用链路，是一次请求进入服务后经过的每一个被Sentinel监控的资源。默认情况下，<code>Sentinel</code>会监控<code>SpringMVC</code>的每一个<code>Endpoint</code>（接口）</p><p><code>/carts</code>这个接口路径就是其中一个簇点，我们可以对其进行限流、熔断、隔离等保护措施。</p><p>默认情况下Sentinel会把路径作为簇点资源的名称，无法区分路径相同但请求方式不同的接口，查询、删除、修改等都被识别为一个簇点资源，这显然是不合适的。</p><p>所以可以选择打开Sentinel的请求方式前缀，把<code>请求方式 + 请求路径</code>作为簇点资源名：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="string">localhost:8090</span></span><br><span class="line">      <span class="attr">http-method-specify:</span> <span class="literal">true</span> <span class="comment"># 开启请求方式前缀</span></span><br></pre></td></tr></table></figure><h3 id="请求限流-1"><a href="#请求限流-1" class="headerlink" title="请求限流"></a>请求限流</h3><p>在簇点链路后面点击流控按钮，即可对其做限流配置</p><h3 id="线程隔离-1"><a href="#线程隔离-1" class="headerlink" title="线程隔离"></a>线程隔离</h3><p>限流可以降低服务器压力，尽量减少因并发流量引起的服务故障的概率，但并不能完全避免服务故障。一旦某个服务出现故障，我们必须隔离对这个服务的调用，避免发生雪崩。所以要对查询商品的FeignClient接口做线程隔离。</p><h4 id="OpenFeign整合Sentinel"><a href="#OpenFeign整合Sentinel" class="headerlink" title="OpenFeign整合Sentinel"></a>OpenFeign整合Sentinel</h4><p>开启Feign的sentinel功能：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">sentinel:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启feign对sentinel的支持</span></span><br></pre></td></tr></table></figure><p>然后重启cart-service服务，可以看到查询商品的FeignClient自动变成了一个簇点资源</p><h4 id="配置线程隔离"><a href="#配置线程隔离" class="headerlink" title="配置线程隔离"></a>配置线程隔离</h4><p>点击查询商品的FeignClient对应的簇点资源后面的流控按钮：</p><p><img src="D:\Blog\source\img\thread_division.png" alt="thread_division"></p><p>这里勾选的是并发线程数限制，也就是说这个查询功能最多使用5个线程，而不是5QPS。如果查询商品的接口每秒处理2个请求，则5个线程的实际QPS在10左右，而超出的请求自然会被拒绝。</p><h3 id="服务熔断-1"><a href="#服务熔断-1" class="headerlink" title="服务熔断"></a>服务熔断</h3><p>通常来说，业务不能只配置线程隔离，还需要搭配服务熔断一起，因为：</p><ul><li>超出的QPS上限的请求就只能抛出异常，会损失用户体验。需要给查询失败设置一个<strong>降级处理</strong>逻辑</li><li>由于查询商品的延迟较高，从而导致其他相关联的业务响应时间也变的很长。对于这种不太健康的接口，应该直接停止调用，直接走降级逻辑，避免影响到当前服务。也就是将商品查询接口<strong>熔断</strong>。</li></ul><h4 id="编写降级逻辑"><a href="#编写降级逻辑" class="headerlink" title="编写降级逻辑"></a>编写降级逻辑</h4><p>触发限流或熔断后的请求不一定要直接报错，也可以返回一些默认数据或者友好提示，用户体验会更好。</p><p>给FeignClient编写失败后的降级逻辑有两种方式：</p><ul><li>FallbackClass，无法对远程调用的异常做处理</li><li>FallbackFactory，可以对远程调用的异常做处理，我们一般选择这种方式。</li></ul><p>定义降级处理类，实现<code>FallbackFactory</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemClientFallback</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;ItemClient&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ItemClient <span class="title function_">create</span><span class="params">(Throwable cause)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ItemClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(Collection&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;远程调用queryItemByIds方法出现异常，参数：&#123;&#125;&quot;</span>, ids, cause);</span><br><span class="line">                <span class="comment">// 查询购物车允许失败，查询失败，返回空集合</span></span><br><span class="line">                <span class="keyword">return</span> CollUtils.emptyList();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(List&lt;OrderDetailDTO&gt; items)</span> &#123;</span><br><span class="line">                <span class="comment">// 库存扣减业务需要触发事务回滚，查询失败，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizIllegalException</span>(cause);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>ItemClientFallback</code>注册为一个<code>Bean</code></p><p>在接口中使用<code>ItemClientFallbackFactory</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;item-service&quot;, configuration = DefaultFeignConfig.class,fallbackFactory = ItemClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/items/stock/deduct&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetailDTO&gt; items)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/stock/add&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStock</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;OrderDetail&gt; items)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务熔断-2"><a href="#服务熔断-2" class="headerlink" title="服务熔断"></a>服务熔断</h4><p>Sentinel中的断路器不仅可以统计某个接口的<strong>慢请求比例</strong>，还可以统计<strong>异常请求比例</strong>。当这些比例超出阈值时，就会<strong>熔断</strong>该接口，即拦截访问该接口的一切请求，降级处理；当该接口恢复正常时，再放行对于该接口的请求。</p><p>断路器的工作状态切换有一个状态机来控制：</p><p><img src="D:\Blog\source\img\sentinel_stop.png" alt="sentinel_stop"></p><p>状态机包括三个状态：</p><ul><li><strong>closed</strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</li><li><strong>open</strong>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态持续一段时间后会进入half-open状态</li><li><strong>half-open</strong>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。 <ul><li>请求成功：则切换到closed状态</li><li>请求失败：则切换到open状态</li></ul></li></ul><p>我们可以在控制台通过点击簇点后的<strong>熔断</strong>按钮来配置熔断策略，这种是按照慢调用比例来做熔断，上述配置的含义是：</p><ul><li>RT超过200毫秒的请求调用就是慢调用</li><li>统计最近1000ms内的最少5次请求，如果慢调用比例不低于0.5，则触发熔断</li><li>熔断持续时长20s</li></ul><h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>整个业务中，各个本地事务是有关联的。因此每个微服务的本地事务，也可以称为<strong>分支事务</strong>。多个有关联的分支事务一起就组成了<strong>全局事务</strong>。必须保证整个全局事务同时成功或失败。</p><p>我们知道每一个分支事务就是传统的<strong>单体事务</strong>，都可以满足ACID(原子性，一致性，隔离性，持久性)，但全局事务跨越多个服务、多个数据库，如何满足ACID呢？</p><h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h2><p>解决分布式事务的方案有很多，但实现起来都比较复杂，因此一般会使用开源的框架来解决分布式事务问题。</p><p>在众多的开源分布式事务框架中，功能最完善、使用最多的是<a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">Seata</a>。</p><p>其实分布式事务产生的一个重要原因，就是参与事务的多个分支事务互相无感知，不知道彼此的执行状态。</p><p>因此解决分布式事务的思想为：就是找一个统一的<strong>事务协调者</strong>，与多个分支事务通信，检测每个分支事务的执行状态，保证全局事务下的每一个分支事务同时成功或失败即可。</p><p>在Seata的事务管理中有三个重要的角色：</p><ul><li>TC (Transaction Coordinator) - <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。 </li><li>TM (Transaction Manager) - <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。 </li><li>RM (Resource Manager) - <strong>资源管理器：</strong>管理分支事务，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li></ul><p>Seata的工作架构为：</p><p><img src="D:\Blog\source\img\seata_frame.png" alt="seata_frame"></p><p>其中，<strong>TM</strong>和<strong>RM</strong>可以理解为Seata的客户端部分，引入到参与事务的微服务依赖中即可。将来<strong>TM</strong>和<strong>RM</strong>就会协助微服务，实现本地分支事务与<strong>TC</strong>之间交互，实现事务的提交或回滚。</p><p>而<strong>TC</strong>服务则是事务协调中心，是一个独立的微服务，需要单独部署。</p><h3 id="部署TC服务"><a href="#部署TC服务" class="headerlink" title="部署TC服务"></a>部署TC服务</h3><p>需要准备数据库表、导入配置文件、使用Docker命令部署，详见<a href="https://blog.csdn.net/studio_1/article/details/135650319">这篇博客</a></p><h4 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h4><p>需要注意，要确保nacos、mysql都在同一网络中。如果某个容器不在同一网络，可以参考下面的命令将某容器加入指定网络：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network connect [网络名] [容器名]</span><br></pre></td></tr></table></figure><h3 id="微服务集成Seata"><a href="#微服务集成Seata" class="headerlink" title="微服务集成Seata"></a>微服务集成Seata</h3><p>参与分布式事务的每一个微服务都需要集成Seata，我们以<code>trade-service</code>为例。</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>为了方便各个微服务集成seata，我们需要把seata配置共享到nacos，因此不仅仅要引入seata依赖，还要引入nacos依赖:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="comment"># TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span> <span class="comment"># 注册中心类型 nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">namespace:</span> <span class="string">&quot;&quot;</span> <span class="comment"># namespace，默认为空</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认是DEFAULT_GROUP</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span> <span class="comment"># seata服务名称</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">nacos</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">nacos</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">hmall</span> <span class="comment"># 事务组名称</span></span><br><span class="line">  <span class="attr">service:</span></span><br><span class="line">    <span class="attr">vgroup-mapping:</span> <span class="comment"># 事务组与tc集群的映射关系</span></span><br><span class="line">      <span class="attr">hmall:</span> <span class="string">&quot;default&quot;</span></span><br></pre></td></tr></table></figure><h4 id="添加数据库表"><a href="#添加数据库表" class="headerlink" title="添加数据库表"></a>添加数据库表</h4><p>seata的客户端在解决分布式事务的时候需要记录一些中间数据，保存在数据库中。因此我们要先准备一个这样的表。加入到需要分布式事务的微服务的数据库中：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `undo_log`</span><br><span class="line">(</span><br><span class="line">    `branch_id`     <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    `xid`           <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    `context`       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    `rollback_info` LONGBLOB     <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    `log_status`    <span class="type">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    `log_created`   DATETIME(<span class="number">6</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    `log_modified`  DATETIME(<span class="number">6</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4 COMMENT <span class="operator">=</span><span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure><p>至此为止，微服务整合的工作就完成了</p><p>那么，Seata是如何解决分布式事务的呢？</p><h3 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h3><p>Seata支持四种不同的分布式事务解决方案：</p><ul><li><strong>XA</strong></li><li><strong>TCC</strong></li><li><strong>AT</strong></li><li><strong>SAGA</strong></li></ul><p><code>XA</code> 规范是<code> X/Open</code> 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA规范描述了全局的<code>TM</code>与局部的<code>RM</code>之间的接口，几乎所有主流的数据库都对XA规范提供了支持。</p><h4 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h4><p>正常情况：</p><p><img src="D:\Blog\source\img\xa_normal.png" alt="xa_normal"></p><p>异常情况：</p><p><img src="D:\Blog\source\img\xa_nonomal.png" alt="xa_nonomal"></p><p>一阶段：</p><ul><li>事务协调者通知每个事务参与者执行本地事务</li><li>本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</li></ul><p>二阶段：</p><ul><li>事务协调者基于一阶段的报告来判断下一步操作</li><li>如果一阶段都成功，则通知所有事务参与者，提交事务</li><li>如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</li></ul><h4 id="Seata的XA模型"><a href="#Seata的XA模型" class="headerlink" title="Seata的XA模型"></a>Seata的XA模型</h4><p>Seata对原始的XA模式做了简单的封装和改造，以适应自己的事务模型，基本架构如图：</p><p><img src="D:\Blog\source\img\xa_model.png" alt="xa_model"></p><p><code>RM</code>一阶段的工作：</p><ol><li>注册分支事务到<code>TC</code></li><li>执行分支业务sql但不提交</li><li>报告执行状态到<code>TC</code></li></ol><p><code>TC</code>二阶段的工作：</p><ol><li><code>TC</code>检测各分支事务执行状态</li><li>如果都成功，通知所有RM提交事务</li><li>如果有失败，通知所有RM回滚事务</li></ol><p><code>RM</code>二阶段的工作：</p><ul><li>接收<code>TC</code>指令，提交或回滚事务</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><code>XA</code>模式的优点是什么？</p><ul><li>事务的强一致性，满足ACID原则</li><li>常用数据库都支持，实现简单，并且没有代码侵入</li></ul><p><code>XA</code>模式的缺点是什么？</p><ul><li>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差</li><li>依赖关系型数据库实现事务</li></ul><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><p>首先，在配置文件中设置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">data-source-proxy-mode:</span> <span class="string">XA</span></span><br></pre></td></tr></table></figure><p>其次，我们要利用<code>@GlobalTransactional</code>标记分布式事务的入口方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="keyword">public</span> Long <span class="title function_">createOrder</span><span class="params">(OrderFormDTO orderFormDTO)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AT模式"><a href="#AT模式" class="headerlink" title="AT模式"></a>AT模式</h3><p><code>AT</code>模式同样是分阶段提交的事务模型，不过缺弥补了<code>XA</code>模型中资源锁定周期过长的缺陷。</p><h4 id="Seata的AT模型"><a href="#Seata的AT模型" class="headerlink" title="Seata的AT模型"></a>Seata的AT模型</h4><p><img src="D:\Blog\source\img\at_model.png" alt="at_model"></p><p>阶段一<code>RM</code>的工作：</p><ul><li>注册分支事务</li><li>记录undo-log（数据快照）</li><li>执行业务sql并提交</li><li>报告事务状态</li></ul><p>阶段二提交时<code>RM</code>的工作：</p><ul><li>删除undo-log即可</li></ul><p>阶段二回滚时<code>RM</code>的工作：</p><ul><li>根据undo-log恢复数据到更新前</li></ul><h4 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h4><p>我们用一个真实的业务来梳理下AT模式的原理。</p><p>比如，现在有一个数据库表，记录用户余额：</p><table><thead><tr><th align="left"><strong>id</strong></th><th align="left"><strong>money</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">100</td></tr></tbody></table><p>其中一个分支业务要执行的SQL为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb_account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">10</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>AT模式下，当前分支事务执行流程如下：</p><p><strong>一阶段</strong>：</p><ol><li><code>TM</code>发起并注册全局事务到<code>TC</code></li><li><code>TM</code>调用分支事务</li><li>分支事务准备执行业务SQL</li><li><code>RM</code>拦截业务SQL，根据where条件查询原始数据，形成快照。</li></ol><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;money&quot;</span><span class="punctuation">:</span> <span class="number">100</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol><li><code>RM</code>执行业务SQL，提交本地事务，释放数据库锁。此时 money &#x3D; 90</li><li><code>RM</code>报告本地事务状态给<code>TC</code></li></ol><p><strong>二阶段</strong>：</p><ol><li><code>TM</code>通知<code>TC</code>事务结束</li><li><code>TC</code>检查分支事务状态<ol><li>如果都成功，则删除快照</li><li>如果有分支事务失败，需要回滚。读取快照数据（{“id”: 1, “money”: 100}），将快照恢复到数据库。此时数据库再次恢复为100</li></ol></li></ol><h3 id="AT与XA的区别"><a href="#AT与XA的区别" class="headerlink" title="AT与XA的区别"></a>AT与XA的区别</h3><p>简述<code>AT</code>模式与<code>XA</code>模式最大的区别是什么？</p><ul><li><code>XA</code>模式一阶段不提交事务，锁定资源；<code>AT</code>模式一阶段直接提交，不锁定资源。</li><li><code>XA</code>模式依赖数据库机制实现回滚；<code>AT</code>模式利用数据快照实现数据回滚。</li><li><code>XA</code>模式强一致；<code>AT</code>模式最终一致</li></ul><p>可见，AT模式使用起来更加简单，无业务侵入，性能更好。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/98835b85.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ElasticSearch基础入门</title>
      <link>http://example.com/inori/d672aa30.html</link>
      <guid>http://example.com/inori/d672aa30.html</guid>
      <pubDate>Sun, 12 May 2024 04:27:15 GMT</pubDate>
      
      <description>elasticsearch入门</description>
      
      
      
      <content:encoded><![CDATA[<p>在某些数据量非常大的项目中，一定会提供搜索功能。如果搜索功能仅仅使用数据库模糊查询实现，就会带来很多问题：</p><ol><li>效率低。由于数据库模糊查询不走索引，在数据量较大的时候，查询性能很差。数据库模糊查询随着表数据量的增多，查询性能的下降会非常明显，</li><li>功能单一。数据库的模糊搜索功能单一，匹配条件非常苛刻，必须恰好包含用户搜索的关键字。</li></ol><p>而使用搜索引擎就没有上述问题。</p><h1 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h1><p><a href="https://www.elastic.co/cn/elasticsearch/">ElasticSearch</a>是一款非常强大的开源搜索引擎，支持的功能非常多</p><h2 id="认识和安装"><a href="#认识和安装" class="headerlink" title="认识和安装"></a>认识和安装</h2><p>Elasticsearch是elastic技术栈中的一部分。完整的技术栈包括：</p><ul><li>Elasticsearch：用于数据存储、计算和搜索</li><li>Logstash&#x2F;Beats：用于数据收集</li><li>Kibana：用于数据可视化</li></ul><p>整套技术栈被称为ELK，经常用来做日志收集、系统监控和状态分析等等，其核心就是用来<strong>存储</strong>、<strong>搜索</strong>、<strong>计算</strong>的Elasticsearch</p><p>需要安装的内容有：</p><ul><li>Elasticsearch：提供核心的数据存储、搜索、分析功能。</li><li>Kibana：Elasticsearch对外提供的是Restful风格的API，任何操作都可以通过发送http请求来完成。不过http请求的方式、路径、还有请求参数的格式都有严格的规范。要借助于Kibana服务</li></ul><p>而且，Kibana的功能非常强大，包括：</p><ul><li>对Elasticsearch数据的搜索、展示</li><li>对Elasticsearch数据的统计、聚合，并形成图形化报表、图形</li><li>对Elasticsearch的集群状态监控</li><li>它还提供了一个开发控制台（DevTools），在其中对Elasticsearch的Restful的API接口提供了<strong>语法提示</strong></li></ul><h3 id="安装elasticsearch"><a href="#安装elasticsearch" class="headerlink" title="安装elasticsearch"></a>安装elasticsearch</h3><p>通过Docker命令安装单机版本的elasticsearch，这里采用的是elasticsearch7版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name es \</span><br><span class="line">  -e <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">  -v es-data:/usr/share/elasticsearch/data \</span><br><span class="line">  -v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">  --privileged \</span><br><span class="line">  --network test-net \</span><br><span class="line">  -p 9200:9200 \</span><br><span class="line">  -p 9300:9300 \</span><br><span class="line">  elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><p>安装完成后，访问9200端口，即可看到响应的Elasticsearch服务的基本信息。</p><h3 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h3><p>通过Docker命令部署Kibana：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name kibana \</span><br><span class="line">-e ELASTICSEARCH_HOSTS=http://es:9200 \</span><br><span class="line">--network=test-net \</span><br><span class="line">-p 5601:5601  \</span><br><span class="line">kibana:7.12.1</span><br></pre></td></tr></table></figure><p>安装完成后，直接访问5601端口，即可看到控制台页面，选择<code>Explore on my own</code>之后，进入主页面，然后选中<code>Dev tools</code>，进入开发工具页面，之后主要在这里预先输入ES查询语句。</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>ES之所以有如此高性能的搜索表现，正是得益于底层的倒排索引技术。倒排索引的概念是基于MySQL这样的正向索引而言的。</p><h3 id="正向索引"><a href="#正向索引" class="headerlink" title="正向索引"></a>正向索引</h3><p>例如有一张名为<code>tb_goods</code>的表：</p><table><thead><tr><th align="left"><strong>id</strong></th><th align="left"><strong>title</strong></th><th align="left"><strong>price</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">小米手机</td><td align="left">3499</td></tr><tr><td align="left">2</td><td align="left">华为手机</td><td align="left">4999</td></tr><tr><td align="left">3</td><td align="left">华为小米充电器</td><td align="left">49</td></tr><tr><td align="left">4</td><td align="left">小米手环</td><td align="left">49</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>其中的<code>id</code>字段已经创建了索引，由于索引底层采用了B+树结构，因此我们根据id搜索的速度会非常快。但是其他字段例如<code>title</code>，只在叶子节点上存在。</p><p>因此要根据<code>title</code>搜索的时候只能遍历树中的每一个叶子节点，判断title数据是否符合要求。</p><p>比如用户的SQL语句为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_goods <span class="keyword">where</span> title <span class="keyword">like</span> <span class="string">&#x27;%手机%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>那搜索的大概流程为：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjM0NTE1OWFhNmQ1ZDc2NTY1OGRhYzA1OTkyYmU5MzZfeXQ4YmlybEFRa3BzQVF6N3NyaDBnSkV6aENkUWVWdzBfVG9rZW46UFlDRGJlNVNub1VHaVV4TFRLTGMwOEJLbkRiXzE3MTU1MTEyMTg6MTcxNTUxNDgxOF9WNA" alt="img"></p><ul><li>1）检查到搜索条件为<code>like &#39;%手机%&#39;</code>，需要找到<code>title</code>中包含<code>手机</code>的数据</li><li>2）逐条遍历每行数据（每个叶子节点），比如第1次拿到<code>id</code>为1的数据</li><li>3）判断数据中的<code>title</code>字段值是否符合条件</li><li>4）如果符合则放入结果集，不符合则丢弃</li><li>5）回到步骤1</li></ul><p>当搜索条件为模糊匹配时，由于索引无法生效，导致从索引查询退化为全表扫描，效率很差。因此，正向索引适合于根据索引字段的精确搜索，不适合基于部分词条的模糊匹配。而倒排索引恰好解决的就是根据部分词条模糊匹配的问题。</p><h3 id="倒排索引-1"><a href="#倒排索引-1" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>倒排索引中有两个概念：</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条</li></ul><p>创建倒排索引是对正向索引的一种特殊处理和应用，流程为：</p><ul><li>将每一个文档的数据利用<strong>分词算法</strong>根据语义拆分，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建<strong>正向</strong>索引</li></ul><p>此时形成的这张以词条为索引的表，就是倒排索引表，两者对比如下：</p><p><strong>正向索引</strong></p><table><thead><tr><th align="left"><strong>id（索引）</strong></th><th align="left"><strong>title</strong></th><th align="left"><strong>price</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">小米手机</td><td align="left">3499</td></tr><tr><td align="left">2</td><td align="left">华为手机</td><td align="left">4999</td></tr><tr><td align="left">3</td><td align="left">华为小米充电器</td><td align="left">49</td></tr><tr><td align="left">4</td><td align="left">小米手环</td><td align="left">49</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p><strong>倒排索引</strong></p><table><thead><tr><th align="left"><strong>词条（索引）</strong></th><th align="left"><strong>文档id</strong></th></tr></thead><tbody><tr><td align="left">小米</td><td align="left">1，3，4</td></tr><tr><td align="left">手机</td><td align="left">1，2</td></tr><tr><td align="left">华为</td><td align="left">2，3</td></tr><tr><td align="left">充电器</td><td align="left">3</td></tr><tr><td align="left">手环</td><td align="left">4</td></tr></tbody></table><p>倒排索引的<strong>搜索流程</strong>如下为：</p><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=Njk5OTBlZWJhMDg1MDNlODc5NWRmYzQ3ZjdlZjZkZjZfWlZkRUxXbDJmYjdQSjhDVjN0Q29NMnpOWFB4UURNRDFfVG9rZW46UUZiQWJEdlZHb3c5RVd4RGFkOWNvc1lFbjhmXzE3MTU1MTEyMTg6MTcxNTUxNDgxOF9WNA" alt="img"></p><p>1）用户输入条件<code>&quot;华为手机&quot;</code>进行搜索。</p><p>2）对用户输入条件分词，得到词条：<code>华为</code>、<code>手机</code></p><p>3）拿着词条在倒排索引中查找（由于词条有索引，查询效率很高），即可得到包含词条的文档id：<code>1、2、3</code></p><p>4）拿着文档<code>id</code>到正向索引中查找具体文档即可（由于<code>id</code>也有索引，查询效率也很高）</p><h3 id="正向和倒排的优缺点"><a href="#正向和倒排的优缺点" class="headerlink" title="正向和倒排的优缺点"></a>正向和倒排的优缺点</h3><p><strong>正向索引</strong>：</p><ul><li>优点： <ul><li>可以给多个字段创建索引</li><li>根据索引字段搜索、排序速度非常快</li></ul></li><li>缺点： <ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul></li></ul><p><strong>倒排索引</strong>：</p><ul><li>优点： <ul><li>根据词条搜索、模糊搜索时，速度非常快</li></ul></li><li>缺点： <ul><li>只能给词条创建索引，而不是字段</li><li>无法根据字段做排序</li></ul></li></ul><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p><h3 id="文档和字段"><a href="#文档和字段" class="headerlink" title="文档和字段"></a>文档和字段</h3><p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为<code>json</code>格式后存储在<code>elasticsearch</code>中：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小米手机&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">3499</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华为手机&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">4999</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华为小米充电器&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">49</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小米手环&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">299</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>因此，原本数据库中的一行数据就是ES中的一个JSON文档；而数据库中每行数据都包含很多列，这些列就转换为JSON文档中的<strong>字段（Field）</strong>。</p><h3 id="索引和映射"><a href="#索引和映射" class="headerlink" title="索引和映射"></a>索引和映射</h3><p>随着业务发展，需要在es中存储的文档也会越来越多，比如有商品的文档、用户的文档、订单文档等等，后期将类型相同的文档集中在一起管理，称为<strong>索引（Index）</strong>。</p><p>例如：</p><ul><li>所有用户文档，就可以组织在一起，称为用户的索引</li><li>所有商品的文档，可以组织在一起，称为商品的索引</li><li>所有订单的文档，可以组织在一起，称为订单的索引</li></ul><p>可以把索引当做是数据库中的表。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p><h3 id="mysql与elasticsearch"><a href="#mysql与elasticsearch" class="headerlink" title="mysql与elasticsearch"></a>mysql与elasticsearch</h3><table><thead><tr><th align="left"><strong>MySQL</strong></th><th align="left"><strong>Elasticsearch</strong></th><th align="left"><strong>说明</strong></th></tr></thead><tbody><tr><td align="left">Table</td><td align="left">Index</td><td align="left">索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td align="left">Row</td><td align="left">Document</td><td align="left">文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td align="left">Column</td><td align="left">Field</td><td align="left">字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td align="left">Schema</td><td align="left">Mapping</td><td align="left">Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td align="left">SQL</td><td align="left">DSL</td><td align="left">DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><ul><li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性 </li><li>Elasticsearch：擅长海量数据的搜索、分析、计算</li></ul><p>项目中往往两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><h2 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h2><p>Elasticsearch的关键就是倒排索引，而倒排索引依赖于对文档内容的分词，而分词则需要高效、精准的分词算法，IK分词器就是这样的中文分词算法。</p><h3 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h3><p>运行命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it es ./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip</span><br></pre></td></tr></table></figure><p>重启es容器：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart es</span><br></pre></td></tr></table></figure><h3 id="使用IK分词器"><a href="#使用IK分词器" class="headerlink" title="使用IK分词器"></a>使用IK分词器</h3><p>IK分词器包含两种模式：</p><ul><li><code>ik_smart</code>——智能语义切分：可以在词典库中识别词语，将句子分成一个个词语</li><li><code>ik_max_word</code>——最细粒度切分：除了将句子分成一个个词语之外，还分出一个个字，便于精确查找</li></ul><h3 id="拓展词典"><a href="#拓展词典" class="headerlink" title="拓展词典"></a>拓展词典</h3><p>互联网发展伴随着越来越多的新词语，而这些新词语在ik分词器的原始词典中并不存在，所以要想正确分词，词库也需要不断的更新，所以分词器提供了扩展词汇的功能。</p><p>1）打开IK分词器config目录</p><p>注意：如果ik插件下没有config目录，要么自己手动创建<code>config目录</code>和<code>IKAnalyzer.cfg.xml</code>文件，要么<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">需要下载复制到服务器中</a></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-v7.12.1.zip</span><br></pre></td></tr></table></figure><p>2）在IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）在IK分词器的config目录新建一个 <code>ext.dic</code>，在其中写入想要扩展的词汇</p><p>4）重启elasticsearch</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart es</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 日志</span></span><br><span class="line">docker logs -f elasticsearch</span><br></pre></td></tr></table></figure><h1 id="索引库操作"><a href="#索引库操作" class="headerlink" title="索引库操作"></a>索引库操作</h1><p>Index就类似数据库表，Mapping映射就类似表的结构。我们要向es中存储数据，必须先创建Index和Mapping</p><h2 id="Mapping映射属性"><a href="#Mapping映射属性" class="headerlink" title="Mapping映射属性"></a>Mapping映射属性</h2><p>Mapping是对索引库中文档的约束，常见的Mapping属性包括：</p><ul><li><code>type</code>：字段数据类型，常见的简单类型有： <ul><li>字符串：<code>text</code>（可分词的文本）、<code>keyword</code>（精确值，例如：品牌、国家、ip地址）</li><li>数值：<code>long</code>、<code>integer</code>、<code>short</code>、<code>byte</code>、<code>double</code>、<code>float</code>、</li><li>布尔：<code>boolean</code></li><li>日期：<code>date</code></li><li>对象：<code>object</code></li></ul></li><li><code>index</code>：是否创建索引，默认为<code>true</code></li><li><code>analyzer</code>：使用哪种分词器</li><li><code>properties</code>：该字段的子字段</li></ul><p>例如下面的json文档：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">52.1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isMarried&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;某某高校某某年级学生&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xxxx111@qq.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;score&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">99.1</span><span class="punctuation">,</span> <span class="number">99.5</span><span class="punctuation">,</span> <span class="number">98.9</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;祈&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;楪&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>对应的每个字段映射（Mapping）：</p><table><thead><tr><th align="left">字段名</th><th align="left">字段类型</th><th align="left">类型说明</th><th align="left">是否参与搜索</th><th align="left">是否参与分词</th><th align="left">分词器</th></tr></thead><tbody><tr><td align="left">age</td><td align="left"><code>integer</code></td><td align="left">整数</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">weight</td><td align="left"><code>float</code></td><td align="left">浮点数</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">isMarried</td><td align="left"><code>boolean</code></td><td align="left">布尔</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">info</td><td align="left"><code>text</code></td><td align="left">字符串，需要分词</td><td align="left">是</td><td align="left">是</td><td align="left">IK</td></tr><tr><td align="left">email</td><td align="left"><code>keyword</code></td><td align="left">字符串，但是不分词</td><td align="left">否</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">score</td><td align="left"><code>float</code></td><td align="left">只看数组中元素类型</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">firstName</td><td align="left"><code>keyword</code></td><td align="left">字符串，但是不分词</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr><tr><td align="left">lastName</td><td align="left"><code>keyword</code></td><td align="left">字符串，但是不分词</td><td align="left">是</td><td align="left">否</td><td align="left">——</td></tr></tbody></table><h2 id="索引库的CRUD"><a href="#索引库的CRUD" class="headerlink" title="索引库的CRUD"></a>索引库的CRUD</h2><p>由于Elasticsearch采用的是Restful风格的API，因此其请求方式和路径相对都比较规范，而且请求参数也都采用JSON风格。</p><h3 id="创建索引库和映射"><a href="#创建索引库和映射" class="headerlink" title="创建索引库和映射"></a>创建索引库和映射</h3><p><strong>基本语法</strong>：</p><ul><li>请求方式：<code>PUT</code></li><li>请求路径：<code>/索引库名</code>，可以自定义</li><li>请求参数：<code>mapping</code>映射</li></ul><p><strong>格式</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;子字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="查询索引库"><a href="#查询索引库" class="headerlink" title="查询索引库"></a>查询索引库</h3><p><strong>基本语法</strong>：</p><ul><li>请求方式：GET </li><li>请求路径：&#x2F;索引库名 </li><li>请求参数：无</li></ul><p><strong>格式</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><h3 id="修改索引库"><a href="#修改索引库" class="headerlink" title="修改索引库"></a>修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p><p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。因此修改索引库能做的就是向索引库中添加新字段，或者更新索引库的基础属性。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="删除索引库"><a href="#删除索引库" class="headerlink" title="删除索引库"></a>删除索引库</h3><p><strong>语法：</strong></p><ul><li>请求方式：DELETE </li><li>请求路径：&#x2F;索引库名 </li><li>请求参数：无</li></ul><p><strong>格式：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure><h1 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h1><h2 id="新增文档"><a href="#新增文档" class="headerlink" title="新增文档"></a>新增文档</h2><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h2><p>根据rest风格，新增是post，查询是get，需在后面加上文档id。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_doc/id</span><br></pre></td></tr></table></figure><h2 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><p><strong>语法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable constant_">DELETE</span> /索引库名/_doc/id</span><br></pre></td></tr></table></figure><h2 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h2><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>局部修改：修改文档中的部分字段</li></ul><h3 id="全量修改"><a href="#全量修改" class="headerlink" title="全量修改"></a>全量修改</h3><p>语法与新增文档相同，全量修改是覆盖原来的文档，其本质是两步操作：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="局部修改"><a href="#局部修改" class="headerlink" title="局部修改"></a>局部修改</h3><p>局部修改是只修改指定id匹配的文档中的部分字段。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;新的值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h2><p>批处理采用POST请求，基本语法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; <span class="string">&quot;index&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value1&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;delete&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;create&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value3&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;update&quot;</span> : &#123;<span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>, <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>&#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;doc&quot;</span> : &#123;<span class="string">&quot;field2&quot;</span> : <span class="string">&quot;value2&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>index</code>代表新增操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li><li><code>&#123; &quot;field1&quot; : &quot;value1&quot; &#125;</code>：则是要新增的文档内容</li></ul></li><li><code>delete</code>代表删除操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li></ul></li><li><code>update</code>代表更新操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li><li><code>&#123; &quot;doc&quot; : &#123;&quot;field2&quot; : &quot;value2&quot;&#125; &#125;</code>：要更新的文档字段</li></ul></li></ul><h1 id="RestAPI"><a href="#RestAPI" class="headerlink" title="RestAPI"></a>RestAPI</h1><p><a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">ES官方</a>提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES</p><h2 id="初始化RestClient"><a href="#初始化RestClient" class="headerlink" title="初始化RestClient"></a>初始化RestClient</h2><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为<code>RestHighLevelClient</code>的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接</p><p>1）引入<code>es</code>的<code>RestHighLevelClient</code>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）因为SpringBoot默认的ES版本是<code>7.17.10</code>，需要覆盖默认的ES版本：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3）初始化RestHighLevelClient：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://ip地址:9200&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>这里为了单元测试方便，我们创建一个测试类<code>IndexTest</code>，然后将初始化的代码编写在<code>@BeforeEach</code>方法中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IndexTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">&quot;http://192.168.145.128:9200&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testConnect</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建索引库"><a href="#创建索引库" class="headerlink" title="创建索引库"></a>创建索引库</h2><p>由于要实现对商品搜索，所以需要将商品添加到Elasticsearch中，不过需要根据搜索业务的需求来设定索引库结构，而不是一股脑的把MySQL数据写入Elasticsearch</p><h3 id="Mapping映射"><a href="#Mapping映射" class="headerlink" title="Mapping映射"></a>Mapping映射</h3><p>实现搜索功能需要的字段包括三大部分：</p><ul><li>搜索过滤字段<ul><li>分类</li><li>品牌</li><li>价格</li></ul></li><li>排序字段<ul><li>默认：按照更新时间降序排序</li><li>销量</li><li>价格</li></ul></li><li>展示字段<ul><li>商品id：用于点击后跳转</li><li>图片地址</li><li>是否是广告推广商品</li><li>名称</li><li>价格</li><li>评价数量</li><li>销量</li></ul></li></ul><p>结合数据库表结构，以上字段对应的mapping映射属性如下：</p><table><thead><tr><th>字段名</th><th>字段类型</th><th>类型说明</th><th>是否参与搜索</th><th>是否参与分词</th><th>分词器</th></tr></thead><tbody><tr><td>id</td><td><code>long</code></td><td>长整数</td><td>是</td><td>否</td><td>——</td></tr><tr><td>name</td><td><code>text</code></td><td>字符串，参与分词搜索</td><td>是</td><td>是</td><td>IK</td></tr><tr><td>price</td><td><code>integer</code></td><td>以分为单位，所以是整数</td><td>是</td><td>否</td><td>——</td></tr><tr><td>stock</td><td><code>integer</code></td><td>字符串，但需要分词</td><td>是</td><td>否</td><td>——</td></tr><tr><td>image</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>否</td><td>否</td><td>——</td></tr><tr><td>category</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>是</td><td>否</td><td>——</td></tr><tr><td>brand</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>是</td><td>否</td><td>——</td></tr><tr><td>sold</td><td><code>integer</code></td><td>销量，整数</td><td>是</td><td>否</td><td>——</td></tr><tr><td>commentCount</td><td><code>integer</code></td><td>评价，整数</td><td>否</td><td>否</td><td>——</td></tr><tr><td>isAD</td><td><code>boolean</code></td><td>布尔类型</td><td>是</td><td>否</td><td>——</td></tr><tr><td>updateTime</td><td><code>Date</code></td><td>更新时间</td><td>是</td><td>否</td><td>——</td></tr></tbody></table><p>最终索引库文档结构应该是这样：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /items</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sold&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;commentCount&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isAD&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;boolean&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>分为三步：</p><p>1）创建Request对象。因为是创建索引库的操作，因此Request是<code>CreateIndexRequest</code></p><p>2）添加请求参数。Json格式的Mapping映射参数</p><p>3）发送请求。<code>client.indices()</code>方法的返回值是<code>IndicesClient</code>类型，封装了所有与索引库操作有关的方法。例如创建索引、删除索引、判断索引是否存在等</p><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPING_TEMPLATE</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;stock\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;image\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;category\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;sold\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;commentCount\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;isAD\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;boolean\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;updateTime\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;date\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="删除索引库-1"><a href="#删除索引库-1" class="headerlink" title="删除索引库"></a>删除索引库</h2><p>与创建索引库相比：</p><ul><li>请求方式从PUT变为DELTE</li><li>请求路径不变</li><li>无请求参数</li></ul><p>所以代码的差异，注意体现在Request对象上。流程如下：</p><p>1）创建Request对象。DeleteIndexRequest对象</p><p>2）准备参数。省略</p><p>3）发送请求。delete方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断索引库是否存在"><a href="#判断索引库是否存在" class="headerlink" title="判断索引库是否存在"></a>判断索引库是否存在</h2><p>判断索引库是否存在，本质就是查询，对应的请求语句是：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /hotel</span><br></pre></td></tr></table></figure><p>因此与删除的Java代码流程是类似的，流程如下：</p><p>1）创建Request对象。GetIndexRequest对象</p><p>2）准备参数。省略</p><p>3）发送请求。exists方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistsIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    System.err.println(exists ? <span class="string">&quot;索引库已经存在！&quot;</span> : <span class="string">&quot;索引库不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaRestClient操作elasticsearch的流程基本类似。核心是<code>client.indices()</code>方法来获取索引库的操作对象。</p><p>索引库操作的基本步骤：</p><ul><li>初始化<code>RestHighLevelClient</code></li><li>创建XxxIndexRequest。XXX是<code>Create</code>、<code>Get</code>、<code>Delete</code></li><li>准备请求参数（<code>Create</code>时需要，其它是无参，可以省略）</li><li>发送请求。调用<code>RestHighLevelClient#indices().xxx()</code>方法，xxx是<code>create</code>、<code>exists</code>、<code>delete</code></li></ul><h1 id="RestClient操作文档"><a href="#RestClient操作文档" class="headerlink" title="RestClient操作文档"></a>RestClient操作文档</h1><h2 id="新增文档-1"><a href="#新增文档-1" class="headerlink" title="新增文档"></a>新增文档</h2><p>新增文档的请求语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>1）创建Request对象，这里是<code>IndexRequest</code>，因为添加文档就是创建倒排索引的过程</p><p>2）准备请求参数，本例中就是Json文档</p><p>3）发送请求</p><p>这里直接使用<code>client.xxx()</code>的API</p><p>整体步骤为：</p><ul><li>1）根据id查询商品数据<code>Item</code></li><li>2）将<code>Item</code>封装为<code>ItemDoc</code></li><li>3）将<code>ItemDoc</code>序列化为JSON</li><li>4）创建IndexRequest，指定索引库名和id</li><li>5）准备请求参数，也就是JSON文档</li><li>6）发送请求</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.根据id查询商品数据</span></span><br><span class="line">    <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> itemService.getById(<span class="number">100002644680L</span>);</span><br><span class="line">    <span class="comment">// 2.转换为文档类型</span></span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class);</span><br><span class="line">    <span class="comment">// 3.将ItemDTO转json</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">doc</span> <span class="operator">=</span> JSONUtil.toJsonStr(itemDoc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(itemDoc.getId());</span><br><span class="line">    <span class="comment">// 2.准备Json文档</span></span><br><span class="line">    request.source(doc, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询文档-1"><a href="#查询文档-1" class="headerlink" title="查询文档"></a>查询文档</h2><p>查询的请求语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /索引库名/_doc/id</span><br></pre></td></tr></table></figure><ul><li>创建Request对象</li><li>发送请求</li></ul><p>流程如下：</p><p>1）准备Request对象。这次是查询，所以是<code>GetRequest</code></p><p>2）发送请求，得到结果。因为是查询，这里调用<code>client.get()</code>方法</p><p>3）解析结果，对JSON做反序列化</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.获取响应结果中的source</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.getSourceAsString();</span><br><span class="line">    </span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> JSONUtil.toBean(json, ItemDoc.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;itemDoc= &quot;</span> + ItemDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除文档-1"><a href="#删除文档-1" class="headerlink" title="删除文档"></a>删除文档</h2><p>删除的请求语句如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /hotel/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与查询相比，仅仅是请求方式从<code>DELETE</code>变成<code>GET</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request，两个参数，第一个是索引库名，第二个是文档id</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;item&quot;</span>, <span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改文档-1"><a href="#修改文档-1" class="headerlink" title="修改文档"></a>修改文档</h2><p>有两种方式：</p><ul><li>全量修改：本质是先根据id删除，再新增</li><li>局部修改：修改文档中的指定字段值</li></ul><p>在RestClient的API中，全量修改与新增的API完全一致。</p><p>局部修改的请求语法如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /索引库名/_update/id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;字段值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;字段值&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>1）准备<code>Request</code>对象。这次是修改，所以是<code>UpdateRequest</code></p><p>2）准备参数。也就是JSON文档，里面包含要修改的字段</p><p>3）更新文档。这里调用<code>client.update()</code>方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;items&quot;</span>, <span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">            <span class="string">&quot;price&quot;</span>, <span class="number">58800</span>,</span><br><span class="line">            <span class="string">&quot;commentCount&quot;</span>, <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="批量导入文档"><a href="#批量导入文档" class="headerlink" title="批量导入文档"></a>批量导入文档</h2><p>如果要将大量数据导入索引库，肯定不能逐条导入，而是采用批处理方案。常见的方案有：</p><ul><li>利用Logstash批量导入<ul><li>需要安装Logstash</li><li>对数据的再加工能力较弱</li><li>无需编码</li></ul></li><li>利用JavaAPI批量导入<ul><li>需要编码，但基于JavaAPI，学习成本低</li><li>更加灵活，可以任意对数据做再加工处理后写入索引库</li></ul></li></ul><p>在这里使用JavaAPI导入。</p><h3 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h3><p>批处理与前面讲的文档的CRUD步骤基本一致：</p><ul><li>创建Request，这次用的是<code>BulkRequest</code></li><li>准备请求参数</li><li>发送请求，用到<code>client.bulk()</code>方法</li></ul><p><code>BulkRequest</code>本身其实并没有请求参数，其本质就是将多个普通的CRUD请求组合在一起发送。例如：</p><ul><li>批量新增文档，就是给每个文档创建一个<code>IndexRequest</code>请求，然后封装到<code>BulkRequest</code>中，一起发出。</li><li>批量删除，就是创建N个<code>DeleteRequest</code>请求，然后封装到<code>BulkRequest</code>，一起发出</li></ul><p>因此<code>BulkRequest</code>中提供了<code>add</code>方法，用以添加其它CRUD的请求：</p><p><img src="D:\Blog\source\img\es_bulk.png" alt="es_bulk"></p><p>能添加的请求有：</p><ul><li><code>IndexRequest</code></li><li><code>UpdateRequest</code></li><li><code>DeleteRequest</code></li></ul><p>因此Bulk中添加了多个<code>IndexRequest</code>，就是批量新增功能了。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulk</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;1&quot;</span>).source(<span class="string">&quot;json doc1&quot;</span>, XContentType.JSON));</span><br><span class="line">    request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;2&quot;</span>).source(<span class="string">&quot;json doc2&quot;</span>, XContentType.JSON));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>文档操作的基本步骤：</p><ul><li>初始化<code>RestHighLevelClient</code></li><li>创建XxxRequest。<ul><li>XXX是<code>Index</code>、<code>Get</code>、<code>Update</code>、<code>Delete</code>、<code>Bulk</code></li></ul></li><li>准备参数（<code>Index</code>、<code>Update</code>、<code>Bulk</code>时需要）</li><li>发送请求。<ul><li>调用<code>RestHighLevelClient#.xxx()</code>方法，xxx是<code>index</code>、<code>get</code>、<code>update</code>、<code>delete</code>、<code>bulk</code></li></ul></li><li>解析结果（<code>Get</code>时需要）</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/elasticsearch/">elasticsearch</category>
      
      
      <category domain="http://example.com/tags/elasticsearch/">elasticsearch</category>
      
      
      <comments>http://example.com/inori/d672aa30.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringCloud微服务入门(一)</title>
      <link>http://example.com/inori/37b2c0e7.html</link>
      <guid>http://example.com/inori/37b2c0e7.html</guid>
      <pubDate>Sun, 12 May 2024 04:26:50 GMT</pubDate>
      
      <description>SpringCloud</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="微服务基础知识"><a href="#微服务基础知识" class="headerlink" title="微服务基础知识"></a>微服务基础知识</h1><h2 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h2><h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><p>单体架构（monolithic structure）即整个项目中所有功能模块都在一个工程中开发。项目部署时需要对所有模块一起编译、打包。项目的架构设计、开发模式都相对简单。</p><p>当项目规模较小时，这种模式上手快，部署、运维也都很方便，因此早期很多小型项目都采用这种模式。</p><p>但随着项目的业务规模越来越大，团队开发人员也不断增加，单体架构就呈现出越来越多的问题：</p><ul><li><strong>团队协作成本高</strong>：团队数十个人同时协作开发同一个项目，由于所有模块都在一个项目中，不同模块的代码之间物理边界越来越模糊。</li><li><strong>系统发布效率低</strong>：任何模块变更都需要发布整个系统，而系统发布过程中需要多个模块之间制约较多，需要对比各种文件，任何一处出现问题都会导致发布失败，往往一次发布需要数十分钟甚至数小时。</li><li><strong>系统可用性差</strong>：单体架构各个功能模块是作为一个服务部署，相互之间会互相影响，一些热点功能会耗尽系统资源，导致其它服务低可用。</li></ul><p>要想解决这些问题，就需要使用微服务架构。</p><h3 id="从单体架构到微服务"><a href="#从单体架构到微服务" class="headerlink" title="从单体架构到微服务"></a>从单体架构到微服务</h3><p>微服务架构，首先是服务化，就是将单体架构中的功能模块从单体应用中拆分出来，独立部署为多个服务。同时要满足下面的一些特点：</p><ul><li><strong>单一职责</strong>：一个微服务负责一部分业务功能，并且其核心数据不依赖于其它模块</li><li><strong>团队自治</strong>：每个微服务都有自己独立的开发、测试、发布、运维人员，团队人员规模较小</li><li><strong>服务自治</strong>：每个微服务都独立打包部署，访问自己独立的数据库。并且要做好服务隔离，避免对其它服务产生影响</li></ul><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><p>SpringCloud框架是目前Java领域最全面的微服务组件的集合。它依托于SpringBoot的自动装配能力，降低了其项目搭建、组件使用的成本。</p><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><p>不同的微服务虽然功能不同，但因为还是同一个项目，或多或少会出现互相调用的情况。但不同的微服务都是不同的项目，不能使用Spring的自动装配，这时就需要服务之间发送Http请求去获取数据。</p><h4 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h4><p>Spring提供了一个RestTemplate的API，可以方便的实现Http请求的发送。其中提供了大量的方法，方便发送Http请求</p><p><img src="D:\Blog\source\img\resttemplate.png" alt="resttemplate"></p><p>常见的Get、Post、Put、Delete请求都支持，如果请求参数比较复杂，还可以使用exchange方法来构造请求。</p><h5 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h5><p>先将RestTemplate注册为一个Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteCallConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用RestTemplate发送请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.获取商品id</span></span><br><span class="line">    Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">// 2.查询商品</span></span><br><span class="line">    <span class="comment">// 利用RestTemplate发起http请求，得到http的响应</span></span><br><span class="line">    ResponseEntity&lt;List&lt;ItemDTO&gt;&gt; response = restTemplate.exchange(</span><br><span class="line">            <span class="string">&quot;http://localhost:8081/items?ids=&#123;ids&#125;&quot;</span>,<span class="comment">// 请求路径</span></span><br><span class="line">            HttpMethod.GET,<span class="comment">// 请求方式</span></span><br><span class="line">            <span class="literal">null</span>, <span class="comment">// 请求实体</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ParameterizedTypeReference</span>&lt;List&lt;ItemDTO&gt;&gt;() &#123;&#125;,<span class="comment">// 返回值类型</span></span><br><span class="line">            Map.of(<span class="string">&quot;ids&quot;</span>, CollUtil.join(itemIds, <span class="string">&quot;,&quot;</span>))<span class="comment">// 请求参数</span></span><br><span class="line">    );</span><br><span class="line">    List&lt;ItemDTO&gt; items = response.getBody();<span class="comment">// 获取返回值</span></span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，利用RestTemplate发送http请求与前端ajax发送请求非常相似，都包含四部分信息：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>在这个过程中，<code>item-service</code>提供了查询接口，<code>cart-service</code>利用Http请求调用该接口。因此<code>item-service</code>可以称为服务的提供者，而<code>cart-service</code>则称为服务的消费者或服务调用者。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>服务拆分之后，不可避免的会出现跨微服务的业务，此时微服务之间就需要进行远程调用。微服务之间的远程调用被称为RPC，即远程过程调用。RPC的实现方式有很多，比如：</p><ul><li>基于Http协议</li><li>基于Dubbo协议</li></ul><p>这里使用的是Http方式，这种方式不关心服务提供者的具体技术实现，只要对外暴露Http接口即可。</p><p>Java发送http请求可以使用Spring提供的RestTemplate，使用的基本步骤如下：</p><ul><li>注册RestTemplate到Spring容器</li><li>调用RestTemplate的API发送请求，常见方法有：<ul><li>getForObject：发送Get请求并返回指定类型对象</li><li>PostForObject：发送Post请求并返回指定类型对象</li><li>put：发送PUT请求</li><li>delete：发送Delete请求</li><li>exchange：发送任意类型请求，返回ResponseEntity</li></ul></li></ul><h2 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h2><p>上面通过Http请求实现了跨微服务的远程调用，不过这种手动发送Http请求的方式存在一些问题。</p><p>试想一下，假如商品微服务被调用较多，为了应对更高的并发，进行了多实例部署，一个微服务对应多个ip地址或端口</p><p>此时，每个service的实例其IP或端口不同，问题来了：</p><ul><li>service这么多实例，其他服务如何知道每一个实例的地址？</li><li>http请求要写url地址，其他服务到底该调用哪个实例？</li><li>如果在运行过程中，该服务实例宕机，其他服务依然在调用该怎么办？</li><li>如果并发太高，该服务临时多部署了N台实例，其他服务如何知道新实例的地址？</li></ul><p>为了解决上述问题，就必须引入注册中心的概念。</p><p>为了解决上述问题，就必须引入注册中心的概念了，接下来我们就一起来分析下注册中心的原理。</p><h3 id="注册中心原理"><a href="#注册中心原理" class="headerlink" title="注册中心原理"></a>注册中心原理</h3><p>在微服务远程调用的过程中，包括两个角色：</p><ul><li>服务提供者：提供接口供其它微服务访问</li><li>服务消费者：调用其它微服务提供的接口</li></ul><p>在大型微服务项目中，服务提供者的数量会非常多，为了管理这些服务就引入了<strong>注册中心</strong>的概念。注册中心、服务提供者、服务消费者三者间关系如下：</p><p><img src="D:\Blog\source\img\log_center.jpg" alt="log_center"></p><p>流程如下：</p><ul><li>服务启动时就会注册自己的服务信息（服务名、IP、端口）到注册中心</li><li>调用者可以从注册中心订阅想要的服务，获取服务对应的实例列表（1个服务可能多实例部署）</li><li>调用者自己对实例列表负载均衡，挑选一个实例</li><li>调用者向该实例发起远程调用</li></ul><p>当服务提供者的实例宕机或者启动新实例时，调用者如何得知呢？</p><ul><li>服务提供者会定期向注册中心发送请求，报告自己的健康状态（心跳请求）</li><li>当注册中心长时间收不到提供者的心跳时，会认为该实例宕机，将其从服务的实例列表中剔除</li><li>当服务有新实例启动时，会发送注册服务请求，其信息会被记录在注册中心的服务实例列表</li><li>当注册中心服务列表变更时，会主动通知微服务，更新本地服务列表</li></ul><h3 id="Nacos注册中心"><a href="#Nacos注册中心" class="headerlink" title="Nacos注册中心"></a>Nacos注册中心</h3><p>目前开源的注册中心框架有很多，比较常见的有：</p><ul><li>Eureka：Netflix公司出品，目前被集成在SpringCloud当中，一般用于Java应用</li><li>Nacos：Alibaba公司出品，目前被集成在SpringCloudAlibaba中，一般用于Java应用</li><li>Consul：HashiCorp公司出品，目前集成在SpringCloud中，不限制微服务语言</li></ul><p>以上几种注册中心都遵循SpringCloud中的API规范，因此在业务开发使用上没有太大差异，这里学习<a href="https://nacos.io/">Nacos</a></p><h4 id="安装nacos"><a href="#安装nacos" class="headerlink" title="安装nacos"></a>安装nacos</h4><p>首先要准备MySQL数据库表，用来存储Nacos的数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 导出 nacos 的数据库结构</span></span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> `nacos`;</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `nacos` <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci */</span> <span class="comment">/*!80016 DEFAULT ENCRYPTION=&#x27;N&#x27; */</span>;</span><br><span class="line">USE `nacos`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_aggr 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_aggr`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_aggr 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_aggr`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_beta 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_beta`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_beta 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_beta`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_info_tag 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_info_tag`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_info_tag 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_info_tag`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.config_tags_relation 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `config_tags_relation`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.config_tags_relation 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `config_tags_relation`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.group_capacity 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `group_capacity`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.group_capacity 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `group_capacity`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.his_config_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `his_config_info`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text <span class="keyword">COLLATE</span> utf8_bin,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.his_config_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `his_config_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.permissions 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `permissions`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `permissions` (</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.permissions 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `permissions`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.roles 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `roles`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `roles` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `idx_user_role` (`username`,`role`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.roles 的数据：~1 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `roles`;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `roles` (`username`, `role`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.tenant_capacity 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tenant_capacity`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.tenant_capacity 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `tenant_capacity`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.tenant_info 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `tenant_info`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">COLLATE</span> utf8_bin <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.tenant_info 的数据：~0 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `tenant_info`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 导出  表 nacos.users 结构</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `users`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `users` (</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">COLLATE</span> utf8mb4_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `enabled` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`username`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正在导出表  nacos.users 的数据：~1 rows (大约)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `users`;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `users` (`username`, `password`, `enabled`) <span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>然后需要配置环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PREFER_HOST_MODE=hostname</span><br><span class="line">MODE=standalone</span><br><span class="line">SPRING_DATASOURCE_PLATFORM=mysql</span><br><span class="line">MYSQL_SERVICE_HOST=192.168.145.128# 改成自己的IP地址</span><br><span class="line">MYSQL_SERVICE_DB_NAME=nacos</span><br><span class="line">MYSQL_SERVICE_PORT=3306</span><br><span class="line">MYSQL_SERVICE_USER=root</span><br><span class="line">MYSQL_SERVICE_PASSWORD=123</span><br><span class="line">MYSQL_SERVICE_DB_PARAM=characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure><p>进入root目录，执行docker命令：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line"><span class="literal">--name</span> nacos \</span><br><span class="line"><span class="literal">--env-file</span> ./nacos/custom.env \</span><br><span class="line"><span class="literal">-p</span> <span class="number">8848</span>:<span class="number">8848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9848</span>:<span class="number">9848</span> \</span><br><span class="line"><span class="literal">-p</span> <span class="number">9849</span>:<span class="number">9849</span> \</span><br><span class="line"><span class="literal">--restart</span>=always \</span><br><span class="line">nacos/nacos<span class="literal">-server</span>:v2.<span class="number">1.0</span><span class="literal">-slim</span></span><br></pre></td></tr></table></figure><p>启动完成后，访问下面地址：<code>http://ip地址/nacos/</code></p><p>首次访问会跳转到登录页，账号密码都是nacos</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>接下来，把service注册到Nacos</p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>在<code>pom.xml</code>中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置Nacos"><a href="#配置Nacos" class="headerlink" title="配置Nacos"></a>配置Nacos</h4><p>在<code>application.yml</code>中添加nacos地址配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">item-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span><span class="string">:8848</span> <span class="comment"># nacos地址</span></span><br></pre></td></tr></table></figure><p>启动服务实例后访问nacos控制台，可以发现服务注册成功</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>服务的消费者要去nacos订阅服务，这个过程就是服务发现</p><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>服务发现除了要引入nacos依赖以外，由于还需要负载均衡，因此要引入SpringCloud提供的LoadBalancer依赖。</p><p>在<code>pom.xml</code>中添加依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos 服务注册发现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以发现，这里Nacos的依赖于服务注册时一致，这个依赖中同时包含了服务注册和发现的功能。因为任何一个微服务都可以调用别人，也可以被别人调用，即可以是调用者，也可以是提供者。</p><h4 id="配置Nacos地址"><a href="#配置Nacos地址" class="headerlink" title="配置Nacos地址"></a>配置Nacos地址</h4><p>在<code>application.yml</code>中添加nacos地址配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><p>####发现并调用服务</p><p>接下来，服务调用者就可以去订阅已经在Nacos注册过的服务了。不过因为服务可能有多个实例，而真正发起调用时只需要知道一个实例的地址。</p><p>因此，服务调用者必须利用负载均衡的算法，从多个实例中挑选一个去访问。常见的负载均衡算法有：</p><ul><li>随机</li><li>轮询</li><li>IPHash</li><li>最近最少访问</li><li>…</li></ul><h2 id="OpenFeign"><a href="#OpenFeign" class="headerlink" title="OpenFeign"></a>OpenFeign</h2><p>上面利用Nacos实现了服务的治理，利用RestTemplate实现了服务的远程调用。但是远程调用的代码太复杂了。</p><p>而且这种调用方式，与原本的本地方法调用差异太大，编程时的体验也不统一，一会儿远程调用，一会儿本地调用。</p><p>因此，必须想办法改变远程调用的开发模式，让<strong>远程调用像本地方法调用一样简单</strong>。而这就要用到OpenFeign组件了。</p><p>其实远程调用的关键点就在于四个：</p><ul><li>请求方式</li><li>请求路径</li><li>请求参数</li><li>返回值类型</li></ul><p>所以，OpenFeign就利用SpringMVC的相关注解来声明上述4个参数，然后基于动态代理帮我们生成远程调用的代码，而无需我们手动再编写，非常方便。</p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h4 id="引入依赖-1"><a href="#引入依赖-1" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在服务调用者的<code>pom.xml</code>中引入<code>OpenFeign</code>的依赖和<code>loadBalancer</code>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--负载均衡器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="启用OpenFeign"><a href="#启用OpenFeign" class="headerlink" title="启用OpenFeign"></a>启用OpenFeign</h4><p>在启动类上添加注解，启动OpenFeign功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span><span class="comment">// 启动OpenFeign</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;...&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        SpringApplication.run(CartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写OpenFeign客户端"><a href="#编写OpenFeign客户端" class="headerlink" title="编写OpenFeign客户端"></a>编写OpenFeign客户端</h4><p>定义一个新的接口，编写Feign客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;item-service&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ItemClient</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/items&quot;)</span></span><br><span class="line">    List&lt;ItemDTO&gt; <span class="title function_">queryItemByIds</span><span class="params">(<span class="meta">@RequestParam(&quot;ids&quot;)</span> Collection&lt;Long&gt; ids)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只需要声明接口，无需实现方法。接口中的几个关键信息：</p><ul><li><code>@FeignClient(&quot;&quot;)</code> ：声明服务名称</li><li><code>@GetMapping</code> ：声明请求方式</li><li><code>@GetMapping(&quot;&quot;)</code> ：声明请求路径</li><li><code>@RequestParam(&quot;ids&quot;) Collection&lt;Long&gt; ids</code> ：声明请求参数</li><li><code>List&lt;ItemDTO&gt;</code> ：返回值类型</li></ul><p>有了上述信息，OpenFeign就可以利用动态代理帮我们实现这个方法，并且向<code>http://item-service/items</code>发送一个<code>GET</code>请求，携带ids为请求参数，并自动将返回值处理为<code>List&lt;ItemDTO&gt;</code>。</p><p>我们只需要直接调用这个方法，即可实现远程调用了。</p><h4 id="使用FeignClient"><a href="#使用FeignClient" class="headerlink" title="使用FeignClient"></a>使用FeignClient</h4><p>最后在服务调用者的调用<code>ItemClient</code>的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;CartMapper, Cart&gt; <span class="keyword">implements</span> <span class="title class_">ICartService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ItemClient itemClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleCartItems</span><span class="params">(List&lt;CartVO&gt; vos)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.获取商品id</span></span><br><span class="line">        Set&lt;Long&gt; itemIds = vos.stream().map(CartVO::getItemId).collect(Collectors.toSet());</span><br><span class="line">        <span class="comment">// 2.查询商品: 使用feign远程调用</span></span><br><span class="line">        List&lt;ItemDTO&gt; items = itemClient.queryItemByIds(itemIds);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>feign完成了服务拉取、负载均衡、发送http请求的所有工作，不再需要RestTemplate了，还省去了RestTemplate的注册</p><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>Feign底层发起http请求，依赖于其它的框架。其底层支持的http客户端实现包括：</p><ul><li>HttpURLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此我们通常会使用带有连接池的客户端来代替默认的HttpURLConnection。比如，使用OKHttp</p><h4 id="引入依赖-2"><a href="#引入依赖-2" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--OK http 的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开启连接池"><a href="#开启连接池" class="headerlink" title="开启连接池"></a>开启连接池</h4><p>在<code>application.yml</code>中开启Feign的连接池功能：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp功能</span></span><br></pre></td></tr></table></figure><p>重启服务，连接池就生效了。</p><h1 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h1><p>单体架构时只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，这就存在一些问题：</p><ul><li>每个微服务都需要编写登录校验、用户信息获取的功能吗？</li><li>当微服务之间调用时，该如何传递用户信息？</li></ul><p>这些问题都可以通过<strong>网关</strong>技术解决。</p><h2 id="网关路由"><a href="#网关路由" class="headerlink" title="网关路由"></a>网关路由</h2><p>网关就是网络的关口。数据在网络间传输，从一个网络传输到另一网络时就需要经过网关来做数据的路由和转发以及数据安全的校验。微服务网关起到同样的作用。前端请求不能直接访问微服务，而是要请求网关：</p><ul><li>网关可以做安全控制，也就是登录身份校验，校验通过才放行</li><li>通过认证后，网关再根据请求判断应该访问哪个微服务，将请求转发过去</li></ul><p><img src="https://b11et3un53m.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTFiODMyMWU3MTdmZjczN2Y1MmZjYzg1ZTE1ZDc4YTdfNHhLNkZzcWZoaEN0T0JFNEhSYWNuRmRxR3pLTUJRYXdfVG9rZW46WFdmaWJuMUpKb0loM0x4V21SdGNneHVsbm9lXzE3MTU0OTI0MTc6MTcxNTQ5NjAxN19WNA" alt="img"></p><p>在SpringCloud当中，提供了两种网关实现方案：</p><ul><li>Netflix Zuul：早期实现，目前已经淘汰</li><li>SpringCloudGateway：基于Spring的WebFlux技术，完全支持响应式编程，吞吐能力更强</li></ul><p>这里学习SpringCloudGateway</p><h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><p>由于网关本身也是一个独立的微服务，因此也需要创建一个模块开发功能。大概步骤如下：</p><ul><li>创建网关微服务</li><li>引入SpringCloudGateway、NacosDiscovery依赖</li><li>编写启动类</li><li>配置网关路由</li></ul><h4 id="引入依赖-3"><a href="#引入依赖-3" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>创建微服务后，在<code>pom.xml</code>文件中引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--common--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.heima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--网关--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--nacos discovery--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--负载均衡--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><p>在<code>application.yaml</code>文件中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span> <span class="comment"># 路由规则id，自定义，唯一</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://service</span> <span class="comment"># 路由的目标服务，lb代表负载均衡，会从注册中心拉取服务列表</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断当前请求是否符合当前规则，符合则路由到目标服务</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span> <span class="comment"># 这里是以请求路径作为判断规则</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">cart</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://cart-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/carts/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://user-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/users/**,/addresses/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">trade</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://trade-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/orders/**</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">pay</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://pay-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/pay-orders/**</span></span><br></pre></td></tr></table></figure><h3 id="路由过滤"><a href="#路由过滤" class="headerlink" title="路由过滤"></a>路由过滤</h3><p>路由规则的定义语法如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><p>其中routes对应的类型为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="meta">@Valid</span></span><br><span class="line"><span class="keyword">private</span> List&lt;RouteDefinition&gt; routes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>是一个集合，也就是说可以定义很多路由规则。集合中的<code>RouteDefinition</code>就是具体的路由规则定义，其中常见的属性如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RouteDefinition</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@NotEmpty</span> <span class="meta">@Valid</span> List&lt;PredicateDefinition&gt; predicates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@Valid</span> List&lt;FilterDefinition&gt; filters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@NotNull</span> URI uri;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>id</code>：路由的唯一标示</li><li><code>predicates</code>：路由断言，其实就是匹配条件</li><li><code>filters</code>：路由过滤条件，后面讲</li><li><code>uri</code>：路由目标地址，<code>lb://</code>代表负载均衡，从注册中心获取目标微服务的实例列表，并且负载均衡选择一个访问。</li></ul><p>这里重点关注<code>predicates</code>，也就是路由断言。SpringCloudGateway中支持的断言类型有很多：</p><table><thead><tr><th align="left"><strong>名称</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left">After</td><td align="left">是某个时间点后的请求</td><td align="left">- After&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Before</td><td align="left">是某个时间点之前的请求</td><td align="left">- Before&#x3D;2031-04-13T15:14:47.433+08:00[Asia&#x2F;Shanghai]</td></tr><tr><td align="left">Between</td><td align="left">是某两个时间点之前的请求</td><td align="left">- Between&#x3D;2037-01-20T17:42:47.789-07:00[America&#x2F;Denver], 2037-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td></tr><tr><td align="left">Cookie</td><td align="left">请求必须包含某些cookie</td><td align="left">- Cookie&#x3D;chocolate, ch.p</td></tr><tr><td align="left">Header</td><td align="left">请求必须包含某些header</td><td align="left">- Header&#x3D;X-Request-Id, \d+</td></tr><tr><td align="left">Host</td><td align="left">请求必须是访问某个host（域名）</td><td align="left">- Host&#x3D;<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td align="left">Method</td><td align="left">请求方式必须是指定方式</td><td align="left">- Method&#x3D;GET,POST</td></tr><tr><td align="left">Path</td><td align="left">请求路径必须符合指定规则</td><td align="left">- Path&#x3D;&#x2F;red&#x2F;{segment},&#x2F;blue&#x2F;**</td></tr><tr><td align="left">Query</td><td align="left">请求参数必须包含指定参数</td><td align="left">- Query&#x3D;name, Jack或者- Query&#x3D;name</td></tr><tr><td align="left">RemoteAddr</td><td align="left">请求者的ip必须是指定范围</td><td align="left">- RemoteAddr&#x3D;192.168.1.1&#x2F;24</td></tr><tr><td align="left">weight</td><td align="left">权重处理</td><td align="left"></td></tr></tbody></table><h2 id="网关登录校验"><a href="#网关登录校验" class="headerlink" title="网关登录校验"></a>网关登录校验</h2><p>单体架构时只需要完成一次用户登录、身份校验，就可以在所有业务中获取到用户信息。而微服务拆分后，每个微服务都独立部署，不再共享数据。也就意味着每个微服务都需要做登录校验，这显然不可取。</p><h3 id="网关过滤器"><a href="#网关过滤器" class="headerlink" title="网关过滤器"></a>网关过滤器</h3><p>登录校验必须在请求转发到微服务之前做，否则就失去了意义。而网关的请求转发是<code>Gateway</code>内部代码实现的，要想在请求转发之前做登录校验，就必须了解<code>Gateway</code>内部工作的基本原理。</p><p><img src="D:\Blog\source\img\gateway_filter.png" alt="gateway_filter"></p><ol><li>客户端请求进入网关后由<code>HandlerMapping</code>对请求做判断，找到与当前请求匹配的路由规则（**<code>Route</code>**），然后将请求交给<code>WebHandler</code>去处理。</li><li><code>WebHandler</code>则会加载当前路由下需要执行的过滤器链（**<code>Filter chain</code><strong>），然后按照顺序逐一执行过滤器（后面称为</strong><code>Filter</code>**）。</li><li><code>Filter</code>被分为左右两部分，是因为<code>Filter</code>内部的逻辑分为<code>pre</code>和<code>post</code>两部分，分别会在请求路由到微服务<strong>之前</strong>和<strong>之后</strong>被执行。</li><li>只有所有<code>Filter</code>的<code>pre</code>逻辑都依次顺序执行通过后，请求才会被路由到微服务。</li><li>微服务返回结果后，再倒序执行<code>Filter</code>的<code>post</code>逻辑。</li><li>最终把响应结果返回。</li></ol><p>最终请求转发是有一个名为<code>NettyRoutingFilter</code>的过滤器来执行的，而且这个过滤器是整个过滤器链中顺序最靠后的一个。如果能够定义一个过滤器，在其中实现登录校验逻辑，并且将过滤器执行顺序定义到<code>NettyRoutingFilter</code>之前，这就符合需求了</p><p>网关过滤器链中的过滤器有两种：</p><ul><li>**<code>GatewayFilter</code>**：路由过滤器，作用范围比较灵活，可以是任意指定的路由<code>Route</code>.</li><li>**<code>GlobalFilter</code>**：全局过滤器，作用范围是所有路由，不可配置</li></ul><p><code>FilteringWebHandler</code>在处理请求时，会将<code>GlobalFilter</code>装饰为<code>GatewayFilter</code>，然后放到同一个过滤器链中，排序以后依次执行。</p><p><code>Gateway</code>中内置了很多的<code>GatewayFilter</code>，详情可以参考<a href="https://docs.spring.io/spring-cloud-gateway/docs/3.1.7/reference/html/#gatewayfilter-factories">官方文档</a></p><p><code>Gateway</code>内置的<code>GatewayFilter</code>过滤器使用起来非常简单，无需编码，只要在yaml文件中简单配置即可。而且其作用范围也很灵活，配置在哪个<code>Route</code>下，就作用于哪个<code>Route</code></p><p>例如，有一个过滤器叫做<code>AddRequestHeaderGatewayFilterFacotry</code>，即添加请求头的过滤器，可以给请求添加一个请求头并传递到下游微服务。只需要在application.yaml中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://test-service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="string">-Path=/test/**</span></span><br><span class="line">        <span class="attr">filters:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">AddRequestHeader=key,</span> <span class="string">value</span> <span class="comment"># 逗号之前是请求头的key，逗号之后是value</span></span><br></pre></td></tr></table></figure><p>如果想要让过滤器作用于所有的路由，则可以这样配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># default-filters下的过滤器可以作用于所有路由</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=key,</span> <span class="string">value</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">test_route</span></span><br><span class="line">        <span class="attr">uri:</span> <span class="string">lb://test-service</span></span><br><span class="line">        <span class="attr">predicates:</span></span><br><span class="line">          <span class="string">-Path=/test/**</span></span><br></pre></td></tr></table></figure><h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p><code>GatewayFilter</code>和<code>GlobalFilter</code>都支持自定义，只不过<strong>编码</strong>方式、<strong>使用</strong>方式略有差别</p><h4 id="自定义GatewayFilter"><a href="#自定义GatewayFilter" class="headerlink" title="自定义GatewayFilter"></a>自定义GatewayFilter</h4><p>自定义<code>GatewayFilter</code>不是直接实现<code>GatewayFilter</code>，而是实现<code>AbstractGatewayFilterFactory</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Object config)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求</span></span><br><span class="line">                <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;过滤器执行&quot;</span>);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：该类的名称一定要以<code>GatewayFilterFactory</code>为后缀</p><p>然后在yaml配置中这样使用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny</span> <span class="comment"># 此处直接以自定义的GatewayFilterFactory类名称前缀类声明过滤器</span></span><br></pre></td></tr></table></figure><p>另外，这种过滤器还可以支持动态配置参数，不过实现起来比较复杂：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGatewayFilterFactory</span> <span class="comment">// 父类泛型是内部类的Config类型</span></span><br><span class="line">                <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;PrintAnyGatewayFilterFactory.Config&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(Config config)</span> &#123;</span><br><span class="line">        <span class="comment">// OrderedGatewayFilter是GatewayFilter的子类，包含两个参数：</span></span><br><span class="line">        <span class="comment">// - GatewayFilter：过滤器</span></span><br><span class="line">        <span class="comment">// - int order值：值越小，过滤器执行优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderedGatewayFilter</span>(<span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">                <span class="comment">// 获取config值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> config.getA();</span><br><span class="line">                <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> config.getB();</span><br><span class="line">                <span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> config.getC();</span><br><span class="line">                <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">                System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">                System.out.println(<span class="string">&quot;c = &quot;</span> + c);</span><br><span class="line">                <span class="comment">// 放行</span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义配置属性，成员变量名称很重要，下面会用到</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Config</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String a;</span><br><span class="line">        <span class="keyword">private</span> String b;</span><br><span class="line">        <span class="keyword">private</span> String c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将变量名称依次返回，顺序很重要，将来读取参数时需要按顺序获取</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 返回当前配置类的类型，也就是内部的Config</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;Config&gt; <span class="title function_">getConfigClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Config.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在yaml文件中使用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">PrintAny=1,2,3</span> <span class="comment"># 注意，这里多个参数以&quot;,&quot;隔开，将来会按照shortcutFieldOrder()方法返回的参数顺序依次复制</span></span><br></pre></td></tr></table></figure><p>上面这种配置方式参数必须严格按照shortcutFieldOrder()方法的返回参数名顺序来赋值。</p><p>还有一种用法，无需按照这个顺序，就是手动指定参数名：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">PrintAny</span></span><br><span class="line">              <span class="attr">args:</span> <span class="comment"># 手动指定参数名，无需按照参数顺序</span></span><br><span class="line">                <span class="attr">a:</span> <span class="number">1</span></span><br><span class="line">                <span class="attr">b:</span> <span class="number">2</span></span><br><span class="line">                <span class="attr">c:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="自定义GlobalFilter"><a href="#自定义GlobalFilter" class="headerlink" title="自定义GlobalFilter"></a>自定义GlobalFilter</h4><p>自定义GlobalFilter则简单很多，直接实现GlobalFilter即可，无法设置动态参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintAnyGlobalFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">// 编写过滤器逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;未登录，无法访问&quot;</span>);</span><br><span class="line">        <span class="comment">// 放行</span></span><br><span class="line">        <span class="comment">// return chain.filter(exchange);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拦截</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setRawStatusCode(<span class="number">401</span>);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 过滤器执行顺序，值越小，优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="微服务获取用户"><a href="#微服务获取用户" class="headerlink" title="微服务获取用户"></a>微服务获取用户</h2><p>当网关将请求转发到微服务时，微服务又该如何获取用户身份呢？</p><p>由于网关发送请求到微服务依然采用的是<code>Http</code>请求，因此可以将用户信息以请求头的方式传递到微服务。然后微服务可以从请求头中获取登录用户信息。考虑到微服务内部可能很多地方都需要用到登录用户信息，因此我们可以利用SpringMVC的拦截器来实现登录用户信息获取，并存入ThreadLocal，方便后续使用。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先，我们修改登录校验拦截器的处理逻辑，保存用户信息到请求头中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> userId.toString();</span><br><span class="line"><span class="type">ServerWebExchange</span> <span class="variable">ex</span> <span class="operator">=</span> exchange.mutate().request(b -&gt; b.header(<span class="string">&quot;user-info&quot;</span>, userInfo)).build();</span><br></pre></td></tr></table></figure><h4 id="拦截器获取用户"><a href="#拦截器获取用户" class="headerlink" title="拦截器获取用户"></a>拦截器获取用户</h4><p>定义拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfoInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.获取请求头中的用户信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userInfo</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;user-info&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(userInfo)) &#123;</span><br><span class="line">            <span class="comment">// 不为空，保存到ThreadLocal</span></span><br><span class="line">                UserContext.setUser(Long.valueOf(userInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 移除用户</span></span><br><span class="line">        UserContext.removeUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置登录拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(DispatcherServlet.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserInfoInterceptor</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OpenFeign传递用户"><a href="#OpenFeign传递用户" class="headerlink" title="OpenFeign传递用户"></a>OpenFeign传递用户</h2><p>前端发起的请求都会经过网关再到微服务，由于我们之前编写的过滤器和拦截器功能，微服务可以轻松获取登录用户信息。</p><p>但有些业务是比较复杂的，请求到达微服务后还需要调用其它多个微服务。比如下单业务，下单的过程中，需要调用商品服务扣减库存，调用购物车服务清理用户购物车。而清理购物车时必须知道当前登录的用户身份。但是，<strong>订单服务调用购物车时并没有传递用户信息</strong>，购物车服务无法知道当前用户是谁</p><p>由于微服务获取用户信息是通过拦截器在请求头中读取，因此要想实现微服务之间的用户信息传递，就<strong>必须在微服务发起调用时把用户信息存入请求头</strong>。</p><p>微服务之间调用是基于OpenFeign来实现的，并不是我们自己发送的请求。我们如何才能让每一个由OpenFeign发起的请求自动携带登录用户信息呢？</p><p>这里要借助Feign中提供的一个拦截器接口：<code>feign.RequestInterceptor</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestInterceptor</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Called for every request. </span></span><br><span class="line"><span class="comment">   * Add data using methods on the supplied &#123;<span class="doctag">@link</span> RequestTemplate&#125;.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要实现这个接口，然后实现apply方法，利用<code>RequestTemplate</code>类来添加请求头，将用户信息保存到请求头中。这样以来，每次OpenFeign发起请求的时候都会调用该方法，传递用户信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RequestInterceptor <span class="title function_">userInfoRequestInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RequestInterceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">apply</span><span class="params">(RequestTemplate template)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取登录用户</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserContext.getUser();</span><br><span class="line">            <span class="keyword">if</span>(userId == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果为空则直接跳过</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不为空则放入请求头中，传递给下游微服务</span></span><br><span class="line">            template.header(<span class="string">&quot;user-info&quot;</span>, userId.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>现在依然还有几个问题需要解决：</p><ul><li>网关路由在配置文件中写死了，如果变更必须重启微服务</li><li>某些业务配置在配置文件中写死了，每次修改都要重启服务</li><li>每个微服务都有很多重复的配置，维护成本高</li></ul><p>这些问题都可以通过统一的<strong>配置管理器服务</strong>解决。而Nacos不仅仅具备注册中心功能，也具备配置管理的功能：</p><p><img src="D:\Blog\source\img\gateway_set_control.jpg" alt="gateway_set_control"></p><p>微服务共享的配置可以统一交给Nacos保存和管理，在Nacos控制台修改配置后，Nacos会将配置变更推送给相关的微服务，并且无需重启即可生效，实现配置热更新。</p><p>网关的路由同样是配置，因此同样可以基于这个功能实现动态路由功能，无需重启网关即可修改路由配置。</p><h3 id="共享配置"><a href="#共享配置" class="headerlink" title="共享配置"></a>共享配置</h3><p>我们可以把微服务共享的配置抽取到Nacos中统一管理，这样就不需要每个微服务都重复配置了。分为两步：</p><ul><li>在Nacos中添加共享配置</li><li>微服务拉取配置</li></ul><h4 id="添加共享配置"><a href="#添加共享配置" class="headerlink" title="添加共享配置"></a>添加共享配置</h4><p>在nacos控制台分别添加这些配置。</p><p>首先是jdbc相关配置，在<code>配置管理</code>-&gt;<code>配置列表</code>中点击<code>+</code>新建一个配置：</p><p><img src="D:\Blog\source\img\nacos_add_set_1.png" alt="nacos_add_set_1"></p><p>在弹出的表单中填写信息：</p><p><img src="D:\Blog\source\img\nacos_add_set_2.png" alt="nacos_add_set_2"></p><p>jdbc的相关参数并没有写死，例如：</p><ul><li><code>数据库ip</code>：通过<code>$&#123;hm.db.host:192.168.145.128&#125;</code>配置了默认值为，同时允许通过<code>$&#123;hm.db.host&#125;</code>来覆盖默认值</li><li><code>数据库端口</code>：通过<code>$&#123;hm.db.port:3306&#125;</code>配置了默认值为<code>3306</code>，同时允许通过<code>$&#123;hm.db.port&#125;</code>来覆盖默认值</li><li><code>数据库database</code>：可以通过<code>$&#123;hm.db.database&#125;</code>来设定</li></ul><h4 id="拉取共享配置"><a href="#拉取共享配置" class="headerlink" title="拉取共享配置"></a>拉取共享配置</h4><p>接下来要在微服务拉取共享配置。将拉取到的共享配置与本地的<code>application.yaml</code>配置合并，完成项目上下文的初始化。</p><p>不过，需要注意的是，读取Nacos配置是SpringCloud上下文（<code>ApplicationContext</code>）初始化时处理的，发生在项目的引导阶段。然后才会初始化SpringBoot上下文，去读取<code>application.yaml</code>。</p><p>也就是说引导阶段，<code>application.yaml</code>文件尚未读取，根本不知道nacos地址，该如何去加载nacos中的配置文件呢？</p><p>SpringCloud在初始化上下文的时候会先读取一个名为<code>bootstrap.yaml</code>(或者<code>bootstrap.properties</code>)的文件，如果我们将nacos地址配置到<code>bootstrap.yaml</code>中，那么在项目引导阶段就可以读取nacos中的配置了</p><p><img src="D:\Blog\source\img\bootstrap.jpg" alt="bootstrap"></p><p>因此，微服务整合Nacos配置管理的步骤如下：</p><p>1）引入依赖：</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--读取bootstrap文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）新建bootstrap.yaml</p><p>在的resources目录新建一个bootstrap.yaml文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">cart-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br><span class="line">        <span class="attr">shared-configs:</span> <span class="comment"># 共享配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-jdbc.yaml</span> <span class="comment"># 共享mybatis配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-swagger.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure><p>3）修改application.yaml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">okhttp:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启OKHttp连接池支持</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">swagger:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">购物车服务接口文档</span></span><br><span class="line">    <span class="attr">package:</span> <span class="string">com.hmall.cart.controller</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="string">hm-cart</span></span><br></pre></td></tr></table></figure><p>重启服务，使配置生效</p><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><p>目前的项目修改了配置需要重新打包、重启服务才能生效。能不能不用重启，直接生效呢？</p><p>这就要用到Nacos的配置热更新能力了，分为两步：</p><ul><li>在Nacos中添加配置</li><li>在微服务读取配置</li></ul><h4 id="添加配置到Nacos"><a href="#添加配置到Nacos" class="headerlink" title="添加配置到Nacos"></a>添加配置到Nacos</h4><p>首先在nacos中添加一个配置文件，注意文件的dataId格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[服务名]-[spring.active.profile].[后缀名]</span><br></pre></td></tr></table></figure><p>文件名称由三部分组成：</p><ul><li><strong><code>服务名</code></strong></li><li>**<code>spring.active.profile</code>**：就是spring boot中的<code>spring.active.profile</code>，可以省略，则所有profile共享该配置</li><li><strong><code>后缀名</code></strong></li></ul><h4 id="配置热更新-1"><a href="#配置热更新-1" class="headerlink" title="配置热更新"></a>配置热更新</h4><p>接着，我们在微服务中读取配置，实现配置热更新。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;test.cart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CartProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer maxAmount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><p>网关的路由配置全部是在项目启动时由<code>org.springframework.cloud.gateway.route.CompositeRouteDefinitionLocator</code>在项目启动的时候加载，并且一经加载就会缓存到内存中的路由表内（一个Map），不会改变。也不会监听路由变更</p><p>因此，我们必须监听Nacos的配置变更，然后手动把最新的路由更新到路由表中。这里有两个难点：</p><ul><li>如何监听Nacos配置变更？</li><li>如何把路由信息更新到路由表？</li></ul><h3 id="监听Nacos配置变更"><a href="#监听Nacos配置变更" class="headerlink" title="监听Nacos配置变更"></a>监听Nacos配置变更</h3><p>在Nacos官网中给出了<a href="https://nacos.io/zh-cn/docs/sdk.html">手动监听Nacos配置变更的SDK</a></p><p>如果希望Nacos推送配置变更，可以使用Nacos动态监听配置接口来实现</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addListener</span><span class="params">(String dataId, String group, Listener listener)</span></span><br></pre></td></tr></table></figure><p>请求参数说明：</p><table><thead><tr><th align="left"><strong>参数名</strong></th><th align="left"><strong>参数类型</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">dataId</td><td align="left">string</td><td align="left">配置 ID，保证全局唯一性，只允许英文字符和 4 种特殊字符（”.”、”:”、”-“、”_”）。不超过 256 字节</td></tr><tr><td align="left">group</td><td align="left">string</td><td align="left">配置分组，一般是默认的DEFAULT_GROUP</td></tr><tr><td align="left">listener</td><td align="left">Listener</td><td align="left">监听器，配置变更进入监听器的回调函数</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;&#123;serverAddr&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;&#123;dataId&#125;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;&#123;group&#125;&quot;</span>;</span><br><span class="line"><span class="comment">// 1.创建ConfigService，连接Nacos</span></span><br><span class="line"><span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.put(<span class="string">&quot;serverAddr&quot;</span>, serverAddr);</span><br><span class="line"><span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> NacosFactory.createConfigService(properties);</span><br><span class="line"><span class="comment">// 2.读取配置</span></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> configService.getConfig(dataId, group, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 3.添加配置监听器</span></span><br><span class="line">configService.addListener(dataId, group, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        <span class="comment">// 配置变更的通知处理</span></span><br><span class="line">                System.out.println(<span class="string">&quot;recieve1:&quot;</span> + configInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里核心的步骤有2步：</p><ul><li>创建ConfigService，目的是连接到Nacos</li><li>添加配置监听器，编写配置变更的通知处理逻辑</li></ul><p>这里采用了<code>spring-cloud-starter-alibaba-nacos-config</code>自动装配，因此<code>ConfigService</code>已经在<code>com.alibaba.cloud.nacos.NacosConfigAutoConfiguration</code>中自动创建好了</p><p>因此只要拿到<code>NacosConfigManager</code>就等于拿到了<code>ConfigService</code>，第一步就实现了。</p><p>第二步，编写监听器。虽然官方提供的SDK是ConfigService中的addListener，不过项目第一次启动时不仅仅需要添加监听器，也需要读取配置，因此建议使用的API是这个：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">getConfigAndSignListener</span><span class="params">(</span></span><br><span class="line"><span class="params">    String dataId, // 配置文件id</span></span><br><span class="line"><span class="params">    String group, // 配置组，走默认</span></span><br><span class="line"><span class="params">    <span class="type">long</span> timeoutMs, // 读取配置的超时时间</span></span><br><span class="line"><span class="params">    Listener listener // 监听器</span></span><br><span class="line"><span class="params">)</span> <span class="keyword">throws</span> NacosException;</span><br></pre></td></tr></table></figure><p>既可以配置监听器，并且会根据dataId和group读取配置并返回。我们就可以在项目启动时先更新一次路由，后续随着配置变更通知到监听器，完成路由更新。</p><h3 id="更新路由"><a href="#更新路由" class="headerlink" title="更新路由"></a>更新路由</h3><p>更新路由要用到<code>org.springframework.cloud.gateway.route.RouteDefinitionWriter</code>接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RouteDefinitionWriter</span> &#123;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新路由到路由表，如果路由id重复，则会覆盖旧的路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">save</span><span class="params">(Mono&lt;RouteDefinition&gt; route)</span>;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据路由id删除某个路由</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        Mono&lt;Void&gt; <span class="title function_">delete</span><span class="params">(Mono&lt;String&gt; routeId)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新的路由，也就是RouteDefinition，包含下列常见字段：</p><ul><li>id：路由id</li><li>predicates：路由匹配规则</li><li>filters：路由过滤器</li><li>uri：路由目的地</li></ul><p>将来我们保存到Nacos的配置也要符合这个对象结构，将来我们以JSON来保存，格式如下：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;item&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;predicates&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Path&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;_genkey_0&quot;</span><span class="punctuation">:</span><span class="string">&quot;/items/**&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;_genkey_1&quot;</span><span class="punctuation">:</span><span class="string">&quot;/search/**&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;filters&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;uri&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lb://item-service&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以上JSON配置就等同于：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">item</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://item-service</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/items/**,/search/**</span></span><br></pre></td></tr></table></figure><h3 id="实现动态路由"><a href="#实现动态路由" class="headerlink" title="实现动态路由"></a>实现动态路由</h3><p>在网关gateway引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--统一配置管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加载bootstrap--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在网关<code>gateway</code>的<code>resources</code>目录创建<code>bootstrap.yaml</code>文件，内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">shared-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">shared-log.yaml</span> <span class="comment"># 共享日志配置</span></span><br></pre></td></tr></table></figure><p>接着，修改<code>gateway</code>的<code>resources</code>目录下的<code>application.yml</code>，把之前的路由移除，最终内容如下：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">hm:</span></span><br><span class="line">  <span class="attr">jwt:</span></span><br><span class="line">    <span class="attr">location:</span>  <span class="comment"># 秘钥地址</span></span><br><span class="line">    <span class="attr">alias:</span>  <span class="comment"># 秘钥别名</span></span><br><span class="line">    <span class="attr">password:</span>  <span class="comment"># 秘钥文件密码</span></span><br><span class="line">    <span class="attr">tokenTTL:</span> <span class="string">30m</span> <span class="comment"># 登录有效期</span></span><br><span class="line">  <span class="attr">auth:</span></span><br><span class="line">    <span class="attr">excludePaths:</span> <span class="comment"># 无需登录校验的路径</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/search/**</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/users/login</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/items/**</span></span><br></pre></td></tr></table></figure><p>然后，在<code>gateway</code>中定义配置监听器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicRouteLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RouteDefinitionWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> NacosConfigManager nacosConfigManager;</span><br><span class="line">    <span class="comment">// 路由配置文件的id和分组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;gateway-routes.json&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span>;</span><br><span class="line">    <span class="comment">// 保存更新过的路由id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; routeIds = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRouteConfigListener</span><span class="params">()</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// 1.注册监听器并首次拉取配置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">configInfo</span> <span class="operator">=</span> nacosConfigManager.getConfigService()</span><br><span class="line">                .getConfigAndSignListener(dataId, group, <span class="number">5000</span>, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">                        updateConfigInfo(configInfo);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 2.首次启动时，更新一次配置</span></span><br><span class="line">        updateConfigInfo(configInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;监听到路由配置变更，&#123;&#125;&quot;</span>, configInfo);</span><br><span class="line">        <span class="comment">// 1.反序列化</span></span><br><span class="line">        List&lt;RouteDefinition&gt; routeDefinitions = JSONUtil.toList(configInfo, RouteDefinition.class);</span><br><span class="line">        <span class="comment">// 2.更新前先清空旧路由</span></span><br><span class="line">        <span class="comment">// 2.1.清除旧路由</span></span><br><span class="line">        <span class="keyword">for</span> (String routeId : routeIds) &#123;</span><br><span class="line">            writer.delete(Mono.just(routeId)).subscribe();</span><br><span class="line">        &#125;</span><br><span class="line">        routeIds.clear();</span><br><span class="line">        <span class="comment">// 2.2.判断是否有新的路由要更新</span></span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(routeDefinitions)) &#123;</span><br><span class="line">            <span class="comment">// 无新路由配置，直接结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.更新路由</span></span><br><span class="line">        routeDefinitions.forEach(routeDefinition -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3.1.更新路由</span></span><br><span class="line">            writer.save(Mono.just(routeDefinition)).subscribe();</span><br><span class="line">            <span class="comment">// 3.2.记录路由id，方便将来删除</span></span><br><span class="line">            routeIds.add(routeDefinition.getId());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接在Nacos控制台添加路由，即可实现动态配置路由。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java/">java</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/37b2c0e7.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RabbitMQ基础入门</title>
      <link>http://example.com/inori/1567c610.html</link>
      <guid>http://example.com/inori/1567c610.html</guid>
      <pubDate>Sat, 11 May 2024 06:47:26 GMT</pubDate>
      
      <description>rabbitMQ入门</description>
      
      
      
      <content:encoded><![CDATA[<p>在微服务中，必然会涉及到服务之间的调用，基于OpenFeign的调用需要调用者发起请求后等待服务提供者执行业务返回结果后，才能执行后续的操作，即调用者在调用过程中处于阻塞状态，这种调用方式为<strong>同步调用</strong>。但在很多场景下，我们可能需要采用<strong>异步调用</strong>的方式，将与业务关系不大的微服务与主干业务剥离开，以提升整体效率。目前常见的实现方案就是基于MQ实现。</p><h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><p>MQ即消息队列(MessageQueue)，目前比较常见的MQ有：</p><ul><li><p>ActiveMQ</p></li><li><p>RabbitMQ</p></li><li><p>RocketMQ</p></li><li><p>Kafka</p></li></ul><table><thead><tr><th></th><th>RabbitMQ</th><th>ActiveMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>公司&#x2F;社区</td><td>Rabbit</td><td>Apache</td><td>阿里</td><td>Apache</td></tr><tr><td>开发语言</td><td>Erlang</td><td>Java</td><td>Java</td><td>Scala&amp;Java</td></tr><tr><td>协议支持</td><td>AMQP，XMPP，SMTP，STOMP</td><td>OpenWire,STOMP，REST,XMPP,AMQP</td><td>自定义协议</td><td>自定义协议</td></tr><tr><td>可用性</td><td>高</td><td>一般</td><td>高</td><td>高</td></tr><tr><td>单机吞吐量</td><td>一般</td><td>差</td><td>高</td><td>非常高</td></tr><tr><td>消息延迟</td><td>微秒级</td><td>毫秒级</td><td>毫秒级</td><td>毫秒以内</td></tr><tr><td>消息可靠性</td><td>高</td><td>一般</td><td>高</td><td>一般</td></tr></tbody></table><p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p><p>追求可靠性：RabbitMQ、RocketMQ</p><p>追求吞吐能力：RocketMQ、Kafka</p><p>追求消息低延迟：RabbitMQ、Kafka</p><p>综合考虑，<a href="https://www.rabbitmq.com/">RabbitMQ</a>更加均衡，这里对RabbitMQ进行学习。</p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>使用docker命令进行安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -e RABBITMQ_DEFAULT_USER=inori -e RABBITMQ_DEFAULT_PASS=123456 -v mq-plugins:/plugins --name mq --hostname mq -p 15672:15672 -p 5672:5672 --network test-net -d rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><p>安装命令中有两个映射的端口：</p><ul><li>15672：RabbitMQ提供的管理控制台的端口</li><li>5672：RabbitMQ的消息发送处理接口</li></ul><p>安装完成后，我们访问<u>服务器地址:15672</u>即可看到管理控制台。在控制台中，可以进行创建和查看交换机、队列中的已有信息，发送消息等步骤，不过开发业务时，一般不会在控制台收发消息，而是基于编程的方式。</p><h3 id="RabbitMQ架构"><a href="#RabbitMQ架构" class="headerlink" title="RabbitMQ架构"></a>RabbitMQ架构</h3><p><img src="D:\Blog\source\img\rabbitmq_frame.png" alt="rabbitmq_frame"></p><ul><li>**<code>publisher</code>**：生产者，发送消息的一方</li><li>**<code>consumer</code>**：消费者，获取消息的一方</li><li>**<code>exchange</code>**：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列，没有存储功能</li><li>**<code>queue</code>**：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理</li><li>**<code>virtual host</code>**：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue，不同的虚拟主机内的交换机和队列可以重名</li></ul><h2 id="WorkQueues模型"><a href="#WorkQueues模型" class="headerlink" title="WorkQueues模型"></a>WorkQueues模型</h2><p>WorkQueues模型就是<strong>让多个消费者绑定到一个队列，共同消费队列中的消息</strong></p><p>适用场景：当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用此模型，<strong>多个消费者共同处理消息处理，消息处理的速度就能大大提高</strong>了。</p><p>WorkQueue默认的处理方式是消息平均分配给每个消费者，并没有考虑到消费者的处理能力，即没有充分利用每一个消费者的能力，这样显然是有问题的。</p><h4 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h4><p>在spring中进行配置，可以解决这个问题。添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><p>添加这个配置后，处理速度较快的消费者就可以处理更多的数据。</p><h2 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h2><p>在之前的测试案例中，都没有交换机，生产者直接发送消息到队列。而一旦引入交换机，消息发送的模式会有很大变化：</p><p><img src="D:\Blog\source\img\add_exchange.png" alt="add_exchange"></p><ul><li><strong>Publisher</strong>：生产者，不再发送消息到队列中，而是发给交换机</li><li><strong>Exchange</strong>：交换机，一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</li><li><strong>Queue</strong>：消息队列也与以前一样，接收消息、缓存消息。不过队列一定要与交换机绑定</li><li><strong>Consumer</strong>：消费者，与以前一样，订阅队列，没有变化</li></ul><p>交换机只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失</p><p>交换机的类型有四种：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><h3 id="Fanout交换机"><a href="#Fanout交换机" class="headerlink" title="Fanout交换机"></a>Fanout交换机</h3><p>可以理解为广播交换机。即当该交换机收到消息后，会转发给所有绑定到该交换机上的队列</p><p>1）可以有多个队列</p><p>2）每个队列都要绑定到Exchange</p><p>3）生产者发送的消息，只能发送到交换机</p><p>4）交换机把消息发送给绑定过的所有队列</p><p>5）订阅队列的消费者都能拿到消息</p><h3 id="Direct交换机"><a href="#Direct交换机" class="headerlink" title="Direct交换机"></a>Direct交换机</h3><p>在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p><img src="D:\Blog\source\img\direct_exchange.png" alt="direct_exchange"></p><p>在Direct模型下：</p><ul><li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code></li><li>消息的发送方在向Exchange发送消息时，也必须指定消息的<code>RoutingKey</code></li><li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的<code>Routing key</code>相同才会接收到消息</li></ul><h4 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h4><p>在publisher服务的SpringAmqpTest类中添加测试方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendDirectExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 交换机名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;hmall.direct&quot;</span>;</span><br><span class="line">    <span class="comment">// 消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;红色&quot;</span>;</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);<span class="comment">// 需要在参数中指定RoutingKey</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息接收"><a href="#消息接收" class="headerlink" title="消息接收"></a>消息接收</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;direct.queue2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Topic交换机"><a href="#Topic交换机" class="headerlink" title="Topic交换机"></a>Topic交换机</h3><p><code>Topic</code>类型与<code>Direct</code>类似，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。</p><p>只不过<code>Topic</code>类型可以让队列在绑定<code>BindingKey</code> 的时候使用通配符</p><p><code>BindingKey</code> 一般都是有一个或多个单词组成，多个单词之间以<code>.</code>分割，例如：item.insert</p><p>通配符规则：</p><ul><li><code>#</code>：匹配一个或多个词</li><li><code>*</code>：匹配1个词</li></ul><p>举例：</p><ul><li><code>item.#</code>：能够匹配<code>item.cpu.insert</code> 或者 <code>item.cpu</code></li><li><code>item.*</code>：只能匹配<code>item.cpu</code></li></ul><h2 id="SpringAMQP"><a href="#SpringAMQP" class="headerlink" title="SpringAMQP"></a>SpringAMQP</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--AMQP依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.145</span><span class="number">.128</span> <span class="comment"># 虚拟机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/test</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">test</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><h3 id="简单消息的发送和接收"><a href="#简单消息的发送和接收" class="headerlink" title="简单消息的发送和接收"></a>简单消息的发送和接收</h3><p>消息发送：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringAmqpTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSimpleQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 队列名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">        <span class="comment">// 消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, spring amqp!&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用RabbitListener来声明要监听的队列信息，一旦监听的队列中有了消息，就会推送给当前服务，调用当前方法，处理消息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="comment">// 可以看到方法体中接收的就是消息体的内容</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringAMQP声明队列和交换机"><a href="#SpringAMQP声明队列和交换机" class="headerlink" title="SpringAMQP声明队列和交换机"></a>SpringAMQP声明队列和交换机</h3><h4 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h4><p>SpringAMQP提供了一个Queue类，用来创建队列,还提供了一个Exchange接口，来表示所有不同类型的交换机，我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：</p><p><img src="D:\Blog\source\img\AMQPApi1.png" alt="AMQPApi1"></p><p>而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：</p><p><img src="D:\Blog\source\img\AMQPApi2.png" alt="AMQPApi2"></p><h4 id="基于Bean声明Fanout示例"><a href="#基于Bean声明Fanout示例" class="headerlink" title="基于Bean声明Fanout示例"></a>基于Bean声明Fanout示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;test.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基于注解声明"><a href="#基于注解声明" class="headerlink" title="基于注解声明"></a>基于注解声明</h4><p>基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。</p><p>例如声明Direct模式的交换机和队列：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;test.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;test.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到direct.queue2的消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转换器"><a href="#消息转换器" class="headerlink" title="消息转换器"></a>消息转换器</h3><p>Spring的消息发送代码接收的消息体是一个Object，而在数据传输时，它会把发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p>只不过，默认情况下Spring采用的序列化方式是JDK序列化。而JDK序列化存在下列问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><p>JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。</p><h4 id="配置JSON转换器"><a href="#配置JSON转换器" class="headerlink" title="配置JSON转换器"></a>配置JSON转换器</h4><p>如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。如果没有则需要引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置消息转换器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息转换器中添加的messageId可以便于将来做幂等性判断</p><h4 id="消费者接收Object"><a href="#消费者接收Object" class="headerlink" title="消费者接收Object"></a>消费者接收Object</h4><p>我们在consumer服务中定义一个新的消费者，publisher是用Map发送，那么消费者也一定要用Map接收，格式如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;object.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(Map&lt;String, Object&gt; msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到object.queue消息：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MQ消息的可靠性"><a href="#MQ消息的可靠性" class="headerlink" title="MQ消息的可靠性"></a>MQ消息的可靠性</h1><p>在大多数异步调用业务场景下，必须确保MQ消息的可靠性，即：消息应该至少被消费者处理1次</p><ul><li>我们该如何确保MQ消息的可靠性？</li><li>如果真的发送失败，有没有其它方案？</li></ul><h2 id="可靠性分析"><a href="#可靠性分析" class="headerlink" title="可靠性分析"></a>可靠性分析</h2><p>消息从发送者发送消息，到消费者处理消息，需要经过发送者发送消息到交换机，交换机转发消息到队列，队列发送到消费者，消费者消费数据。</p><p>其中每一步都可能导致消息丢失：</p><ul><li>发送消息时丢失：<ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li>MQ导致消息丢失：<ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li>消费者处理消息时：<ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p>综上，我们要解决消息丢失问题，保证MQ的可靠性，就必须从3个方面入手：</p><ul><li>确保生产者一定把消息发送到MQ</li><li>确保MQ不会将消息弄丢</li><li>确保消费者一定要处理消息</li></ul><h2 id="生产者的可靠性"><a href="#生产者的可靠性" class="headerlink" title="生产者的可靠性"></a>生产者的可靠性</h2><h3 id="生产者重试机制"><a href="#生产者重试机制" class="headerlink" title="生产者重试机制"></a>生产者重试机制</h3><p>SpringAMQP提供的消息发送时的重试机制。即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。</p><p>修改<code>publisher</code>模块的<code>application.yaml</code>文件，添加下面的内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：当网络不稳定的时候，利用重试机制可以有效提高消息发送的成功率。不过SpringAMQP提供的重试机制是<strong>阻塞式</strong>的重试，也就是说多次重试等待的过程中，当前线程是被阻塞的。</p><p>如果对于业务性能有要求，建议禁用重试机制。如果一定要使用，请合理配置等待时长和重试次数，当然也可以考虑使用异步线程来执行发送消息的代码。</p><h3 id="生产者确认机制"><a href="#生产者确认机制" class="headerlink" title="生产者确认机制"></a>生产者确认机制</h3><p>一般情况下，只要生产者与MQ之间的网路连接顺畅，基本不会出现发送消息丢失的情况。</p><p>不过，在少数情况下，也会出现消息发送到MQ之后丢失的现象，比如：</p><ul><li>MQ内部处理消息的进程发生了异常</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code>，因此无法路由</li></ul><p>针对上述情况，RabbitMQ提供了生产者消息确认机制，包括<code>Publisher Confirm</code>和<code>Publisher Return</code>两种。在开启确认机制的情况下，当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的<strong>回执</strong>。</p><p><img src="D:\Blog\source\img\mq_publisher_return.png" alt="mq_publisher_return"></p><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回Ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>其中<code>ack</code>和<code>nack</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于<strong>Publisher Return</strong>机制。</p><p>默认两种机制都是关闭状态，需要通过配置文件来开启。</p><h4 id="实现生产者确认"><a href="#实现生产者确认" class="headerlink" title="实现生产者确认"></a>实现生产者确认</h4><p>在publisher模块的<code>application.yaml</code>中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span> <span class="comment"># 开启publisher confirm机制，并设置confirm类型</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment"># 开启publisher return机制</span></span><br></pre></td></tr></table></figure><p>这里<code>publisher-confirm-type</code>有三种模式可选：</p><ul><li><code>none</code>：关闭confirm机制</li><li><code>simple</code>：同步阻塞等待MQ的回执</li><li><code>correlated</code>：MQ异步回调返回回执</li></ul><p>一般我们推荐使用<code>correlated</code>，回调机制。</p><h4 id="定义ReturnCallback"><a href="#定义ReturnCallback" class="headerlink" title="定义ReturnCallback"></a>定义ReturnCallback</h4><p>每个<code>RabbitTemplate</code>只能配置一个<code>ReturnCallback</code>，因此我们可以在配置类中统一设置。我们在publisher模块定义一个配置类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.setReturnsCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnsCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(ReturnedMessage returned)</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;触发return callback,&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;exchange: &#123;&#125;&quot;</span>, returned.getExchange());</span><br><span class="line">                log.debug(<span class="string">&quot;routingKey: &#123;&#125;&quot;</span>, returned.getRoutingKey());</span><br><span class="line">                log.debug(<span class="string">&quot;message: &#123;&#125;&quot;</span>, returned.getMessage());</span><br><span class="line">                log.debug(<span class="string">&quot;replyCode: &#123;&#125;&quot;</span>, returned.getReplyCode());</span><br><span class="line">                log.debug(<span class="string">&quot;replyText: &#123;&#125;&quot;</span>, returned.getReplyText());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定义ConfirmCallback"><a href="#定义ConfirmCallback" class="headerlink" title="定义ConfirmCallback"></a>定义ConfirmCallback</h4><p>由于每个消息发送时的处理逻辑不一定相同，因此ConfirmCallback需要在每次发消息时定义。具体来说，是在调用RabbitTemplate中的convertAndSend方法时，多传递一个参数：CorrelationData</p><p>这里的CorrelationData中包含两个核心的东西：</p><ul><li><code>id</code>：消息的唯一标示，MQ对不同的消息的回执以此做判断，避免混淆</li><li><code>SettableListenableFuture</code>：回执结果的Future对象</li></ul><p>将来MQ的回执就会通过这个<code>Future</code>来返回，可以提前给<code>CorrelationData</code>中的<code>Future</code>添加回调函数来处理消息回执</p><p>新建一个测试，向系统自带的交换机发送消息，并且添加<code>ConfirmCallback</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherConfirm</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建CorrelationData</span></span><br><span class="line">    <span class="type">CorrelationData</span> <span class="variable">cd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorrelationData</span>();</span><br><span class="line">    <span class="comment">// 2.给Future添加ConfirmCallback</span></span><br><span class="line">    cd.getFuture().addCallback(<span class="keyword">new</span> <span class="title class_">ListenableFutureCallback</span>&lt;CorrelationData.Confirm&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1.Future发生异常时的处理逻辑，基本不会触发</span></span><br><span class="line">            log.error(<span class="string">&quot;send message fail&quot;</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(CorrelationData.Confirm result)</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2.Future接收到回执的处理逻辑，参数中的result就是回执内容</span></span><br><span class="line">            <span class="keyword">if</span>(result.isAck())&#123; <span class="comment">// result.isAck()，boolean类型，true代表ack回执，false 代表 nack回执</span></span><br><span class="line">                log.debug(<span class="string">&quot;发送消息成功，收到 ack!&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">// result.getReason()，String类型，返回nack时的异常描述</span></span><br><span class="line">                log.error(<span class="string">&quot;发送消息失败，收到 nack, reason : &#123;&#125;&quot;</span>, result.getReason());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 3.发送消息</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;hmall.direct&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;hello&quot;</span>, cd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>开启生产者确认比较消耗MQ性能，一般不建议开启。而且大家思考一下触发确认的几种情况：</p><ul><li>路由失败：一般是因为RoutingKey错误导致，往往是编程导致</li><li>交换机名称错误：同样是编程错误导致</li><li>MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了。</li></ul><h2 id="MQ的可靠性"><a href="#MQ的可靠性" class="headerlink" title="MQ的可靠性"></a>MQ的可靠性</h2><p>消息到达MQ以后，如果MQ不能及时保存，也会导致消息丢失，所以MQ的可靠性也非常重要。</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>为了提升性能，默认情况下MQ的数据都是在内存存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化：在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数：设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</li><li>队列持久化：在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数</li><li>消息持久化：在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code></li></ul><p><strong>说明</strong>：在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。</p><p>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。</p><h3 id="LazyQueue"><a href="#LazyQueue" class="headerlink" title="LazyQueue"></a>LazyQueue</h3><p>在默认情况下，RabbitMQ会将接收到的信息保存在内存中以降低消息收发的延迟。但在某些特殊情况下，这会导致消息积压，比如：</p><ul><li>消费者宕机或出现网络故障</li><li>消息发送量激增，超过了消费者处理速度</li><li>消费者处理业务发生阻塞</li></ul><p>一旦出现消息堆积问题，RabbitMQ的内存占用就会越来越高，直到触发内存预警上限。此时RabbitMQ会将内存消息刷到磁盘上，这个行为称为<code>PageOut</code>。</p><p><code>PageOut</code>会耗费一段时间，并且会阻塞队列进程。因此在这个过程中RabbitMQ不会再处理新的消息，生产者的所有请求都会被阻塞。</p><p>为了解决这个问题，从RabbitMQ的3.6版本开始，就增加了LazyQueues的模式，也就是惰性队列。惰性队列的特征如下：</p><ul><li>接收到消息后直接存入磁盘而非内存</li><li>消费者要消费消息时才会从磁盘中读取并加载到内存（也就是懒加载）</li><li>支持数百万条的消息存储</li></ul><p>而在3.12版本之后，LazyQueue已经成为所有队列的默认格式。</p><h4 id="代码配置Lazy模式"><a href="#代码配置Lazy模式" class="headerlink" title="代码配置Lazy模式"></a>代码配置Lazy模式</h4><p>在利用SpringAMQP声明队列的时候，添加<code>x-queue-mod=lazy</code>参数可以设置队列为Lazy模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以基于注解来声明队列并设置为Lazy模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新已有队列为lazy模式"><a href="#更新已有队列为lazy模式" class="headerlink" title="更新已有队列为lazy模式"></a>更新已有队列为lazy模式</h4><p>对于已经存在的队列，也可以配置为lazy模式，但是要通过设置policy实现。</p><p>可以基于命令行设置policy：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy Lazy &quot;^lazy-queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues  </span><br></pre></td></tr></table></figure><p>命令解读：</p><ul><li><code>rabbitmqctl</code> ：RabbitMQ的命令行工具</li><li><code>set_policy</code> ：添加一个策略</li><li><code>Lazy</code> ：策略名称，可以自定义</li><li><code>&quot;^lazy-queue$&quot;</code> ：用正则表达式匹配队列的名字</li><li><code>&#39;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#39;</code> ：设置队列模式为lazy模式</li><li><code>--apply-to queues</code>：策略的作用对象，是所有的队列</li></ul><p>当然，也可以在控制台配置policy，进入在控制台的<code>Admin</code>页面，点击<code>Policies</code>，即可添加配置：</p><p><img src="D:\Blog\source\img\lazyqueue_set_in_window.png" alt="lazyqueue_set_in_window"></p><h2 id="消费者的可靠性"><a href="#消费者的可靠性" class="headerlink" title="消费者的可靠性"></a>消费者的可靠性</h2><p>当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li></ul><p>一旦发生上述情况，消息也会丢失。因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息。</p><h3 id="消费者确认机制"><a href="#消费者确认机制" class="headerlink" title="消费者确认机制"></a>消费者确认机制</h3><p>为了确认消费者是否成功处理消息，RabbitMQ提供了消费者确认机制（<strong>Consumer Acknowledgement</strong>）即：当消费者处理消息结束后，向RabbitMQ发送一个回执，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li>ack：成功处理消息，RabbitMQ从队列中删除该消息</li><li>nack：消息处理失败，RabbitMQ需要再次投递消息</li><li>reject：消息处理失败并拒绝该消息，RabbitMQ从队列中删除该消息</li></ul><p>一般reject方式用的较少，除非是消息格式有问题。因此大多数情况下我们需要将消息处理的代码通过<code>try catch</code>机制捕获，消息处理成功时返回ack，处理失败时返回nack.</p><p>由于消息回执的处理代码比较统一，SpringAMQP帮我们实现了消息确认。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li>**<code>none</code>**：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。不建议使用</li><li>**<code>manual</code>**：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵（在当前业务中插入与当前业务无关的其他逻辑），但更灵活</li><li>**<code>auto</code>**：自动模式。SpringAMQP利用AOP对消息处理逻辑做了环绕增强，当业务正常执行时则自动返回<code>ack</code>.当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是<strong>业务异常</strong>，会自动返回<code>nack</code></li><li>如果是<strong>消息处理或校验异常</strong>，自动返回<code>reject</code></li></ul></li></ul><p>通过下面的配置可以修改SpringAMQP的ACK处理方式：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动模式</span></span><br></pre></td></tr></table></figure><h3 id="失败重试机制"><a href="#失败重试机制" class="headerlink" title="失败重试机制"></a>失败重试机制</h3><p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者。如果消费者再次执行依然出错，消息会再次requeue到队列，再次投递，直到消息处理成功为止。</p><p>极端情况就是消费者一直无法执行成功，那么消息requeue就会无限循环，导致mq的消息处理飙升，带来不必要的压力，为了应对该情况，Spring提供了消费者失败重试机制：在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列</p><p>修改consumer服务的application.yml文件，添加内容：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态，false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><ul><li>消费者在失败后消息没有重新回到MQ无限重新投递，而是在本地重试了3次</li><li>本地重试3次以后，抛出了<code>AmqpRejectAndDontRequeueException</code>异常。查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是<code>reject</code></li></ul><p>结论：</p><ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回reject，消息会被丢弃</li></ul><h3 id="失败处理策略"><a href="#失败处理策略" class="headerlink" title="失败处理策略"></a>失败处理策略</h3><p>在之前的测试中，本地测试达到最大重试次数后，消息会被丢弃。这在某些对于消息可靠性要求较高的业务场景下，显然不太合适</p><p>因此Spring允许我们自定义重试次数耗尽后的消息处理策略，这个策略是由<code>MessageRecovery</code>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。默认就是这种方式 </li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队</li><li><code>RepublishMessageRecoverer</code>：重试耗尽后，将失败消息投递到指定的交换机</li></ul><p>比较推荐的是<code>RepublishMessageRecoverer</code>，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续集中处理</p><p>1）定义处理失败消息的交换机和队列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）定义RepublishMessageRecoverer，关联队列和交换机</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务幂等性"><a href="#业务幂等性" class="headerlink" title="业务幂等性"></a>业务幂等性</h3><p><strong>幂等</strong>是一个数学概念，用函数表达式来描述是这样的：<code>f(x) = f(f(x))</code>，例如求绝对值函数。</p><p>在程序开发中，则是指同一个业务，执行一次或多次对业务状态的影响是一致的。例如：</p><ul><li>根据id删除数据</li><li>查询数据</li><li>新增数据</li></ul><p>但数据的更新往往不是幂等的，如果重复执行可能造成不一样的后果。比如：</p><ul><li>取消订单，恢复库存的业务。如果多次恢复就会出现库存重复增加的情况</li><li>退款业务。重复退款对商家而言会有经济损失。</li></ul><p>所以，我们要尽可能避免业务被重复执行。</p><p>然而在实际业务场景中，由于意外经常会出现业务被重复执行的情况，例如：</p><ul><li>页面卡顿时频繁刷新导致表单重复提交</li><li>服务间调用的重试</li><li>MQ消息的重复投递</li></ul><p>因此，我们必须想办法保证消息处理的幂等性。这里给出两种方案：</p><ul><li>唯一消息ID</li><li>业务状态判断</li></ul><h4 id="唯一消息ID"><a href="#唯一消息ID" class="headerlink" title="唯一消息ID"></a>唯一消息ID</h4><ol><li>每一条消息都生成一个唯一的id，与消息一起投递给消费者。</li><li>消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</li><li>如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</li></ol><p>SpringAMQP的MessageConverter自带了MessageID的功能，我们只要开启这个功能即可。</p><p>以Jackson的消息转换器为例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jjmc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jjmc.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jjmc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务判断"><a href="#业务判断" class="headerlink" title="业务判断"></a>业务判断</h4><p>业务判断就是基于业务本身的逻辑或状态来判断是否是重复的请求或消息，不同的业务场景判断的思路也不一样，大体思路为在获取到MQ的消息后，先判断当前数据库中的数据的某些状态是否与要修改之前的数据的状态保持一致，若一致则修改。</p><p>相比较而言，消息ID的方案需要改造原有的数据库，所以更推荐使用业务判断的方案。</p><h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><p>在某些业务中，对于一些库存有限的商品，为了更好的用户体验，通常都会在用户下单时立刻扣减商品库存。例如电影院购票、高铁购票，下单后就会锁定座位资源，其他人无法重复购买。</p><p>但是这样就存在一个问题，假如用户下单后一直不付款，就会一直占有库存资源，导致其他客户无法正常交易</p><p>通常的做法就是：<strong>对于超过一定时间未支付的订单，应该立刻取消订单并释放占用的库存</strong>。</p><p>像这种在一段时间以后才执行的任务称之为<strong>延迟任务</strong>，而要实现延迟任务，最简单的方案是利用MQ的延迟消息。</p><p>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><h3 id="死信交换机和延迟消息"><a href="#死信交换机和延迟消息" class="headerlink" title="死信交换机和延迟消息"></a>死信交换机和延迟消息</h3><h4 id="死信交换机"><a href="#死信交换机" class="headerlink" title="死信交换机"></a>死信交换机</h4><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或<code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过**<code>dead-letter-exchange</code><strong>属性指定了一个交换机，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为</strong>死信交换机**（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p>死信交换机有什么作用呢？</p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><p>前面两种作用场景可以看做是把死信交换机当做一种消息处理的最终兜底方案，与消费者重试的<code>RepublishMessageRecoverer</code>作用类似。</p><p>而最后一种场景，可以作为延迟消息的实现方式</p><h3 id="延迟消息-1"><a href="#延迟消息-1" class="headerlink" title="延迟消息"></a>延迟消息</h3><p>假设有一组绑定的交换机（<code>ttl.fanout</code>）和队列（<code>ttl.queue</code>）。但是<code>ttl.queue</code>没有消费者监听，而是设定了死信交换机<code>hmall.direct</code>，而队列<code>direct.queue1</code>则与死信交换机绑定，RoutingKey是blue</p><p><img src="D:\Blog\source\img\mq_delayMessage.png" alt="mq_delayMessage"></p><ol><li>假如我们现在发送一条消息到<code>ttl.fanout</code>，RoutingKey为blue，并设置消息的有效期。尽管这里的<code>ttl.fanout</code>不需要RoutingKey，但是当消息变为死信并投递到死信交换机时，会沿用之前的RoutingKey，这样<code>hmall.direct</code>才能正确路由消息，消息肯定会被投递到<code>ttl.queue</code>之后，由于没有消费者，消息无人消费</li><li>5秒之后，消息的有效期到期，成为死信</li><li>死信被再次投递到死信交换机<code>hmall.direct</code>，并沿用之前的RoutingKey，也就是<code>blue</code></li><li>由于<code>direct.queue1</code>与<code>hmall.direct</code>绑定的key是blue，因此最终消息被成功路由到<code>direct.queue1</code>，如果此时有消费者与<code>direct.queue1</code>绑定， 也就能成功消费消息了。但此时已经是5秒钟以后了</li></ol><p>也就是说，publisher发送了一条消息，但最终consumer在5秒后才收到消息。我们成功实现了<strong>延迟消息</strong>。</p><p><strong>注意：</strong></p><p>RabbitMQ的消息过期是基于追溯方式来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。</p><p>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此设置的TTL时间不一定准确。</p><h3 id="DelayExchange插件"><a href="#DelayExchange插件" class="headerlink" title="DelayExchange插件"></a>DelayExchange插件</h3><p>基于死信队列虽然可以实现延迟消息，但是太麻烦。因此RabbitMQ社区提供了一个<a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">延迟消息插件</a>来实现相同的效果。</p><p><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">插件下载</a>后，因为mq是基于Docker安装，所以需要先查看RabbitMQ的插件目录对应的数据卷。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume inspect mq-plugins</span><br></pre></td></tr></table></figure><p>插件目录被挂载到了<code>/var/lib/docker/volumes/mq-plugins/_data</code>这个目录，我们上传插件到该目录下。</p><p>接下来执行命令，安装插件：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><h4 id="声明延迟交换机"><a href="#声明延迟交换机" class="headerlink" title="声明延迟交换机"></a>声明延迟交换机</h4><p>基于注解方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于<code>@Bean</code>的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送延迟消息"><a href="#发送延迟消息" class="headerlink" title="发送延迟消息"></a>发送延迟消息</h4><p>必须通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的延迟时间设置较长，可能会导致堆积的延迟消息非常多，会带来较大的CPU开销，同时延迟消息的时间会存在误差。</p><p>因此不建议设置延迟时间过长的延迟消息</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/rabbitMQ/">rabbitMQ</category>
      
      
      <category domain="http://example.com/tags/rabbitMQ/">rabbitMQ</category>
      
      
      <comments>http://example.com/inori/1567c610.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
