<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>楪祈のBlog</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>星座になれたら。</description>
    <pubDate>Sat, 06 Jan 2024 12:48:45 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>LeetCode每日一题.1</title>
      <link>http://example.com/inori/7752405a.html</link>
      <guid>http://example.com/inori/7752405a.html</guid>
      <pubDate>Sat, 06 Jan 2024 11:27:32 GMT</pubDate>
      
      <description>LeetCode每日一题</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="LeetCode每日一题"><a href="#LeetCode每日一题" class="headerlink" title="LeetCode每日一题"></a>LeetCode每日一题</h1><p>​今天的每日一题是<a href="https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/">2807. 在链表中插入最大公约数</a>，难度标的中等，不过我认为应该是简单题</p><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给你一个链表的头 <code>head</code> ，每个结点包含一个整数值。</p><p>在相邻结点之间，请你插入一个新的结点，结点值为这两个相邻结点值的 <strong>最大公约数</strong> 。</p><p>请你返回插入之后的链表。</p><p>两个数的 <strong>最大公约数</strong> 是可以被两个数字整除的最大正整数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/07/18/ex1_copy.png" alt="img"></p><blockquote><p>输入：head &#x3D; [18,6,10,3]<br>输出：[18,6,6,2,10,1,3]<br>解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。</p><ul><li>18 和 6 的最大公约数为 6 ，插入第一和第二个结点之间。</li><li>6 和 10 的最大公约数为 2 ，插入第二和第三个结点之间。</li><li>10 和 3 的最大公约数为 1 ，插入第三和第四个结点之间。<br>所有相邻结点之间都插入完毕，返回链表。</li></ul></blockquote><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2023/07/18/ex2_copy1.png" alt="img"></p><blockquote><p>输入：head &#x3D; [7]<br>输出：[7]<br>解释：第一幅图是一开始的链表，第二幅图是插入新结点后的图（蓝色结点为新插入结点）。<br>没有相邻结点，所以返回初始链表。</p></blockquote><p><strong>提示：</strong></p><ul><li>链表中结点数目在 <code>[1, 5000]</code> 之间。</li><li><code>1 &lt;= Node.val &lt;= 1000</code></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>​这道题很直观，明显是考差欧几里得算法(辗转相除法)<code>gcd(a,b) = gcd(b,a mod b)</code>原理为：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。</p><p>​明白了考察的知识点，这道题就非常简单了，直接遍历链表，在每两个节点直接插入这两个节点的值的最大公约数<code>gcd(node1.val, node2.val)</code>即可，计算gcd的方法可以是 <code>Math.gcd</code>或者自定义方法。</p><p>​有一点需要注意，只有节点数大于1时才需要插入，否则直接返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">insertGreatestCommonDivisors</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = head, *ne = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(ne)&#123;</span><br><span class="line">            ListNode *node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="built_in">gcd</span>(pre-&gt;val, ne-&gt;val), ne);</span><br><span class="line">            pre-&gt;next = node;</span><br><span class="line">            pre = ne;</span><br><span class="line">            ne = ne-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">insertGreatestCommonDivisors</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, ne = head.next;</span><br><span class="line">        <span class="keyword">while</span>(ne != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> gcd(pre.val, ne.val);</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(g, ne);</span><br><span class="line">            pre.next = newNode;</span><br><span class="line">            pre = ne;</span><br><span class="line">            ne = ne.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertGreatestCommonDivisors</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">            <span class="keyword">return</span> a <span class="keyword">if</span> b == <span class="number">0</span> <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        pre, ne = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> ne:</span><br><span class="line">            node = ListNode(gcd(pre.val, ne.val), ne)</span><br><span class="line">            pre.<span class="built_in">next</span> = node</span><br><span class="line">            pre = ne</span><br><span class="line">            ne = ne.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(nlog⁡M)，其中n为链表长度，M是节点最大可能的值，每次计算要O(logM)的时间。</li><li>空间复杂度：O(1)。</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/LeetCode/">LeetCode</category>
      
      
      <category domain="http://example.com/tags/LeetCode/">LeetCode</category>
      
      
      <comments>http://example.com/inori/7752405a.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://example.com/inori/4a17b156.html</link>
      <guid>http://example.com/inori/4a17b156.html</guid>
      <pubDate>Sun, 31 Dec 2023 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;费了不少劲！终于把我的博客搭好了！&lt;/p&gt;
&lt;h3 id=&quot;所用技术&quot;&gt;&lt;a href=&quot;#所用技术&quot; class=&quot;headerlink&quot; title=&quot;所用技术&quot;&gt;&lt;/a&gt;所用技术&lt;/h3&gt;&lt;p&gt;​	本网站使用GitHub后端+Hexo框架+Butterfly渲染，并在</description>
        
      
      
      
      <content:encoded><![CDATA[<p>费了不少劲！终于把我的博客搭好了！</p><h3 id="所用技术"><a href="#所用技术" class="headerlink" title="所用技术"></a>所用技术</h3><p>​本网站使用GitHub后端+Hexo框架+Butterfly渲染，并在基础上做出了一小部分魔改，加了些花里胡哨的东西，域名在阿里云选购。</p><hr><p>​就说这么多吧，后续我争取做到把每日学到的东西做一个总结，更新在这里，希望可以用这种方法来加深我对知识的理解与记忆。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/">碎碎念</category>
      
      
      <category domain="http://example.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/">碎碎念</category>
      
      
      <comments>http://example.com/inori/4a17b156.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
