<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>楪祈のBlog</title>
    <link>http://ltynote.cn/</link>
    
    <atom:link href="http://ltynote.cn/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>星座になれたら。</description>
    <pubDate>Fri, 15 Aug 2025 08:56:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>手撕—实现JSON字符串解析</title>
      <link>http://ltynote.cn/inori/a6efffa.html</link>
      <guid>http://ltynote.cn/inori/a6efffa.html</guid>
      <pubDate>Fri, 15 Aug 2025 08:28:08 GMT</pubDate>
      
      <description>面试专题——手撕</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现一个方法，找到json字符串的对应路径的值。</p><p>输入：一个Json格式的字符串和一个路径字符串</p><p>输出：对应路径的值</p><blockquote><p>例子：</p><p>输入：”{“a”:{“b”:1},”c”:1}”  “a.b”</p><p>输出：1</p></blockquote><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>分析：主要考字符串处理和递归，主要思路为将输入的字符串转化成哈希表，便于查找，然后递归进行哈希表键值对的插入，然后处理路径，一层一层找即可。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title function_">parseJson</span><span class="params">(String json)</span>&#123;</span><br><span class="line">        json = json.trim();</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> json.substring(<span class="number">1</span>, json.length() - <span class="number">1</span>).trim();</span><br><span class="line">        <span class="keyword">if</span>(content.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] pairs = content.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(String pair: pairs)&#123;</span><br><span class="line">            pair = pair.trim();</span><br><span class="line">            String[] kv = pair.substring(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> kv[<span class="number">0</span>].trim().replaceAll(<span class="string">&quot;\&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> kv[<span class="number">1</span>].trim();</span><br><span class="line">            Object v;</span><br><span class="line">            <span class="keyword">if</span>(value.startsWith(<span class="string">&quot;&#123;&quot;</span>))&#123;</span><br><span class="line">                v = parseJson(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(valueStr.startsWith(<span class="string">&quot;\&quot;&quot;</span>))&#123;</span><br><span class="line">                v = value.substring(<span class="number">1</span>, valueStr.length() - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    v = Integer.parseInt(value);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        v = Double.parseDouble(value);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (NumberFormatException e2) &#123;</span><br><span class="line">                        <span class="comment">// 如果都不是，保持原样</span></span><br><span class="line">                        v = value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">(String json, String path)</span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = parseJson(json);</span><br><span class="line">        String[] keys = path.trim().split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">cur</span> <span class="operator">=</span> map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keys[i];</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isLastKey</span> <span class="operator">=</span> (i == keys.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!isLastKey)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!(cur <span class="keyword">instanceof</span> Map)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                cur = ((Map&lt;?, ?&gt;) cur).get(key);</span><br><span class="line">                <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ((Map&lt;?, ?&gt;) current).get(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        System.out.println(<span class="string">&quot;结果：&quot;</span> + getValue(json, path));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/a6efffa.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>手撕—带过期时间的LRU</title>
      <link>http://ltynote.cn/inori/17befa9.html</link>
      <guid>http://ltynote.cn/inori/17befa9.html</guid>
      <pubDate>Wed, 13 Aug 2025 06:38:59 GMT</pubDate>
      
      <description>面试专题——手撕</description>
      
      
      
      <content:encoded><![CDATA[<p>与传统的LUR类似，使用双向链表+哈希表来完成</p><ul><li><p>双向链表按照被使用顺序存储键值对，靠近头部的键值对是最近使用的，哈希表通过缓存数据的键映射到其在双向链表中的位置</p></li><li><p>对于get操作，首先判断key是否存在，如果key存在，再判断key是否过期，如未过期，则key对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值</p></li><li><p>对于put操作，首先清理所有过期的节点，再判断key是否存在，如果key不存在，使用key和value创建一个新的节点，在双向链表的头部添加该节点，并将key和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项。如果key存在，先通过哈希表定位，再将对应的节点的值更新为value，并将该节点移到双向链表的头部</p></li></ul><h2 id="以系统时间为基准"><a href="#以系统时间为基准" class="headerlink" title="以系统时间为基准"></a>以系统时间为基准</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkedList</span>&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">long</span> expireTime;</span><br><span class="line">    DLinkedList pre;</span><br><span class="line">    DLinkedList next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLinkedList</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLinkedList</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">long</span> ttlMillis)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.expireTime = System.currentTimeMillis() + ttlMillis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpirableLRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> cnt, capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedList head, tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedList&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ExpirableLRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.head = <span class="keyword">new</span> <span class="title class_">DLinkedList</span>();</span><br><span class="line">        <span class="built_in">this</span>.tail = <span class="keyword">new</span> <span class="title class_">DLinkedList</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedList node)</span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        map.remove(node.key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedList node)</span>&#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.next.pre = node;</span><br><span class="line">        map.put(node.key, node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedList node)</span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeTail</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        <span class="keyword">if</span>(node != head)&#123;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isExpired</span><span class="params">(DLinkedList node)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() &gt; node.expireTime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeExpiredNodes</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DLinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        <span class="keyword">while</span>(cur != head)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isExpired(cur))&#123;</span><br><span class="line">                <span class="type">DLinkedList</span> <span class="variable">pre</span> <span class="operator">=</span> cur.pre;</span><br><span class="line">                removeNode(cur);</span><br><span class="line">                map.remove(cur.key);</span><br><span class="line">                cnt --;</span><br><span class="line">                cur = pre;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span>(isExpired(node))&#123;</span><br><span class="line">                removeNode(node);</span><br><span class="line">                cnt --;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">long</span> ttlMillis)</span>&#123;</span><br><span class="line">        removeExpiredNodes();</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            node.expireTime = System.currentTimeMillis() + ttlMillis;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedList</span>(key, value, ttlMillis);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; capacity)&#123;</span><br><span class="line">                removeTail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逻辑过期时间"><a href="#逻辑过期时间" class="headerlink" title="逻辑过期时间"></a>逻辑过期时间</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">int</span> expireStep; <span class="comment">// 逻辑时间到期步数</span></span><br><span class="line">    DLinkedList pre, next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DLinkedList</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">int</span> expireStep)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.expireStep = expireStep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExpirableLRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentStep</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 逻辑时间步</span></span><br><span class="line">    <span class="keyword">private</span> DLinkedList head, tail;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedList&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StepLRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedList</span>(-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedList</span>(-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedList node)</span> &#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        map.remove(node.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedList node)</span> &#123;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">        map.put(node.key, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedList node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        <span class="keyword">if</span> (node != head) &#123;</span><br><span class="line">            removeNode(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeExpiredNodes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedList</span> <span class="variable">cur</span> <span class="operator">=</span> tail.pre;</span><br><span class="line">        <span class="keyword">while</span> (cur != head) &#123;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">pre</span> <span class="operator">=</span> cur.pre;</span><br><span class="line">            <span class="keyword">if</span> (cur.expireStep &lt;= currentStep) &#123;</span><br><span class="line">                removeNode(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        currentStep++;</span><br><span class="line">        removeExpiredNodes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value, <span class="type">int</span> ttlSteps)</span> &#123;</span><br><span class="line">        currentStep++;</span><br><span class="line">        removeExpiredNodes();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            node.expireStep = currentStep + ttlSteps;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">DLinkedList</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedList</span>(key, value, currentStep + ttlSteps);</span><br><span class="line">            addToHead(node);</span><br><span class="line">            <span class="keyword">if</span> (map.size() &gt; capacity) &#123;</span><br><span class="line">                removeTail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/17befa9.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>手撕—单例模式</title>
      <link>http://ltynote.cn/inori/c29b5d38.html</link>
      <guid>http://ltynote.cn/inori/c29b5d38.html</guid>
      <pubDate>Wed, 13 Aug 2025 06:16:41 GMT</pubDate>
      
      <description>面试专题——手撕</description>
      
      
      
      <content:encoded><![CDATA[<p>这里有两种实现方式，<strong>双重检查锁定(DCL)<strong>或</strong>静态内部类</strong></p><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// volatile保证可见性和禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Use getInstance() method to get the single instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次检查，避免不必要的同步</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 第二次检查，确保只有一个实例被创建</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一次检查发现实例为null时，进入同步块，确保只有一个线程能进入创建实例的代码</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 防止反射攻击</span></span><br><span class="line">        <span class="keyword">if</span> (SingletonHolder.INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Use getInstance() method to get the single instance&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM在类加载阶段会加锁，保证一个类只被加载一次，静态内部类<code>SingletonHolder</code>只有在被主动使用时才会加载，由JVM保证<code>INSTANCE</code>只被初始化一次</p><p>外部类加载时不会立即加载内部类，只有当调用<code>getInstance()</code>时才会触发<code>SingletonHolder</code>的加载</p>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/c29b5d38.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>SpringSecurity基础入门</title>
      <link>http://ltynote.cn/inori/a774566a.html</link>
      <guid>http://ltynote.cn/inori/a774566a.html</guid>
      <pubDate>Tue, 22 Jul 2025 06:08:57 GMT</pubDate>
      
      <description>SpringSecurity</description>
      
      
      
      <content:encoded><![CDATA[<p>Spring Security是一个功能强大且高度可定制的身份验证和访问控制框架</p><h2 id="SpringSecurity配置示例"><a href="#SpringSecurity配置示例" class="headerlink" title="SpringSecurity配置示例"></a>SpringSecurity配置示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">            .csrf(AbstractHttpConfigurer::disable) <span class="comment">// 关闭CSRF</span></span><br><span class="line">            .authorizeHttpRequests(auth -&gt; auth</span><br><span class="line">                .requestMatchers(<span class="string">&quot;/login&quot;</span>, <span class="string">&quot;/register&quot;</span>).permitAll()</span><br><span class="line">                .anyRequest().authenticated()</span><br><span class="line">            )</span><br><span class="line">            .formLogin(form -&gt; form</span><br><span class="line">                .loginPage(<span class="string">&quot;/login&quot;</span>) <span class="comment">// 自定义登录页</span></span><br><span class="line">                .defaultSuccessUrl(<span class="string">&quot;/home&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">                .permitAll()</span><br><span class="line">            )</span><br><span class="line">            .logout(LogoutConfigurer::permitAll);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> UserDetailsService <span class="title function_">userDetailsService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟用户信息（可换为从数据库中读取）</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;admin&quot;</span>.equals(username)) &#123;</span><br><span class="line">                <span class="keyword">return</span> User.withUsername(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                           .password(<span class="string">&quot;&#123;noop&#125;123456&quot;</span>) <span class="comment">// &#123;noop&#125;表示不加密</span></span><br><span class="line">                           .roles(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                           .build();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;User not found&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td>认证</td><td>验证“你是谁”，例如用户名密码登录</td></tr><tr><td>授权</td><td>验证“你是否有权限做某件事”，如访问某个接口或资源</td></tr><tr><td>攻击防护</td><td>防止常见攻击：CSRF、Session Fixation、点击劫持、密码暴力破解等</td></tr><tr><td>会话管理</td><td>登录用户的session管控，限制登录次数，踢出旧会话等</td></tr><tr><td>Remember-Me</td><td>实现“记住我”功能</td></tr><tr><td>与第三方认证集成</td><td>支持OAuth2 &#x2F; JWT &#x2F; OpenID Connect 认证</td></tr><tr><td>安全拦截链</td><td>通过过滤器链实现请求安全控制</td></tr></tbody></table><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><table><thead><tr><th>组件</th><th>说明</th></tr></thead><tbody><tr><td><code>SecurityFilterChain</code></td><td>安全过滤器链，是SpringSecurity的核心机制</td></tr><tr><td><code>AuthenticationManager</code></td><td>认证管理器，处理用户身份认证</td></tr><tr><td><code>UserDetailsService</code></td><td>用户数据获取接口，通常配合数据库实现</td></tr><tr><td><code>UserDetails</code></td><td>表示用户信息的接口（用户名、密码、权限）</td></tr><tr><td><code>GrantedAuthority</code></td><td>权限标识对象，通常是一个字符串</td></tr><tr><td><code>SecurityContextHolder</code></td><td>存储当前用户的认证信息（线程本地变量）</td></tr></tbody></table><h3 id="SecurityFilterChain"><a href="#SecurityFilterChain" class="headerlink" title="SecurityFilterChain"></a>SecurityFilterChain</h3><p>SpringSecurity的请求处理核心机制，是多个<code>Filter</code>的组合，每个请求都会通过这些过滤器进行处理，支持自定义过滤器链：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    http.authorizeHttpRequests(auth -&gt; auth.anyRequest().authenticated())</span><br><span class="line">        .formLogin(); <span class="comment">// 支持表单登录</span></span><br><span class="line">    <span class="keyword">return</span> http.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AuthenticationManager"><a href="#AuthenticationManager" class="headerlink" title="AuthenticationManager"></a>AuthenticationManager</h3><p>接收<code>Authentication</code>对象，负责认证过程，默认使用 <code>ProviderManager</code> 实现，它委托多个<code>AuthenticationProvider</code>去完成具体认证，<code>AuthenticationProvider</code>用于执行真正的认证逻辑，内置的<code>DaoAuthenticationProvider</code>使用用户名 + 密码来做认证</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">AuthenticationManager</span> <span class="variable">authManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProviderManager</span>(List.of(customProvider));</span><br></pre></td></tr></table></figure><h3 id="UserDetailsService-UserDetails"><a href="#UserDetailsService-UserDetails" class="headerlink" title="UserDetailsService + UserDetails"></a>UserDetailsService + UserDetails</h3><p><code>UserDetailsService</code>提供用户数据的服务，定义了如何根据用户名加载用户信息</p><p><code>UserDetails</code>是你返回的用户对象，必须包含用户名、密码、权限等字段</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 假设从数据库查到了用户</span></span><br><span class="line">        <span class="keyword">return</span> User.builder()</span><br><span class="line">                .username(<span class="string">&quot;admin&quot;</span>)</span><br><span class="line">                .password(passwordEncoder().encode(<span class="string">&quot;123456&quot;</span>))</span><br><span class="line">                .roles(<span class="string">&quot;ADMIN&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GrantedAuthority"><a href="#GrantedAuthority" class="headerlink" title="GrantedAuthority"></a>GrantedAuthority</h3><p>表示当前用户所拥有的权限&#x2F;角色,SpringSecurity默认会将角色前缀加上<code>ROLE_</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GrantedAuthority</span> <span class="variable">authority</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(<span class="string">&quot;ROLE_ADMIN&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="SecurityContextHolder"><a href="#SecurityContextHolder" class="headerlink" title="SecurityContextHolder"></a>SecurityContextHolder</h3><p>用于保存当前登录用户的认证信息（线程安全的ThreadLocal），可在任何地方获取当前用户</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Authentication</span> <span class="variable">auth</span> <span class="operator">=</span> SecurityContextHolder.getContext().getAuthentication();</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> auth.getName();</span><br></pre></td></tr></table></figure><h3 id="注解权限控制"><a href="#注解权限控制" class="headerlink" title="注解权限控制"></a>注解权限控制</h3><p>需要启用@EnableMethodSecurity，常用注解：</p><table><thead><tr><th>注解</th><th>作用</th></tr></thead><tbody><tr><td><code>@PreAuthorize(&quot;hasRole(&#39;ADMIN&#39;)&quot;)</code></td><td>方法执行前权限检查</td></tr><tr><td><code>@PostAuthorize</code></td><td>方法执行后权限检查</td></tr><tr><td><code>@Secured(&quot;ROLE_USER&quot;)</code></td><td>基于角色</td></tr><tr><td><code>@RolesAllowed(&quot;ADMIN&quot;)</code></td><td>JSR-250标准注解</td></tr></tbody></table><h3 id="Session会话管理"><a href="#Session会话管理" class="headerlink" title="Session会话管理"></a>Session会话管理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sessionManagement(session -&gt; session</span><br><span class="line">    .maximumSessions(<span class="number">1</span>)         <span class="comment">// 只允许一个登录会话</span></span><br><span class="line">    .maxSessionsPreventsLogin(<span class="literal">true</span>)) <span class="comment">// 后一个登录失败</span></span><br></pre></td></tr></table></figure><h3 id="与JWT结合"><a href="#与JWT结合" class="headerlink" title="与JWT结合"></a>与JWT结合</h3><p>jwt登录过滤器，用户登录时认证：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtLoginFilter</span> <span class="keyword">extends</span> <span class="title class_">UsernamePasswordAuthenticationFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JwtLoginFilter</span><span class="params">(AuthenticationManager authenticationManager)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">        setFilterProcessesUrl(<span class="string">&quot;/login&quot;</span>); <span class="comment">// 登录路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span></span><br><span class="line">            <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">LoginRequest</span> <span class="variable">creds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().readValue(req.getInputStream(), LoginRequest.class);</span><br><span class="line">            <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">token</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(creds.getUsername(), creds.getPassword());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> authenticationManager.authenticate(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录成功后生成 JWT</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest req,</span></span><br><span class="line"><span class="params">                                            HttpServletResponse res,</span></span><br><span class="line"><span class="params">                                            FilterChain chain,</span></span><br><span class="line"><span class="params">                                            Authentication auth)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> JwtUtils.generateToken(auth.getName());</span><br><span class="line">        res.addHeader(<span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Bearer &quot;</span> + token);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jwt校验过滤器，解析请求头中 token：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtAuthFilter</span> <span class="keyword">extends</span> <span class="title class_">OncePerRequestFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">                                    HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                    FilterChain filterChain)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">header</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (header != <span class="literal">null</span> &amp;&amp; header.startsWith(<span class="string">&quot;Bearer &quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> header.replace(<span class="string">&quot;Bearer &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (JwtUtils.validateToken(token)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> JwtUtils.getUsernameFromToken(token);</span><br><span class="line">                <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authToken</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line"></span><br><span class="line">                SecurityContextHolder.getContext().setAuthentication(authToken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SpringSecurity测试"><a href="#SpringSecurity测试" class="headerlink" title="SpringSecurity测试"></a>SpringSecurity测试</h3><p><code>@WithMockUser</code>是SpringSecurity提供的一个测试注解，用于在单元测试或集成测试中模拟一个已认证的用户，使得测试环境下无需实际登录即可进行权限校验。</p><h4 id="使用背景"><a href="#使用背景" class="headerlink" title="使用背景"></a>使用背景</h4><p>在用Spring Boot+Spring Security开发应用时，我们常需要测试某些受保护的接口，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/admin&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasRole(&#x27;ADMIN&#x27;)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">adminPage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不设置用户上下文，直接访问这个接口的测试方法会返回 <code>403 Forbidden</code>。这时候 <code>@WithMockUser</code> 就能派上用场</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@AutoConfigureMockMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminControllerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@WithMockUser(username = &quot;testuser&quot;, roles = &#123;&quot;ADMIN&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">adminPage_shouldReturnOk_forAdminUser</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        mockMvc.perform(get(<span class="string">&quot;/admin&quot;</span>))</span><br><span class="line">               .andExpect(status().isOk());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注解参数"><a href="#注解参数" class="headerlink" title="注解参数"></a>注解参数</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>username</code></td><td>模拟用户的用户名，默认是 “user”</td></tr><tr><td><code>password</code></td><td>模拟用户的密码（仅用于显示，无实际用途）</td></tr><tr><td><code>roles</code></td><td>角色，最终会自动加前缀 <code>&quot;ROLE_&quot;</code></td></tr><tr><td><code>authorities</code></td><td>权限，比 <code>roles</code> 更细粒度控制（不加前缀）</td></tr></tbody></table><ul><li><code>roles = &#123;&quot;ADMIN&quot;&#125;</code>实际注入的是<code>&quot;ROLE_ADMIN&quot;</code></li><li><code>roles</code>和<code>authorities</code>不能同时使用，只能用一个</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul><li><code>@WithMockUser</code>是通过<code>SecurityContextHolder</code>注入一个<code>UsernamePasswordAuthenticationToken</code>到当前测试线程上下文中</li><li>在<code>MockMvc</code>执行测试时，Spring Security会自动从<code>SecurityContextHolder</code>中获取已设置的用户认证信息</li></ul><h2 id="执行流程（表单登录为例）"><a href="#执行流程（表单登录为例）" class="headerlink" title="执行流程（表单登录为例）"></a>执行流程（表单登录为例）</h2><ol><li>用户访问受保护资源 → 被过滤器拦截</li><li>若未登录，跳转到登录页面</li><li>用户提交用户名和密码</li><li><code>UsernamePasswordAuthenticationFilter</code>拦截登录请求</li><li>交给<code>AuthenticationManager</code>进行身份验证</li><li><code>UserDetailsService</code>加载用户信息并校验密码</li><li>验证成功，将认证信息存入<code>SecurityContextHolder</code></li><li>之后所有请求都带上用户身份，可以访问授权资源</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="过滤器和拦截器"><a href="#过滤器和拦截器" class="headerlink" title="过滤器和拦截器"></a>过滤器和拦截器</h3><table><thead><tr><th>项目</th><th>Filter（过滤器）</th><th>Interceptor（拦截器）</th></tr></thead><tbody><tr><td>所属规范</td><td>Servlet 规范（JavaEE）</td><td>Spring MVC 组件</td></tr><tr><td>作用范围</td><td>所有请求（包括静态资源、DispatcherServlet前）</td><td>Spring MVC 控制器处理的请求</td></tr><tr><td>执行位置</td><td>早于DispatcherServlet</td><td>DispatcherServlet之后，<strong>只拦截Controller请求</strong></td></tr><tr><td>应用场景</td><td>安全认证、请求日志、编码处理、权限校验（全局）</td><td>登录拦截、权限校验、业务预处理（Controller层面）</td></tr><tr><td>配置方式</td><td><code>@WebFilter</code>或<code>FilterRegistrationBean</code></td><td>实现<code>HandlerInterceptor</code>接口</td></tr><tr><td>执行顺序控制</td><td>通过<code>@Order</code>或<code>FilterChain</code>顺序控制</td><td><code>WebMvcConfigurer.addInterceptors()</code>顺序配置</td></tr></tbody></table><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">    ┌────────────────────────────┐</span><br><span class="line">    │      前端请求进入服务器       │</span><br><span class="line">    └────────────────────────────┘</span><br><span class="line">                  ↓</span><br><span class="line">   <span class="selector-attr">[Filter 1]</span> --&gt; 前置逻辑</span><br><span class="line">                  ↓</span><br><span class="line">   <span class="selector-attr">[Filter 2]</span> --&gt; 前置逻辑</span><br><span class="line">                  ↓</span><br><span class="line">┌──── DispatcherServlet (Spring MVC) ────┐</span><br><span class="line">│               ↓                        │</span><br><span class="line">│      <span class="selector-attr">[Interceptor 1]</span> <span class="built_in">preHandle</span>()       │</span><br><span class="line">│               ↓                        │</span><br><span class="line">│      <span class="selector-attr">[Interceptor 2]</span> <span class="built_in">preHandle</span>()       │</span><br><span class="line">│               ↓                        │</span><br><span class="line">│           Controller 方法              │</span><br><span class="line">│               ↑                        │</span><br><span class="line">│      <span class="selector-attr">[Interceptor 2]</span> <span class="built_in">postHandle</span>()      │</span><br><span class="line">│      <span class="selector-attr">[Interceptor 1]</span> <span class="built_in">postHandle</span>()      │</span><br><span class="line">└───────────────↑────────────────────────┘</span><br><span class="line">                  ↑</span><br><span class="line">   <span class="selector-attr">[Filter 2]</span> --&gt; 后置逻辑</span><br><span class="line">                  ↑</span><br><span class="line">   <span class="selector-attr">[Filter 1]</span> --&gt; 后置逻辑</span><br><span class="line">                  ↑</span><br><span class="line">        响应返回到客户端</span><br></pre></td></tr></table></figure><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><table><thead><tr><th>比较维度</th><th>Filter</th><th>Interceptor</th></tr></thead><tbody><tr><td>基于机制</td><td>Servlet API</td><td>Spring MVC 拦截器链</td></tr><tr><td>是否依赖 Spring</td><td>无需依赖 Spring，可用于非 Spring 项目</td><td>只适用于 Spring 环境</td></tr><tr><td>本质实现</td><td>继承 <code>javax.servlet.Filter</code> 接口</td><td>实现 <code>HandlerInterceptor</code> 接口</td></tr><tr><td>是否可拦截静态资源</td><td>是，能拦截所有HTTP请求</td><td>不能拦截静态资源</td></tr><tr><td>是否能拿到Controller方法信息</td><td>拿不到</td><td>拿得到（<code>HandlerMethod</code>）</td></tr><tr><td>适用粒度</td><td>适合系统层面拦截（如 XSS、防盗链、日志）</td><td>适合业务层面拦截（如用户登录、角色权限）</td></tr></tbody></table><h4 id="SpringSecurity是基于什么实现的"><a href="#SpringSecurity是基于什么实现的" class="headerlink" title="SpringSecurity是基于什么实现的"></a>SpringSecurity是基于什么实现的</h4><p>Spring Security是基于Servlet的Filter实现的</p><ul><li>Spring Security 的设计目标是“请求级安全防护”，要在DispatcherServlet之前就拦截请求，包括静态资源、API、文件上传、非法访问等</li><li>若等到拦截器阶段再处理，控制粒度太晚，系统容易被绕过</li></ul><h3 id="springsecurity有几种权限控制机制"><a href="#springsecurity有几种权限控制机制" class="headerlink" title="springsecurity有几种权限控制机制"></a>springsecurity有几种权限控制机制</h3><ul><li>基于URL的权限控制，根据请求的路径来控制访问权限</li><li>基于方法的权限控制（注解方式）：@PreAuthorize、@PostAuthorize、@Secured、@RolesAllowed等</li><li>基于注解表达式的权限控制（SpEL表达式）</li><li>基于权限标签的控制（结合前端Thymeleaf）</li></ul><h3 id="springsecurity有什么过滤器"><a href="#springsecurity有什么过滤器" class="headerlink" title="springsecurity有什么过滤器"></a>springsecurity有什么过滤器</h3><p>Spring Security的核心是一条由多个过滤器组成的过滤器链，常用的有</p><ul><li>WebAsyncManagerIntegrationFilter（将Security上下文与异步线程绑定）</li><li>SecurityContextPersistenceFilter（加载<code>SecurityContext</code>到<code>SecurityContextHolder</code>）</li><li>CorsFilter（处理跨域请求）</li><li>UsernamePasswordAuthenticationFilter（登录处理）</li><li>LogoutFilter（处理登出逻辑）</li><li>BearerTokenAuthenticationFilter（处理Bearer Token认证）</li><li>OAuth2LoginAuthenticationFilter（处理OAuth2登录）</li><li>SessionManagementFilter（管理 Session）</li><li>FilterSecurityInterceptor（授权过滤器）</li></ul>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/java/">java</category>
      
      
      <category domain="http://ltynote.cn/tags/java/">java</category>
      
      
      <comments>http://ltynote.cn/inori/a774566a.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JUnit与Mockito测试框架入门</title>
      <link>http://ltynote.cn/inori/a2118cb.html</link>
      <guid>http://ltynote.cn/inori/a2118cb.html</guid>
      <pubDate>Mon, 21 Jul 2025 02:02:43 GMT</pubDate>
      
      <description>Java单元测试</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p>测试过程按照阶段划分可以分为：</p><ol><li><p>单元测试：对程序模块进行输出正确性检验</p></li><li><p>集成测试：在单元测试基础上，整合各个模块组成子系统，进行集成测试</p></li><li><p>系统测试：将整个交付所涉及的协作内容都纳入其中考虑，包含硬件、软件、接口、操作等等一系列作为一个整体，检验是否满足软件或需求说明</p></li><li><p>验收测试：在交付或者发布之前对所做的工作进行测试检验</p></li></ol><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>单元测试是阶段性测试的首要环节，也是白盒测试的一种，该内容的编写与实践可以前置在研发完成，研发在编写业务代码的时候就需要生成对应代码的单元测试。单元测试其实是针对软件中最小的测试单元来进行验证的。这里的单元就是指相关的功能子集，比如一个方法、一个类等。值得注意的是作为最低级别的测试活动，单元测试验证的对象仅限于当前测试内容，与程序其它部分内容相隔离</p><p>单元测试有以下特征：</p><ol><li><p>主要功能是证明编写的代码内容与期望输出一致</p></li><li><p>最小最低级的测试内容，保证程序基本组件正常</p></li><li><p>单元测试尽量不区分类与方法，主张以过程性的方法为测试单位</p></li><li><p>专注于测试一小块的代码，保证基础功能</p></li><li><p>剥离与外部接口、存储之间的依赖，使单元测试可控</p></li><li><p>任何时间任何顺序执行单元测试都需要是成功的</p></li></ol><h2 id="JUnit"><a href="#JUnit" class="headerlink" title="JUnit"></a>JUnit</h2><p>JUnit是一个用于编写可重复测试的简单框架。它是用于单元测试框架的xUnit体系结构的一个实例</p><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><table><thead><tr><th align="left">名称</th><th align="left">功能作用</th></tr></thead><tbody><tr><td align="left">Assert</td><td align="left">断言方法集合</td></tr><tr><td align="left">TestCase</td><td align="left">表示一个测试案例</td></tr><tr><td align="left">TestSuite</td><td align="left">包含一组TestCase，构成一组测试</td></tr><tr><td align="left">TestResult</td><td align="left">收集测试结果</td></tr></tbody></table><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>JUnit的断言主要由<code>org.junit.jupiter.api.Assertions</code>提供</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>assertEquals(expected, actual)</td><td>判断两个值是否相等</td></tr><tr><td>assertNotEquals(expected, actual)</td><td>判断两个值是否不相等</td></tr><tr><td>assertTrue(condition)</td><td>判断一个条件是否为 true</td></tr><tr><td>assertFalse(condition)</td><td>判断一个条件是否为 false</td></tr><tr><td>assertNull(object)</td><td>判断对象是否为 null</td></tr><tr><td>assertNotNull(object)</td><td>判断对象是否不为 null</td></tr><tr><td>assertSame(expected, actual)</td><td>判断两个对象是否引用同一个实例</td></tr><tr><td>assertNotSame(expected, actual)</td><td>判断两个对象是否不是同一个实例</td></tr><tr><td>assertArrayEquals(expectedArray, actualArray)</td><td>判断两个数组内容是否完全相等</td></tr><tr><td>assertThrows(Exception.class, () -&gt; code)</td><td>断言某段代码抛出指定异常</td></tr><tr><td>fail(“message”)</td><td>强制让测试失败</td></tr></tbody></table><p>所有断言方法都可以添加第三个参数作为失败时的提示信息，便于定位错误：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertEquals(<span class="number">10</span>, result, <span class="string">&quot;计算结果不符合预期&quot;</span>);</span><br></pre></td></tr></table></figure><p>或者使用延迟消息构造：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">assertEquals(<span class="number">10</span>, result, () -&gt; <span class="string">&quot;result 应为 10，但实际是 &quot;</span> + result);</span><br></pre></td></tr></table></figure><p>这样只有当断言失败时才会调用lambda构造提示信息，提高性能</p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>表示一个测试方法</td></tr><tr><td>@BeforeEach</td><td>每个测试方法执行前执行（类似 JUnit4 的 <code>@Before</code>）</td></tr><tr><td>@AfterEach</td><td>每个测试方法执行后执行</td></tr><tr><td>@BeforeAll</td><td>所有测试前执行一次（需为 static）</td></tr><tr><td>@AfterAll</td><td>所有测试后执行一次（需为 static）</td></tr><tr><td>@DisplayName</td><td>给测试用例起一个更可读的名字</td></tr><tr><td>@Disabled</td><td>暂时禁用某个测试方法</td></tr></tbody></table><h4 id="BeforeEach、BeforeAll、AfterEach、AfterAll的区别"><a href="#BeforeEach、BeforeAll、AfterEach、AfterAll的区别" class="headerlink" title="BeforeEach、BeforeAll、AfterEach、AfterAll的区别"></a>BeforeEach、BeforeAll、AfterEach、AfterAll的区别</h4><ul><li>BeforeEach是每个测试方法执行前执行一次，适合初始化测试对象</li><li>BeforeAll是只无论多少个测试方法，都只执行一次，适合加载公共资源</li><li>AfterEach是每个测试方法后执行一次，可以清理mock状态、删除临时文件、回滚测试数据</li><li>AfterAll是所有测试结束后执行一次，可以关闭数据库连接、删除全局缓存、输出整体测试报告、</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beforeAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;== BeforeAll：初始化数据库连接池 ==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">beforeEach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-- BeforeEach：新建测试数据 --&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 test1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行 test2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterEach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;-- AfterEach：清理测试数据 --&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterAll</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">afterAll</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;== AfterAll：释放数据库连接池 ==&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@BeforeEach&#x2F;@AfterEach和@Test一样，作用于每个测试用例，适合每个方法都需要初始化&#x2F;清理的场景</p><p>@BeforeAll&#x2F;@AfterAll是整个测试类级别的初始化&#x2F;清理，更适合执行前后全局配置资源或统计信息的处理</p><h2 id="Mockito"><a href="#Mockito" class="headerlink" title="Mockito"></a>Mockito</h2><p>在实际开发中，我们常常需要测试某个类或方法的行为，但这些行为可能依赖于其他复杂的外部对象（如数据库、网络服务等）。为了隔离这些依赖，我们可以使用<strong>Mock</strong>对象（伪对象）。Mockito是一个用于创建mock对象的测试框架，适用于：</p><ul><li>模拟Service、DAO、远程调用等依赖</li><li>断言依赖对象的调用方式</li><li>编写真正“单元级”的测试，而不是集成测试</li></ul><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Mock</td><td>模拟一个类的对象，只保留你关心的方法行为</td></tr><tr><td>Stub</td><td>给mock的方法设置固定返回值</td></tr><tr><td>Verify</td><td>验证某个方法是否被调用、调用次数、传参是否符合预期</td></tr><tr><td>Spy</td><td>真实对象的包装器，可部分mock，适用于部分逻辑保持原样</td></tr><tr><td>Injection</td><td>把mock对象注入到被测试类中，通常结合注解@InjectMocks使用</td></tr></tbody></table><h3 id="常用注解-1"><a href="#常用注解-1" class="headerlink" title="常用注解"></a>常用注解</h3><ul><li>@Mock：创建mock对象</li><li>@InjectMocks：自动将@Mock注入到被测试对象中</li><li>@Spy：创建spy对象（保留原逻辑，可选定mock部分）</li><li>@Captor：用于捕获方法调用的参数</li></ul><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法&#x2F;语法</th><th>含义</th></tr></thead><tbody><tr><td>mock(Class.class)</td><td>创建一个mock对象</td></tr><tr><td>when(xxx).thenReturn(val)</td><td>设置方法返回值（stub）</td></tr><tr><td>verify(obj).method()</td><td>验证方法是否被调用</td></tr><tr><td>doReturn(x).when(obj).method()</td><td>用于spy中设置行为（避免调用真实方法）</td></tr><tr><td>doThrow(ex).when(obj).method()</td><td>设置方法抛出异常</td></tr><tr><td>any(), eq(x)</td><td>参数匹配器，用于模糊匹配参数</td></tr></tbody></table><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设有如下业务逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用Mockito测试而不用真的访问数据库：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.*;</span><br><span class="line"><span class="keyword">import</span> com.project.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    UserDao userDao;</span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">        MockitoAnnotations.openMocks(<span class="built_in">this</span>); <span class="comment">// 初始化 @Mock/@InjectMocks</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testGetUserById</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Stub 返回值</span></span><br><span class="line">        when(userDao.findById(<span class="number">1</span>)).thenReturn(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;Alice&quot;</span>));</span><br><span class="line">        <span class="comment">// 调用测试方法</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">result</span> <span class="operator">=</span> userService.getUserById(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 验证调用和结果</span></span><br><span class="line">        verify(userDao).findById(<span class="number">1</span>);</span><br><span class="line">        assertEquals(<span class="string">&quot;Alice&quot;</span>, result.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spy和Mock的区别"><a href="#Spy和Mock的区别" class="headerlink" title="Spy和Mock的区别"></a>Spy和Mock的区别</h4><table><thead><tr><th>对象类型</th><th>调用方法时行为</th><th>适用场景</th></tr></thead><tbody><tr><td><code>mock()</code></td><td>所有方法默认无效（返回默认值）</td><td>完全隔离依赖</td></tr><tr><td><code>spy()</code></td><td>保留原逻辑，部分方法可被stub</td><td>测试部分真实逻辑、或已有对象的包装</td></tr></tbody></table><h4 id="调用次数验证"><a href="#调用次数验证" class="headerlink" title="调用次数验证"></a>调用次数验证</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java复制编辑verify(userDao, times(2)).findById(1);</span><br><span class="line">verify(userDao, never()).delete(anyInt());</span><br><span class="line">verify(userDao, atLeastOnce()).findById(anyInt());</span><br></pre></td></tr></table></figure><h4 id="AAA原则"><a href="#AAA原则" class="headerlink" title="AAA原则"></a>AAA原则</h4><ol><li>Arrange：布置场景（mock&#x2F;stub）</li><li>Act：执行操作</li><li>Assert：断言结果 + verify行为</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLoginSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Arrange</span></span><br><span class="line">    when(authClient.verify(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;pass&quot;</span>)).thenReturn(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Act</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> loginService.login(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;pass&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assert</span></span><br><span class="line">    assertTrue(result);</span><br><span class="line">    verify(authClient).verify(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;pass&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot-JUnit-Mockito结合使用示例"><a href="#Spring-Boot-JUnit-Mockito结合使用示例" class="headerlink" title="Spring Boot+JUnit+Mockito结合使用示例"></a>Spring Boot+JUnit+Mockito结合使用示例</h2><p>模拟一个用户注册服务的真实开发场景，进行测试</p><h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>有一个<code>UserService</code>类用于注册用户，它依赖于：</p><ul><li><code>UserDao</code>：用户数据库操作接口</li><li><code>EmailService</code>：注册成功后发送欢迎邮件</li></ul><p>现在要测试<code>UserService.register(user)</code>方法是否：</p><ol><li>成功保存用户</li><li>发送了邮件</li><li>对重复注册用户抛出异常</li></ol><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Boot Test，包含JUnit 5、AssertJ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Mockito Core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- Mockito for JUnit 5 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mockito<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mockito-junit-jupiter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.11.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p>用户实体类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>UserDao接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    User <span class="title function_">findByEmail</span><span class="params">(String email)</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MailService接口（省略实现类）：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sendWelcomeEmail</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserService类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(UserDao userDao, MailService mailService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">        <span class="built_in">this</span>.mailService = mailService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (userDao.findByEmail(user.getEmail()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserAlreadyExistsException</span>(<span class="string">&quot;User already exists&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        userDao.insert(user);</span><br><span class="line">        mailService.sendWelcomeEmail(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUnit + Mockito测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ExtendWith(MockitoExtension.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> User newUser;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        newUser = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        newUser.setEmail(<span class="string">&quot;test@example.com&quot;</span>);</span><br><span class="line">        newUser.setPassword(<span class="string">&quot;securePassword&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testRegisterSuccess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 用户不存在</span></span><br><span class="line">        Mockito.when(userDao.findByEmail(newUser.getEmail())).thenReturn(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        userService.register(newUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证调用了保存方法</span></span><br><span class="line">        Mockito.verify(userDao).insert(newUser);</span><br><span class="line">        <span class="comment">// 验证发送了邮件</span></span><br><span class="line">        Mockito.verify(mailService).sendWelcomeEmail(newUser);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testRegister_UserAlreadyExists_ShouldThrowException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 用户已存在</span></span><br><span class="line">        Mockito.when(userDao.findByEmail(newUser.getEmail())).thenReturn(newUser);</span><br><span class="line"></span><br><span class="line">        Assertions.assertThrows(UserAlreadyExistsException.class, () -&gt; &#123;</span><br><span class="line">            userService.register(newUser);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证未保存</span></span><br><span class="line">        Mockito.verify(userDao, Mockito.never()).insert(Mockito.any());</span><br><span class="line">        <span class="comment">// 验证未发送邮件</span></span><br><span class="line">        Mockito.verify(mailService, Mockito.never()).sendWelcomeEmail(Mockito.any());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试</category>
      
      
      <category domain="http://ltynote.cn/tags/java/">java</category>
      
      
      <comments>http://ltynote.cn/inori/a2118cb.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>OSS与优化基础入门</title>
      <link>http://ltynote.cn/inori/6b394c8.html</link>
      <guid>http://ltynote.cn/inori/6b394c8.html</guid>
      <pubDate>Sun, 20 Jul 2025 02:30:13 GMT</pubDate>
      
      <description>oss入门</description>
      
      
      
      <content:encoded><![CDATA[<p>OSS（Object Storage Service）是阿里云提供的海量、安全、低成本的云存储服务，用于存储和管理任意类型的文件（如图片、视频、文档等）</p><p>特点：</p><ul><li>无限容量：按需扩展，无需提前规划存储空间</li><li>高可靠性：数据多副本存储，保障持久性</li><li>低成本：按实际使用量付费，无闲置费用</li><li>高并发访问：支持CDN加速，适合大流量场景</li></ul><p>能解决什么问题？</p><ul><li>文件存储与管理：替代自建文件服务器，避免运维成本</li><li>静态资源托管：存储网站图片、视频等静态资源，提升加载速度</li><li>备份与归档：长期保存日志、数据库备份等冷数据</li><li>跨地域访问：结合CDN实现全球加速</li></ul><h2 id="OSS的组成"><a href="#OSS的组成" class="headerlink" title="OSS的组成"></a>OSS的组成</h2><p>OSS的存储结构相当于windows的盘符中，不创建文件夹，而是把所有文件都堆到一块</p><h3 id="Bucket-存储桶"><a href="#Bucket-存储桶" class="headerlink" title="Bucket (存储桶)"></a>Bucket (存储桶)</h3><p>在初始化oss容器时就需要指定，在OSS全局命名空间中必须有唯一名称，支持私有（只有Bucket拥有者可以读写，其他用户无权限）、公共读（Bucket拥有者可读写，匿名用户可读，知道对象URL即可下载）、公共读写（Bucket拥有者可读写，匿名用户可读写，可上传&#x2F;删除&#x2F;覆盖对象）三种ACL权限</p><ul><li>相当于文件系统中的”顶级目录”</li><li>是存储对象的容器</li><li>创建时可以指定区域(Region)，数据会物理存储在该区域</li><li>可以设置自动转换存储类型(标准→低频访问→归档)</li><li>可以设置自动过期删除规则</li></ul><h3 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object (对象)"></a>Object (对象)</h3><p>虽然OSS控制台显示类似目录的结构，但实际上OSS内部是扁平存储结构，目录是通过Object Key中的”&#x2F;“字符模拟的，即列出目录内容时，OSS服务端会做前缀匹配</p><ul><li>相当于文件系统中的”文件”</li><li>包含三个部分：<ul><li>Key (对象键&#x2F;文件名)</li><li>Data (数据内容)</li><li>Metadata (元数据)</li></ul></li></ul><h3 id="与Windows文件系统对比"><a href="#与Windows文件系统对比" class="headerlink" title="与Windows文件系统对比"></a>与Windows文件系统对比</h3><table><thead><tr><th align="center">特性</th><th align="center">阿里云 OSS</th><th align="center">Windows 文件系统</th></tr></thead><tbody><tr><td align="center"><strong>组织结构</strong></td><td align="center">扁平结构(只有Bucket和Object两级)</td><td align="center">树状结构(多级目录)</td></tr><tr><td align="center"><strong>目录概念</strong></td><td align="center">通过Key中的”&#x2F;“模拟目录(实际不存在真实目录)</td><td align="center">真实存在的目录结构</td></tr><tr><td align="center"><strong>访问方式</strong></td><td align="center">RESTful API、SDK、控制台</td><td align="center">文件系统API、资源管理器</td></tr><tr><td align="center"><strong>元数据</strong></td><td align="center">每个Object有独立的元数据</td><td align="center">文件属性与文件内容分离</td></tr><tr><td align="center"><strong>性能</strong></td><td align="center">高并发访问性能好</td><td align="center">单机文件系统性能有限</td></tr><tr><td align="center"><strong>扩展性</strong></td><td align="center">理论上无限扩展</td><td align="center">受单机存储容量限制</td></tr></tbody></table><h2 id="数据写入流程"><a href="#数据写入流程" class="headerlink" title="数据写入流程"></a>数据写入流程</h2><p>客户端调用oss的sdk，发送http请求到OSS网关中，前端服务器接收HTTP请求，对数据进行流式处理，然后路由到对应的bucket，写入Object</p><p>持久化过程中，oss会对写入的数据进行数据分块（默认4MB&#x2F;块），并行写入多个存储节点，还会有分层存储的逻辑，可以在oss控制台配置冷热数据逻辑：</p><ul><li>热数据：保留在SSD缓存层</li><li>温数据：存储在HDD层</li><li>冷数据：下沉到归档存储</li></ul><h2 id="上传速度优化"><a href="#上传速度优化" class="headerlink" title="上传速度优化"></a>上传速度优化</h2><p>OSS在单连接上传时，通常可达50-200Mbps，多线程并发上传时，最高可达5Gbps</p><p>对速度要求不是非常高时，可以使用单连接上传，配合线程池进行优化，在我的技术选型中，我使用了单连接+OkHttpClient进行吞吐优化</p><h3 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h3><p>OkHttpClient是一个高性能、支持HTTP&#x2F;HTTPS的Java网络请求客户端库，常用于：</p><ul><li>调用REST接口</li><li>发送文件或表单</li><li>下载文件&#x2F;数据流</li><li>和OSS等第三方云服务通信</li></ul><p>OkHttpClient本身是线程安全的，是一个连接复用+异步调度的客户端，它内部包含：</p><ul><li>连接池（ConnectionPool）：复用TCP连接，减少握手开销</li><li>调度器（Dispatcher）：管理请求队列和异步执行</li><li>线程池（ExecutorService）：用于调度异步任务，允许发起多个异步请求而不会阻塞主线程，并提高网络IO的吞吐量</li><li>失败重试：提升弱网稳定性</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>引入sdk依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>oss配合OkHttpClient使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>().newBuilder()</span><br><span class="line">    .dispatcher(<span class="keyword">new</span> <span class="title class_">Dispatcher</span>(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">10</span>,<span class="number">60L</span>,TimeUnit.SECONDS,<span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>(),Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>))))</span><br><span class="line">    .writeTimeout(<span class="number">30</span>, TimeUnit.MINUTES)</span><br><span class="line">    .readTimeout(<span class="number">30</span>, TimeUnit.MINUTES)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">uploadInnerFile</span><span class="params">(String url, String filePath, String bucketName, String objectName, String apiToken)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">RequestBody</span> <span class="variable">requestBody</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipartBody</span>.Builder()</span><br><span class="line">        .setType(MultipartBody.FORM)</span><br><span class="line">        .addFormDataPart(<span class="string">&quot;file&quot;</span>, UUID.randomUUID().toString(),</span><br><span class="line">            RequestBody.create(MediaType.parse(<span class="string">&quot;multipart/form-data&quot;</span>), <span class="keyword">new</span> <span class="title class_">File</span>(filePath)))</span><br><span class="line">        .addFormDataPart(<span class="string">&quot;objectName&quot;</span>,objectName)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .header(<span class="string">&quot;accessToken&quot;</span>,apiToken)</span><br><span class="line">        .header(<span class="string">&quot;bucketName&quot;</span>, bucketName)</span><br><span class="line">        .header(<span class="string">&quot;objectName&quot;</span>, objectName)</span><br><span class="line">        .url(url)</span><br><span class="line">        .post(requestBody)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute(); <span class="comment">// 同步请求</span></span><br><span class="line">    <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/oss/">oss</category>
      
      
      <category domain="http://ltynote.cn/tags/oss/">oss</category>
      
      
      <comments>http://ltynote.cn/inori/6b394c8.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>常见问题汇总（持续更新中）</title>
      <link>http://ltynote.cn/inori/c92e9465.html</link>
      <guid>http://ltynote.cn/inori/c92e9465.html</guid>
      <pubDate>Thu, 05 Jun 2025 11:11:44 GMT</pubDate>
      
      <description>面试专题——八股篇</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="你项目中用到了哪些设计模式"><a href="#你项目中用到了哪些设计模式" class="headerlink" title="你项目中用到了哪些设计模式"></a>你项目中用到了哪些设计模式</h2><p>在线程池的创建，Zookeeper客户端的创建使用到的单例模式，避免重复创建</p><p>创建序列化器，编解码器用到了工厂模式，根据用户配置创建不同的序列化方式</p><p>在实现不同序列化方式的时候用到了策略模式，把不同序列化方式封装成一个策略，实现统一接口</p><p>小程序项目中使用注解+AOP实现权限控制，本质是基于代理方法在方法调用前做拦截，用到了代理模式</p><p>在RPC框架中注册中心监听节点变化用到了观察者模式</p><h2 id="Spring中用到了哪些设计模式"><a href="#Spring中用到了哪些设计模式" class="headerlink" title="Spring中用到了哪些设计模式"></a>Spring中用到了哪些设计模式</h2><p>Bean的创建是单例的，用到了单例模式</p><p>Bean的管理使用的BeanFactory，用到了工厂模式</p><p>Bean的注入用到了原型模式，每次注入新实例</p><p>通用逻辑的封装，比如JdbcTemplate，用到了模板方法模式</p><p>Spring事件监听机制用到了观察者模式</p><p>SpringMVC的拦截器、过滤器链用到了责任链模式</p><p>Bean的生命周期管理用到了状态模式</p><p>AOP用到了代理模式</p><p>SpringMVC的HandlerAdapter适配不同Controller用到了适配器模式</p><h2 id="ES的基本原理"><a href="#ES的基本原理" class="headerlink" title="ES的基本原理"></a>ES的基本原理</h2><p>ES中比较关键的概念有索引，相当于MySQL的表，文档，相当于表中的行，字段，相当于表中的列。然后还可以组成集群和分片。</p><p>ES内部的索引使用的倒排索引，原理就是把每个文档的内容进行分词，建立词对应文档ID列表的映射</p><p>当有新的文档写入时，ES首先会通过分词器做文本分析，建立倒排索引，再把数据写到主分片上，由主分片同步到副分片，写入不是立即可见的，默认一秒钟刷新一次</p><h2 id="Nacos如何避免读写冲突"><a href="#Nacos如何避免读写冲突" class="headerlink" title="Nacos如何避免读写冲突"></a>Nacos如何避免读写冲突</h2><p>Nacos主要通过两种机制来避免配置读写冲突。一是写时使用乐观锁机制，客户端提交配置时必须带上当前版本号，如果版本不一致则更新失败，避免写写冲突。二是通过Raft协议实现集群间的数据强一致，所有写请求必须通过Leader，读请求默认从本地读取，如果需要强一致也可以强制读Leader。Nacos客户端使用长轮询机制感知配置变更，确保读时的数据是最新的。</p><h2 id="为什么Kryo序列化方式的体积小"><a href="#为什么Kryo序列化方式的体积小" class="headerlink" title="为什么Kryo序列化方式的体积小"></a>为什么Kryo序列化方式的体积小</h2><p>Kryo直接将对象编码为二进制字节数组，没有像JSON那样的字符冗余，并且Kryo不使用Java的反射机制，而是提前注册类信息，序列化时不需要写类的全限定名，它还支持对象引用追踪，避免重复序列化同一个对象</p><h2 id="zk的一致性算法"><a href="#zk的一致性算法" class="headerlink" title="zk的一致性算法"></a>zk的一致性算法</h2><p>Zookeeper使用Zab协议来实现集群一致性。有领导选举和原子广播两个阶段。当集群初次启动或者Leader节点宕机时会进入领导选举阶段，主要是通过投票和对比事务ID来选择，原子广播阶段，所有写请求由Leader发起并生成事务，广播给所有的Follower，需被超过半数的Follower写入后才能提交，Leader再广播提交消息，确保所有节点以相同顺序应用事务，从而实现强一致性。</p><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>我在参与商城项目的时候有过JVM调优的经历，当时压测的时候频繁出现Full GC，我通过jstat分析内存使用情况，使用-Xms和-Xmx调整了堆的大小，用-Xmn扩大了新生代的大小，后面我还有使用jstack查看线程状态，检查是否有死锁的情况</p><h2 id="单机MySQL如果不做任何优化，最大可以承受多大并发"><a href="#单机MySQL如果不做任何优化，最大可以承受多大并发" class="headerlink" title="单机MySQL如果不做任何优化，最大可以承受多大并发"></a>单机MySQL如果不做任何优化，最大可以承受多大并发</h2><p>MySQL默认的最大连接数是151，也就是最多151个线程同时连接执行SQL，如果只是执行简单的查询，单机QPS大概5000左右，如果是频繁写入的话，TPS可能在1000上下</p><h2 id="如何发现和优化慢SQL"><a href="#如何发现和优化慢SQL" class="headerlink" title="如何发现和优化慢SQL"></a>如何发现和优化慢SQL</h2><p>开启数据库慢查询日志，使用<code>mysqldumpslow</code>汇总慢sql，发现慢sql语句之后，使用<code>explain</code>分析这条语句，主要关注是否用了全表扫描，keys是否走了索引，rows是否过大，然后针对常用的字段，使用最左前缀原则建立索引，同时也要避免select *查询，数据量大时，可以用<code>LIMIT</code>限制查询数量，使用分页时避免大偏移量分页，避免慢sql的话可以针对大数据量的表使用分库分表，也可以结合缓存，分担数据库压力</p><h2 id="RocketMQ和RabbitMQ的异同点，使用场景"><a href="#RocketMQ和RabbitMQ的异同点，使用场景" class="headerlink" title="RocketMQ和RabbitMQ的异同点，使用场景"></a>RocketMQ和RabbitMQ的异同点，使用场景</h2><p>RabbitMQ基于AMQP协议实现，消息存储在Broker上，采用push模式，消息主动推送给消费者，可靠性一般通过确认机制保证，部署简单，适合中小型系统</p><p>RocketMQ采用的分布式架构，消息存储在Broker集群，消息被分为多个Topic和Partition，不同分区可并行处理，支持顺序消息、分布式事务等特性，采用pull模式，消费者主动拉取消息，适合用于大规模、高吞吐量场景</p><h2 id="Unity中C-的生命周期"><a href="#Unity中C-的生命周期" class="headerlink" title="Unity中C#的生命周期"></a>Unity中C#的生命周期</h2><p>C#脚本的生命周期主要围绕<code>MonoBehaviour</code>类展开，首先是初始化阶段，可以使用Awake（最早被调用，仅执行一次），Start（在第一次 <code>Update</code> 前调用，仅执行一次）进行初始化，然后是运行阶段，使用update、fixedupdate，然后是渲染阶段，OnPreRender，OnRenderObject，OnPostRender，最后是销毁阶段，OnDisable</p><h2 id="Unity为什么需要协程"><a href="#Unity为什么需要协程" class="headerlink" title="Unity为什么需要协程"></a>Unity为什么需要协程</h2><ul><li>实现延时执行而不阻塞主线程：Unity是单线程的，而协程允许先等待一段时间后再执行后续代码</li><li>逐帧执行复杂操作，防止掉帧：当某个任务太重时（如大量计算、加载资源等），协程可以把任务分成多帧执行</li></ul><h2 id="SpringBoot相比于Spring有哪些优点"><a href="#SpringBoot相比于Spring有哪些优点" class="headerlink" title="SpringBoot相比于Spring有哪些优点"></a>SpringBoot相比于Spring有哪些优点</h2><ul><li>Spring需要XML或Java配置类进行配置，SpringBoot提供了自动化配置，大部分默认配置就能满足开发需求</li><li>SpringBoot内置了Tomcat容器，项目可以直接打包成jar运行，不需要部署到外部服务器</li><li>SpringBoot提供了多种starter依赖（如 <code>spring-boot-starter-web</code>、<code>starter-data-jpa</code>），解决了版本兼容与依赖整合的问题</li><li>SpringBoot提供了对主流中间件的默认整合，如Redis、RabbitMQ、MyBatis、Elasticsearch等，通过yml文件即可完成连接配置，无需手动创建Bean</li></ul><h2 id="SpringBoot项目中的分层架构，以及会用到的注解"><a href="#SpringBoot项目中的分层架构，以及会用到的注解" class="headerlink" title="SpringBoot项目中的分层架构，以及会用到的注解"></a>SpringBoot项目中的分层架构，以及会用到的注解</h2><ul><li>Controller层（处理请求，参数解析，返回响应）：@RestController、@Controller、@RequestMapping、@GetMapping、@ResponseBody、@RequestBody</li><li>Service 层（处理具体业务逻辑）：@Service、@Transactional</li><li>DAO层（与数据库交互）：@Mapper</li></ul><h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><ul><li>如何在Linux系统中查询所有运行的java项目：ps -ef | grep java</li><li>linux中查找文件：find -name “filename”</li><li>linux中查看端口号占用情况：netstat或ss -tunlp | grep 端口号</li><li>linux查看进程占用了哪个端口：lsof -p <PID> -i</PID></li></ul><h2 id="性能测试的指标"><a href="#性能测试的指标" class="headerlink" title="性能测试的指标"></a>性能测试的指标</h2><ul><li>响应类，比如响应时间、延迟、TPS、帧时间</li><li>资源占用类，比如CPU、内存、带宽和磁盘I&#x2F;O</li><li>稳定性和并发类，比如并发用户数、崩溃率、卡顿率、内存泄漏等</li></ul><p>实际测试中结合场景，比如副本战斗关注FPS与卡顿率，主界面关注内存占用和帧时间，PVP联网则重点看延迟和同步情况，服务器端则关注并发连接、TPS和崩溃率等。</p><h2 id="如何发现性能测试的瓶颈"><a href="#如何发现性能测试的瓶颈" class="headerlink" title="如何发现性能测试的瓶颈"></a>如何发现性能测试的瓶颈</h2><p>首先要明确测试的目标和场景，是为了找到响应慢的接口还是检查资源使用过高，可以重点关注CPU使用率、负载、内存的占用率、网络的吞吐量和延迟、磁盘的IO次数和数据库的查询耗时、连接数等，如果是接口响应慢可能是有慢SQL、或者出现远程的资源调用与加载比较慢，如果是高并发时崩溃，可能是数据库连接池出了问题，内存溢出，如果是频繁丢帧和卡顿，可能是机器配置不足或者优化没到位等等</p><h2 id="游戏中哪些地方需要性能测试"><a href="#游戏中哪些地方需要性能测试" class="headerlink" title="游戏中哪些地方需要性能测试"></a>游戏中哪些地方需要性能测试</h2><p>开放世界的流式加载，就是从一个地方跑到另一个地方不会产生卡顿和割裂感，玩家快速切换视角和缩放场景的时候的流畅度</p><p>城市场景和高密度对象共存的场景，对于NPC密集的地方，统计一下帧率和抖动的情况</p><p>战斗场景，对于放技能时特效的加载和多种角色技能共存时对于帧率和电脑或者手机负载的影响</p><p>资源的加载和切换，当使用传送功能的时候，资源加载的效率</p><p>长时间运行的稳定性，就是模拟多个小时不间断游戏，看看与刚进入游戏时对比，帧率和负载是否有比较大的变化</p><p>异常网络环境测试，对于弱网环境也可以测试一下</p><h2 id="用户端程序崩溃，如何复现"><a href="#用户端程序崩溃，如何复现" class="headerlink" title="用户端程序崩溃，如何复现"></a>用户端程序崩溃，如何复现</h2><p>从用户或日志中获取尽可能完整的上下文信息，比如崩溃发生的设备型号、操作系统、内存情况，是否有崩溃弹窗&#x2F;错误码&#x2F;闪退提示，崩溃前执行了哪些操作，点击了哪个功能和崩溃时的网络状态（在线&#x2F;离线&#x2F;弱网），然后查看日志文件，搜集信息。然后在调试环境下，执行与用户相同的操作流程</p><h2 id="黑盒测试、白盒测试、灰盒测试"><a href="#黑盒测试、白盒测试、灰盒测试" class="headerlink" title="黑盒测试、白盒测试、灰盒测试"></a>黑盒测试、白盒测试、灰盒测试</h2><p>黑盒测试是不关注代码逻辑，只关注功能是否符合需求，从用户的视角测试系统的输入输出。主要测试软件或者游戏的一些功能是否符合规格，边界值处理是否正确，系统响应是否正确等等，常见的方法有等价类划分、边界值分析、错误推测法、场景法等</p><p>白盒测试是从开发者视角出发，测试代码的各个逻辑分支，条件和循环结构。常见的方法有语句覆盖、分支覆盖、条件覆盖、循环覆盖等</p><p>现在一般两者融合使用，就是部分了解系统内部逻辑，同时也关注一些功能表现，叫灰盒测试，主要测试一些业务流程是否合理，模块之间的接口是否生效，安全验证是否生效等</p><h2 id="JMeter的断言方式"><a href="#JMeter的断言方式" class="headerlink" title="JMeter的断言方式"></a>JMeter的断言方式</h2><p>最常用的是响应断言，用于检查响应的数据中是否包含某些字符串或者关键词，可以校验文本、状态码、响应头、响应数据等</p><p>JSON断言，校验JSON格式相应的数据结构或字段值</p><p>HTML断言，检查返回的HTML页面是否符合规范</p><p>大小断言和持续时间断言，判断响应的数据长度或者相应的时间是否符合预期</p><h2 id="hr面相关"><a href="#hr面相关" class="headerlink" title="hr面相关"></a>hr面相关</h2><h3 id="为什么选择我们公司"><a href="#为什么选择我们公司" class="headerlink" title="为什么选择我们公司"></a>为什么选择我们公司</h3><p>我认为贵公司身为一线互联网企业，技术栈和工程实践能力一定都非常成熟，我相信内部一定非常重视技术氛围。在这样一个重视技术、节奏高效的环境，我认为我的能力可以快速得到提升，而且贵公司应该也会有完善的新员工或实习生的培养流程，可以更好的进行线性成长。并且可以在真实项目中锻炼自己的工程能力。而且我了解贵公司在业务领域持续扩展，也有很强的发展潜力，我希望能在这样的平台上深入了解业务</p><h3 id="你对自己的职业规划是怎样的"><a href="#你对自己的职业规划是怎样的" class="headerlink" title="你对自己的职业规划是怎样的"></a>你对自己的职业规划是怎样的</h3><p>短期内，我希望能在测试开发的岗位上打好基础，快速的了解所负责的基础业务和大体流程，在熟悉业务的同时提升自己对系统架构、质量保障的理解，同时也要重点看一下需求文档和开发文档，着重关注侧重点。中期来看，我希望自己不仅仅是执行测试，还能参与到测试平台的开发或质量体系建设中，在“懂技术又懂业务”的方向上深入发展，培养自己的产品意识和工程能力</p><h3 id="是否接受加班"><a href="#是否接受加班" class="headerlink" title="是否接受加班"></a>是否接受加班</h3><p>加班我是完全可以接受的。我理解研发和测试周期中有一些阶段确实需要投入更多，尤其是版本上线前或者新项目初期，我也愿意配合团队冲刺目标。</p><h3 id="你有没有其它公司的offer"><a href="#你有没有其它公司的offer" class="headerlink" title="你有没有其它公司的offer"></a>你有没有其它公司的offer</h3><p>之前收到过一些offer，不过我都拒绝掉了，目前有一些面试在进行中，也收到了部分反馈，但从技术氛围和业务来看，我个人更倾向于贵公司</p><h3 id="用几个词描述一下自己"><a href="#用几个词描述一下自己" class="headerlink" title="用几个词描述一下自己"></a>用几个词描述一下自己</h3><p>踏实、自驱、逻辑性强。我在项目中喜欢梳理问题和业务逻辑，有条理地分解任务，也习惯自己查资料解决问题；同时我也具备较强的执行力，能把任务落地</p><h3 id="最有成就感的一件事"><a href="#最有成就感的一件事" class="headerlink" title="最有成就感的一件事"></a>最有成就感的一件事</h3><p>是我在读研期间负责的一个国家自然科学基金项目，当时是从零开始写系统设计书，在一次次的项目对接中实现各种功能和交互的逻辑，并且最后的算法训练也是我来做的，期间遇到了项目开发冲突，需求推倒重做，智能体训练失败等问题，但是最终也是平稳交付。负责一个成功交付的项目让我很有成就感</p><h3 id="最成功的一次团队合作经历"><a href="#最成功的一次团队合作经历" class="headerlink" title="最成功的一次团队合作经历"></a>最成功的一次团队合作经历</h3><p>我在去年做一个导师的横向课题时，担任的是场景构建的角色和团队负责人之一，在项目初期，我们带领团队成员制定了一个详细的项目计划和时间表，明确了每个人的职责。然后我进行场景构建的时候，也会与进行具体逻辑开发的成员进行及时的沟通，说明场景的构建蓝图和可行的训练方案。然后我的任务完成之后，由于我也是负责人之一，我也会及时的跟进项目当前的进度。</p><p>在项目快收尾的时候，我们遇到了一个问题，就是强化学习智能体达不到合同中规定的性能要求，在进行增加训练轮次，修改奖励函数等补救措施之后依然不行，然后我决定重新构建一版场景，让智能体更容易探索，最终解决了这个问题，然后我们合作的项目也成功的结题了。</p><p>团队合作让我认识到成功的关键在于及时的沟通和协作，就是每个人不能只干完自己的事情就啥都不管了，也要力所能及的跟进到项目的整体中。</p>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/c92e9465.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>xxl-Job基础入门</title>
      <link>http://ltynote.cn/inori/226b10d6.html</link>
      <guid>http://ltynote.cn/inori/226b10d6.html</guid>
      <pubDate>Thu, 05 Jun 2025 10:32:24 GMT</pubDate>
      
      <description>xxl-job基础入门</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><p>我们可以思考一下下面业务场景的解决方案:</p><ul><li>某电商平台需要每天上午10点，下午3点，晚上8点发放一批优惠券</li><li>某银行系统需要在信用卡到期还款日的前三天进行短信提醒</li><li>某财务系统需要在每天凌晨0:10分结算前一天的财务数据，统计汇总</li></ul><p>以上场景就是任务调度所需要解决的问题</p><p><strong>任务调度是为了自动完成特定任务，在约定的特定时刻去执行任务的过程</strong></p><h3 id="为什么需要分布式调度"><a href="#为什么需要分布式调度" class="headerlink" title="为什么需要分布式调度"></a>为什么需要分布式调度</h3><p>使用Spring中提供的注解@Scheduled，也能实现调度的功能，在业务类中方法中贴上这个注解,然后在启动类上贴上<code>@EnableScheduling</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/20 * * * * ? &quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//doSomething   </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>但是这种方式：</p><ul><li>只能在一台机器上运行，如果程序或者系统出现异常就会导致功能不可用</li><li>在单机模式下，定时任务是没什么问题的。但当我们部署了多台服务，同时又每台服务又有定时任务时，若不进行合理的控制在同一时间，只有一个定时任务启动执行，定时执行的结果就可能存在混乱和错误了</li><li>原本1分钟内需要处理1万个订单，但是现在需要1分钟内处理10万个订单；原来一个统计需要1小时，现在业务方需要10分钟就统计出来。也许可以多线程、单机多进程处理。的确，多线程并行处理可以提高单位时间的处理效率，但是单机能力毕竟有限（主要是CPU、内存和磁盘），始终会有单机处理不过来的情况</li></ul><h2 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="XXL-Job"></a>XXL-Job</h2><p><a href="https://github.com/xuxueli/xxl-job">XXL-Job</a>是一个轻量级分布式任务调度平台, 其核心设计目标是开发迅速、学习简单、轻量级、易扩展</p><p><img src="/inori/226b10d6/framework.png"></p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p><p>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</p><p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性</p><h3 id="配置调度中心"><a href="#配置调度中心" class="headerlink" title="配置调度中心"></a>配置调度中心</h3><ol><li>下载xxl的源码后，有一个调度数据库初始化的SQL脚本，首先需要把这个脚本导入到数据库中</li><li>按照maven格式将源码导入到idea，使用maven进行编译后运行即可</li></ol><p><img src="/inori/226b10d6/structure.png"></p><ol start="3"><li>修改<code>xxl-job-admin</code>项目的配置文件<code>application.properties</code>,把数据库账号密码配置上</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### web</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/xxl-job-admin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### actuator</span></span><br><span class="line"><span class="attr">management.server.servlet.context-path</span>=<span class="string">/actuator</span></span><br><span class="line"><span class="attr">management.health.mail.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### resources</span></span><br><span class="line"><span class="attr">spring.mvc.servlet.load-on-startup</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">spring.mvc.static-path-pattern</span>=<span class="string">/static/**</span></span><br><span class="line"><span class="attr">spring.resources.static-locations</span>=<span class="string">classpath:/static/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### freemarker</span></span><br><span class="line"><span class="attr">spring.freemarker.templateLoaderPath</span>=<span class="string">classpath:/templates/</span></span><br><span class="line"><span class="attr">spring.freemarker.suffix</span>=<span class="string">.ftl</span></span><br><span class="line"><span class="attr">spring.freemarker.charset</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="attr">spring.freemarker.request-context-attribute</span>=<span class="string">request</span></span><br><span class="line"><span class="attr">spring.freemarker.settings.number_format</span>=<span class="string">0.##########</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### mybatis</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:/mybatis-mapper/*Mapper.xml</span></span><br><span class="line"><span class="comment">#mybatis.type-aliases-package=com.xxl.job.admin.core.model</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, datasource</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://IP地址:端口号/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### datasource-pool</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.idle-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.pool-name</span>=<span class="string">HikariCP</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.max-lifetime</span>=<span class="string">900000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-timeout</span>=<span class="string">10000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-test-query</span>=<span class="string">SELECT 1</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.validation-timeout</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, email</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">spring.mail.port</span>=<span class="string">25</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">xxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.from</span>=<span class="string">xxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.required</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, access token</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string">default_token</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)</span></span><br><span class="line"><span class="attr">xxl.job.i18n</span>=<span class="string">zh_CN</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## xxl-job, triggerpool max size</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.fast.max</span>=<span class="string">200</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.slow.max</span>=<span class="string">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, log retention days</span></span><br><span class="line"><span class="attr">xxl.job.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><ol start="4"><li>运行<code>XxlJobAdminApplication</code>程序，访问调度中心：<a href="http://localhost:8080/xxl-job-admin%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7">http://localhost:8080/xxl-job-admin，默认登录账号</a> “admin&#x2F;123456”</li></ol><h3 id="配置执行器"><a href="#配置执行器" class="headerlink" title="配置执行器"></a>配置执行器</h3><ol><li>添加Maven依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>执行器配置，在配置文件中添加配置</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span></span><br><span class="line"><span class="attr">xxl.job.admin.addresses</span>=<span class="string">http://127.0.0.1:8080/xxl-job-admin</span></span><br><span class="line"><span class="comment">### 执行器通讯TOKEN [选填]：非空时启用；</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string">default_token</span></span><br><span class="line"><span class="comment">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span></span><br><span class="line"><span class="attr">xxl.job.executor.appname</span>=<span class="string">xxl-job-executor-sample</span></span><br><span class="line"><span class="comment">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span></span><br><span class="line"><span class="attr">xxl.job.executor.address</span>=<span class="string"></span></span><br><span class="line"><span class="comment">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span></span><br><span class="line"><span class="attr">xxl.job.executor.ip</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span></span><br><span class="line"><span class="attr">xxl.job.executor.port</span>=<span class="string">9999</span></span><br><span class="line"><span class="comment">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logpath</span>=<span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line"><span class="comment">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建<code>XxlJobConfig</code>配置对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加任务处理类，交给Spring容器管理，在处理方法上贴上<code>@XxlJob</code>注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleXxlJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行定时任务,执行时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>登录调度中心,在任务管理中新增任务,配置内容如下：</p><p><img src="/inori/226b10d6/config1.png"></p><p>然后启动定时调度任务，回到管控台，就可以看到任务已经执行</p><h3 id="执行器集群"><a href="#执行器集群" class="headerlink" title="执行器集群"></a>执行器集群</h3><p>在IDEA中设置SpringBoot项目运行开启多个集群，启动两个SpringBoot程序,需要修改Tomcat端口和执行器端口</p><ul><li><p>Tomcat端口8090程序的命令行参数:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8090 -Dxxl.job.executor.port=9998</span><br></pre></td></tr></table></figure></li><li><p>Tomcat端口8091程序的命令行参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8091 -Dxxl.job.executor.port=9999</span><br></pre></td></tr></table></figure></li></ul><p>在任务管理中，修改路由策略，修改成<code>轮询</code></p><p><img src="/inori/226b10d6/config2.png"></p><p>重新启动,我们可以看到效果是,定时任务会在这两台机器中进行轮询的执行</p><h4 id="调度路由算法"><a href="#调度路由算法" class="headerlink" title="调度路由算法"></a>调度路由算法</h4><ol><li><p>FIRST（第一个）：固定选择第一个机器</p></li><li><p>LAST（最后一个）：固定选择最后一个机器</p></li><li><p>ROUND（轮询）：依次的选择在线的机器发起调度</p></li><li><p>RANDOM（随机）：随机选择在线的机器</p></li><li><p>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上</p></li><li><p>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举</p></li><li><p>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举</p></li><li><p>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度</p></li><li><p>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度</p></li><li><p>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务</p></li></ol><h3 id="分片功能"><a href="#分片功能" class="headerlink" title="分片功能"></a>分片功能</h3><p>需求:在指定节假日，需要给平台的所有用户去发送祝福的短信</p><h4 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h4><p>在数据库中导入<code>xxl_job_demo.sql</code>数据</p><h4 id="集成Druid-MyBatis"><a href="#集成Druid-MyBatis" class="headerlink" title="集成Druid&amp;MyBatis"></a>集成Druid&amp;MyBatis</h4><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加配置</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/xxl_job_demo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p><strong>添加实体类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMobilePlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">private</span> String username;<span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">private</span> String phone;<span class="comment">//手机号码</span></span><br><span class="line">    <span class="keyword">private</span> String info;<span class="comment">//备注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加Mapper处理类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务功能实现"><a href="#业务功能实现" class="headerlink" title="业务功能实现"></a>业务功能实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot;,处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟发送短信动作</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们的案例中有2000+条数据，如果不采取分片形式的话，任务只会在一台机器上执行，这样的话需要20+秒才能执行完任务</p><p>如果采取分片广播的形式的话，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数，可根据分片参数开发分片任务</p><p>获取分片参数方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可参考Sample示例执行器中的示例任务&quot;ShardingJobHandler&quot;了解试用 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line"><span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br></pre></td></tr></table></figure><p>通过这两个参数，我们可以通过求模取余的方式，分别查询，分别执行，这样的话就可以提高处理的速度</p><p>之前2000+条数据只在一台机器上执行需要20+秒才能完成任务，分片后，有两台机器可以共同完成2000+条数据，每台机器处理1000+条数据，这样的话只需要10+秒就能完成任务</p><h4 id="案例改造"><a href="#案例改造" class="headerlink" title="案例改造"></a>案例改造</h4><p><strong>Mapper增加查询方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan where mod(id,#&#123;shardingTotal&#125;)=#&#123;shardingIndex&#125;&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectByMod</span><span class="params">(<span class="meta">@Param(&quot;shardingIndex&quot;)</span> Integer shardingIndex,<span class="meta">@Param(&quot;shardingTotal&quot;)</span>Integer shardingTotal)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务类方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgShardingHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgShardingHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(shardTotal==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果没有分片就直接查询所有数据</span></span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectByMod(shardIndex,shardTotal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把路由策略改成分片广播即可实现分片功能</p><p><img src="/inori/226b10d6/demo.png"></p>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/xxl/">xxl</category>
      
      
      <category domain="http://ltynote.cn/tags/xxl/">xxl</category>
      
      
      <comments>http://ltynote.cn/inori/226b10d6.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>项目常见问题梳理（持续更新中）</title>
      <link>http://ltynote.cn/inori/b4ace844.html</link>
      <guid>http://ltynote.cn/inori/b4ace844.html</guid>
      <pubDate>Sat, 31 May 2025 08:17:54 GMT</pubDate>
      
      <description>面试专题——项目篇</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h1><h2 id="为什么要做RPC项目"><a href="#为什么要做RPC项目" class="headerlink" title="为什么要做RPC项目"></a>为什么要做RPC项目</h2><p>目前的应用大部分都是分布式或者微服务架构，通常各个模块之间都是通过rpc来进行调用的，所以我认为自己写一个rpc项目可以更加深入的理解rpc的原理</p><p>然后在写rpc项目的过程中，学会了对Zookeeper和netty的使用，也学会了通信协议设计、序列化算法、服务注册与发现、负载均衡策略的设计和使用。</p><h2 id="项目有什么难点，如何解决的"><a href="#项目有什么难点，如何解决的" class="headerlink" title="项目有什么难点，如何解决的"></a>项目有什么难点，如何解决的</h2><ol><li>关于通信协议的实现和切换模块，我希望客户端和服务端支持http，socket和netty传输协议，并且根据配置自动切换。我的解决方案是首先定义了统一的接口<code>RpcClient</code> 和 <code>RpcServer</code>，然后实现其协议子类比如<code>NettyRpcServer</code>和<code>HttpRpcServer</code>，利用Spring Boot的 <code>@ConditionalOnProperty</code>和<code>@ConditionalOnMissingBean</code> 机制，支持配置项自动装配对应的协议实现</li><li>关于负载均衡模块的实现，就是服务调用时如何在多个服务节点直接选择一个合适的目标节点。我的解决方案是定义一个统一的接口<code>LoadBalance</code>，在此基础上扩展成随机、轮询和一致性哈希三种方法，使用SPI的方式决定具体使用哪种策略，最后把LoadBalance注入到服务发现模块中，实现调用时选择</li><li>关于服务注册和发现模块的实现，我编写了一个注解<code>RpcService</code>，服务启动时会遍历所有使用了这个注解的Bean，然后将服务的接口全限定名和服务提供地址注册到注册中心，然后在Zookeeper层面会创建一个临时节点，表明这个服务被创建成功。然后在客户端通过代理类发起远程调用时，如果存在多个地址，就是用负载均衡模块选择一个，最后建立连接发起远程调用</li><li>还有就是Kryo序列化与多线程环境的兼容性。因为Kryo是线程不安全的，直接复用同一个实例会导致数据错乱。后来我通过ThreadLocal为每个线程分配独立的Kryo实例，避免了线程间冲突，同时保持了性能</li></ol><h2 id="为什么用Netty做网络通信"><a href="#为什么用Netty做网络通信" class="headerlink" title="为什么用Netty做网络通信"></a>为什么用Netty做网络通信</h2><p>因为相比于Java原生的Socket和Http更适合高性能和高并发的场景</p><ul><li>Netty的IO是异步非阻塞的，支持大量并发连接，吞吐量高</li><li>Netty使用线程复用、事件驱动机制，资源占用低，GC压力小</li><li>Netty内部提供粘包半包处理器，实现rpc协议更方便</li></ul><h2 id="http、socket、netty三种网络通信方式的区别"><a href="#http、socket、netty三种网络通信方式的区别" class="headerlink" title="http、socket、netty三种网络通信方式的区别"></a>http、socket、netty三种网络通信方式的区别</h2><ul><li>socket是传输层的协议，是操作系统提供的网络编程接口，只提供最基础的通信方式，可以是阻塞或者非阻塞的，需要自己实现编解码器和传输的逻辑</li><li>http是应用层的协议，基于请求-响应的模式，默认是短连接的，并且不支持双向通信，性能比较低，但是http被很多框架支持，使用比较方便</li><li>netty是一个基于NIO的网络通信框架，底层用到了socket，是异步非阻塞，基于事件驱动的，性能比较高，并且其中提供了粘包半包的处理器和对自定义协议的支持，扩展性比较好</li></ul><h2 id="JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别"><a href="#JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别" class="headerlink" title="JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别"></a>JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别</h2><ul><li>JDK是Java原生的序列化方式，不需要引入三方库，但是序列化后体积比较大，性能低，反序列化速度慢</li><li>Json的可读性比较强，支持跨语言调用，比较适合web接口，但是它占用空间比较大，而且不支持复杂的对象图</li><li>Protostuff是基于Protobuf的序列化方式，支持基础的Java Bean，可以跨语言，并且序列化后体积小，性能高，但是它序列化后不可读</li><li>Hession是一个二进制协议，支持序列化复杂对象，也可以跨语言支持，兼容性比较好</li><li>Kryo适合Java内部序列化，不支持跨语言，序列化性能非常高，默认要求类有无参构造器，而且kryo是线程不安全的</li></ul><h2 id="讲一下自定义协议"><a href="#讲一下自定义协议" class="headerlink" title="讲一下自定义协议"></a>讲一下自定义协议</h2><p>我在rpc项目中的自定义协议头有魔数（4byte，识别协议是否合法），版本号（1byte，兼容后续可能的更新），序列化算法（1byte，具体使用的序列化协议），消息类型（1byte，有请求、响应、心跳），消息状态（1byte，成功，失败，超时），消息序列号（4byte，每个请求的唯一id，处理多路复用的时候可以用到），消息长度（4byte）</p><h2 id="讲一下编解码器"><a href="#讲一下编解码器" class="headerlink" title="讲一下编解码器"></a>讲一下编解码器</h2><p>编码部分是出站处理，把RpcMessage编码成Bytebuf对象，先把自定义协议头写到bytebuf中，再把协议体经过序列化后填充到bytebuf中</p><p>解码部分分为粘包半包解码器和具体解码两部分，关于粘包半包处理我使用的是Netty的定长解码器，在解码器中我设定了偏移量和消息体长度值，因为我的协议有16字节，后4字节代表消息体长度，所以偏移量是12字节，长度是4字节，解码器就通过长度字段，得出body的长度，然后从TCP流中拼接出这条完整消息，或者如果多条消息被粘在一起，Netty会按每条消息长度拆分出多条消息。然后再是具体解码，先校验是否符合我自定义协议的格式，再解出具体消息体</p><h2 id="讲一下Netty心跳机制和Channel的连接复用"><a href="#讲一下Netty心跳机制和Channel的连接复用" class="headerlink" title="讲一下Netty心跳机制和Channel的连接复用"></a>讲一下Netty心跳机制和Channel的连接复用</h2><p>TCP是长连接，但不会自动告诉你对方是否断线，如果一端异常断开，另一端会长时间挂起资源，会造成一定的资源浪费，所以我使用了定期的心跳检测，确认连接是否存活。我使用了netty的IdleStateHandler来实现心跳检测，当检测到写空闲时自动发送一个心跳检测数据包</p><p>然后在rpc框架中，如果每发一次请求就新建TCP连接，就会导致大量Socket打开关闭，并且并发高时会造成端口耗尽的问题。我在项目中使用ConcurrentHashMap存放每个<code>IP+端口号</code>使用过的Channel，如果当前IP的端口再次发起rpc请求后，检测到之前的Channel还没关闭，就可以再次使用，避免重复连接服务端</p><p>然后是多路复用的实现，因为同一个服务可能会发出多个不同的rpc请求，我使用一个<code>ConcurrentHashMap</code>存放每个请求的等待结果区，key是协议头中的sequenceId，value是Netty的Promise（代表一个异步响应），当响应回来时，用sequenceId找到对应的Promise完成结果，就可以做到同一个连接处理多个不同的请求。</p><h2 id="注册中心为什么使用Zookeeper不用Nacos"><a href="#注册中心为什么使用Zookeeper不用Nacos" class="headerlink" title="注册中心为什么使用Zookeeper不用Nacos"></a>注册中心为什么使用Zookeeper不用Nacos</h2><p>我这个RPC框架作为一个独立项目，需要自己实现服务注册&#x2F;发现、监听机制、负载均衡等功能。</p><ul><li>项目对一致性的要求更高，服务注册、注销都是临时节点，Zookeeper会在连接断开时自动清理</li><li>Zookeeper支持监听机制，服务节点变化能即时通知客户端，便于实现本地缓存刷新，Nacos的监听更偏配置文件，服务变化通知粒度更粗一些</li><li>项目使用的是Netty和SpringBoot，整体较轻量，不需要配置中心功能</li><li>Nacos提供了配置中心和服务注册功能，对于微服务项目来说非常适合。但我的RPC框架更偏向于底层架构搭建和分布式通信机制学习，所以我更偏向选用Zookeeper，它更容易控制细节、简洁可定制</li></ul><h2 id="服务如何注册、客户端如何发现、服务如何下线"><a href="#服务如何注册、客户端如何发现、服务如何下线" class="headerlink" title="服务如何注册、客户端如何发现、服务如何下线"></a>服务如何注册、客户端如何发现、服务如何下线</h2><p>服务注册的逻辑在服务提供端，主要流程是服务启动时，连接到Zookeeper，创建持久结点，表示这个服务，然后在持久结点下面创建临时子节点，表示提供这个服务的IP地址和端口号，临时节点中会存数据，是Json格式的服务对象，有服务名，ip地址，端口号和版本号。注册成功后，Zookeeper会维持与该服务实例的心跳连接</p><p>服务发现的逻辑在服务调用端，主要流程是服务启动时连接到Zookeeper，发送rpc请求时，先根据服务名查找服务。如果客户端第一次查找该服务，会从Zookeeper拉取服务列表，构建本地缓存，并设置监听器，后续若服务变化，缓存会自动更新。不是第一次的话则直接调用缓存，然后使用负载均衡算法从服务列表中选一个可用实例，返回该实例信息用于客户端建立连接并发起请求</p><p>服务下线分为两种情况，第一种情况是服务主动下线，服务关闭时使用注销方法将服务从Zookeeper中删除，然后客户端因为配置了监听器，会自动更新缓存列表。第二种情况是服务异常下线，因为Zookeeper有心跳机制，当检测不到这个服务时，会认为这个服务已经停止了，删除这个服务</p><h2 id="介绍一下客户端调用、服务端响应的一个完整流程"><a href="#介绍一下客户端调用、服务端响应的一个完整流程" class="headerlink" title="介绍一下客户端调用、服务端响应的一个完整流程"></a>介绍一下客户端调用、服务端响应的一个完整流程</h2><p>客户端通过代理类发起服务调用，动态代理类会封装请求，客户端进行服务发现，然后使用负载均衡算法选择一个服务提供者发起网络通信请求，请求成功后，使用自定义协议将信息封装为消息头和消息体，并通过编码器和序列化器转成字节数组，将数据发送到目标Channel，服务端收到数据后，进行解码和反序列化，还原消息体，然后通过反射调用目标方法，获取返回结果，再封装消息，进行编码和序列化后将字节数组通过Channel发回到客户端中，然后客户端再进行解码和反序列化获得结果。</p><h2 id="如果zk中的服务节点退出了，服务还能访问吗，怎么做"><a href="#如果zk中的服务节点退出了，服务还能访问吗，怎么做" class="headerlink" title="如果zk中的服务节点退出了，服务还能访问吗，怎么做"></a>如果zk中的服务节点退出了，服务还能访问吗，怎么做</h2><p>如果Zookeeper中某个服务节点退出，它注册的临时节点会自动被删除。客户端如果还用旧地址调用，就会访问失败。为避免这个问题，我在客户端实现了本地服务地址缓存和动态监听机制，保证地址列表是实时更新的。客户端在读取服务地址的时候会注册监听器，一旦某个节点下线了，Zookeeper会提交一个事件给监听器，进而更新本地缓存。但是如果是一个客户端已经请求到这个服务节点了，但是此时这个节点宕机了，那么会出现请求失败的情况，关于这种情况，我配置了失败重试策略，请求发送失败时，使用负载均衡策略切换下一个地址重试</p><h2 id="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信"><a href="#如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信" class="headerlink" title="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信"></a>如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信</h2><p>如果一个服务正在被请求，此时直接下线可能会导致请求失败或连接中断。我采用的是优雅下线策略，先从注册中心摘除服务，但不会马上关闭进程，等待处理中的请求完成后再关闭服务进程，保证客户端本次调用能够完成（netty的EventLoopGroup.shutdownGracefully()）</p><h2 id="你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别"><a href="#你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别" class="headerlink" title="你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别"></a>你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别</h2><p>我做的这个RPC框架虽然不如Dubbo、gRPC功能全面，但胜在轻量级，更适合作为学习、定制型服务通信的基础框架。同时我也实现了一些Dubbo和gRPC中的重要特性，如服务注册、序列化、连接复用、自动注入等功能。</p><p>当然与成熟框架相比，我的RPC框架还存在一些后续可以升级的点：</p><ul><li>服务治理能力（如限流、熔断、降级）</li><li>跨语言支持</li><li>服务可观测性（如日志链路追踪）</li></ul><h2 id="实现一个RPC框架最主要看重哪些点"><a href="#实现一个RPC框架最主要看重哪些点" class="headerlink" title="实现一个RPC框架最主要看重哪些点"></a>实现一个RPC框架最主要看重哪些点</h2><ol><li>通信协议的设计，协议需要清晰的定义请求和响应结构，序列化格式和状态码等数据</li><li>编解码和序列化，编解码和序列化的效率应该要高，然后序列化后的数据体积应该小，看具体业务判断是否需要跨语言</li><li>网络通信性能，阻塞式或者异步式，是否支持连接池、长连接、心跳机制</li><li>服务注册与发现，负载均衡，是否具备故障感知能力</li><li>容错与高可用机制，是否支持失败重试，熔断和降级策略</li><li>还有易用性和可扩展性，是否支持注解，自动装配和可插拔机制</li></ol><h2 id="本地方法调用和远程过程调用有什么区别"><a href="#本地方法调用和远程过程调用有什么区别" class="headerlink" title="本地方法调用和远程过程调用有什么区别"></a>本地方法调用和远程过程调用有什么区别</h2><p>本地方法调用是程序内的方法直接调用，属于同一个进程内的方法调用，延迟很低，调用比较可靠，不需要中间件支持，但是代码的耦合度比较高</p><p>远程过程调用是调用远程服务器上提供的方法，属于不同进程或者不同机器上的方法调用，需要进行网络通信，所以有网络延迟，效率相对较低，也会有网络中断，超时等异常情况，需要中间件的支持，但是做到了服务之间的解耦合</p><h2 id="rpc如何支持服务的熔断和降级的"><a href="#rpc如何支持服务的熔断和降级的" class="headerlink" title="rpc如何支持服务的熔断和降级的"></a>rpc如何支持服务的熔断和降级的</h2><p>熔断是如果某个服务连续调用失败，系统就会临时阻止再发起请求，防止拖垮系统，可以在rpc中引入熔断器组件Sentinel，每个服务接口调用前先经过熔断器判断是否“断路”，统计失败率、超时数等动态判断是否进入熔断状态，还可以支持闭合-&gt;半开-&gt;打开的状态转换</p><p>降级是如果调用失败次数太多，系统就自动返回默认数据或走备用逻辑，可以编写Fallback方法，方法调用失败&#x2F;超时后，调用备用逻辑，返回默认值</p><h2 id="介绍一下一致性哈希算法"><a href="#介绍一下一致性哈希算法" class="headerlink" title="介绍一下一致性哈希算法"></a>介绍一下一致性哈希算法</h2><p>如果使用简单的哈希方式，当服务节点发生变化的时候，所有请求的分发都会大范围变化，这会导致缓存失效，影响系统效率。一致性哈希算法可以做到：节点数量变化时，尽量少地影响原有请求的分配规律，就是请求一致性和低扰动性。</p><p>一致性哈希算法把哈希空间想象成一个环，所有服务实例都通过哈希函数映射到这个环上某个位置，对服务的ip地址，端口号以及服务名称进行hash后对一个比较大的数进行取模，对数据key也进行hash，然后顺时针找到某一个node，就是这个key要存储的服务器。这样如果增加或者删除一台服务器的话，就只会影响部分数据。但是这样做，当节点比较少的时候会造成数据倾斜的问题，大部分数据会集中在某一个服务上。我的项目中使用了虚拟节点的解决方式，每个真实节点会映射为160个虚拟节点，通过MD5算法再生成多个哈希值，映射到哈希环上，对于请求来说，使用服务方法名加请求参数拼接后做MD5，再映射成哈希值，定位到哈希环上离它最近的服务节点，当服务列表变更时，重新构建哈希环，保证一致性，然后这个重建是不会造成大批量请求映射出错的，比如某个请求落到虚拟节点 A，服务列表变了，A 还在，请求还是到 A，如果A不在了，请求会顺时针走一点落到B。</p><h2 id="项目中哪些地方使用到了异步"><a href="#项目中哪些地方使用到了异步" class="headerlink" title="项目中哪些地方使用到了异步"></a>项目中哪些地方使用到了异步</h2><ul><li>Netty的核心通信是异步的，就是所有的IO操作都是异步非阻塞的</li><li>发送rpc请求是异步的，可以发送消息后立刻返回，监听发送是否成功</li><li>接收响应也是异步的，我在发生时生成了一个id，将future对象存到HashMap里，等收到响应后再异步完成这个future</li></ul><h1 id="小程序项目"><a href="#小程序项目" class="headerlink" title="小程序项目"></a>小程序项目</h1><h2 id="你用自定义注解实现了权限控制，讲讲具体是怎么做的"><a href="#你用自定义注解实现了权限控制，讲讲具体是怎么做的" class="headerlink" title="你用自定义注解实现了权限控制，讲讲具体是怎么做的"></a>你用自定义注解实现了权限控制，讲讲具体是怎么做的</h2><p>在这个小程序中，会涉及到三种角色：管理员root，活动发起者admin和活动参与者visitor，不同角色访问系统中接口的权限是不同的。</p><p>在项目中我使用JWT实现用户认证，用户登录后会签发Token，并将用户信息存入上下文，作为认证依据。</p><p>授权部分，我设计了一个自定义注解<code>@CheckPermission</code>来标记每个接口需要的具体权限，并结合AOP实现了权限切面。切面会在方法执行前解析注解，获取当前用户权限列表，进行匹配校验。如果用户具备权限，就放行接口，否则抛出无权限异常，交由全局异常处理器处理。</p><h2 id="用了三级缓存，讲一下细节"><a href="#用了三级缓存，讲一下细节" class="headerlink" title="用了三级缓存，讲一下细节"></a>用了三级缓存，讲一下细节</h2><p>我的项目中使用了Caffeine、Redis和MySQL结构来优化数据访问性能，本地缓存用于存储访问最频繁的数据，活动列表和当前登录用户信息。Redis作为二级缓存，用于存储访问过的活动详情、活动列表和用户信息，最后由数据库层面，存储全部数据</p><p>整体流程是用户访问数据时，先查本地缓存，未命中则查Redis，如果Redis也未命中再查数据库，并将结果同步回前两级缓存。</p><p>关于过期策略，活动信息在Caffeine中缓存5分钟左右，在Redis中缓存30分钟左右。</p><p>本地缓存层面，我使用了Caffeine的<code>CacheLoader</code>和<code>refreshAfterWrite</code>来预先加载数据避免本地的缓存穿透</p><h2 id="数据库表是怎么设计的"><a href="#数据库表是怎么设计的" class="headerlink" title="数据库表是怎么设计的"></a>数据库表是怎么设计的</h2><p>用户表，存放用户信息和用户的角色</p><p>活动表，存放已经发布的活动，活动的相关信息和发起人</p><p>活动报名表，表示活动id和用户id之间的关系</p><h2 id="如何部署项目，上线流程讲一下"><a href="#如何部署项目，上线流程讲一下" class="headerlink" title="如何部署项目，上线流程讲一下"></a>如何部署项目，上线流程讲一下</h2><p>预先在yaml文件中配置好生产环境参数，然后使用maven对项目进行打包，生成jar文件，传到服务器上，使用systemd后台运行项目，然后配置Nginx，将小程序API请求代理到SpringBoot项目端口，然后配置Nginx的ssl，让小程序支持HTTPS。</p><p>redis和mysql都部署在同一台服务器上，SpringBoot通过配置文件连接到redis和mysql</p><h2 id="活动报名如果高并发，怎么防止名额超限或重复提交"><a href="#活动报名如果高并发，怎么防止名额超限或重复提交" class="headerlink" title="活动报名如果高并发，怎么防止名额超限或重复提交"></a>活动报名如果高并发，怎么防止名额超限或重复提交</h2><p>我在每个活动创建的时候，会把名额写入redis中，使用<code>DECR</code>命令，用户报名前先<code>DECR</code>名额，如果减成功则允许报名，否则失败，因为<code>DECR</code>操作是Redis原子命令，天然支持并发控制，报名成功之后我使用redis创建一个活动名加上用户id的分布式锁，表示这个用户已经报名了这个活动，然后这个设置了一个过期时间，在过期时间内我会把这个报名数据写到数据库中，后续用户再重复报名时，因为redis层面的对应数据已经过期了，就会去查询数据库是否有他的信息，如果有再返回已报名的提示，用这个方式防止名额超限和重复报名</p><h2 id="三级缓存的缓存一致性怎么保证"><a href="#三级缓存的缓存一致性怎么保证" class="headerlink" title="三级缓存的缓存一致性怎么保证"></a>三级缓存的缓存一致性怎么保证</h2><p>读请求是如果访问的是用户信息和首页活动列表，那么会先查询本地缓存，在查询redis，最后查询数据库，然后把数据库返回的数据存到redis和本地缓存中</p><p>如果访问的不是这两个，就直接查询redis，没查到再查询数据库，再写会redis。</p><p>写请求的话，我使用的是先更新数据库，在删除缓存的策略。</p><h1 id="电商项目"><a href="#电商项目" class="headerlink" title="电商项目"></a>电商项目</h1><h2 id="说一下分布式事务"><a href="#说一下分布式事务" class="headerlink" title="说一下分布式事务"></a>说一下分布式事务</h2><p>由多个服务通过网络完成一个事务叫分布式事务。</p><p>首先根据CAP原理决定我们的需求，是要实现CP、还是要实现AP。</p><p>实现CP就是要实现强一致性，可以使用 Seata 框架基于AT、TCC模式去实现。</p><p>我们项目中大部分实现的是AP，使用本地消息表加任务调度完成分布式事务最终数据一致性。</p><h2 id="项目中哪里用到了分布式事务，如何解决的"><a href="#项目中哪里用到了分布式事务，如何解决的" class="headerlink" title="项目中哪里用到了分布式事务，如何解决的"></a>项目中哪里用到了分布式事务，如何解决的</h2><ol><li>发布商品，发布商品需要在商品服务的数据库表中记录，同时将商品信息同步到redis和ES</li></ol><ul><li>发布商品使用本地事务向商品表中写入商品数据，同时写入一条待处理的消息到本地消息表</li><li>提交本地事务之后，xxl的调度中心使用分片广播模式向执行器下发任务，开始扫描消息表，查询待处理的消息</li><li>根据消息内容，通过调用Redis和ES的接口完成数据同步</li><li>任务完成后删除消息表记录</li></ul><ol start="2"><li>用户下单，需要调用商品服务扣减库存，订单服务创建订单，用户服务添加购买记录</li></ol><ul><li>订单服务收到下单请求后，开启本地事务，生成订单记录，然后写入本地消息表，记录要通知商品服务和用户服务的消息，提交事务后，通过消息队列发送通知消息</li><li>商品服务和用户服务通过监听消息队列来处理库存的扣减和添加购买记录的逻辑</li><li>如果消息队列发送失败或者没有被消费，就会使用xxl作为定时任务调度器，每隔一段时间扫描本地消息表中的异常记录进行消息补发</li></ul><h2 id="如何进行分布式事务的回滚"><a href="#如何进行分布式事务的回滚" class="headerlink" title="如何进行分布式事务的回滚"></a>如何进行分布式事务的回滚</h2><p>我项目中采用的是一种基于本地消息表和补偿机制的最终一致性方案。没有使用传统的强一致性分布式事务框架，通过状态标记和异步处理来实现逻辑上的回滚</p><p>在整个业务流程中，每个关键操作都配合本地消息表记录执行状态。当某个服务执行失败时，首先在服务内部有失败重试机制，尽最大努力成功，如果重试后仍失败，会将失败消息记录转移到数据库中的事务失败表，并在消息表中更新状态字段，最后使用xxl定时扫描失败记录表，执行补偿逻辑，并且对于一致性要求比较强的场景，我还使用了消息队列进行即时的通知，xxl作为兜底</p><p>比如用户下单操作中，订单服务已经创建好订单了，但是后续商品扣减库存出了问题，现在想要回滚，那么首先商品服务会发送一条失败消息到消息队列中，并且将失败消息记录到数据库中，订单服务获取到之后，会修改订单表中的状态字段为失败，通过状态标记避免后续的处理</p><h2 id="除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路"><a href="#除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路" class="headerlink" title="除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路"></a>除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路</h2><ul><li>XA，两阶段提交，先准备资源，再统一提交或者回滚</li><li>TCC，把每个操作拆分成三部分，先预检查，再尝试获取资源，最后提交实际操作</li><li>SAGA，长事务补偿，将事务拆分为一系列子事务，每个子事务完成后立刻提交，如果后续事务失败，则按顺序调用每个子事务的补偿操作来回滚</li></ul><p>为什么我选择任务调度这种方式，因为我认为这个项目中主要以性能和并发为优先考虑，不适合xa和tcc，并且业务是允许最终一致性的，不是强一致性的，而且消息队列和xxl的方式比较好实现</p><h2 id="Elasticsearch是怎么使用的"><a href="#Elasticsearch是怎么使用的" class="headerlink" title="Elasticsearch是怎么使用的"></a>Elasticsearch是怎么使用的</h2><p>1）首先创建索引（相当于mysql的表），将商品信息添加到索引库，对商品信息进行分词，存储到索引库</p><p>2）在商品服务中编写商品搜索接口，调用es的rest接口根据关键字、商品分类信息进行搜索</p><h3 id="如何保证索引同步"><a href="#如何保证索引同步" class="headerlink" title="如何保证索引同步"></a>如何保证索引同步</h3><p>我项目是使用本地任务表加xxl-job任务调度进行索引同步</p><p>1）添加或修改或删除商品的同时向任务表插入一条记录，这条记录就记录了是修改了哪个商品</p><p>2）任务调度定时扫描任务表，根据任务表的内容对商品信息进行同步，如果添加了商品将商品添加到索引库，如果修改了商品就修改索引库的商品，如果是删除了商品将商品信息从索引库删除</p><h2 id="xxl-job的工作原理是什么"><a href="#xxl-job的工作原理是什么" class="headerlink" title="xxl-job的工作原理是什么"></a>xxl-job的工作原理是什么</h2><p>xxl由调度中心和执行器组成，在应用启动时，执行器会将自己注册到调度中心Admin，然后在Admin中配置定时任务，指定要调哪个Bean和方法，到达任务触发时间后，Admin通过HTTP请求调用对应的执行器，执行结果会通过回调上传给调度中心，如果失败还可以配置自动重试机制。并且如果有很多执行器，xxl还支持负载均衡策略和任务分片</p><p>在我的项目中，我主要使用xxl实现对本地消息表和失败记录表的定时扫描，还有对于优惠券和商品的限时抢购的时间预订功能</p><h2 id="如何保证任务不重复执行"><a href="#如何保证任务不重复执行" class="headerlink" title="如何保证任务不重复执行"></a>如何保证任务不重复执行</h2><p>主要有两种方式，一个是每个任务都会生成一个唯一的Id，业务层判断该任务是否已经执行过，还有每条待处理的消息记录在消息表中含有状态字段，调度器扫描任务时，通过状态判断是否执行过，避免重复触发</p><h2 id="未支付订单如何处理"><a href="#未支付订单如何处理" class="headerlink" title="未支付订单如何处理"></a>未支付订单如何处理</h2><p>在我的项目中使用RabbitMQ的死信队列机制处理未支付订单，用户提交订单之后，系统会向消息队列中发送一条消息，交换机配置为死信交换机，过期后，消息被路由到死信队列，然后执行取消订单，恢复库存的逻辑</p><h2 id="如何保证RabbitMQ的消息可靠性"><a href="#如何保证RabbitMQ的消息可靠性" class="headerlink" title="如何保证RabbitMQ的消息可靠性"></a>如何保证RabbitMQ的消息可靠性</h2><p>可靠性保证主要分为三部分，一个是生产者到消息队列的可靠性，这部分由消息确认机制保证，就是生产者发送消息后，会异步等待消息队列反馈ACK，一个是消息队列内部的可靠性，消息队列内部有持久化机制，可以将未消费消息保存到硬盘中，一个是消息队列到消费者的可靠性，这个与生产者类似，消费者接收到消息并且成功处理之后，会反馈给消息队列，然后消息队列才会把这条消息删除，如果处理失败或者一直没有处理会触发重试机制</p><h3 id="如何避免消息重复消费"><a href="#如何避免消息重复消费" class="headerlink" title="如何避免消息重复消费"></a>如何避免消息重复消费</h3><p>每个业务操作都有唯一ID，这个ID会随着消息一起发送到消息队列中，如果这个消息已经被消费了，就一定会在数据库中有记录，就算消费者后续反馈到消息队列的ack丢失，触发消息队列的重试机制了，消费者再次收到相同消息时也不会重复消费</p><h2 id="为什么选择RabbitMQ"><a href="#为什么选择RabbitMQ" class="headerlink" title="为什么选择RabbitMQ"></a>为什么选择RabbitMQ</h2><p>首先RabbitMQ支持可靠性传输机制，提供了持久化，ack确认机制，消息重试和死信机制，然后它提供了很多的消息路由类型（点对点路由、模糊匹配路由、广播路由），可以应对不同的业务场景</p><h2 id="项目使用Redis缓存了哪些数据"><a href="#项目使用Redis缓存了哪些数据" class="headerlink" title="项目使用Redis缓存了哪些数据"></a>项目使用Redis缓存了哪些数据</h2><p>缓存内容有商品详情、商品列表、用户信息等访问频率可能比较高的数据</p><p>使用的数据结构：</p><ul><li>String：商品详情</li><li>Hash：用户信息、购物车数据</li><li>List：排行榜、热门商品</li></ul><h2 id="如何保证Redis缓存一致性"><a href="#如何保证Redis缓存一致性" class="headerlink" title="如何保证Redis缓存一致性"></a>如何保证Redis缓存一致性</h2><p>对于正常读写场景，我采用的是先更新数据库，再删除缓存的方式，对于高并发写场景，我采用的是先更新缓存，再异步更新数据库的方式，高并发为了减轻数据库压力、提高写入性能，直接写缓存，再通过消息队列异步写数据库，确保最终一致</p><h2 id="优惠券秒杀部分怎么实现的"><a href="#优惠券秒杀部分怎么实现的" class="headerlink" title="优惠券秒杀部分怎么实现的"></a>优惠券秒杀部分怎么实现的</h2><p>秒杀的核心目标首先是保证优惠券不能超卖，同一用户不能重复领券。首先我会把券的库存预加载进Redis中，然后把校验用户身份和扣减库存这两步写到lua脚本里原子执行，然后如果redis返回成功，就会向消息队列中发一条更新数据库的消息，把优惠券写到用户信息中，这样既能流量削峰，也能保证幂等性。</p><h2 id="秒杀的核心瓶颈是什么"><a href="#秒杀的核心瓶颈是什么" class="headerlink" title="秒杀的核心瓶颈是什么"></a>秒杀的核心瓶颈是什么</h2><ul><li>高并发，瞬间就会有上万的用户访问同一个服务，可能会导致服务崩溃。可以使用令牌桶拦截多余请求，或者使用消息队列异步处理</li><li>库存超卖，多个用户并发抢购，有可能库存为0时仍被扣减。可以使用Redis+Lua脚本原子操作</li><li>数据库写入压力，秒杀成功时大量请求写入数据库。可以使用消息队列异步写入，或者分库分表缓解单表写入瓶颈</li><li>重复下单，在redis加一个用户id锁，然后在过期之前把优惠券持有情况写到数据库中，后续分布式锁过期了也可以保证幂等性</li></ul><h2 id="当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施"><a href="#当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施" class="headerlink" title="当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施"></a>当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施</h2><ul><li>首先可以在网关层限流，对IP限流，每个IP每秒不超过5次</li><li>然后可以在服务层限流，以用户id统计单位时间内的访问次数，超出阈值后进入冷却期，在一定时间内限制该用户的访问</li><li>然后在核心接口的访问使用令牌桶，用户抢到令牌才能继续请求</li></ul><h2 id="假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理"><a href="#假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理" class="headerlink" title="假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理"></a>假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理</h2><p>关于这一点，我采用了订单状态控制和幂等机制来确保流程正确性。我在设计订单支付功能时，订单表中有一个状态字段，支付成功只能从未支付转为已支付，退款只能从已支付状态进入。支付成功后立马发起退款，如果当前数据库的订单状态还没转换成未支付，说明当前的订单服务都还没执行完，就会拒绝退款，如果订单状态已经转换成已支付了，就会进入退款流程，然后把订单状态改为已退款，因为订单服务之后会走用户服务和商品服务，用户服务是一定会走的，因为用户曾经创建过这个订单，然后商品服务的话会执行恢复库存这样的操作</p><h2 id="订单失败如何给用户进行反馈的"><a href="#订单失败如何给用户进行反馈的" class="headerlink" title="订单失败如何给用户进行反馈的"></a>订单失败如何给用户进行反馈的</h2><p>用户下单请求是通过接口发起的，在Controller层会捕获所有异常情况，如果业务逻辑执行失败，后端会返回统一格式的失败响应结构，前端拿到响应后通过异常响应信息提示用户。在订单表中有一个状态字段，每个订单可能的到达的状态在字段中都有记录，无论哪一步失败，都会更新订单状态字段，保障用户能获取订单失败的原因</p><h2 id="当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做"><a href="#当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做" class="headerlink" title="当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做"></a>当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做</h2><p>首先将先将失败订单进行归类管理，为后续调度处理提供依据，比如超时未支付，扣库存失败等情况，每一类对应着不同的处理策略</p><p>然后为每个服务维护一张失败任务表，记录异常信息与状态字段，用xxl定时扫描任务表，使用分片广播模式将任务分发到多个执行器实例，每次任务执行前先通过订单状态字段判断是否已经处理保证幂等性，高并发场景下，也可结合分布式锁，确保订单只被一个任务执行，对处理失败的任务，支持自动重试机制，配置最大重试次数，失败次数超过阈值后自动转为人工处理，处理完成后更新订单状态，防止重复处理</p><h2 id="项目中的线程池使用什么方式创建的"><a href="#项目中的线程池使用什么方式创建的" class="headerlink" title="项目中的线程池使用什么方式创建的"></a>项目中的线程池使用什么方式创建的</h2><p>在项目中我使用的是Java原生的ThreadPoolExecutor，核心线程数我选择的是CPU核心数的两倍，最大线程数我用的核心线程数的两倍，非核心线程存活时间我设置的是一分钟，任务队列我用的有界数组队列，长度2000，拒绝策略使用的CallerRunsPolicy，当前线程执行任务。</p><h2 id="做微服务的意义是什么，耦合带来了什么问题，为什么要降低耦合，耦合高了有什么好处"><a href="#做微服务的意义是什么，耦合带来了什么问题，为什么要降低耦合，耦合高了有什么好处" class="headerlink" title="做微服务的意义是什么，耦合带来了什么问题，为什么要降低耦合，耦合高了有什么好处"></a>做微服务的意义是什么，耦合带来了什么问题，为什么要降低耦合，耦合高了有什么好处</h2><p>微服务的核心理念是将一个大而全的系统拆分为多个小而独立的服务，每个服务专注于一个业务功能，各服务之间通过API通信。</p><p>微服务可以降低模块之间的依赖，每个服务可以独立开发、测试、部署；然后如果某个服务出了故障，不一定影响全局，可以提高系统稳定性；多团队可并行开发，各自维护自己负责的服务；技术栈灵活，每个服务可以选用不同的技术；扩展性也好</p><p>耦合高了提高维护成本，改一个模块容易影响其他模块，容易引发连锁 Bug；扩展困难，无法对某个功能进行独立扩展，只能整体扩容，浪费资源；容错性比较差，一个模块崩了可能导致整个系统挂掉</p><p>耦合高了也有好处，单体应用性能高，逻辑直观，开发调试方便，高频调用时，方法级耦合比微服务高效</p><h1 id="国自然项目"><a href="#国自然项目" class="headerlink" title="国自然项目"></a>国自然项目</h1><h2 id="白天和夜晚的光照变化是怎么控制的"><a href="#白天和夜晚的光照变化是怎么控制的" class="headerlink" title="白天和夜晚的光照变化是怎么控制的"></a>白天和夜晚的光照变化是怎么控制的</h2><p>时间的变化主要是通过调整全局光照和天空盒参数实现的，把主光源作为太阳光源，绑定到脚本中，根据时间参数控制旋转角度和光照强度</p><p>Skybox使用支持昼夜渐变的材质（或者用两个不同的天空盒，通过插值过渡），颜色和曝光参数跟随时间变化</p><p>环境光在夜晚降低亮度，并增加微弱的蓝色调，让场景不至于完全漆黑</p><p>在夜晚阶段，还会动态启用海面反光的高光效果，模拟月光反射</p><h2 id="无人艇之间的交互逻辑和避障策略是怎样的"><a href="#无人艇之间的交互逻辑和避障策略是怎样的" class="headerlink" title="无人艇之间的交互逻辑和避障策略是怎样的"></a>无人艇之间的交互逻辑和避障策略是怎样的</h2><p>无人艇分为红方和蓝方，红方的任务是护送一艘大型舰艇，蓝方是接近并攻击，在逻辑上，每艘艇会周期性计算与目标和其他艇的距离与角度，根据博弈规则（保护优先、进攻优先等）决定下一步动作，信息是通过共享状态表实现的（集群队友的位置和速度）</p><p>针对静态障碍物的避障使用的Unity自带的NavMesh系统，动态的无人艇集群之间的避障使用的<code>Raycast</code>，根据探测距离设定危险等级，如果探测到最近距离小于安全阈值，就会微调航向角进行躲避</p><h2 id="你提到场景切换，状态是如何保存的"><a href="#你提到场景切换，状态是如何保存的" class="headerlink" title="你提到场景切换，状态是如何保存的"></a>你提到场景切换，状态是如何保存的</h2><p>我们在场景切换时主要会保存场景的本地状态，我是用一个脚本标记可保存的物体，保存时遍历这些物体，把 Prefab 名称、位置、旋转、缩放还有挂载的脚本等关键信息存成JSON文件。加载时再用这些数据实例化相应Prefab并恢复属性。</p><h3 id="为什么不用PlayerPrefs保存"><a href="#为什么不用PlayerPrefs保存" class="headerlink" title="为什么不用PlayerPrefs保存"></a>为什么不用PlayerPrefs保存</h3><p>PlayerPrefs更适合保存少量持久化设置，不适合频繁更新或存储复杂对象，序列化到内存或ScriptableObject性能更好。</p><h2 id="当前Unity项目与强化学习的集成点在哪"><a href="#当前Unity项目与强化学习的集成点在哪" class="headerlink" title="当前Unity项目与强化学习的集成点在哪"></a>当前Unity项目与强化学习的集成点在哪</h2><ul><li><p>Unity作为强化学习的环境端，负责渲染场景、模拟物理、生成状态信息，例如无人艇的位置信息、速度、任务完成进度，都会在Unity中实时计算</p></li><li><p>状态与动作交互是通过Unity与Python的通信接口传递数据，这里用的是ML-Agents的gRPC接口</p></li></ul><ul><li><p>Unity每一帧会将当前环境的状态向量打包传给RL端，RL算法根据策略网络输出动作，再传回Unity</p></li><li><p>奖励函数设计在Unity，在检测到回合结束条件时，会发出episode结束信号给RL端</p></li></ul><h1 id="RL项目"><a href="#RL项目" class="headerlink" title="RL项目"></a>RL项目</h1><h2 id="你怎么实现奖励与惩罚机制，Unity里怎么写这个逻辑"><a href="#你怎么实现奖励与惩罚机制，Unity里怎么写这个逻辑" class="headerlink" title="你怎么实现奖励与惩罚机制，Unity里怎么写这个逻辑"></a>你怎么实现奖励与惩罚机制，Unity里怎么写这个逻辑</h2><p>在Unity中，会给每个智能体挂载一个脚本，在其中维护当前步的奖励值，主要是基于事件驱动的方式计算奖励，比如：</p><ul><li>达成目标（寻路成功、穿越圆环）正奖励</li><li>碰撞障碍物或越界 负奖励</li><li>行动效率（节省时间&#x2F;距离）适度奖励或惩罚</li></ul><p>奖励值实时累加或反馈给强化学习算法</p><h2 id="Unity和Python是怎么通信的，用的什么方式"><a href="#Unity和Python是怎么通信的，用的什么方式" class="headerlink" title="Unity和Python是怎么通信的，用的什么方式"></a>Unity和Python是怎么通信的，用的什么方式</h2><p>主要通信方式是用ML-Agents提供的API，Unity作为环境端，将状态数据序列化后发送给Python端的RL算法，Python算法根据状态返回动作指令，再发送给Unity执行，通信通常是同步请求响应模式，确保每步动作对应环境状态</p><h2 id="那在Unity中如何定义结束条件"><a href="#那在Unity中如何定义结束条件" class="headerlink" title="那在Unity中如何定义结束条件"></a>那在Unity中如何定义结束条件</h2><p>结束条件通过检测特定事件触发，比如：</p><ul><li>智能体完成任务（到达目标点）</li><li>触发最大步数限制（训练回合结束）</li><li>智能体碰撞或越界（失败）</li></ul><p>C#脚本中实现回合结束函数，触发环境重置和奖励结算</p><h2 id="复杂场景是怎么设计的？有什么特殊优化点？"><a href="#复杂场景是怎么设计的？有什么特殊优化点？" class="headerlink" title="复杂场景是怎么设计的？有什么特殊优化点？"></a>复杂场景是怎么设计的？有什么特殊优化点？</h2><p>设计思路：</p><ul><li>利用Terrain工具构建地形，包括山地、沟壑、湖泊等，使用贴图和植被系统增强真实感</li><li>放置障碍物和地标，设计合理路径和盲区增加训练难度</li></ul><p>优化点：</p><ul><li>使用NavMesh做路径规划和避障，提升性能和准确性</li><li>按需加载场景资源，避免一次性加载过多导致卡顿</li></ul>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://ltynote.cn/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://ltynote.cn/inori/b4ace844.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>基于Netty的RPC框架实现</title>
      <link>http://ltynote.cn/inori/2408437c.html</link>
      <guid>http://ltynote.cn/inori/2408437c.html</guid>
      <pubDate>Wed, 28 May 2025 02:53:58 GMT</pubDate>
      
      <description>基于Netty的RPC框架</description>
      
      
      
      <content:encoded><![CDATA[<p>RPC又称远程过程调用（Remote Procedure Call），用于解决分布式系统中服务之间的调用问题。通俗地讲，就是开发者能够像调用本地方法一样调用远程的服务。</p><img src="/inori/2408437c/rpc.png" style="zoom:50%;"><p>RPC框架一般必须包含三个组件，分别是<strong>客户端、服务端</strong>以及<strong>注册中心</strong>，一次完整的RPC调用流程一般为：</p><ol><li>服务端启动服务后，将他提供的服务列表发布到注册中心（服务注册）</li><li>客户端会向注册中心订阅相关的服务地址（服务订阅）</li><li>客户端通常会利用本地代理模块 Proxy 向服务端发起远程过程调用，Proxy 负责将调用的方法、参数等数据转化为网络字节流</li><li>客户端从服务列表中根据负载均衡策略选择一个服务地址，并将数据通过网络发送给服务端</li><li>服务端得到数据后，调用对应的服务，然后将结果通过网络返回给客户端</li></ol><p>虽然 RPC 调用流程很容易理解，但是实现一个完整的 RPC 框架设计到很多内容，例如服务注册与发现、通信协议与序列化、负载均衡、动态代理等</p><h2 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h2><ul><li>实现基于Netty&#x2F;Socket&#x2F;Http三种方式进行网路通信</li><li>自定义消息协议，编解码器</li><li>五种序列化算法（JDK、JSON、HESSIAN、KRYO、PROTOSTUFF）</li><li>三种负载均衡算法（RoundRobin、Random、ConsistentHash）</li><li>两种动态代理（JDK、CGLIB）</li><li>基于 Zookeeper 的服务注册与发现，增加服务本地缓存与监听</li><li>集成 Spring，自定义注解提供 RPC 组件扫描、服务注册、服务消费</li><li>集成 SpringBoot，完成自动配置</li><li>增加 Netty 心跳机制，复用 Channel 连接</li><li>实现自定义 SPI 机制</li></ul><h2 id="编解码模块"><a href="#编解码模块" class="headerlink" title="编解码模块"></a>编解码模块</h2><h3 id="粘包半包解决"><a href="#粘包半包解决" class="headerlink" title="粘包半包解决"></a>粘包半包解决</h3><p>这里采取的是消息长度 + 消息内容来解决的此问题，将每一条消息分为header和body，header中包含body的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 粘包半包编码器，使用固定长度的帧解码器，通过约定用定长字节表示接下来数据的长度</span></span><br><span class="line"><span class="comment"> * 非共享，保存了 ByteBuf 的状态信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcFrameDecoder</span> <span class="keyword">extends</span> <span class="title class_">LengthFieldBasedFrameDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">k RpcFrameDecoder#RpcFrameDecoder(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcFrameDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">16384</span>, <span class="number">12</span>, <span class="number">4</span>);  <span class="comment">// 前缀长度16字节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxFrameLength    数据帧的最大长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldOffset 长度域的偏移字节数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldLength 长度域所占的字节数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcFrameDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里我给定的消息体最大长度是16384Byte，即16KB，如果消息体长度比这个要大，就会抛出异常，无法接收</p><blockquote><p> Netty官方建议不要轻易超过 8MB，否则可能导致内存过度分配、内存攻击等问题</p></blockquote><h3 id="编解码实现"><a href="#编解码实现" class="headerlink" title="编解码实现"></a>编解码实现</h3><p>编码部分是出站处理，需要编写RpcMessage模块，即header和body，header是自定义协议：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------</span><br><span class="line">| 魔数 (4byte) | 版本号 (1byte)  | 序列化算法 (1byte) | 消息类型 (1byte) |</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">|    状态类型 (1byte)  |    消息序列号 (4byte)   |    消息长度 (4byte)   |</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">|                        消息内容 (不固定)                             |</span><br><span class="line">---------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>共16字节，在粘包半包解码器中定义了偏移量。</p><p>body部分使用序列化算法进行序列化，然后向下传递。</p><p>解码部分，先验证魔数是否符合要求，然后再进行后续的解码，在使用反序列化算法解析body部分获取消息体，然后向下传递。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Sharable</span><span class="comment">// 不存在线程竞争</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharableRpcMessageCodec</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, RpcMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码器为出站处理，将 RpcMessage 编码为 ByteBuf 对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> msg.getHeader();</span><br><span class="line">        <span class="comment">// 4字节 魔数</span></span><br><span class="line">        buf.writeBytes(header.getMagicNum());</span><br><span class="line">        <span class="comment">// 1字节 版本号</span></span><br><span class="line">        buf.writeByte(header.getVersion());</span><br><span class="line">        <span class="comment">// 1字节 序列化算法</span></span><br><span class="line">        buf.writeByte(header.getSerializerType());</span><br><span class="line">        <span class="comment">// 1字节 消息类型</span></span><br><span class="line">        buf.writeByte(header.getMessageType());</span><br><span class="line">        <span class="comment">// 1字节 消息状态</span></span><br><span class="line">        buf.writeByte(header.getMessageStatus());</span><br><span class="line">        <span class="comment">// 4字节 消息序列号</span></span><br><span class="line">        buf.writeInt(header.getSequenceId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出消息体</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> msg.getBody();</span><br><span class="line">        <span class="comment">// 获取序列化算法</span></span><br><span class="line">        <span class="type">Serialization</span> <span class="variable">serialization</span> <span class="operator">=</span> SerializationFactory</span><br><span class="line">                .getSerialization(SerializationType.parseByType(header.getSerializerType()));</span><br><span class="line">        <span class="comment">// 进行序列化</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = serialization.serialize(body);</span><br><span class="line">        <span class="comment">// 设置消息体长度</span></span><br><span class="line">        header.setLength(bytes.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4字节 消息内容长度</span></span><br><span class="line">        buf.writeInt(header.getLength());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不固定字节 消息内容字节数组</span></span><br><span class="line">        buf.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传递到下一个出站处理器</span></span><br><span class="line">        out.add(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码器为入站处理，将 ByteBuf 对象解码成 RpcMessage 对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 4字节 魔数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> ProtocolConstants.MAGIC_NUM.length;</span><br><span class="line">        <span class="type">byte</span>[] magicNum = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        msg.readBytes(magicNum, <span class="number">0</span>, len);</span><br><span class="line">        <span class="comment">// 判断魔数是否正确，不正确表示非协议请求，不进行处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (magicNum[i] != ProtocolConstants.MAGIC_NUM[i]) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown magic code: &quot;</span> + Arrays.toString(magicNum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1字节 版本号</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 检查版本号是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (version != ProtocolConstants.VERSION) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The version isn&#x27;t compatible &quot;</span> + version);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1字节 序列化算法</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializeType</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 1字节 消息类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 1字节 消息状态</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageStatus</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 4字节 消息序列号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> msg.readInt();</span><br><span class="line">        <span class="comment">// 4字节 长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> msg.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        msg.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建协议头部信息</span></span><br><span class="line">        <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> MessageHeader.builder()</span><br><span class="line">                .magicNum(magicNum)</span><br><span class="line">                .version(version)</span><br><span class="line">                .serializerType(serializeType)</span><br><span class="line">                .messageType(messageType)</span><br><span class="line">                .sequenceId(sequenceId)</span><br><span class="line">                .messageStatus(messageStatus)</span><br><span class="line">                .length(length).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取反序列化算法</span></span><br><span class="line">        <span class="type">Serialization</span> <span class="variable">serialization</span> <span class="operator">=</span> SerializationFactory</span><br><span class="line">                .getSerialization(SerializationType.parseByType(serializeType));</span><br><span class="line">        <span class="comment">// 获取消息枚举类型</span></span><br><span class="line">        <span class="type">MessageType</span> <span class="variable">type</span> <span class="operator">=</span> MessageType.parseByType(messageType);</span><br><span class="line">        <span class="type">RpcMessage</span> <span class="variable">protocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcMessage</span>();</span><br><span class="line">        protocol.setHeader(header);</span><br><span class="line">        <span class="keyword">if</span> (type == MessageType.REQUEST) &#123;</span><br><span class="line">            <span class="comment">// 进行反序列化</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> serialization.deserialize(RpcRequest.class, bytes);</span><br><span class="line">            protocol.setBody(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == MessageType.RESPONSE) &#123;</span><br><span class="line">            <span class="comment">// 进行反序列化</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> serialization.deserialize(RpcResponse.class, bytes);</span><br><span class="line">            protocol.setBody(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == MessageType.HEARTBEAT_REQUEST || type == MessageType.HEARTBEAT_RESPONSE) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> serialization.deserialize(String.class, bytes);</span><br><span class="line">            protocol.setBody(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 传递到下一个处理器</span></span><br><span class="line">        out.add(protocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化算法"><a href="#序列化算法" class="headerlink" title="序列化算法"></a>序列化算法</h2><p>客户端和服务端在通信过程中肯定要传输数据，但是这些数据不可能是直接明文传输的，我们需要对数据进行编码，那么该如何编解码呢？</p><p>如果采用TCP协议，我们需要将调用的接口、方法、请求参数、调用属性等信息序列化成二进制字节流传递给服务提供方，服务端接收到数据后，再把二进制字节流反序列化得到调用信息，然后利用反射的原理调用对应方法，最后将返回结果、返回码、异常信息等返回给客户端。所谓序列化和反序列化就是将对象转换成二进制流以及将二进制流再转换成对象的过程。因为网络通信依赖于字节流，而且这些请求信息都是不确定的，所以一般会选用通用且高效的序列化算法。比较常用的序列化算法有<code>FastJson、Kryo、Hessian、Protobuf</code>等，这些第三方序列化算法都比Java原生的序列化操作都更加高效</p><p>Dubbo支持多种序列化算法，并定义了Serialization接口规范，所有序列化算法扩展都必须实现该接口，其中默认使用的是<code>Hessian</code>序列化算法</p><p>序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等同样也起着至关重要的作用，是提升分布式系统性能的最关键因素之一</p><p>判断一个编码框架的优劣主要从以下几个方面：</p><ol><li>是否支持跨语言，支持语种是否丰富</li><li>编码后的码流</li><li>编解码的性能</li><li>类库是否小巧，API使用是否方便</li><li>使用者开发的工作量和难度</li></ol><p>本项目计划实现5种序列化算法，分别为：<u>JDK、JSON、HESSIAN、KRYO 、PROTOSTUFF</u>，其中JSON使用GSON实现</p><p>五种序列化算法的比较如下：</p><table><thead><tr><th>序列化算法</th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>Kryo</strong></td><td>速度快，序列化后体积小</td><td>跨语言支持较复杂</td></tr><tr><td><strong>Hessian</strong></td><td>默认支持跨语言</td><td>较慢</td></tr><tr><td><strong>Protostuff</strong></td><td>速度快，基于protobuf</td><td>需静态编译</td></tr><tr><td><strong>Json</strong></td><td>使用方便</td><td>性能一般</td></tr><tr><td><strong>Jdk</strong></td><td>使用方便，可序列化所有类</td><td>速度慢，占空间</td></tr></tbody></table><h3 id="Hessian序列化"><a href="#Hessian序列化" class="headerlink" title="Hessian序列化"></a>Hessian序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HessianSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建字节数组输出流（内存缓冲区）</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="comment">// 创建Hessian序列化输出流</span></span><br><span class="line">            <span class="type">HessianSerializerOutput</span> <span class="variable">hso</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializerOutput</span>(baos);</span><br><span class="line">            hso.writeObject(object);</span><br><span class="line">            hso.flush();</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Hessian serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将字节数组包装为输入流</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="comment">// 创建 Hessian 反序列化输入流</span></span><br><span class="line">            <span class="type">HessianSerializerInput</span> <span class="variable">hsi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializerInput</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> (T) hsi.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Hessian deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jdk序列化"><a href="#Jdk序列化" class="headerlink" title="Jdk序列化"></a>Jdk序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">            oos.writeObject(object);</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Jdk serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line">            <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Jdk deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h3><p>由于Gson默认不能序列化Class对象，因为Class没有默认的序列化方案，举个例子，我们的RPCRequest类是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名称：请求的服务名 + 版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求调用的方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameterValues;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们要远程调用的方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(String id, <span class="type">int</span> level)</span></span><br></pre></td></tr></table></figure><p>那我们就会创建这个<code>RpcRequest</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequest</span>();</span><br><span class="line">request.setMethod(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">request.setParameterTypes(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;String.class, <span class="type">int</span>.class&#125;);</span><br><span class="line">request.setParameterValues(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;abc123&quot;</span>, <span class="number">5</span>&#125;);</span><br></pre></td></tr></table></figure><p>如果我们要使用Gson序列化这个类时，就可以自己注册一个 <code>JsonSerializer&lt;Class&lt;?&gt;&gt;</code> 和 <code>JsonDeserializer&lt;Class&lt;?&gt;&gt;</code>，完全实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义 JavaClass 对象序列化，解决 Gson 无法序列化 Class 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassCodec</span> <span class="keyword">implements</span> <span class="title class_">JsonSerializer</span>&lt;Class&lt;?&gt;&gt;, JsonDeserializer&lt;Class&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// 反序列化 String -&gt; Class</span></span><br><span class="line">        <span class="meta">@SneakyThrows</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) <span class="keyword">throws</span> JsonParseException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> json.getAsString();</span><br><span class="line">            <span class="keyword">return</span> Class.forName(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化 Class -&gt; String (类名)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> JsonElement <span class="title function_">serialize</span><span class="params">(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonPrimitive</span>(src.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class="keyword">new</span> <span class="title class_">ClassCodec</span>()).create();</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> gson.toJson(object);</span><br><span class="line">            <span class="keyword">return</span> json.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Json serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class="keyword">new</span> <span class="title class_">ClassCodec</span>()).create();</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="keyword">return</span> gson.fromJson(json, clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonSyntaxException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Json deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kryo序列化"><a href="#Kryo序列化" class="headerlink" title="Kryo序列化"></a>Kryo序列化</h3><p>为什么Kryo线程不安全？其他序列化方法为什么线程安全？这个问题我们之后单独开一个帖子说~</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// kryo 线程不安全，所以使用 ThreadLocal 保存 kryo 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        <span class="comment">// 注册需要序列化的类（提高性能并减少数据体积）</span></span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(baos);</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get(); <span class="comment">// 获取当前线程的 Kryo 实例</span></span><br><span class="line">            <span class="comment">// 将对象序列化为 byte 数组</span></span><br><span class="line">            kryo.writeObject(output, object);</span><br><span class="line">            <span class="comment">// 清理线程变量，避免内存泄漏</span></span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Kryo serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(bais);</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// 将 byte 数组反序列化为 T 对象</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">object</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Kryo deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Protostuff序列化"><a href="#Protostuff序列化" class="headerlink" title="Protostuff序列化"></a>Protostuff序列化</h3><p>Protostuff需要用一个<code>LinkedBuffer</code>作为临时写入区域，项目中提前分配一个共享的 <code>BUFFER</code>，避免每次都重新分配，提高性能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtostuffSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提前分配好 Buffer，避免每次进行序列化都需要重新分配 buffer 内存空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;LinkedBuffer&gt; BUFFER_THREAD_LOCAL =</span><br><span class="line">        ThreadLocal.withInitial(() -&gt; LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="type">LinkedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> BUFFER_THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取对象的运行时 schema</span></span><br><span class="line">            <span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> RuntimeSchema.getSchema(object.getClass());</span><br><span class="line">            <span class="comment">// 使用 protostuff 将对象转为字节数组</span></span><br><span class="line">            <span class="keyword">return</span> ProtostuffIOUtil.toByteArray(object, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Protostuff serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 使用完 buffer 后清空，避免内存泄漏</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Schema&lt;T&gt; schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="comment">// 创建空对象并填充数据</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">object</span> <span class="operator">=</span> schema.newMessage();</span><br><span class="line">            ProtostuffIOUtil.mergeFrom(bytes, object, schema);</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Protostuff deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>在分布式系统中，不同服务之间应该如何通信呢？传统的方式可以通过 HTTP 请求调用、保存服务端的服务列表等，这样做需要开发者主动感知到服务端暴露的信息，系统之间耦合严重。为了更好地将客户端和服务端解耦，以及实现服务优雅上线和下线，于是注册中心就出现了。在RPC框架中，主要是使用注册中心来实现服务注册和发现的功能。服务端节点上线后自行向注册中心注册服务列表，节点下线时需要从注册中心将节点元数据信息移除。客户端向服务端发起调用时，自己负责从注册中心获取服务端的服务列表，然后在通过负载均衡算法选择其中一个服务节点进行调用。</p><p>现在思考一个问题，服务在下线时需要从注册中心移除元数据，那么注册中心怎么才能感知到服务下线呢？我们最先想到的方法就是节点主动通知的实现方式，当节点需要下线时，向注册中心发送下线请求，让注册中心移除自己的元数据信息。但是如果节点异常退出，例如断网、进程崩溃等，那么注册中心将会一直残留异常节点的元数据，从而可能造成服务调用出现问题。</p><p>为了避免上述问题，实现服务优雅下线比较好的方式是采用主动通知 + 心跳检测的方案。除了主动通知注册中心下线外，还需要增加节点与注册中心的心跳检测功能，这个过程也叫作探活。心跳检测可以由节点或者注册中心负责，例如注册中心可以向服务节点每 60s 发送一次心跳包，如果 3 次心跳包都没有收到请求结果，可以任务该服务节点已经下线。</p><p>采用注册中心的好处是可以解耦客户端和服务端之间错综复杂的关系，并且能够实现对服务的动态管理。服务配置可以支持动态修改，然后将更新后的配置推送到客户端和服务端，无须重启任何服务。</p><p>本项目计划实现以Zookeeper为注册中心。</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>关键字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会话超时时间，客户端在此时间内未与 zk 服务器保持心跳，则认为连接断开</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SESSION_TIMEOUT</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// zk 客户端连接 zk 服务器时的连接超时时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONNECT_TIMEOUT</span> <span class="operator">=</span> <span class="number">15</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 超时重试间隔时间，用于指数回退重试策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE_SLEEP_TIME</span> <span class="operator">=</span> <span class="number">3</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 最大重试次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RETRY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// zk中所有服务注册的根路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/rpc&quot;</span>;</span><br><span class="line"><span class="comment">// Curator 提供的 zk 客户端对象，封装了 zookeeper 的连接管理、重试、监听等功能</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"><span class="comment">// Curator 的服务发现组件，用于查询、注册、注销服务实例</span></span><br><span class="line"><span class="keyword">private</span> ServiceDiscovery&lt;ServiceInfo&gt; serviceDiscovery;</span><br></pre></td></tr></table></figure><p>构造方法，传入Zookeeper地址并进行初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ZookeeperServiceRegistry</span><span class="params">(String registryAddress)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建zk客户端示例</span></span><br><span class="line">        client = CuratorFrameworkFactory</span><br><span class="line">                .newClient(registryAddress, SESSION_TIMEOUT, CONNECT_TIMEOUT,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(BASE_SLEEP_TIME, MAX_RETRY));</span><br><span class="line">        <span class="comment">// 开启客户端通信</span></span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 ServiceDiscovery 服务注册中心</span></span><br><span class="line">        serviceDiscovery = ServiceDiscoveryBuilder.builder(ServiceInfo.class)</span><br><span class="line">                .client(client)</span><br><span class="line">                .serializer(<span class="keyword">new</span> <span class="title class_">JsonInstanceSerializer</span>&lt;&gt;(ServiceInfo.class))</span><br><span class="line">                .basePath(BASE_PATH)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        serviceDiscovery.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;An error occurred while starting the zookeeper registry: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册方法，将服务注册到zk中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceInstance&lt;ServiceInfo&gt; serviceInstance = ServiceInstance.&lt;ServiceInfo&gt;builder()</span><br><span class="line">                .name(serviceInfo.getServiceName())</span><br><span class="line">                .address(serviceInfo.getAddress())</span><br><span class="line">                .port(serviceInfo.getPort())</span><br><span class="line">                .payload(serviceInfo)</span><br><span class="line">                .build();</span><br><span class="line">        serviceDiscovery.registerService(serviceInstance);</span><br><span class="line">        log.info(<span class="string">&quot;Successfully registered [&#123;&#125;] service.&quot;</span>, serviceInstance.getName());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;An error occurred when rpc server registering [%s] service.&quot;</span>,</span><br><span class="line">                serviceInfo.getServiceName()), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务注销与删除方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(ServiceInfo serviceInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ServiceInstance&lt;ServiceInfo&gt; serviceInstance = ServiceInstance.&lt;ServiceInfo&gt;builder()</span><br><span class="line">            .name(serviceInfo.getServiceName())</span><br><span class="line">            .address(serviceInfo.getAddress())</span><br><span class="line">            .port(serviceInfo.getPort())</span><br><span class="line">            .payload(serviceInfo)</span><br><span class="line">            .build();</span><br><span class="line">    serviceDiscovery.unregisterService(serviceInstance);</span><br><span class="line">    log.warn(<span class="string">&quot;Successfully unregistered &#123;&#125; service.&quot;</span>, serviceInstance.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    serviceDiscovery.close();</span><br><span class="line">    client.close();</span><br><span class="line">    log.info(<span class="string">&quot;Destroy zookeeper registry completed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>关键字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SESSION_TIMEOUT</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONNECT_TIMEOUT</span> <span class="operator">=</span> <span class="number">15</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE_SLEEP_TIME</span> <span class="operator">=</span> <span class="number">3</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RETRY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/rpc&quot;</span>;</span><br><span class="line"><span class="comment">// 负载均衡接口</span></span><br><span class="line"><span class="keyword">private</span> LoadBalance loadBalance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> org.apache.curator.x.discovery.ServiceDiscovery&lt;ServiceInfo&gt; serviceDiscovery;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServiceCache: 将在zk中的服务数据缓存至本地，并监听服务变化，实时更新缓存</span></span><br><span class="line"><span class="comment"> * 服务本地缓存，将服务缓存到本地并增加 watch 事件，当远程服务发生改变时自动更新服务缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ServiceCache&lt;ServiceInfo&gt;&gt; serviceCacheMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 将服务列表缓存到本地内存，当服务发生变化时，由 serviceCache 进行服务列表更新操作，当 zk 挂掉时，将保存当前服务列表以便继续提供服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;ServiceInfo&gt;&gt; serviceMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>构造方法，初始化zk客户端和服务发现对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ZookeeperServiceDiscovery</span><span class="params">(String registryAddress, LoadBalance loadBalance)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadBalance = loadBalance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建zk客户端示例</span></span><br><span class="line">        client = CuratorFrameworkFactory</span><br><span class="line">                .newClient(registryAddress, SESSION_TIMEOUT, CONNECT_TIMEOUT,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(BASE_SLEEP_TIME, MAX_RETRY));</span><br><span class="line">        <span class="comment">// 开启客户端通信</span></span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 ServiceDiscovery 服务注册中心</span></span><br><span class="line">        serviceDiscovery = ServiceDiscoveryBuilder.builder(ServiceInfo.class)</span><br><span class="line">                .client(client)</span><br><span class="line">                .serializer(<span class="keyword">new</span> <span class="title class_">JsonInstanceSerializer</span>&lt;&gt;(ServiceInfo.class))</span><br><span class="line">                .basePath(BASE_PATH)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 开启 服务发现</span></span><br><span class="line">        serviceDiscovery.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;An error occurred while starting the zookeeper discovery: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取服务列表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ServiceInfo&gt; <span class="title function_">getServices</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!serviceMap.containsKey(serviceName)) &#123;</span><br><span class="line">        <span class="comment">// 首次调用时，为该服务名构建一个本地缓存，并开始监听 zk 目录下该服务名节点的变化</span></span><br><span class="line">        ServiceCache&lt;ServiceInfo&gt; serviceCache = serviceDiscovery.serviceCacheBuilder()</span><br><span class="line">                .name(serviceName)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 添加服务监听，当服务发生变化时主动更新本地缓存并通知</span></span><br><span class="line">        serviceCache.addListener(<span class="keyword">new</span> <span class="title class_">ServiceCacheListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cacheChanged</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;The service [&#123;&#125;] cache has changed. The current number of service samples is &#123;&#125;.&quot;</span></span><br><span class="line">                        , serviceName, serviceCache.getInstances().size());</span><br><span class="line">                <span class="comment">// 更新本地缓存的服务列表</span></span><br><span class="line">                serviceMap.put(serviceName, serviceCache.getInstances().stream()</span><br><span class="line">                        .map(ServiceInstance::getPayload)</span><br><span class="line">                        .collect(Collectors.toList()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> &#123;</span><br><span class="line">                <span class="comment">// 当连接状态发生改变时，只打印提示信息，保留本地缓存的服务列表</span></span><br><span class="line">                log.info(<span class="string">&quot;The client &#123;&#125; connection status has changed. The current status is: &#123;&#125;.&quot;</span></span><br><span class="line">                        , client, newState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 开启服务缓存监听</span></span><br><span class="line">        serviceCache.start();</span><br><span class="line">        <span class="comment">// 将服务缓存对象存入本地</span></span><br><span class="line">        serviceCacheMap.put(serviceName, serviceCache);</span><br><span class="line">        <span class="comment">// 将服务列表缓存到本地</span></span><br><span class="line">        serviceMap.put(serviceName, serviceCacheMap.get(serviceName).getInstances()</span><br><span class="line">                .stream()</span><br><span class="line">                .map(ServiceInstance::getPayload)</span><br><span class="line">                .collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serviceMap.get(serviceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择服务实例，根据服务名 + 负载均衡策略选择一个可用的 <code>ServiceInfo</code> 服务实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">discover</span><span class="params">(RpcRequest request)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loadBalance.select(getServices(request.getServiceName()), request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;Remote service discovery did not find service %s.&quot;</span>,</span><br><span class="line">                request.getServiceName()), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清理所有zk相关连接资源，确保优雅下线：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (ServiceCache&lt;ServiceInfo&gt; serviceCache : serviceCacheMap.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (serviceCache != <span class="literal">null</span>) &#123;</span><br><span class="line">            serviceCache.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (serviceDiscovery != <span class="literal">null</span>) &#123;</span><br><span class="line">        serviceDiscovery.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>在分布式系统中，服务提供者和服务消费者都会有多台节点，如何保证服务提供者所有节点的负载均衡呢？</p><p>客户端在发起调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。客户端需要拿到服务端节点的状态信息，并根据不同的策略实现负载均衡算法</p><ul><li>Round-Robin轮询：依次轮询服务端节点</li><li>Weighted Round-Robin 权重轮询：对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量</li><li>Least Connections 最少连接数：客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU利用率最低等其他维度的负载均衡方案</li><li>Consistent Hash 一致性 Hash：目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点</li></ul><p>本项目实现Random、Round-Robin、Consistent Hash三种负载均衡算法</p><p>首先编写一个抽象类，定义实现负载均衡的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLoadBalance</span> <span class="keyword">implements</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">select</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="literal">null</span> || invokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果服务列表中只有一个服务，无需进行负载均衡，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行负载均衡，由具体的子类实现</span></span><br><span class="line">        <span class="keyword">return</span> doSelect(invokers, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现具体负载均衡策略的选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers 服务列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  rpc 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回服务信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机负载均衡"><a href="#随机负载均衡" class="headerlink" title="随机负载均衡"></a>随机负载均衡</h3><p>随机选择一个节点即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(random.nextInt(invokers.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="轮询负载均衡"><a href="#轮询负载均衡" class="headerlink" title="轮询负载均衡"></a>轮询负载均衡</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(getAndIncrement() % invokers.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前值并加一，通过 CAS 原子更新，当前值到达 &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125; 时，重新设值为 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回当前的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = atomicInteger.get();</span><br><span class="line">            next = prev == Integer.MAX_VALUE ? <span class="number">0</span> : prev + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!atomicInteger.compareAndSet(prev, next));<span class="comment">//把prev更新成next</span></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性哈希负载均衡"><a href="#一致性哈希负载均衡" class="headerlink" title="一致性哈希负载均衡"></a>一致性哈希负载均衡</h3><p>在分布式系统中，负载均衡是将请求分发到多个服务节点上的关键手段。如果使用简单的哈希方式（比如：<code>hash(key) % 节点数量</code>），当服务节点发生变化（如新增或下线一个服务节点），所有请求的分发都会大范围变化，这会导致：</p><ul><li>原本某个 key 缓存在 A 节点，新请求可能被分配到 B，导致缓存失效</li><li>用户粘性丧失，会话丢失</li><li>系统效率大幅下降</li></ul><p>所以我们希望：<strong>节点数量变化时，尽量少地影响原有请求的分配规律</strong></p><p>一致性哈希算法就是为此设计的，它有两个目标：</p><ol><li>相同的请求key总是路由到同一个节点（请求一致性）</li><li>节点变动时，只有<strong>极少数 key</strong>被重新分配（低扰动性）</li></ol><h4 id="一致性哈希的基本原理"><a href="#一致性哈希的基本原理" class="headerlink" title="一致性哈希的基本原理"></a>一致性哈希的基本原理</h4><ol><li>将哈希空间想象成一个“环”</li></ol><ul><li>假设 hash 值范围是 0 ~ 2³²-1，我们可以把它画成一个圆环</li><li>所有节点（服务实例）都通过哈希函数映射到这个环上某个位置</li></ul><ol start="2"><li>将请求（根据其 key）也映射到环上</li></ol><ul><li>请求经过哈希函数也会得到一个 hash 值，在环上的某个点</li></ul><ol start="3"><li>如何选择目标节点？</li></ol><ul><li>从请求所在的 hash 点开始，顺时针查找，直到找到第一个节点</li><li>这个节点就是这个请求应该被分配到的服务节点</li></ul><p>举个例子：</p><p>假设环上有 3 个节点：</p><ul><li>A → 哈希值 1000</li><li>B → 哈希值 4000</li><li>C → 哈希值 7000</li></ul><p>如果请求 key 哈希值为 4200，它将落在 C（7000）上</p><p>如果 key 哈希值为 8000，环上没有节点比它大，就从头开始找，第一个是 A（1000），所以分到 A</p><h4 id="虚拟节点机制"><a href="#虚拟节点机制" class="headerlink" title="虚拟节点机制"></a>虚拟节点机制</h4><p>真实服务节点数量较少（如3~5个），哈希分布不均匀，可能会出现某个节点承载大量请求的情况，导致负载不均</p><p>虚拟节点的做法：</p><ul><li>每个真实节点被映射成多个虚拟节点（通常是160个）</li><li>每个虚拟节点 hash 后也放在环上</li><li>请求还是通过 hash 值查找最近的虚拟节点，然后找出它对应的真实节点</li></ul><p>效果</p><ul><li>请求被均匀地分布到多个虚拟节点上</li><li>从而间接实现真实节点的负载均衡</li></ul><h4 id="处理节点变更问题"><a href="#处理节点变更问题" class="headerlink" title="处理节点变更问题"></a>处理节点变更问题</h4><p>新增节点：</p><ul><li>会在环上增加一些新的虚拟节点</li><li>新虚拟节点会“截断”一小段原本属于其他节点的请求范围</li><li>只有这一小部分请求分配发生变化，其他绝大部分 key 对应的服务节点不变</li></ul><p>删除节点：</p><ul><li>其虚拟节点从环上移除</li><li>这些虚拟节点对应的请求会顺时针路由到下一个节点</li><li>同样只影响少部分请求</li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>编写静态内部类，实现一致性哈希的核心部分，维护一个<strong>虚拟节点环</strong>来实现平衡性和低扰动性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashSelector</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 TreeMap 存储虚拟节点（virtualInvokers 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构，底层使用红黑树，比HashMap查询速度要快）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, ServiceInfo&gt; virtualInvokers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invokers 的原始哈希码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> identityHashCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个 ConsistentHashSelector 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers         存储虚拟节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replicaNumber    虚拟节点数，默认为 160</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> identityHashCode invokers 的原始哈希码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsistentHashSelector</span><span class="params">(List&lt;ServiceInfo&gt; invokers, <span class="type">int</span> replicaNumber, <span class="type">int</span> identityHashCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.virtualInvokers = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.identityHashCode = identityHashCode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ServiceInfo invoker : invokers) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> invoker.getAddress();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 对 address + i 进行 md5 运算，得到一个长度为16的字节数组</span></span><br><span class="line">                <span class="type">byte</span>[] digest = md5(address + i);</span><br><span class="line">                <span class="comment">// 对 digest 部分字节进行4次 hash 运算，得到四个不同的 long 型正整数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                    <span class="comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span></span><br><span class="line">                    <span class="comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span></span><br><span class="line">                    <span class="comment">// h = 2, h = 3 时过程同上</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> hash(digest, h);</span><br><span class="line">                    <span class="comment">// 将 hash 到 invoker 的映射关系存储到 virtualInvokers 中</span></span><br><span class="line">                    virtualInvokers.put(m, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行 md5 运算，返回摘要字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 编码字符串 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编码后的摘要内容，长度为 16 的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] md5(String key) &#123;</span><br><span class="line">        MessageDigest md;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] bytes = key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            md.update(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> md.digest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据摘要生成 hash 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> digest md5摘要内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number 当前索引数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> hash 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">hash</span><span class="params">(<span class="type">byte</span>[] digest, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (((<span class="type">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">                &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">select</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 对参数 key 进行 md5 运算</span></span><br><span class="line">        <span class="type">byte</span>[] digest = md5(key);</span><br><span class="line">        <span class="comment">// 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，</span></span><br><span class="line">        <span class="comment">// 寻找合适的 Invoker</span></span><br><span class="line">        <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个大于等于 hash 值的服务信息，若没有则返回第一个</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ServiceInfo <span class="title function_">selectForKey</span><span class="params">(<span class="type">long</span> hash)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到 TreeMap 中查找第一个节点值大于或等于当前 hash 的 Invoker</span></span><br><span class="line">        Map.Entry&lt;Long, ServiceInfo&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class="line">        <span class="comment">// 如果 hash 大于 Invoker 在圆环上最大的位置，此时 entry = null，需要将 TreeMap 的头节点赋值给 entry</span></span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">            entry = virtualInvokers.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希方法步骤：</p><ol><li>用MD5算法生成摘要：对IP地址+端口号执行MD5，得到长度16字节的摘要</li><li>从摘要中提取出多个32-bit的无符号整数（即虚拟节点哈希值）<ul><li>每次从 16 字节的摘要中，取出连续的 4 字节</li><li>对这四个字节通过位运算拼接成一个32位的整数，代表一个hash值</li><li>执行4次，得到4个hash值</li></ul></li></ol><p>具体轮询方法实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到请求的方法名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    <span class="comment">// 构建对应的 key 值，key = 全限定类名 + &quot;.&quot; + 方法名，比如 com.xxx.DemoService.sayHello</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> request.getServiceName() + <span class="string">&quot;.&quot;</span> + method;</span><br><span class="line">    <span class="comment">// 获取 invokers 原始的 hashCode</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">identityHashCode</span> <span class="operator">=</span> System.identityHashCode(invokers);</span><br><span class="line">    <span class="comment">// 从 map 从获取对应的 selector</span></span><br><span class="line">    <span class="type">ConsistentHashSelector</span> <span class="variable">selector</span> <span class="operator">=</span> selectors.get(key);</span><br><span class="line">    <span class="comment">// 如果为 null，表示之前没有缓存过，如果 hashcode 不一致，表示缓存的服务列表发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="literal">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">        <span class="comment">// 创建新的 selector 并缓存</span></span><br><span class="line">        selectors.put(key, <span class="keyword">new</span> <span class="title class_">ConsistentHashSelector</span>(invokers, <span class="number">160</span>, identityHashCode));</span><br><span class="line">        selector = selectors.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 ConsistentHashSelector 的 select 方法选择 Invoker</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">selectKey</span> <span class="operator">=</span> key;</span><br><span class="line">    <span class="comment">// 将 key 与 方法参数进行 hash 运算，因此 ConsistentHashLoadBalance 的负载均衡逻辑只受参数值影响，</span></span><br><span class="line">    <span class="comment">// 具有相同参数值的请求将会被分配给同一个服务提供者。ConsistentHashLoadBalance 不关系权重</span></span><br><span class="line">    <span class="keyword">if</span> (request.getParameterValues() != <span class="literal">null</span> &amp;&amp; request.getParameterValues().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        selectKey += Arrays.stream(request.getParameterValues());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selector.select(selectKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方法名和参数生成哈希键，从缓存中获取一致性哈希选择器，根据选择器将相同参数请求始终路由到同一个服务节点，实现基于参数的一致性哈希负载均衡</p><h2 id="网络通信模块"><a href="#网络通信模块" class="headerlink" title="网络通信模块"></a>网络通信模块</h2><p>本项目实现了基于Netty、Http、Socket三种网络通信方式，关于这三种通信方式的区别，我会在另一个文章中说明</p><h3 id="Netty通信"><a href="#Netty通信" class="headerlink" title="Netty通信"></a>Netty通信</h3><p>首先编写通信处理入口，使用Netty启动TCP服务器监听指定端口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Integer port)</span> &#123;</span><br><span class="line">        <span class="comment">// boss 处理 accept 事件</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">// worker 处理 read/write 事件</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line"></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 是否开启 TCP 底层心跳机制</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG))</span><br><span class="line">                    <span class="comment">// 当客户端第一次请求时才会进行初始化</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 30s内没有收到客户端的请求就关闭连接，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcFrameDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SharableRpcMessageCodec</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyRpcRequestHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，同步等待绑定成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(inetAddress, port).sync();</span><br><span class="line">            log.debug(<span class="string">&quot;Rpc server add &#123;&#125; started on the port &#123;&#125;.&quot;</span>, inetAddress, port);</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException | InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;An error occurred while starting the rpc service.&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler中我加入了NettyRpcRequestHandler，作为具体的业务实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcRequestHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestHandler rpcRequestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NettyRpcRequestHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">RpcMessage</span> <span class="variable">responseRpcMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcMessage</span>();</span><br><span class="line">                <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> msg.getHeader();</span><br><span class="line">                <span class="type">MessageType</span> <span class="variable">type</span> <span class="operator">=</span> MessageType.parseByType(header.getMessageType());</span><br><span class="line">                log.debug(<span class="string">&quot;The message received by the server is: &#123;&#125;&quot;</span>, msg.getBody());</span><br><span class="line">                <span class="comment">// 如果是心跳检测请求信息</span></span><br><span class="line">                <span class="keyword">if</span> (type == MessageType.HEARTBEAT_REQUEST) &#123;</span><br><span class="line">                    header.setMessageType(MessageType.HEARTBEAT_RESPONSE.getType());</span><br><span class="line">                    header.setMessageStatus(MessageStatus.SUCCESS.getCode());</span><br><span class="line">                    <span class="comment">// 设置响应头部信息</span></span><br><span class="line">                    responseRpcMessage.setHeader(header);</span><br><span class="line">                    responseRpcMessage.setBody(ProtocolConstants.PONG);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理 Rpc 请求信息</span></span><br><span class="line">                    <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> (RpcRequest) msg.getBody();</span><br><span class="line">                    <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">                    <span class="comment">// 设置头部消息类型</span></span><br><span class="line">                    header.setMessageType(MessageType.RESPONSE.getType());</span><br><span class="line">                    <span class="comment">// 反射调用</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取本地反射调用结果</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> rpcRequestHandler.handleRpcRequest(request);</span><br><span class="line">                        response.setReturnValue(result);</span><br><span class="line">                        header.setMessageStatus(MessageStatus.SUCCESS.getCode());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;The service [&#123;&#125;], the method [&#123;&#125;] invoke failed!&quot;</span>, request.getServiceName(), request.getMethod());</span><br><span class="line">                        <span class="comment">// 若不设置，堆栈信息过多，导致报错</span></span><br><span class="line">                        response.setExceptionValue(<span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Error in remote procedure call, &quot;</span> + e.getMessage()));</span><br><span class="line">                        header.setMessageStatus(MessageStatus.FAIL.getCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置响应头部信息</span></span><br><span class="line">                    responseRpcMessage.setHeader(header);</span><br><span class="line">                    responseRpcMessage.setBody(response);</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;responseRpcMessage: &#123;&#125;.&quot;</span>, responseRpcMessage);</span><br><span class="line">                <span class="comment">// 将结果写入，传递到下一个处理器</span></span><br><span class="line">                ctx.writeAndFlush(responseRpcMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 确保 ByteBuf 被释放，防止发生内存泄露</span></span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义事件，当触发读空闲时，自动关闭客户端channel连接，netty自动调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="type">IdleState</span> <span class="variable">state</span> <span class="operator">=</span> ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;idle check happen, so close the connection.&quot;</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;server catch exception&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Http通信"><a href="#Http通信" class="headerlink" title="Http通信"></a>Http通信</h3><p>编写http通信实现类，通过内置Tomcat实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRpcServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Integer port)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> tomcat.getServer();</span><br><span class="line">            <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> server.findService(<span class="string">&quot;Tomcat&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>();</span><br><span class="line">            connector.setPort(port);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">hostname</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line"></span><br><span class="line">            <span class="type">StandardEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEngine</span>();</span><br><span class="line">            engine.setDefaultHost(hostname);</span><br><span class="line"></span><br><span class="line">            <span class="type">StandardHost</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardHost</span>();</span><br><span class="line">            host.setName(hostname);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardContext</span>();</span><br><span class="line">            context.setPath(contextPath);</span><br><span class="line">            context.addLifecycleListener(<span class="keyword">new</span> <span class="title class_">Tomcat</span>.FixContextListener());</span><br><span class="line"></span><br><span class="line">            host.addChild(context);</span><br><span class="line">            engine.addChild(host);</span><br><span class="line"></span><br><span class="line">            service.setContainer(engine);</span><br><span class="line">            service.addConnector(connector);</span><br><span class="line"></span><br><span class="line">            tomcat.addServlet(contextPath, <span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>());</span><br><span class="line">            context.addServletMappingDecoded(<span class="string">&quot;/*&quot;</span>, <span class="string">&quot;dispatcher&quot;</span>);</span><br><span class="line"></span><br><span class="line">            tomcat.start();</span><br><span class="line">            tomcat.getServer().await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException | UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Tomcat server failed to start.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat接收到http请求后，会交给DispatcherServlet类进行统一处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前处理器数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cpuNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(cpuNum * <span class="number">2</span>, cpuNum * <span class="number">2</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpRpcRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> SingletonFactory.getInstance(HttpRpcRequestHandler.class);</span><br><span class="line">        threadPool.submit(() -&gt; handler.handle(req, resp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后由DispatcherServlet将请求发给HttpRpcRequestHandler进行实际业务处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRpcRequestHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestHandler rpcRequestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HttpRpcRequestHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(req.getInputStream());</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(resp.getOutputStream());</span><br><span class="line">            <span class="comment">// 读取客户端请求</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> (RpcRequest) ois.readObject();</span><br><span class="line">            log.debug(<span class="string">&quot;The server received message is &#123;&#125;.&quot;</span>, request);</span><br><span class="line">            <span class="comment">// 创建一个 RpcResponse 对象来响应客户端</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求的服务对应的实例对象反射调用方法的结果</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> rpcRequestHandler.handleRpcRequest(request);</span><br><span class="line">                response.setReturnValue(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;The service [&#123;&#125;], the method [&#123;&#125;] invoke failed!&quot;</span>, request.getServiceName(), request.getMethod());</span><br><span class="line">                <span class="comment">// 若不设置，堆栈信息过多，导致报错</span></span><br><span class="line">                response.setExceptionValue(<span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Error in remote procedure call, &quot;</span> + e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;The response is &#123;&#125;.&quot;</span>, response);</span><br><span class="line">            oos.writeObject(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The http server failed to handle client rpc request.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Socket通信"><a href="#Socket通信" class="headerlink" title="Socket通信"></a>Socket通信</h3><p>socket通信是最原始的通信方式，首先编写server类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketRpcServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前处理器数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cpuNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程大小：这一点要看我们执行的任务是cpu密集型，还是io密集型</span></span><br><span class="line">    <span class="comment">// 如果有关于计算机计算，比较消耗资源的是cpu密集型，线程大小应该设置为：cpu 核数 + 1</span></span><br><span class="line">    <span class="comment">// 如果有关网络传输，连接数据库等，是io密集型，线程大小应该设置为：cpu * 2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(cpuNum * <span class="number">2</span>, cpuNum * <span class="number">2</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Integer port)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">hostAddress</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(hostAddress, port));</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="comment">// 循环接受客户端 Socket 连接（accept为阻塞时等待连接）</span></span><br><span class="line">            <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;The client connected [&#123;&#125;].&quot;</span>, socket.getInetAddress());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> <span class="title class_">SocketRpcRequestHandler</span>(socket));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 服务端连断开，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;The socket server failed to start on port %d.&quot;</span>, port), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是具体的请求处理逻辑，实现<code>Runnable</code>接口，配合线程池执行每一个客户端连接的请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketRpcRequestHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestHandler rpcRequestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketRpcRequestHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;The server handle client message by thread &#123;&#125;.&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream())) &#123;</span><br><span class="line">            <span class="comment">// 注意：SocketServer 接受和发送的数据为：RpcRequest, RpcResponse</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">// 直接读取客户端发送过来的 RpcRequest，此时不需要进行编解码，无需消息协议</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> (RpcRequest) ois.readObject();</span><br><span class="line">            log.debug(<span class="string">&quot;The server received message is &#123;&#125;.&quot;</span>, request);</span><br><span class="line">            <span class="comment">// 创建一个 RpcResponse 对象用来响应给客户端</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求的服务对应的实例对象反射调用方法的结果</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> rpcRequestHandler.handleRpcRequest(request);</span><br><span class="line">                response.setReturnValue(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;The service [&#123;&#125;], the method [&#123;&#125;] invoke failed!&quot;</span>, request.getServiceName(), request.getMethod());</span><br><span class="line">                <span class="comment">// 若不设置，堆栈信息过多，导致报错</span></span><br><span class="line">                response.setExceptionValue(<span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Error in remote procedure call, &quot;</span> + e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;The response is &#123;&#125;.&quot;</span>, response);</span><br><span class="line">            oos.writeObject(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The socket server failed to handle client rpc request.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>RPC框架怎么做到像调用本地接口一样调用远端服务呢？这必须依赖动态代理来实现</p><p>需要创建一个代理对象，在代理对象中完成数据报文编码，然后发起调用发送数据给服务提供方，以此屏蔽RPC框架的调用细节。因为代理类是在运行时生成的，所以代理类的生成速度、生成的字节码大小都会影响RPC框架整体的性能和资源消耗</p><p>动态代理比较主流的实现方案有以下几种：JDK、Cglib、Javassist、ASM、ByteBuddy</p><ul><li>JDK：在运行时可以动态创建代理类，但是 JDK 动态代理的功能比较局限，代理对象必须实现一个接口，否则抛出异常。因为代理类会继承Proxy类，然而 Java 是不支持多重继承的，只能通过接口实现多态。JDK 动态代理所生成的代理类是接口的实现类，不能代理接口中不存在的方法。JDK 动态代理是通过反射调用的形式代理类中的方法，比直接调用肯定是性能要慢的</li><li>Cglib：Cglib是基于ASM字节码生成框架实现的，通过字节码技术生成的代理类，所以代理类的类型是不受限制的。而且Cglib生成的代理类是继承于被代理类，所以可以提供更加灵活的功能。在代理方法方面，Cglib 是有优势的，它采用了 FastClass 机制，为代理类和被代理类各自创建一个 Class，这个 Class会为代理类和被代理类的方法分配 index 索引，FastClass 就可以通过 index 直接定位要调用的方法，并直接调用，这是一种空间换时间的优化思路</li><li>Javassist和ASM。二者都是Java字节码操作框架，使用起来难度较大，需要开发者对 Class 文件结构以及 JVM 都有所了解，但是它们都比反射的性能要高</li><li>Byte Buddy 也是一个字节码生成和操作的类库，Byte Buddy 功能强大，相比于 Javassist 和 ASM，Byte Buddy 提供了更加便捷的 API，用于创建和修改 Java 类，无须理解字节码的格式，而且 Byte Buddy 更加轻量，性能更好</li></ul><p>本项目实现了JDK和CGLIB动态代理</p><p>具体的代理逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientStubProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务发现中心实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery discovery;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RpcClient 传输实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient rpcClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端配置属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClientProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientStubProxyFactory</span><span class="params">(ServiceDiscovery discovery, RpcClient rpcClient, RpcClientProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.discovery = discovery;</span><br><span class="line">        <span class="built_in">this</span>.rpcClient = rpcClient;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理对象缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; proxyMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz   服务接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version 版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;     代理对象的参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应版本的代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz, String version)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) proxyMap.computeIfAbsent(ServiceUtil.serviceKey(clazz.getName(), version), serviceName -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果目标类是一个接口或者 是 java.lang.reflect.Proxy 的子类 则默认使用 JDK 动态代理</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isInterface() || Proxy.isProxyClass(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;clazz&#125;, <span class="comment">// 注意，这里的接口是 clazz 本身（要代理的实现类所实现的接口）</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ClientStubInvocationHandler</span>(discovery, rpcClient, properties, serviceName));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 使用 CGLIB 动态代理</span></span><br><span class="line">                <span class="comment">// 创建动态代理增加类</span></span><br><span class="line">                <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">                <span class="comment">// 设置类加载器</span></span><br><span class="line">                enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">                <span class="comment">// 设置被代理类</span></span><br><span class="line">                enhancer.setSuperclass(clazz);</span><br><span class="line">                <span class="comment">// 设置方法拦截器</span></span><br><span class="line">                enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">ClientStubMethodInterceptor</span>(discovery, rpcClient, properties, serviceName));</span><br><span class="line">                <span class="comment">// 创建代理类</span></span><br><span class="line">                <span class="keyword">return</span> enhancer.create();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Netty心跳机制与Channel复用"><a href="#Netty心跳机制与Channel复用" class="headerlink" title="Netty心跳机制与Channel复用"></a>Netty心跳机制与Channel复用</h2><p>为了解决每次请求客户端都要重新与服务端建立netty连接，非常耗时，增加心跳检查机制，保持长连接，复用channel连接；</p><ul><li>长连接：避免了每次调用新建TCP连接，提高了调用的响应速度</li><li>Channel 连接复用：避免重复连接服务端</li><li>多路复用：单个TCP连接可交替传输多个请求和响应的消息，降低了连接的等待闲置时间，从而减少了同样并发数下的网络连接数，提高了系统吞吐量</li></ul><h3 id="多路复用实现"><a href="#多路复用实现" class="headerlink" title="多路复用实现"></a>多路复用实现</h3><p>使用一个<code>ConcurrentHashMap</code>存放每个请求的等待结果区，当响应回来时，用sequenceId找到对应的Promise完成结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Promise&lt;RpcMessage&gt;&gt; UNPROCESSED_RPC_RESPONSES = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>拿到已经返回结果的Promise：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MessageType</span> <span class="variable">type</span> <span class="operator">=</span> MessageType.parseByType(msg.getHeader().getMessageType());</span><br><span class="line">        <span class="comment">// 如果是 RpcResponse 请求</span></span><br><span class="line">        <span class="keyword">if</span> (type == MessageType.RESPONSE) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> msg.getHeader().getSequenceId();</span><br><span class="line">            <span class="comment">// 拿到还未执行完成的 promise 对象</span></span><br><span class="line">            Promise&lt;RpcMessage&gt; promise = UNPROCESSED_RPC_RESPONSES.remove(sequenceId);</span><br><span class="line">            <span class="keyword">if</span> (promise != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> ((RpcResponse) msg.getBody()).getExceptionValue();</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="literal">null</span>) &#123;</span><br><span class="line">                    promise.setSuccess(msg);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.setFailure(exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == MessageType.HEARTBEAT_RESPONSE) &#123; <span class="comment">// 如果是心跳检查请求</span></span><br><span class="line">            log.debug(<span class="string">&quot;Heartbeat info &#123;&#125;.&quot;</span>, msg.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放内存，防止内存泄漏</span></span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发出请求后，存放还未返回结果的Promise：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RpcMessage <span class="title function_">sendRpcRequest</span><span class="params">(RequestMetadata requestMetadata)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建接收返回结果的 promise</span></span><br><span class="line">    Promise&lt;RpcMessage&gt; promise;</span><br><span class="line">    <span class="comment">// 获取 Channel 对象</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> getChannel(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(requestMetadata.getServerAddr(), requestMetadata.getPort()));</span><br><span class="line">    <span class="keyword">if</span> (channel.isActive()) &#123;</span><br><span class="line">        <span class="comment">// 创建 promise 来接受结果         指定执行完成通知的线程</span></span><br><span class="line">        promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(channel.eventLoop());</span><br><span class="line">        <span class="comment">// 获取请求的序列号 ID</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> requestMetadata.getRpcMessage().getHeader().getSequenceId();</span><br><span class="line">        <span class="comment">// 存入还未处理的请求</span></span><br><span class="line">        RpcResponseHandler.UNPROCESSED_RPC_RESPONSES.put(sequenceId, promise);</span><br><span class="line">        <span class="comment">// 发送数据并监听发送状态</span></span><br><span class="line">        channel.writeAndFlush(requestMetadata.getRpcMessage()).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;The client send the message successfully, msg: [&#123;&#125;].&quot;</span>, requestMetadata);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                future.channel().close();</span><br><span class="line">                promise.setFailure(future.cause());</span><br><span class="line">                log.error(<span class="string">&quot;The client send the message failed.&quot;</span>, future.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">timeout</span> <span class="operator">=</span> requestMetadata.getTimeout();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待结果返回（让出cpu资源，同步阻塞调用线程main，其他线程去执行获取操作（eventLoop））</span></span><br><span class="line">        <span class="comment">// 如果没有指定超时时间，则 await 直到 promise 完成</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="literal">null</span> || timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            promise.await();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在指定超时时间内等待结果返回</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> promise.await(requestMetadata.getTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                promise.setFailure(<span class="keyword">new</span> <span class="title class_">TimeoutException</span>(String.format(<span class="string">&quot;The Remote procedure call exceeded the &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;specified timeout of %dms.&quot;</span>, timeout)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (promise.isSuccess()) &#123;</span><br><span class="line">            <span class="comment">// 返回响应结果</span></span><br><span class="line">            <span class="keyword">return</span> promise.getNow();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(promise.cause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The channel is inactivate.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="长连接实现"><a href="#长连接实现" class="headerlink" title="长连接实现"></a>长连接实现</h3><p>在client的响应消息处理器中添加自定义时间处理器，当检测到写空闲发生时自动发送一个心跳包：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户自定义事件处理器，处理写空闲，当检测到写空闲发生自动发送一个心跳检测数据包</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx ctx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evt evt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception ex</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((IdleStateEvent) evt).state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Write idle happen [&#123;&#125;].&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">            <span class="comment">// 构造 心跳检查 RpcMessage</span></span><br><span class="line">            <span class="type">RpcMessage</span> <span class="variable">rpcMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcMessage</span>();</span><br><span class="line">            <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> MessageHeader.build(SerializationType.KRYO.name());</span><br><span class="line">            header.setMessageType(MessageType.HEARTBEAT_REQUEST.getType());</span><br><span class="line">            rpcMessage.setHeader(header);</span><br><span class="line">            rpcMessage.setBody(ProtocolConstants.PING);</span><br><span class="line">            <span class="comment">// 发送心跳检测请求</span></span><br><span class="line">            ctx.writeAndFlush(rpcMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Channel连接复用"><a href="#Channel连接复用" class="headerlink" title="Channel连接复用"></a>Channel连接复用</h3><p>使用ConcurrentHashMap存放每个<code>IP+端口号</code>使用过的Channel，如果当前IP的端口再次发起rpc请求后，检测到之前的Channel还没关闭，就可以再次使用，避免重复连接服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储 Channel，key 为 ip:port，val 为 channel 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">get</span><span class="params">(String hostname, Integer port)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> hostname + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">        <span class="comment">// 如果之前对应的 ip port 已经建立了 channel</span></span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 取出 channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channels.get(key);</span><br><span class="line">            <span class="comment">// 如果 channel 不为 null，并且处于活跃状态（连接状态）</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 为 null 或者已经关闭连接，从 map 中移除</span></span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">get</span><span class="params">(InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(inetSocketAddress.getHostName(), inetSocketAddress.getPort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String hostname, Integer port, Channel channel)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> hostname + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(InetSocketAddress inetSocketAddress, Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.set(inetSocketAddress.getHostName(), inetSocketAddress.getPort(), channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成Spring自定义注解"><a href="#集成Spring自定义注解" class="headerlink" title="集成Spring自定义注解"></a>集成Spring自定义注解</h2><p>首先编写RpcService注解类，提供服务接口、接口名和版本等元数据，供框架进行服务发现、注册和远程调用时使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口类型，默认为 void.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口名（全限定名），默认为 &quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本号，默认 1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写Spring扩展机制中的一个实现类，扫描被@RpcService标注的组件并将对应的BeanDefiniton对象注册到Spring</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法会在 spring 自定义扫描执行之后执行，这个时候 beanDefinitionMap 已经有扫描到的 beanDefinition 对象了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotationMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry           current bean definition registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 RpcComponentScan 注解的属性和值</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">annotationAttributes</span> <span class="operator">=</span> AnnotationAttributes</span><br><span class="line">                .fromMap(annotationMetadata.getAnnotationAttributes(RpcComponentScan.class.getName()));</span><br><span class="line">        String[] basePackages = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (annotationAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处去获取RpcComponentScan 注解的 basePackages 值</span></span><br><span class="line">            basePackages = annotationAttributes.getStringArray(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有指定名称的话,默认就用当前类所在包</span></span><br><span class="line">        <span class="keyword">if</span> (basePackages.length == <span class="number">0</span>) &#123;</span><br><span class="line">            basePackages = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;((StandardAnnotationMetadata) annotationMetadata).getIntrospectedClass().getPackage().getName()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个浏览 RpcService 注解的 Scanner</span></span><br><span class="line">        <span class="type">RpcClassPathBeanDefinitionScanner</span> <span class="variable">rpcServiceScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcClassPathBeanDefinitionScanner</span>(registry, RpcService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.resourceLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">            rpcServiceScanner.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描包下的所有 Rpc bean 并返回注册成功的数量（scan方法会调用register方法去注册扫描到的类并生成 BeanDefinition 注册到 spring 容器）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rpcServiceScanner.scan(basePackages);</span><br><span class="line">        log.info(<span class="string">&quot;The number of BeanDefinition scanned and registered by RpcServiceScanner is &#123;&#125;.&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写RpcComponentScan注解类，调用上述具体实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(RpcBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcComponentScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扫描包路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;basePackages&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扫描包路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在经过调用链，服务已经被注册到Spring中了，接下来利用Spring框架自动将服务信息注册到注册中心：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcServer rpcServer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcServerProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcServerBeanPostProcessor</span><span class="params">(ServiceRegistry serviceRegistry, RpcServer rpcServer, RpcServerProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">        <span class="built_in">this</span>.rpcServer = rpcServer;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 bean 实例化后，初始化后，检测标注有 <span class="doctag">@RpcService</span> 注解的类，将对应的服务类进行注册，对外暴露服务，同时进行本地服务注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增强后的 bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException Bean 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 判断当前 bean 是否被 @RpcService 注解标注</span></span><br><span class="line">        <span class="keyword">if</span> (bean.getClass().isAnnotationPresent(RpcService.class)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[&#123;&#125;] is annotated with [&#123;&#125;].&quot;</span>, bean.getClass().getName(), RpcService.class.getCanonicalName());</span><br><span class="line">            <span class="comment">// 获取到该类的 @RpcService 注解</span></span><br><span class="line">            <span class="type">RpcService</span> <span class="variable">rpcService</span> <span class="operator">=</span> bean.getClass().getAnnotation(RpcService.class);</span><br><span class="line">            String interfaceName;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(rpcService.interfaceName())) &#123;</span><br><span class="line">                interfaceName = rpcService.interfaceClass().getName();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                interfaceName = rpcService.interfaceName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> rpcService.version();</span><br><span class="line">            <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> ServiceUtil.serviceKey(interfaceName, version);</span><br><span class="line">            <span class="comment">// 构建 ServiceInfo 对象</span></span><br><span class="line">            <span class="type">ServiceInfo</span> <span class="variable">serviceInfo</span> <span class="operator">=</span> ServiceInfo.builder()</span><br><span class="line">                    .appName(properties.getAppName())</span><br><span class="line">                    .serviceName(serviceName)</span><br><span class="line">                    .version(version)</span><br><span class="line">                    .address(properties.getAddress())</span><br><span class="line">                    .port(properties.getPort())</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 进行远程服务注册</span></span><br><span class="line">            serviceRegistry.register(serviceInfo);</span><br><span class="line">            <span class="comment">// 进行本地服务缓存注册</span></span><br><span class="line">            LocalServiceCache.addService(serviceName, bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开机自启动 - 此方法实现于 &#123;<span class="doctag">@link</span> CommandLineRunner&#125; 接口，基于 springboot</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args incoming main method arguments 命令行参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 启动异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; rpcServer.start(properties.getPort())).start();</span><br><span class="line">        log.info(<span class="string">&quot;Rpc server [&#123;&#125;] start, the appName is &#123;&#125;, the port is &#123;&#125;&quot;</span>,</span><br><span class="line">                rpcServer, properties.getAppName(), properties.getPort());</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当服务关闭之后，将服务从 注册中心 上清除（关闭连接）</span></span><br><span class="line">                serviceRegistry.destroy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个注解是服务提供方的，下面实现服务调用方的注解<code>RpcReference</code>，用于标记需要动态代理生成远程服务调用客户端的字段或方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口类型，默认为 void.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口名（全限定名），默认为 &quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本号，默认 1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负载均衡策略，合法的值包括：random, roundrobin, leastactive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">loadbalance</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service mock name, use interface name + Mock if not set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">mock</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务调用超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写打上注解标签后的实现细节，在Spring完成Bean实例化之后，扫描Bean中标注了<code>@RpcReference</code>注解的字段，并将这些字段替换为对应的客户端代理对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClientStubProxyFactory proxyFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcClientBeanPostProcessor</span><span class="params">(ClientStubProxyFactory proxyFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxyFactory = proxyFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在bean实例化完后，扫描bean中需要进行rpc注入的属性，将对应的属性使用代理对象进行替换</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     bean 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName bean 名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后置增强后的 bean 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException bean 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取该 bean 的类的所有属性（getFields - 获取所有的public属性，getDeclaredFields - 获取所有声明的属性，不区分访问修饰符）</span></span><br><span class="line">        Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">        <span class="comment">// 遍历所有属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 判断是否被 RpcReference 注解标注</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(RpcReference.class)) &#123;</span><br><span class="line">                <span class="comment">// 获得 RpcReference 注解</span></span><br><span class="line">                <span class="type">RpcReference</span> <span class="variable">rpcReference</span> <span class="operator">=</span> field.getAnnotation(RpcReference.class);</span><br><span class="line">                <span class="comment">// 默认类为属性当前类型</span></span><br><span class="line">                <span class="comment">// filed.class = java.lang.reflect.Field</span></span><br><span class="line">                <span class="comment">// filed.type = com.wxy.xxx.service.XxxService</span></span><br><span class="line">                Class&lt;?&gt; clazz = field.getType();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果指定了全限定类型接口名</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(rpcReference.interfaceName())) &#123;</span><br><span class="line">                        clazz = Class.forName(rpcReference.interfaceName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果指定了接口类型</span></span><br><span class="line">                    <span class="keyword">if</span> (rpcReference.interfaceClass() != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">                        clazz = rpcReference.interfaceClass();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取指定类型的代理对象</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> proxyFactory.getProxy(clazz, rpcReference.version());</span><br><span class="line">                    <span class="comment">// 关闭安全检查</span></span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 设置域的值为代理对象</span></span><br><span class="line">                    field.set(bean, proxy);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;Failed to obtain proxy object, the type of field %s is %s, &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;and the specified loaded proxy type is %s.&quot;</span>, field.getName(), field.getClass(), clazz), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成SpringBoot实现自动装配"><a href="#集成SpringBoot实现自动装配" class="headerlink" title="集成SpringBoot实现自动装配"></a>集成SpringBoot实现自动装配</h2><p>编写对应的自动配置的配置类以及 <code>spring.factories</code> 文件，引入对应的<code>starter</code>即可完成自动配置功能。</p><p>server端的配置类，主要作用有</p><ul><li>将服务注册到注册中心</li><li>启动RPC服务，监听请求连接</li><li>开启Bean后处理器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RpcServerProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RpcServerProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ServiceRegistry 实例 bean，当没有配置时默认使用 zookeeper 作为配置中心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceRegistry&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;registry&quot;, havingValue = &quot;zookeeper&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceRegistry <span class="title function_">zookeeperServiceRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZookeeperServiceRegistry</span>(properties.getRegistryAddr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceRegistry&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;registry&quot;, havingValue = &quot;nacos&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceRegistry <span class="title function_">nacosServiceRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosServiceRegistry</span>(properties.getRegistryAddr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当没有配置通信协议属性时，默认使用 netty 作为通讯协议</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcServer&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;transport&quot;, havingValue = &quot;netty&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServer <span class="title function_">nettyRpcServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NettyRpcServer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcServer&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;transport&quot;, havingValue = &quot;http&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &#123;&quot;org.apache.catalina.startup.Tomcat&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServer <span class="title function_">httpRpcServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpRpcServer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcServer&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;transport&quot;, havingValue = &quot;socket&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServer <span class="title function_">socketRpcServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SocketRpcServer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(&#123;ServiceRegistry.class, RpcServer.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServerBeanPostProcessor <span class="title function_">rpcServerBeanPostProcessor</span><span class="params">(<span class="meta">@Autowired</span> ServiceRegistry serviceRegistry,</span></span><br><span class="line"><span class="params">                                                                 <span class="meta">@Autowired</span> RpcServer rpcServer,</span></span><br><span class="line"><span class="params">                                                                 <span class="meta">@Autowired</span> RpcServerProperties properties)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcServerBeanPostProcessor</span>(serviceRegistry, rpcServer, properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client的自动配置类，主要作用有：</p><ul><li>配置负载均衡算法</li><li>服务发现</li><li>客户端网络通信，用来发送和接收响应</li><li>动态代理类</li><li>开启Bean后处理器</li><li>退出时清理组件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RpcClientProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性绑定的实现方式二：</span></span><br><span class="line"><span class="comment">     * - 创建 RpcClientProperties 对象，绑定到配置文件</span></span><br><span class="line"><span class="comment">     * - 如果使用此方法，可以直接给属性赋初始值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment 当前应用的环境（支持 yaml、properties 等文件格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的绑定属性类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> 弃用，使用被 &#123;<span class="doctag">@link</span> org.springframework.boot.context.properties.ConfigurationProperties&#125; 标注的属性类代替，</span></span><br><span class="line"><span class="comment">     * 生成 metadata。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> RpcClientProperties <span class="title function_">rpcClientProperties</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取绑定器，将对应的属性绑定到指定类上</span></span><br><span class="line">        BindResult&lt;RpcClientProperties&gt; bind = Binder.get(environment).bind(<span class="string">&quot;rpc.client&quot;</span>, RpcClientProperties.class);</span><br><span class="line">        <span class="comment">// 获取实例</span></span><br><span class="line">        <span class="keyword">return</span> bind.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RpcClientProperties rpcClientProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;loadBalance&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">// 不指定 value 则值默认为当前创建的类</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;loadbalance&quot;, havingValue = &quot;random&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalance <span class="title function_">randomLoadBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomLoadBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;loadBalance&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;loadbalance&quot;, havingValue = &quot;roundRobin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalance <span class="title function_">roundRobinLoadBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoundRobinLoadBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;loadBalance&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;loadbalance&quot;, havingValue = &quot;consistentHash&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalance <span class="title function_">consistentHashLoadBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsistentHashLoadBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceDiscovery&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(LoadBalance.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;registry&quot;, havingValue = &quot;zookeeper&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceDiscovery <span class="title function_">zookeeperServiceDiscovery</span><span class="params">(<span class="meta">@Autowired</span> LoadBalance loadBalance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZookeeperServiceDiscovery</span>(rpcClientProperties.getRegistryAddr(), loadBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceDiscovery&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(LoadBalance.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;registry&quot;, havingValue = &quot;nacos&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceDiscovery <span class="title function_">nacosServiceDiscovery</span><span class="params">(<span class="meta">@Autowired</span> LoadBalance loadBalance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosServiceDiscovery</span>(rpcClientProperties.getRegistryAddr(), loadBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcClient&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;transport&quot;, havingValue = &quot;netty&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> RpcClient <span class="title function_">nettyRpcClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NettyRpcClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcClient&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;transport&quot;, havingValue = &quot;http&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcClient <span class="title function_">httpRpcClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpRpcClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcClient&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;transport&quot;, havingValue = &quot;socket&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcClient <span class="title function_">socketRpcClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SocketRpcClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(&#123;ServiceDiscovery.class, RpcClient.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> ClientStubProxyFactory <span class="title function_">clientStubProxyFactory</span><span class="params">(<span class="meta">@Autowired</span> ServiceDiscovery serviceDiscovery,</span></span><br><span class="line"><span class="params">                                                         <span class="meta">@Autowired</span> RpcClient rpcClient,</span></span><br><span class="line"><span class="params">                                                         <span class="meta">@Autowired</span> RpcClientProperties rpcClientProperties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientStubProxyFactory</span>(serviceDiscovery, rpcClient, rpcClientProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> RpcClientBeanPostProcessor <span class="title function_">rpcClientBeanPostProcessor</span><span class="params">(<span class="meta">@Autowired</span> ClientStubProxyFactory clientStubProxyFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcClientBeanPostProcessor</span>(clientStubProxyFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> RpcClientExitDisposableBean <span class="title function_">rpcClientExitDisposableBean</span><span class="params">(<span class="meta">@Autowired</span> ServiceDiscovery serviceDiscovery)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcClientExitDisposableBean</span>(serviceDiscovery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://ltynote.cn/categories/RPC/">RPC</category>
      
      
      <category domain="http://ltynote.cn/tags/RPC/">RPC</category>
      
      
      <comments>http://ltynote.cn/inori/2408437c.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
