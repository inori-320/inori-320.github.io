<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>楪祈のBlog</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>星座になれたら。</description>
    <pubDate>Mon, 09 Jun 2025 02:50:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>常见问题汇总（持续更新中）</title>
      <link>http://example.com/inori/c92e9465.html</link>
      <guid>http://example.com/inori/c92e9465.html</guid>
      <pubDate>Thu, 05 Jun 2025 11:11:44 GMT</pubDate>
      
      <description>面试专题——八股篇</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="你项目中用到了哪些设计模式"><a href="#你项目中用到了哪些设计模式" class="headerlink" title="你项目中用到了哪些设计模式"></a>你项目中用到了哪些设计模式</h2><p>在线程池的创建，Zookeeper客户端的创建使用到的单例模式，避免重复创建</p><p>创建序列化器，编解码器用到了工厂模式，根据用户配置创建不同的序列化方式</p><p>在实现不同序列化方式的时候用到了策略模式，把不同序列化方式封装成一个策略，实现统一接口</p><p>小程序项目中使用注解+AOP实现权限控制，本质是基于代理方法在方法调用前做拦截，用到了代理模式</p><p>在RPC框架中注册中心监听节点变化用到了观察者模式</p><h2 id="Spring中用到了哪些设计模式"><a href="#Spring中用到了哪些设计模式" class="headerlink" title="Spring中用到了哪些设计模式"></a>Spring中用到了哪些设计模式</h2><p>Bean的创建是单例的，用到了单例模式</p><p>Bean的管理使用的BeanFactory，用到了工厂模式</p><p>Bean的注入用到了原型模式，每次注入新实例</p><p>通用逻辑的封装，比如JdbcTemplate，用到了模板方法模式</p><p>Spring事件监听机制用到了观察者模式</p><p>SpringMVC的拦截器、过滤器链用到了责任链模式</p><p>Bean的生命周期管理用到了状态模式</p><p>AOP用到了代理模式</p><p>SpringMVC的HandlerAdapter适配不同Controller用到了适配器模式</p><h2 id="ES的基本原理"><a href="#ES的基本原理" class="headerlink" title="ES的基本原理"></a>ES的基本原理</h2><p>ES中比较关键的概念有索引，相当于MySQL的表，文档，相当于表中的行，字段，相当于表中的列。然后还可以组成集群和分片。</p><p>ES内部的索引使用的倒排索引，原理就是把每个文档的内容进行分词，建立词对应文档ID列表的映射</p><p>当有新的文档写入时，ES首先会通过分词器做文本分析，建立倒排索引，再把数据写到主分片上，由主分片同步到副分片，写入不是立即可见的，默认一秒钟刷新一次</p><h2 id="Nacos如何避免读写冲突"><a href="#Nacos如何避免读写冲突" class="headerlink" title="Nacos如何避免读写冲突"></a>Nacos如何避免读写冲突</h2><p>Nacos主要通过两种机制来避免配置读写冲突。一是写时使用乐观锁机制，客户端提交配置时必须带上当前版本号，如果版本不一致则更新失败，避免写写冲突。二是通过Raft协议实现集群间的数据强一致，所有写请求必须通过Leader，读请求默认从本地读取，如果需要强一致也可以强制读Leader。Nacos客户端使用长轮询机制感知配置变更，确保读时的数据是最新的。</p><h2 id="为什么Kryo序列化方式的体积小"><a href="#为什么Kryo序列化方式的体积小" class="headerlink" title="为什么Kryo序列化方式的体积小"></a>为什么Kryo序列化方式的体积小</h2><p>Kryo直接将对象编码为二进制字节数组，没有像JSON那样的字符冗余，并且Kryo不使用Java的反射机制，而是提前注册类信息，序列化时不需要写类的全限定名，它还支持对象引用追踪，避免重复序列化同一个对象</p><h2 id="zk的一致性算法"><a href="#zk的一致性算法" class="headerlink" title="zk的一致性算法"></a>zk的一致性算法</h2><p>Zookeeper使用Zab协议来实现集群一致性。有领导选举和原子广播两个阶段。当集群初次启动或者Leader节点宕机时会进入领导选举阶段，主要是通过投票和对比事务ID来选择，原子广播阶段，所有写请求由Leader发起并生成事务，广播给所有的Follower，需被超过半数的Follower写入后才能提交，Leader再广播提交消息，确保所有节点以相同顺序应用事务，从而实现强一致性。</p><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><p>我在参与商城项目的时候有过JVM调优的经历，当时压测的时候频繁出现Full GC，我通过jstat分析内存使用情况，使用-Xms和-Xmx调整了堆的大小，用-Xmn扩大了新生代的大小，后面我还有使用jstack查看线程状态，检查是否有死锁的情况</p><h2 id="单机MySQL如果不做任何优化，最大可以承受多大并发"><a href="#单机MySQL如果不做任何优化，最大可以承受多大并发" class="headerlink" title="单机MySQL如果不做任何优化，最大可以承受多大并发"></a>单机MySQL如果不做任何优化，最大可以承受多大并发</h2><p>MySQL默认的最大连接数是151，也就是最多151个线程同时连接执行SQL，如果只是执行简单的查询，单机QPS大概5000左右，如果是频繁写入的话，TPS可能在1000上下</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://example.com/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://example.com/inori/c92e9465.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>xxl-Job基础入门</title>
      <link>http://example.com/inori/226b10d6.html</link>
      <guid>http://example.com/inori/226b10d6.html</guid>
      <pubDate>Thu, 05 Jun 2025 10:32:24 GMT</pubDate>
      
      <description>xxl-job基础入门</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><p>我们可以思考一下下面业务场景的解决方案:</p><ul><li>某电商平台需要每天上午10点，下午3点，晚上8点发放一批优惠券</li><li>某银行系统需要在信用卡到期还款日的前三天进行短信提醒</li><li>某财务系统需要在每天凌晨0:10分结算前一天的财务数据，统计汇总</li></ul><p>以上场景就是任务调度所需要解决的问题</p><p><strong>任务调度是为了自动完成特定任务，在约定的特定时刻去执行任务的过程</strong></p><h3 id="为什么需要分布式调度"><a href="#为什么需要分布式调度" class="headerlink" title="为什么需要分布式调度"></a>为什么需要分布式调度</h3><p>使用Spring中提供的注解@Scheduled，也能实现调度的功能，在业务类中方法中贴上这个注解,然后在启动类上贴上<code>@EnableScheduling</code>注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/20 * * * * ? &quot;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doWork</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="comment">//doSomething   </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>但是这种方式：</p><ul><li>只能在一台机器上运行，如果程序或者系统出现异常就会导致功能不可用</li><li>在单机模式下，定时任务是没什么问题的。但当我们部署了多台服务，同时又每台服务又有定时任务时，若不进行合理的控制在同一时间，只有一个定时任务启动执行，定时执行的结果就可能存在混乱和错误了</li><li>原本1分钟内需要处理1万个订单，但是现在需要1分钟内处理10万个订单；原来一个统计需要1小时，现在业务方需要10分钟就统计出来。也许可以多线程、单机多进程处理。的确，多线程并行处理可以提高单位时间的处理效率，但是单机能力毕竟有限（主要是CPU、内存和磁盘），始终会有单机处理不过来的情况</li></ul><h2 id="XXL-Job"><a href="#XXL-Job" class="headerlink" title="XXL-Job"></a>XXL-Job</h2><p><a href="https://github.com/xuxueli/xxl-job">XXL-Job</a>是一个轻量级分布式任务调度平台, 其核心设计目标是开发迅速、学习简单、轻量级、易扩展</p><p><img src="/inori/226b10d6/framework.png"></p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。</p><p>将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。</p><p>因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性</p><h3 id="配置调度中心"><a href="#配置调度中心" class="headerlink" title="配置调度中心"></a>配置调度中心</h3><ol><li>下载xxl的源码后，有一个调度数据库初始化的SQL脚本，首先需要把这个脚本导入到数据库中</li><li>按照maven格式将源码导入到idea，使用maven进行编译后运行即可</li></ol><p><img src="/inori/226b10d6/structure.png"></p><ol start="3"><li>修改<code>xxl-job-admin</code>项目的配置文件<code>application.properties</code>,把数据库账号密码配置上</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### web</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8080</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/xxl-job-admin</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### actuator</span></span><br><span class="line"><span class="attr">management.server.servlet.context-path</span>=<span class="string">/actuator</span></span><br><span class="line"><span class="attr">management.health.mail.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### resources</span></span><br><span class="line"><span class="attr">spring.mvc.servlet.load-on-startup</span>=<span class="string">0</span></span><br><span class="line"><span class="attr">spring.mvc.static-path-pattern</span>=<span class="string">/static/**</span></span><br><span class="line"><span class="attr">spring.resources.static-locations</span>=<span class="string">classpath:/static/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### freemarker</span></span><br><span class="line"><span class="attr">spring.freemarker.templateLoaderPath</span>=<span class="string">classpath:/templates/</span></span><br><span class="line"><span class="attr">spring.freemarker.suffix</span>=<span class="string">.ftl</span></span><br><span class="line"><span class="attr">spring.freemarker.charset</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="attr">spring.freemarker.request-context-attribute</span>=<span class="string">request</span></span><br><span class="line"><span class="attr">spring.freemarker.settings.number_format</span>=<span class="string">0.##########</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### mybatis</span></span><br><span class="line"><span class="attr">mybatis.mapper-locations</span>=<span class="string">classpath:/mybatis-mapper/*Mapper.xml</span></span><br><span class="line"><span class="comment">#mybatis.type-aliases-package=com.xxl.job.admin.core.model</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, datasource</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://IP地址:端口号/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### datasource-pool</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.minimum-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.maximum-pool-size</span>=<span class="string">30</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.auto-commit</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.idle-timeout</span>=<span class="string">30000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.pool-name</span>=<span class="string">HikariCP</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.max-lifetime</span>=<span class="string">900000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-timeout</span>=<span class="string">10000</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.connection-test-query</span>=<span class="string">SELECT 1</span></span><br><span class="line"><span class="attr">spring.datasource.hikari.validation-timeout</span>=<span class="string">1000</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, email</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">spring.mail.port</span>=<span class="string">25</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">xxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.from</span>=<span class="string">xxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.required</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, access token</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string">default_token</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, i18n (default is zh_CN, and you can choose &quot;zh_CN&quot;, &quot;zh_TC&quot; and &quot;en&quot;)</span></span><br><span class="line"><span class="attr">xxl.job.i18n</span>=<span class="string">zh_CN</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## xxl-job, triggerpool max size</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.fast.max</span>=<span class="string">200</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.slow.max</span>=<span class="string">100</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### xxl-job, log retention days</span></span><br><span class="line"><span class="attr">xxl.job.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><ol start="4"><li>运行<code>XxlJobAdminApplication</code>程序，访问调度中心：<a href="http://localhost:8080/xxl-job-admin%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%99%BB%E5%BD%95%E8%B4%A6%E5%8F%B7">http://localhost:8080/xxl-job-admin，默认登录账号</a> “admin&#x2F;123456”</li></ol><h3 id="配置执行器"><a href="#配置执行器" class="headerlink" title="配置执行器"></a>配置执行器</h3><ol><li>添加Maven依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>执行器配置，在配置文件中添加配置</li></ol><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 调度中心部署根地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span></span><br><span class="line"><span class="attr">xxl.job.admin.addresses</span>=<span class="string">http://127.0.0.1:8080/xxl-job-admin</span></span><br><span class="line"><span class="comment">### 执行器通讯TOKEN [选填]：非空时启用；</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string">default_token</span></span><br><span class="line"><span class="comment">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span></span><br><span class="line"><span class="attr">xxl.job.executor.appname</span>=<span class="string">xxl-job-executor-sample</span></span><br><span class="line"><span class="comment">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span></span><br><span class="line"><span class="attr">xxl.job.executor.address</span>=<span class="string"></span></span><br><span class="line"><span class="comment">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span></span><br><span class="line"><span class="attr">xxl.job.executor.ip</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span></span><br><span class="line"><span class="attr">xxl.job.executor.port</span>=<span class="string">9999</span></span><br><span class="line"><span class="comment">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logpath</span>=<span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line"><span class="comment">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logretentiondays</span>=<span class="string">30</span></span><br></pre></td></tr></table></figure><ol start="3"><li>创建<code>XxlJobConfig</code>配置对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>添加任务处理类，交给Spring容器管理，在处理方法上贴上<code>@XxlJob</code>注解</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleXxlJob</span> &#123;</span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demoJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行定时任务,执行时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><p>登录调度中心,在任务管理中新增任务,配置内容如下：</p><p><img src="/inori/226b10d6/config1.png"></p><p>然后启动定时调度任务，回到管控台，就可以看到任务已经执行</p><h3 id="执行器集群"><a href="#执行器集群" class="headerlink" title="执行器集群"></a>执行器集群</h3><p>在IDEA中设置SpringBoot项目运行开启多个集群，启动两个SpringBoot程序,需要修改Tomcat端口和执行器端口</p><ul><li><p>Tomcat端口8090程序的命令行参数:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8090 -Dxxl.job.executor.port=9998</span><br></pre></td></tr></table></figure></li><li><p>Tomcat端口8091程序的命令行参数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-Dserver.port=8091 -Dxxl.job.executor.port=9999</span><br></pre></td></tr></table></figure></li></ul><p>在任务管理中，修改路由策略，修改成<code>轮询</code></p><p><img src="/inori/226b10d6/config2.png"></p><p>重新启动,我们可以看到效果是,定时任务会在这两台机器中进行轮询的执行</p><h4 id="调度路由算法"><a href="#调度路由算法" class="headerlink" title="调度路由算法"></a>调度路由算法</h4><ol><li><p>FIRST（第一个）：固定选择第一个机器</p></li><li><p>LAST（最后一个）：固定选择最后一个机器</p></li><li><p>ROUND（轮询）：依次的选择在线的机器发起调度</p></li><li><p>RANDOM（随机）：随机选择在线的机器</p></li><li><p>CONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上</p></li><li><p>LEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举</p></li><li><p>LEAST_RECENTLY_USED（最近最久未使用）：最久未使用的机器优先被选举</p></li><li><p>FAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度</p></li><li><p>BUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度</p></li><li><p>SHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务</p></li></ol><h3 id="分片功能"><a href="#分片功能" class="headerlink" title="分片功能"></a>分片功能</h3><p>需求:在指定节假日，需要给平台的所有用户去发送祝福的短信</p><h4 id="初始化数据"><a href="#初始化数据" class="headerlink" title="初始化数据"></a>初始化数据</h4><p>在数据库中导入<code>xxl_job_demo.sql</code>数据</p><h4 id="集成Druid-MyBatis"><a href="#集成Druid-MyBatis" class="headerlink" title="集成Druid&amp;MyBatis"></a>集成Druid&amp;MyBatis</h4><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--MyBatis驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--lombok依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加配置</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/xxl_job_demo?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="attr">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><p><strong>添加实体类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMobilePlan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;<span class="comment">//主键</span></span><br><span class="line">    <span class="keyword">private</span> String username;<span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String nickname;<span class="comment">//昵称</span></span><br><span class="line">    <span class="keyword">private</span> String phone;<span class="comment">//手机号码</span></span><br><span class="line">    <span class="keyword">private</span> String info;<span class="comment">//备注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加Mapper处理类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="业务功能实现"><a href="#业务功能实现" class="headerlink" title="业务功能实现"></a>业务功能实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot;,处理任务数量:&quot;</span>+userMobilePlans.size());</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟发送短信动作</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们的案例中有2000+条数据，如果不采取分片形式的话，任务只会在一台机器上执行，这样的话需要20+秒才能执行完任务</p><p>如果采取分片广播的形式的话，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时系统自动传递分片参数，可根据分片参数开发分片任务</p><p>获取分片参数方式:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可参考Sample示例执行器中的示例任务&quot;ShardingJobHandler&quot;了解试用 </span></span><br><span class="line"><span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line"><span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br></pre></td></tr></table></figure><p>通过这两个参数，我们可以通过求模取余的方式，分别查询，分别执行，这样的话就可以提高处理的速度</p><p>之前2000+条数据只在一台机器上执行需要20+秒才能完成任务，分片后，有两台机器可以共同完成2000+条数据，每台机器处理1000+条数据，这样的话只需要10+秒就能完成任务</p><h4 id="案例改造"><a href="#案例改造" class="headerlink" title="案例改造"></a>案例改造</h4><p><strong>Mapper增加查询方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMobilePlanMapper</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan where mod(id,#&#123;shardingTotal&#125;)=#&#123;shardingIndex&#125;&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectByMod</span><span class="params">(<span class="meta">@Param(&quot;shardingIndex&quot;)</span> Integer shardingIndex,<span class="meta">@Param(&quot;shardingTotal&quot;)</span>Integer shardingTotal)</span>;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_user_mobile_plan&quot;)</span></span><br><span class="line">    List&lt;UserMobilePlan&gt; <span class="title function_">selectAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>任务类方法</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;sendMsgShardingHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgShardingHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务开始时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    List&lt;UserMobilePlan&gt; userMobilePlans = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(shardTotal==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//如果没有分片就直接查询所有数据</span></span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectAll();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        userMobilePlans = userMobilePlanMapper.selectByMod(shardIndex,shardTotal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    userMobilePlans.forEach(item-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;任务结束时间:&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    System.out.println(<span class="string">&quot;任务耗时:&quot;</span>+(System.currentTimeMillis()-startTime)+<span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把路由策略改成分片广播即可实现分片功能</p><p><img src="/inori/226b10d6/demo.png"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/xxl/">xxl</category>
      
      
      <category domain="http://example.com/tags/xxl/">xxl</category>
      
      
      <comments>http://example.com/inori/226b10d6.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>项目常见问题梳理（持续更新中）</title>
      <link>http://example.com/inori/b4ace844.html</link>
      <guid>http://example.com/inori/b4ace844.html</guid>
      <pubDate>Sat, 31 May 2025 08:17:54 GMT</pubDate>
      
      <description>面试专题——项目篇</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="RPC项目"><a href="#RPC项目" class="headerlink" title="RPC项目"></a>RPC项目</h1><h2 id="为什么要做RPC项目"><a href="#为什么要做RPC项目" class="headerlink" title="为什么要做RPC项目"></a>为什么要做RPC项目</h2><p>目前的应用大部分都是分布式或者微服务架构，通常各个模块之间都是通过rpc来进行调用的，所以我认为自己写一个rpc项目可以更加深入的理解rpc的原理</p><p>然后在写rpc项目的过程中，学会了对Zookeeper和netty的使用，也学会了通信协议设计、序列化算法、服务注册与发现、负载均衡策略的设计和使用。</p><h2 id="项目有什么难点，如何解决的"><a href="#项目有什么难点，如何解决的" class="headerlink" title="项目有什么难点，如何解决的"></a>项目有什么难点，如何解决的</h2><ol><li>关于通信协议的实现和切换模块，我希望客户端和服务端支持http，socket和netty传输协议，并且根据配置自动切换。我的解决方案是首先定义了统一的接口<code>RpcClient</code> 和 <code>RpcServer</code>，然后实现其协议子类比如<code>NettyRpcServer</code>和<code>HttpRpcServer</code>，利用Spring Boot的 <code>@ConditionalOnProperty</code>和<code>@ConditionalOnMissingBean</code> 机制，支持配置项自动装配对应的协议实现</li><li>关于负载均衡模块的实现，就是服务调用时如何在多个服务节点直接选择一个合适的目标节点。我的解决方案是定义一个统一的接口<code>LoadBalance</code>，在此基础上扩展成随机、轮询和一致性哈希三种方法，使用SPI的方式决定具体使用哪种策略，最后把LoadBalance注入到服务发现模块中，实现调用时选择</li><li>关于服务注册和发现模块的实现，我编写了一个注解<code>RpcService</code>，服务启动时会遍历所有使用了这个注解的Bean，然后将服务的接口全限定名和服务提供地址注册到注册中心，然后在Zookeeper层面会创建一个临时节点，表明这个服务被创建成功。然后在客户端通过代理类发起远程调用时，如果存在多个地址，就是用负载均衡模块选择一个，最后建立连接发起远程调用</li><li>还有就是Kryo序列化与多线程环境的兼容性。因为Kryo是线程不安全的，直接复用同一个实例会导致数据错乱。后来我通过ThreadLocal为每个线程分配独立的Kryo实例，避免了线程间冲突，同时保持了性能</li></ol><h2 id="为什么用Netty做网络通信"><a href="#为什么用Netty做网络通信" class="headerlink" title="为什么用Netty做网络通信"></a>为什么用Netty做网络通信</h2><p>因为相比于Java原生的Socket和Http更适合高性能和高并发的场景</p><ul><li>Netty的IO是异步非阻塞的，支持大量并发连接，吞吐量高</li><li>Netty使用线程复用、事件驱动机制，资源占用低，GC压力小</li><li>Netty内部提供粘包半包处理器，实现rpc协议更方便</li></ul><h2 id="http、socket、netty三种网络通信方式的区别"><a href="#http、socket、netty三种网络通信方式的区别" class="headerlink" title="http、socket、netty三种网络通信方式的区别"></a>http、socket、netty三种网络通信方式的区别</h2><ul><li>socket是传输层的协议，是操作系统提供的网络编程接口，只提供最基础的通信方式，可以是阻塞或者非阻塞的，需要自己实现编解码器和传输的逻辑</li><li>http是应用层的协议，基于请求-响应的模式，默认是短连接的，并且不支持双向通信，性能比较低，但是http被很多框架支持，使用比较方便</li><li>netty是一个基于NIO的网络通信框架，底层用到了socket，是异步非阻塞，基于事件驱动的，性能比较高，并且其中提供了粘包半包的处理器和对自定义协议的支持，扩展性比较好</li></ul><h2 id="JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别"><a href="#JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别" class="headerlink" title="JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别"></a>JDK、JSON、Protostuff、Hession、Kryo五种序列化方式的区别</h2><ul><li>JDK是Java原生的序列化方式，不需要引入三方库，但是序列化后体积比较大，性能低，反序列化速度慢</li><li>Json的可读性比较强，支持跨语言调用，比较适合web接口，但是它占用空间比较大，而且不支持复杂的对象图</li><li>Protostuff是基于Protobuf的序列化方式，支持基础的Java Bean，可以跨语言，并且序列化后体积小，性能高，但是它序列化后不可读</li><li>Hession是一个二进制协议，支持序列化复杂对象，也可以跨语言支持，兼容性比较好</li><li>Kryo适合Java内部序列化，不支持跨语言，序列化性能非常高，默认要求类有无参构造器，而且kryo是线程不安全的</li></ul><h2 id="讲一下自定义协议"><a href="#讲一下自定义协议" class="headerlink" title="讲一下自定义协议"></a>讲一下自定义协议</h2><p>我在rpc项目中的自定义协议头有魔数（4byte，识别协议是否合法），版本号（1byte，兼容后续可能的更新），序列化算法（1byte，具体使用的序列化协议），消息类型（1byte，有请求、响应、心跳），消息状态（1byte，成功，失败，超时），消息序列号（4byte，每个请求的唯一id，处理多路复用的时候可以用到），消息长度（4byte）</p><h2 id="讲一下编解码器"><a href="#讲一下编解码器" class="headerlink" title="讲一下编解码器"></a>讲一下编解码器</h2><p>编码部分是出站处理，把RpcMessage编码成Bytebuf对象，先把自定义协议头写到bytebuf中，再把协议体经过序列化后填充到bytebuf中</p><p>解码部分分为粘包半包解码器和具体解码两部分，关于粘包半包处理我使用的是Netty的定长解码器，在解码器中我设定了偏移量和消息体长度值，因为我的协议有16字节，后4字节代表消息体长度，所以偏移量是12字节，长度是4字节，解码器就通过长度字段，得出body的长度，然后从TCP流中拼接出这条完整消息，或者如果多条消息被粘在一起，Netty会按每条消息长度拆分出多条消息。然后再是具体解码，先校验是否符合我自定义协议的格式，再解出具体消息体</p><h2 id="讲一下Netty心跳机制和Channel的连接复用"><a href="#讲一下Netty心跳机制和Channel的连接复用" class="headerlink" title="讲一下Netty心跳机制和Channel的连接复用"></a>讲一下Netty心跳机制和Channel的连接复用</h2><p>TCP是长连接，但不会自动告诉你对方是否断线，如果一端异常断开，另一端会长时间挂起资源，会造成一定的资源浪费，所以我使用了定期的心跳检测，确认连接是否存活。我使用了netty的IdleStateHandler来实现心跳检测，当检测到写空闲时自动发送一个心跳检测数据包</p><p>然后在rpc框架中，如果每发一次请求就新建TCP连接，就会导致大量Socket打开关闭，并且并发高时会造成端口耗尽的问题。我在项目中使用ConcurrentHashMap存放每个<code>IP+端口号</code>使用过的Channel，如果当前IP的端口再次发起rpc请求后，检测到之前的Channel还没关闭，就可以再次使用，避免重复连接服务端</p><p>然后是多路复用的实现，因为同一个服务可能会发出多个不同的rpc请求，我使用一个<code>ConcurrentHashMap</code>存放每个请求的等待结果区，key是协议头中的sequenceId，value是Netty的Promise（代表一个异步响应），当响应回来时，用sequenceId找到对应的Promise完成结果，就可以做到同一个连接处理多个不同的请求。</p><h2 id="注册中心为什么使用Zookeeper不用Nacos"><a href="#注册中心为什么使用Zookeeper不用Nacos" class="headerlink" title="注册中心为什么使用Zookeeper不用Nacos"></a>注册中心为什么使用Zookeeper不用Nacos</h2><p>我这个RPC框架作为一个独立项目，需要自己实现服务注册&#x2F;发现、监听机制、负载均衡等功能。</p><ul><li>项目对一致性的要求更高，服务注册、注销都是临时节点，Zookeeper会在连接断开时自动清理</li><li>Zookeeper支持监听机制，服务节点变化能即时通知客户端，便于实现本地缓存刷新，Nacos的监听更偏配置文件，服务变化通知粒度更粗一些</li><li>项目使用的是Netty和SpringBoot，整体较轻量，不需要配置中心功能</li><li>Nacos提供了配置中心和服务注册功能，对于微服务项目来说非常适合。但我的RPC框架更偏向于底层架构搭建和分布式通信机制学习，所以我更偏向选用Zookeeper，它更容易控制细节、简洁可定制</li></ul><h2 id="服务如何注册、客户端如何发现、服务如何下线"><a href="#服务如何注册、客户端如何发现、服务如何下线" class="headerlink" title="服务如何注册、客户端如何发现、服务如何下线"></a>服务如何注册、客户端如何发现、服务如何下线</h2><p>服务注册的逻辑在服务提供端，主要流程是服务启动时，连接到Zookeeper，创建持久结点，表示这个服务，然后在持久结点下面创建临时子节点，表示提供这个服务的IP地址和端口号，临时节点中会存数据，是Json格式的服务对象，有服务名，ip地址，端口号和版本号。注册成功后，Zookeeper会维持与该服务实例的心跳连接</p><p>服务发现的逻辑在服务调用端，主要流程是服务启动时连接到Zookeeper，发送rpc请求时，先根据服务名查找服务。如果客户端第一次查找该服务，会从Zookeeper拉取服务列表，构建本地缓存，并设置监听器，后续若服务变化，缓存会自动更新。不是第一次的话则直接调用缓存，然后使用负载均衡算法从服务列表中选一个可用实例，返回该实例信息用于客户端建立连接并发起请求</p><p>服务下线分为两种情况，第一种情况是服务主动下线，服务关闭时使用注销方法将服务从Zookeeper中删除，然后客户端因为配置了监听器，会自动更新缓存列表。第二种情况是服务异常下线，因为Zookeeper有心跳机制，当检测不到这个服务时，会认为这个服务已经停止了，删除这个服务</p><h2 id="介绍一下客户端调用、服务端响应的一个完整流程"><a href="#介绍一下客户端调用、服务端响应的一个完整流程" class="headerlink" title="介绍一下客户端调用、服务端响应的一个完整流程"></a>介绍一下客户端调用、服务端响应的一个完整流程</h2><p>客户端通过代理类发起服务调用，动态代理类会封装请求，客户端进行服务发现，然后使用负载均衡算法选择一个服务提供者发起网络通信请求，请求成功后，使用自定义协议将信息封装为消息头和消息体，并通过编码器和序列化器转成字节数组，将数据发送到目标Channel，服务端收到数据后，进行解码和反序列化，还原消息体，然后通过反射调用目标方法，获取返回结果，再封装消息，进行编码和序列化后将字节数组通过Channel发回到客户端中，然后客户端再进行解码和反序列化获得结果。</p><h2 id="如果zk中的服务节点退出了，服务还能访问吗，怎么做"><a href="#如果zk中的服务节点退出了，服务还能访问吗，怎么做" class="headerlink" title="如果zk中的服务节点退出了，服务还能访问吗，怎么做"></a>如果zk中的服务节点退出了，服务还能访问吗，怎么做</h2><p>如果Zookeeper中某个服务节点退出，它注册的临时节点会自动被删除。客户端如果还用旧地址调用，就会访问失败。为避免这个问题，我在客户端实现了本地服务地址缓存和动态监听机制，保证地址列表是实时更新的。客户端在读取服务地址的时候会注册监听器，一旦某个节点下线了，Zookeeper会提交一个事件给监听器，进而更新本地缓存。但是如果是一个客户端已经请求到这个服务节点了，但是此时这个节点宕机了，那么会出现请求失败的情况，关于这种情况，我配置了失败重试策略，请求发送失败时，使用负载均衡策略切换下一个地址重试</p><h2 id="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信"><a href="#如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信" class="headerlink" title="如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信"></a>如果一个正在被客户端请求的服务提供方准备下线，有什么方法能保证客户端这次能正常通信</h2><p>如果一个服务正在被请求，此时直接下线可能会导致请求失败或连接中断。我采用的是优雅下线策略，先从注册中心摘除服务，但不会马上关闭进程，等待处理中的请求完成后再关闭服务进程，保证客户端本次调用能够完成（netty的EventLoopGroup.shutdownGracefully()）</p><h2 id="你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别"><a href="#你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别" class="headerlink" title="你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别"></a>你做的rpc项目与目前主流的rpc框架对比有哪些优势或区别</h2><p>我做的这个RPC框架虽然不如Dubbo、gRPC功能全面，但胜在轻量级，更适合作为学习、定制型服务通信的基础框架。同时我也实现了一些Dubbo和gRPC中的重要特性，如服务注册、序列化、连接复用、自动注入等功能。</p><p>当然与成熟框架相比，我的RPC框架还存在一些后续可以升级的点：</p><ul><li>服务治理能力（如限流、熔断、降级）</li><li>跨语言支持</li><li>服务可观测性（如日志链路追踪）</li></ul><h2 id="实现一个RPC框架最主要看重哪些点"><a href="#实现一个RPC框架最主要看重哪些点" class="headerlink" title="实现一个RPC框架最主要看重哪些点"></a>实现一个RPC框架最主要看重哪些点</h2><ol><li>通信协议的设计，协议需要清晰的定义请求和响应结构，序列化格式和状态码等数据</li><li>编解码和序列化，编解码和序列化的效率应该要高，然后序列化后的数据体积应该小，看具体业务判断是否需要跨语言</li><li>网络通信性能，阻塞式或者异步式，是否支持连接池、长连接、心跳机制</li><li>服务注册与发现，负载均衡，是否具备故障感知能力</li><li>容错与高可用机制，是否支持失败重试，熔断和降级策略</li><li>还有易用性和可扩展性，是否支持注解，自动装配和可插拔机制</li></ol><h2 id="本地方法调用和远程过程调用有什么区别"><a href="#本地方法调用和远程过程调用有什么区别" class="headerlink" title="本地方法调用和远程过程调用有什么区别"></a>本地方法调用和远程过程调用有什么区别</h2><p>本地方法调用是程序内的方法直接调用，属于同一个进程内的方法调用，延迟很低，调用比较可靠，不需要中间件支持，但是代码的耦合度比较高</p><p>远程过程调用是调用远程服务器上提供的方法，属于不同进程或者不同机器上的方法调用，需要进行网络通信，所以有网络延迟，效率相对较低，也会有网络中断，超时等异常情况，需要中间件的支持，但是做到了服务之间的解耦合</p><h2 id="rpc如何支持服务的熔断和降级的"><a href="#rpc如何支持服务的熔断和降级的" class="headerlink" title="rpc如何支持服务的熔断和降级的"></a>rpc如何支持服务的熔断和降级的</h2><p>熔断是如果某个服务连续调用失败，系统就会临时阻止再发起请求，防止拖垮系统，可以在rpc中引入熔断器组件Sentinel，每个服务接口调用前先经过熔断器判断是否“断路”，统计失败率、超时数等动态判断是否进入熔断状态，还可以支持闭合-&gt;半开-&gt;打开的状态转换</p><p>降级是如果调用失败次数太多，系统就自动返回默认数据或走备用逻辑，可以编写Fallback方法，方法调用失败&#x2F;超时后，调用备用逻辑，返回默认值</p><h2 id="介绍一下一致性哈希算法"><a href="#介绍一下一致性哈希算法" class="headerlink" title="介绍一下一致性哈希算法"></a>介绍一下一致性哈希算法</h2><p>如果使用简单的哈希方式，当服务节点发生变化的时候，所有请求的分发都会大范围变化，这会导致缓存失效，影响系统效率。一致性哈希算法可以做到：节点数量变化时，尽量少地影响原有请求的分配规律，就是请求一致性和低扰动性。</p><p>一致性哈希算法把哈希空间想象成一个环，所有服务实例都通过哈希函数映射到这个环上某个位置，对服务的ip地址，端口号以及服务名称进行hash后对一个比较大的数进行取模，对数据key也进行hash，然后顺时针找到某一个node，就是这个key要存储的服务器。这样如果增加或者删除一台服务器的话，就只会影响部分数据。但是这样做，当节点比较少的时候会造成数据倾斜的问题，大部分数据会集中在某一个服务上。我的项目中使用了虚拟节点的解决方式，每个真实节点会映射为160个虚拟节点，通过MD5算法再生成多个哈希值，映射到哈希环上，对于请求来说，使用服务方法名加请求参数拼接后做MD5，再映射成哈希值，定位到哈希环上离它最近的服务节点，当服务列表变更时，重新构建哈希环，保证一致性，然后这个重建是不会造成大批量请求映射出错的，比如某个请求落到虚拟节点 A，服务列表变了，A 还在，请求还是到 A，如果A不在了，请求会顺时针走一点落到B。</p><h2 id="项目中哪些地方使用到了异步"><a href="#项目中哪些地方使用到了异步" class="headerlink" title="项目中哪些地方使用到了异步"></a>项目中哪些地方使用到了异步</h2><ul><li>Netty的核心通信是异步的，就是所有的IO操作都是异步非阻塞的</li><li>发送rpc请求是异步的，可以发送消息后立刻返回，监听发送是否成功</li><li>接收响应也是异步的，我在发生时生成了一个id，将future对象存到HashMap里，等收到响应后再异步完成这个future</li></ul><h1 id="小程序项目"><a href="#小程序项目" class="headerlink" title="小程序项目"></a>小程序项目</h1><h2 id="你用自定义注解实现了权限控制，讲讲具体是怎么做的"><a href="#你用自定义注解实现了权限控制，讲讲具体是怎么做的" class="headerlink" title="你用自定义注解实现了权限控制，讲讲具体是怎么做的"></a>你用自定义注解实现了权限控制，讲讲具体是怎么做的</h2><p>在这个小程序中，会涉及到三种角色：管理员root，活动发起者admin和活动参与者visitor，不同角色访问系统中接口的权限是不同的。</p><p>在项目中我使用JWT实现用户认证，用户登录后会签发Token，并将用户信息存入上下文，作为认证依据。</p><p>授权部分，我设计了一个自定义注解<code>@CheckPermission</code>来标记每个接口需要的具体权限，并结合AOP实现了权限切面。切面会在方法执行前解析注解，获取当前用户权限列表，进行匹配校验。如果用户具备权限，就放行接口，否则抛出无权限异常，交由全局异常处理器处理。</p><h2 id="用了三级缓存，讲一下细节"><a href="#用了三级缓存，讲一下细节" class="headerlink" title="用了三级缓存，讲一下细节"></a>用了三级缓存，讲一下细节</h2><p>我的项目中使用了Caffeine、Redis和MySQL结构来优化数据访问性能，本地缓存用于存储访问最频繁的数据，活动列表和当前登录用户信息。Redis作为二级缓存，用于存储访问过的活动详情、活动列表和用户信息，最后由数据库层面，存储全部数据</p><p>整体流程是用户访问数据时，先查本地缓存，未命中则查Redis，如果Redis也未命中再查数据库，并将结果同步回前两级缓存。</p><p>关于过期策略，活动信息在Caffeine中缓存5分钟左右，在Redis中缓存30分钟左右。</p><p>本地缓存层面，我使用了Caffeine的<code>CacheLoader</code>和<code>refreshAfterWrite</code>来预先加载数据避免本地的缓存穿透</p><h2 id="数据库表是怎么设计的"><a href="#数据库表是怎么设计的" class="headerlink" title="数据库表是怎么设计的"></a>数据库表是怎么设计的</h2><p>用户表，存放用户信息和用户的角色</p><p>活动表，存放已经发布的活动，活动的相关信息和发起人</p><p>活动报名表，表示活动id和用户id之间的关系</p><h2 id="如何部署项目，上线流程讲一下"><a href="#如何部署项目，上线流程讲一下" class="headerlink" title="如何部署项目，上线流程讲一下"></a>如何部署项目，上线流程讲一下</h2><p>预先在yaml文件中配置好生产环境参数，然后使用maven对项目进行打包，生成jar文件，传到服务器上，使用systemd后台运行项目，然后配置Nginx，将小程序API请求代理到SpringBoot项目端口，然后配置Nginx的ssl，让小程序支持HTTPS。</p><p>redis和mysql都部署在同一台服务器上，SpringBoot通过配置文件连接到redis和mysql</p><h2 id="活动报名如果高并发，怎么防止名额超限或重复提交"><a href="#活动报名如果高并发，怎么防止名额超限或重复提交" class="headerlink" title="活动报名如果高并发，怎么防止名额超限或重复提交"></a>活动报名如果高并发，怎么防止名额超限或重复提交</h2><p>我在每个活动创建的时候，会把名额写入redis中，使用<code>DECR</code>命令，用户报名前先<code>DECR</code>名额，如果减成功则允许报名，否则失败，因为<code>DECR</code>操作是Redis原子命令，天然支持并发控制，报名成功之后我使用redis创建一个活动名加上用户id的分布式锁，表示这个用户已经报名了这个活动，然后这个设置了一个过期时间，在过期时间内我会把这个报名数据写到数据库中，后续用户再重复报名时，因为redis层面的对应数据已经过期了，就会去查询数据库是否有他的信息，如果有再返回已报名的提示，用这个方式防止名额超限和重复报名</p><h2 id="三级缓存的缓存一致性怎么保证"><a href="#三级缓存的缓存一致性怎么保证" class="headerlink" title="三级缓存的缓存一致性怎么保证"></a>三级缓存的缓存一致性怎么保证</h2><p>读请求是如果访问的是用户信息和首页活动列表，那么会先查询本地缓存，在查询redis，最后查询数据库，然后把数据库返回的数据存到redis和本地缓存中</p><p>如果访问的不是这两个，就直接查询redis，没查到再查询数据库，再写会redis。</p><p>写请求的话，我使用的是先更新数据库，在删除缓存的策略。</p><h1 id="电商项目"><a href="#电商项目" class="headerlink" title="电商项目"></a>电商项目</h1><h2 id="说一下分布式事务"><a href="#说一下分布式事务" class="headerlink" title="说一下分布式事务"></a>说一下分布式事务</h2><p>由多个服务通过网络完成一个事务叫分布式事务。</p><p>首先根据CAP原理决定我们的需求，是要实现CP、还是要实现AP。</p><p>实现CP就是要实现强一致性，可以使用 Seata 框架基于AT、TCC模式去实现。</p><p>我们项目中大部分实现的是AP，使用本地消息表加任务调度完成分布式事务最终数据一致性。</p><h2 id="项目中哪里用到了分布式事务，如何解决的"><a href="#项目中哪里用到了分布式事务，如何解决的" class="headerlink" title="项目中哪里用到了分布式事务，如何解决的"></a>项目中哪里用到了分布式事务，如何解决的</h2><ol><li>发布商品，发布商品需要在商品服务的数据库表中记录，同时将商品信息同步到redis和ES</li></ol><ul><li>发布商品使用本地事务向商品表中写入商品数据，同时写入一条待处理的消息到本地消息表</li><li>提交本地事务之后，xxl的调度中心使用分片广播模式向执行器下发任务，开始扫描消息表，查询待处理的消息</li><li>根据消息内容，通过调用Redis和ES的接口完成数据同步</li><li>任务完成后删除消息表记录</li></ul><ol start="2"><li>用户下单，需要调用商品服务扣减库存，订单服务创建订单，用户服务添加购买记录</li></ol><ul><li>订单服务收到下单请求后，开启本地事务，生成订单记录，然后写入本地消息表，记录要通知商品服务和用户服务的消息，提交事务后，通过消息队列发送通知消息</li><li>商品服务和用户服务通过监听消息队列来处理库存的扣减和添加购买记录的逻辑</li><li>如果消息队列发送失败或者没有被消费，就会使用xxl作为定时任务调度器，每隔一段时间扫描本地消息表中的异常记录进行消息补发</li></ul><h2 id="如何进行分布式事务的回滚"><a href="#如何进行分布式事务的回滚" class="headerlink" title="如何进行分布式事务的回滚"></a>如何进行分布式事务的回滚</h2><p>我项目中采用的是一种基于本地消息表和补偿机制的最终一致性方案。没有使用传统的强一致性分布式事务框架，通过状态标记和异步处理来实现逻辑上的回滚</p><p>在整个业务流程中，每个关键操作都配合本地消息表记录执行状态。当某个服务执行失败时，首先在服务内部有失败重试机制，尽最大努力成功，如果重试后仍失败，会将失败消息记录转移到数据库中的事务失败表，并在消息表中更新状态字段，最后使用xxl定时扫描失败记录表，执行补偿逻辑，并且对于一致性要求比较强的场景，我还使用了消息队列进行即时的通知，xxl作为兜底</p><p>比如用户下单操作中，订单服务已经创建好订单了，但是后续商品扣减库存出了问题，现在想要回滚，那么首先商品服务会发送一条失败消息到消息队列中，并且将失败消息记录到数据库中，订单服务获取到之后，会修改订单表中的状态字段为失败，通过状态标记避免后续的处理</p><h2 id="除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路"><a href="#除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路" class="headerlink" title="除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路"></a>除了本地信息表加任务调度保证分布式事务，还有什么思路去做，为什么选择这种思路</h2><ul><li>XA，两阶段提交，先准备资源，再统一提交或者回滚</li><li>TCC，把每个操作拆分成三部分，先预检查，再尝试获取资源，最后提交实际操作</li><li>SAGA，长事务补偿，将事务拆分为一系列子事务，每个子事务完成后立刻提交，如果后续事务失败，则按顺序调用每个子事务的补偿操作来回滚</li></ul><p>为什么我选择任务调度这种方式，因为我认为这个项目中主要以性能和并发为优先考虑，不适合xa和tcc，并且业务是允许最终一致性的，不是强一致性的，而且消息队列和xxl的方式比较好实现</p><h2 id="Elasticsearch是怎么使用的"><a href="#Elasticsearch是怎么使用的" class="headerlink" title="Elasticsearch是怎么使用的"></a>Elasticsearch是怎么使用的</h2><p>1）首先创建索引（相当于mysql的表），将商品信息添加到索引库，对商品信息进行分词，存储到索引库</p><p>2）在商品服务中编写商品搜索接口，调用es的rest接口根据关键字、商品分类信息进行搜索</p><h3 id="如何保证索引同步"><a href="#如何保证索引同步" class="headerlink" title="如何保证索引同步"></a>如何保证索引同步</h3><p>我项目是使用本地任务表加xxl-job任务调度进行索引同步</p><p>1）添加或修改或删除商品的同时向任务表插入一条记录，这条记录就记录了是修改了哪个商品</p><p>2）任务调度定时扫描任务表，根据任务表的内容对商品信息进行同步，如果添加了商品将商品添加到索引库，如果修改了商品就修改索引库的商品，如果是删除了商品将商品信息从索引库删除</p><h2 id="xxl-job的工作原理是什么"><a href="#xxl-job的工作原理是什么" class="headerlink" title="xxl-job的工作原理是什么"></a>xxl-job的工作原理是什么</h2><p>xxl由调度中心和执行器组成，在应用启动时，执行器会将自己注册到调度中心Admin，然后在Admin中配置定时任务，指定要调哪个Bean和方法，到达任务触发时间后，Admin通过HTTP请求调用对应的执行器，执行结果会通过回调上传给调度中心，如果失败还可以配置自动重试机制。并且如果有很多执行器，xxl还支持负载均衡策略和任务分片</p><p>在我的项目中，我主要使用xxl实现对本地消息表和失败记录表的定时扫描，还有对于优惠券和商品的限时抢购的时间预订功能</p><h2 id="如何保证任务不重复执行"><a href="#如何保证任务不重复执行" class="headerlink" title="如何保证任务不重复执行"></a>如何保证任务不重复执行</h2><p>主要有两种方式，一个是每个任务都会生成一个唯一的Id，业务层判断该任务是否已经执行过，还有每条待处理的消息记录在消息表中含有状态字段，调度器扫描任务时，通过状态判断是否执行过，避免重复触发</p><h2 id="未支付订单如何处理"><a href="#未支付订单如何处理" class="headerlink" title="未支付订单如何处理"></a>未支付订单如何处理</h2><p>在我的项目中使用RabbitMQ的死信队列机制处理未支付订单，用户提交订单之后，系统会向消息队列中发送一条消息，交换机配置为死信交换机，过期后，消息被路由到死信队列，然后执行取消订单，恢复库存的逻辑</p><h2 id="如何保证RabbitMQ的消息可靠性"><a href="#如何保证RabbitMQ的消息可靠性" class="headerlink" title="如何保证RabbitMQ的消息可靠性"></a>如何保证RabbitMQ的消息可靠性</h2><p>可靠性保证主要分为三部分，一个是生产者到消息队列的可靠性，这部分由消息确认机制保证，就是生产者发送消息后，会异步等待消息队列反馈ACK，一个是消息队列内部的可靠性，消息队列内部有持久化机制，可以将未消费消息保存到硬盘中，一个是消息队列到消费者的可靠性，这个与生产者类似，消费者接收到消息并且成功处理之后，会反馈给消息队列，然后消息队列才会把这条消息删除，如果处理失败或者一直没有处理会触发重试机制</p><h3 id="如何避免消息重复消费"><a href="#如何避免消息重复消费" class="headerlink" title="如何避免消息重复消费"></a>如何避免消息重复消费</h3><p>每个业务操作都有唯一ID，这个ID会随着消息一起发送到消息队列中，如果这个消息已经被消费了，就一定会在数据库中有记录，就算消费者后续反馈到消息队列的ack丢失，触发消息队列的重试机制了，消费者再次收到相同消息时也不会重复消费</p><h2 id="为什么选择RabbitMQ"><a href="#为什么选择RabbitMQ" class="headerlink" title="为什么选择RabbitMQ"></a>为什么选择RabbitMQ</h2><p>首先RabbitMQ支持可靠性传输机制，提供了持久化，ack确认机制，消息重试和死信机制，然后它提供了很多的消息路由类型（点对点路由、模糊匹配路由、广播路由），可以应对不同的业务场景</p><h2 id="项目使用Redis缓存了哪些数据"><a href="#项目使用Redis缓存了哪些数据" class="headerlink" title="项目使用Redis缓存了哪些数据"></a>项目使用Redis缓存了哪些数据</h2><p>缓存内容有商品详情、商品列表、用户信息等访问频率可能比较高的数据</p><p>使用的数据结构：</p><ul><li>String：商品详情</li><li>Hash：用户信息、购物车数据</li><li>List：排行榜、热门商品</li></ul><h2 id="如何保证Redis缓存一致性"><a href="#如何保证Redis缓存一致性" class="headerlink" title="如何保证Redis缓存一致性"></a>如何保证Redis缓存一致性</h2><p>对于正常读写场景，我采用的是先更新数据库，再删除缓存的方式，对于高并发写场景，我采用的是先更新缓存，再异步更新数据库的方式，高并发为了减轻数据库压力、提高写入性能，直接写缓存，再通过消息队列异步写数据库，确保最终一致</p><h2 id="优惠券秒杀部分怎么实现的"><a href="#优惠券秒杀部分怎么实现的" class="headerlink" title="优惠券秒杀部分怎么实现的"></a>优惠券秒杀部分怎么实现的</h2><p>秒杀的核心目标首先是保证优惠券不能超卖，同一用户不能重复领券。首先我会把券的库存预加载进Redis中，然后把校验用户身份和扣减库存这两步写到lua脚本里原子执行，然后如果redis返回成功，就会向消息队列中发一条更新数据库的消息，把优惠券写到用户信息中，这样既能流量削峰，也能保证幂等性。</p><h2 id="秒杀的核心瓶颈是什么"><a href="#秒杀的核心瓶颈是什么" class="headerlink" title="秒杀的核心瓶颈是什么"></a>秒杀的核心瓶颈是什么</h2><ul><li>高并发，瞬间就会有上万的用户访问同一个服务，可能会导致服务崩溃。可以使用令牌桶拦截多余请求，或者使用消息队列异步处理</li><li>库存超卖，多个用户并发抢购，有可能库存为0时仍被扣减。可以使用Redis+Lua脚本原子操作</li><li>数据库写入压力，秒杀成功时大量请求写入数据库。可以使用消息队列异步写入，或者分库分表缓解单表写入瓶颈</li><li>重复下单，在redis加一个用户id锁，然后在过期之前把优惠券持有情况写到数据库中，后续分布式锁过期了也可以保证幂等性</li></ul><h2 id="当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施"><a href="#当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施" class="headerlink" title="当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施"></a>当有人恶意使用脚本多台机器多个账号去进行抢购，达到一个十几万的并发量，如何应对做限流措施</h2><ul><li>首先可以在网关层限流，对IP限流，每个IP每秒不超过5次</li><li>然后可以在服务层限流，以用户id统计单位时间内的访问次数，超出阈值后进入冷却期，在一定时间内限制该用户的访问</li><li>然后在核心接口的访问使用令牌桶，用户抢到令牌才能继续请求</li></ul><h2 id="假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理"><a href="#假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理" class="headerlink" title="假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理"></a>假设当有人支付成功后立马又发起了退款，并且还没有完成分布式事务，如何处理</h2><p>关于这一点，我采用了订单状态控制和幂等机制来确保流程正确性。我在设计订单支付功能时，订单表中有一个状态字段，支付成功只能从未支付转为已支付，退款只能从已支付状态进入。支付成功后立马发起退款，如果当前数据库的订单状态还没转换成未支付，说明当前的订单服务都还没执行完，就会拒绝退款，如果订单状态已经转换成已支付了，就会进入退款流程，然后把订单状态改为已退款，因为订单服务之后会走用户服务和商品服务，用户服务是一定会走的，因为用户曾经创建过这个订单，然后商品服务的话会执行恢复库存这样的操作</p><h2 id="订单失败如何给用户进行反馈的"><a href="#订单失败如何给用户进行反馈的" class="headerlink" title="订单失败如何给用户进行反馈的"></a>订单失败如何给用户进行反馈的</h2><p>用户下单请求是通过接口发起的，在Controller层会捕获所有异常情况，如果业务逻辑执行失败，后端会返回统一格式的失败响应结构，前端拿到响应后通过异常响应信息提示用户。在订单表中有一个状态字段，每个订单可能的到达的状态在字段中都有记录，无论哪一步失败，都会更新订单状态字段，保障用户能获取订单失败的原因</p><h2 id="当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做"><a href="#当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做" class="headerlink" title="当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做"></a>当有大量失败订单，如果让你来设计如何去调度处理，你会怎么做</h2><p>首先将先将失败订单进行归类管理，为后续调度处理提供依据，比如超时未支付，扣库存失败等情况，每一类对应着不同的处理策略</p><p>然后为每个服务维护一张失败任务表，记录异常信息与状态字段，用xxl定时扫描任务表，使用分片广播模式将任务分发到多个执行器实例，每次任务执行前先通过订单状态字段判断是否已经处理保证幂等性，高并发场景下，也可结合分布式锁，确保订单只被一个任务执行，对处理失败的任务，支持自动重试机制，配置最大重试次数，失败次数超过阈值后自动转为人工处理，处理完成后更新订单状态，防止重复处理</p><h2 id="项目中的线程池使用什么方式创建的"><a href="#项目中的线程池使用什么方式创建的" class="headerlink" title="项目中的线程池使用什么方式创建的"></a>项目中的线程池使用什么方式创建的</h2><p>在项目中我使用的是Java原生的ThreadPoolExecutor，核心线程数我选择的是CPU核心数的两倍，最大线程数我用的核心线程数的两倍，非核心线程存活时间我设置的是一分钟，任务队列我用的有界数组队列，长度2000，拒绝策略使用的CallerRunsPolicy，当前线程执行任务。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://example.com/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://example.com/inori/b4ace844.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>基于Netty的RPC框架实现</title>
      <link>http://example.com/inori/2408437c.html</link>
      <guid>http://example.com/inori/2408437c.html</guid>
      <pubDate>Wed, 28 May 2025 02:53:58 GMT</pubDate>
      
      <description>基于Netty的RPC框架</description>
      
      
      
      <content:encoded><![CDATA[<p>RPC又称远程过程调用（Remote Procedure Call），用于解决分布式系统中服务之间的调用问题。通俗地讲，就是开发者能够像调用本地方法一样调用远程的服务。</p><img src="/inori/2408437c/rpc.png" style="zoom:50%;"><p>RPC框架一般必须包含三个组件，分别是<strong>客户端、服务端</strong>以及<strong>注册中心</strong>，一次完整的RPC调用流程一般为：</p><ol><li>服务端启动服务后，将他提供的服务列表发布到注册中心（服务注册）</li><li>客户端会向注册中心订阅相关的服务地址（服务订阅）</li><li>客户端通常会利用本地代理模块 Proxy 向服务端发起远程过程调用，Proxy 负责将调用的方法、参数等数据转化为网络字节流</li><li>客户端从服务列表中根据负载均衡策略选择一个服务地址，并将数据通过网络发送给服务端</li><li>服务端得到数据后，调用对应的服务，然后将结果通过网络返回给客户端</li></ol><p>虽然 RPC 调用流程很容易理解，但是实现一个完整的 RPC 框架设计到很多内容，例如服务注册与发现、通信协议与序列化、负载均衡、动态代理等</p><h2 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h2><ul><li>实现基于Netty&#x2F;Socket&#x2F;Http三种方式进行网路通信</li><li>自定义消息协议，编解码器</li><li>五种序列化算法（JDK、JSON、HESSIAN、KRYO、PROTOSTUFF）</li><li>三种负载均衡算法（RoundRobin、Random、ConsistentHash）</li><li>两种动态代理（JDK、CGLIB）</li><li>基于 Zookeeper 的服务注册与发现，增加服务本地缓存与监听</li><li>集成 Spring，自定义注解提供 RPC 组件扫描、服务注册、服务消费</li><li>集成 SpringBoot，完成自动配置</li><li>增加 Netty 心跳机制，复用 Channel 连接</li><li>实现自定义 SPI 机制</li></ul><h2 id="编解码模块"><a href="#编解码模块" class="headerlink" title="编解码模块"></a>编解码模块</h2><h3 id="粘包半包解决"><a href="#粘包半包解决" class="headerlink" title="粘包半包解决"></a>粘包半包解决</h3><p>这里采取的是消息长度 + 消息内容来解决的此问题，将每一条消息分为header和body，header中包含body的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 粘包半包编码器，使用固定长度的帧解码器，通过约定用定长字节表示接下来数据的长度</span></span><br><span class="line"><span class="comment"> * 非共享，保存了 ByteBuf 的状态信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcFrameDecoder</span> <span class="keyword">extends</span> <span class="title class_">LengthFieldBasedFrameDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">k RpcFrameDecoder#RpcFrameDecoder(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcFrameDecoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">16384</span>, <span class="number">12</span>, <span class="number">4</span>);  <span class="comment">// 前缀长度16字节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxFrameLength    数据帧的最大长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldOffset 长度域的偏移字节数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldLength 长度域所占的字节数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcFrameDecoder</span><span class="params">(<span class="type">int</span> maxFrameLength, <span class="type">int</span> lengthFieldOffset, <span class="type">int</span> lengthFieldLength)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里我给定的消息体最大长度是16384Byte，即16KB，如果消息体长度比这个要大，就会抛出异常，无法接收</p><blockquote><p> Netty官方建议不要轻易超过 8MB，否则可能导致内存过度分配、内存攻击等问题</p></blockquote><h3 id="编解码实现"><a href="#编解码实现" class="headerlink" title="编解码实现"></a>编解码实现</h3><p>编码部分是出站处理，需要编写RpcMessage模块，即header和body，header是自定义协议：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---------------------------------------------------------------------</span><br><span class="line">| 魔数 (4byte) | 版本号 (1byte)  | 序列化算法 (1byte) | 消息类型 (1byte) |</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">|    状态类型 (1byte)  |    消息序列号 (4byte)   |    消息长度 (4byte)   |</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">|                        消息内容 (不固定)                             |</span><br><span class="line">---------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>共16字节，在粘包半包解码器中定义了偏移量。</p><p>body部分使用序列化算法进行序列化，然后向下传递。</p><p>解码部分，先验证魔数是否符合要求，然后再进行后续的解码，在使用反序列化算法解析body部分获取消息体，然后向下传递。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Sharable</span><span class="comment">// 不存在线程竞争</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharableRpcMessageCodec</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, RpcMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码器为出站处理，将 RpcMessage 编码为 ByteBuf 对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> msg.getHeader();</span><br><span class="line">        <span class="comment">// 4字节 魔数</span></span><br><span class="line">        buf.writeBytes(header.getMagicNum());</span><br><span class="line">        <span class="comment">// 1字节 版本号</span></span><br><span class="line">        buf.writeByte(header.getVersion());</span><br><span class="line">        <span class="comment">// 1字节 序列化算法</span></span><br><span class="line">        buf.writeByte(header.getSerializerType());</span><br><span class="line">        <span class="comment">// 1字节 消息类型</span></span><br><span class="line">        buf.writeByte(header.getMessageType());</span><br><span class="line">        <span class="comment">// 1字节 消息状态</span></span><br><span class="line">        buf.writeByte(header.getMessageStatus());</span><br><span class="line">        <span class="comment">// 4字节 消息序列号</span></span><br><span class="line">        buf.writeInt(header.getSequenceId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出消息体</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">body</span> <span class="operator">=</span> msg.getBody();</span><br><span class="line">        <span class="comment">// 获取序列化算法</span></span><br><span class="line">        <span class="type">Serialization</span> <span class="variable">serialization</span> <span class="operator">=</span> SerializationFactory</span><br><span class="line">                .getSerialization(SerializationType.parseByType(header.getSerializerType()));</span><br><span class="line">        <span class="comment">// 进行序列化</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = serialization.serialize(body);</span><br><span class="line">        <span class="comment">// 设置消息体长度</span></span><br><span class="line">        header.setLength(bytes.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4字节 消息内容长度</span></span><br><span class="line">        buf.writeInt(header.getLength());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不固定字节 消息内容字节数组</span></span><br><span class="line">        buf.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传递到下一个出站处理器</span></span><br><span class="line">        out.add(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解码器为入站处理，将 ByteBuf 对象解码成 RpcMessage 对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 4字节 魔数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> ProtocolConstants.MAGIC_NUM.length;</span><br><span class="line">        <span class="type">byte</span>[] magicNum = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        msg.readBytes(magicNum, <span class="number">0</span>, len);</span><br><span class="line">        <span class="comment">// 判断魔数是否正确，不正确表示非协议请求，不进行处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (magicNum[i] != ProtocolConstants.MAGIC_NUM[i]) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown magic code: &quot;</span> + Arrays.toString(magicNum));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1字节 版本号</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 检查版本号是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (version != ProtocolConstants.VERSION) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;The version isn&#x27;t compatible &quot;</span> + version);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1字节 序列化算法</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializeType</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 1字节 消息类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 1字节 消息状态</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageStatus</span> <span class="operator">=</span> msg.readByte();</span><br><span class="line">        <span class="comment">// 4字节 消息序列号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> msg.readInt();</span><br><span class="line">        <span class="comment">// 4字节 长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> msg.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        msg.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建协议头部信息</span></span><br><span class="line">        <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> MessageHeader.builder()</span><br><span class="line">                .magicNum(magicNum)</span><br><span class="line">                .version(version)</span><br><span class="line">                .serializerType(serializeType)</span><br><span class="line">                .messageType(messageType)</span><br><span class="line">                .sequenceId(sequenceId)</span><br><span class="line">                .messageStatus(messageStatus)</span><br><span class="line">                .length(length).build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取反序列化算法</span></span><br><span class="line">        <span class="type">Serialization</span> <span class="variable">serialization</span> <span class="operator">=</span> SerializationFactory</span><br><span class="line">                .getSerialization(SerializationType.parseByType(serializeType));</span><br><span class="line">        <span class="comment">// 获取消息枚举类型</span></span><br><span class="line">        <span class="type">MessageType</span> <span class="variable">type</span> <span class="operator">=</span> MessageType.parseByType(messageType);</span><br><span class="line">        <span class="type">RpcMessage</span> <span class="variable">protocol</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcMessage</span>();</span><br><span class="line">        protocol.setHeader(header);</span><br><span class="line">        <span class="keyword">if</span> (type == MessageType.REQUEST) &#123;</span><br><span class="line">            <span class="comment">// 进行反序列化</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> serialization.deserialize(RpcRequest.class, bytes);</span><br><span class="line">            protocol.setBody(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == MessageType.RESPONSE) &#123;</span><br><span class="line">            <span class="comment">// 进行反序列化</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> serialization.deserialize(RpcResponse.class, bytes);</span><br><span class="line">            protocol.setBody(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == MessageType.HEARTBEAT_REQUEST || type == MessageType.HEARTBEAT_RESPONSE) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> serialization.deserialize(String.class, bytes);</span><br><span class="line">            protocol.setBody(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 传递到下一个处理器</span></span><br><span class="line">        out.add(protocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列化算法"><a href="#序列化算法" class="headerlink" title="序列化算法"></a>序列化算法</h2><p>客户端和服务端在通信过程中肯定要传输数据，但是这些数据不可能是直接明文传输的，我们需要对数据进行编码，那么该如何编解码呢？</p><p>如果采用TCP协议，我们需要将调用的接口、方法、请求参数、调用属性等信息序列化成二进制字节流传递给服务提供方，服务端接收到数据后，再把二进制字节流反序列化得到调用信息，然后利用反射的原理调用对应方法，最后将返回结果、返回码、异常信息等返回给客户端。所谓序列化和反序列化就是将对象转换成二进制流以及将二进制流再转换成对象的过程。因为网络通信依赖于字节流，而且这些请求信息都是不确定的，所以一般会选用通用且高效的序列化算法。比较常用的序列化算法有<code>FastJson、Kryo、Hessian、Protobuf</code>等，这些第三方序列化算法都比Java原生的序列化操作都更加高效</p><p>Dubbo支持多种序列化算法，并定义了Serialization接口规范，所有序列化算法扩展都必须实现该接口，其中默认使用的是<code>Hessian</code>序列化算法</p><p>序列化对于远程调用的响应速度、吞吐量、网络带宽消耗等同样也起着至关重要的作用，是提升分布式系统性能的最关键因素之一</p><p>判断一个编码框架的优劣主要从以下几个方面：</p><ol><li>是否支持跨语言，支持语种是否丰富</li><li>编码后的码流</li><li>编解码的性能</li><li>类库是否小巧，API使用是否方便</li><li>使用者开发的工作量和难度</li></ol><p>本项目计划实现5种序列化算法，分别为：<u>JDK、JSON、HESSIAN、KRYO 、PROTOSTUFF</u>，其中JSON使用GSON实现</p><p>五种序列化算法的比较如下：</p><table><thead><tr><th>序列化算法</th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>Kryo</strong></td><td>速度快，序列化后体积小</td><td>跨语言支持较复杂</td></tr><tr><td><strong>Hessian</strong></td><td>默认支持跨语言</td><td>较慢</td></tr><tr><td><strong>Protostuff</strong></td><td>速度快，基于protobuf</td><td>需静态编译</td></tr><tr><td><strong>Json</strong></td><td>使用方便</td><td>性能一般</td></tr><tr><td><strong>Jdk</strong></td><td>使用方便，可序列化所有类</td><td>速度慢，占空间</td></tr></tbody></table><h3 id="Hessian序列化"><a href="#Hessian序列化" class="headerlink" title="Hessian序列化"></a>Hessian序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HessianSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建字节数组输出流（内存缓冲区）</span></span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="comment">// 创建Hessian序列化输出流</span></span><br><span class="line">            <span class="type">HessianSerializerOutput</span> <span class="variable">hso</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializerOutput</span>(baos);</span><br><span class="line">            hso.writeObject(object);</span><br><span class="line">            hso.flush();</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Hessian serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将字节数组包装为输入流</span></span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="comment">// 创建 Hessian 反序列化输入流</span></span><br><span class="line">            <span class="type">HessianSerializerInput</span> <span class="variable">hsi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianSerializerInput</span>(bis);</span><br><span class="line">            <span class="keyword">return</span> (T) hsi.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Hessian deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jdk序列化"><a href="#Jdk序列化" class="headerlink" title="Jdk序列化"></a>Jdk序列化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">            oos.writeObject(object);</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Jdk serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line">            <span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Jdk deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Json序列化"><a href="#Json序列化" class="headerlink" title="Json序列化"></a>Json序列化</h3><p>由于Gson默认不能序列化Class对象，因为Class没有默认的序列化方案，举个例子，我们的RPCRequest类是这样的：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名称：请求的服务名 + 版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求调用的方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameterValues;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们要远程调用的方法如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(String id, <span class="type">int</span> level)</span></span><br></pre></td></tr></table></figure><p>那我们就会创建这个<code>RpcRequest</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequest</span>();</span><br><span class="line">request.setMethod(<span class="string">&quot;getUser&quot;</span>);</span><br><span class="line">request.setParameterTypes(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;String.class, <span class="type">int</span>.class&#125;);</span><br><span class="line">request.setParameterValues(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;abc123&quot;</span>, <span class="number">5</span>&#125;);</span><br></pre></td></tr></table></figure><p>如果我们要使用Gson序列化这个类时，就可以自己注册一个 <code>JsonSerializer&lt;Class&lt;?&gt;&gt;</code> 和 <code>JsonDeserializer&lt;Class&lt;?&gt;&gt;</code>，完全实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义 JavaClass 对象序列化，解决 Gson 无法序列化 Class 信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ClassCodec</span> <span class="keyword">implements</span> <span class="title class_">JsonSerializer</span>&lt;Class&lt;?&gt;&gt;, JsonDeserializer&lt;Class&lt;?&gt;&gt; &#123;</span><br><span class="line">        <span class="comment">// 反序列化 String -&gt; Class</span></span><br><span class="line">        <span class="meta">@SneakyThrows</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) <span class="keyword">throws</span> JsonParseException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> json.getAsString();</span><br><span class="line">            <span class="keyword">return</span> Class.forName(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化 Class -&gt; String (类名)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> JsonElement <span class="title function_">serialize</span><span class="params">(Class&lt;?&gt; src, Type typeOfSrc, JsonSerializationContext context)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JsonPrimitive</span>(src.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class="keyword">new</span> <span class="title class_">ClassCodec</span>()).create();</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> gson.toJson(object);</span><br><span class="line">            <span class="keyword">return</span> json.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Json serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GsonBuilder</span>().registerTypeAdapter(Class.class, <span class="keyword">new</span> <span class="title class_">ClassCodec</span>()).create();</span><br><span class="line">            <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="keyword">return</span> gson.fromJson(json, clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonSyntaxException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Json deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kryo序列化"><a href="#Kryo序列化" class="headerlink" title="Kryo序列化"></a>Kryo序列化</h3><p>为什么Kryo线程不安全？其他序列化方法为什么线程安全？这个问题我们之后单独开一个帖子说~</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// kryo 线程不安全，所以使用 ThreadLocal 保存 kryo 对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        <span class="comment">// 注册需要序列化的类（提高性能并减少数据体积）</span></span><br><span class="line">        kryo.register(RpcRequest.class);</span><br><span class="line">        kryo.register(RpcResponse.class);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(baos);</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get(); <span class="comment">// 获取当前线程的 Kryo 实例</span></span><br><span class="line">            <span class="comment">// 将对象序列化为 byte 数组</span></span><br><span class="line">            kryo.writeObject(output, object);</span><br><span class="line">            <span class="comment">// 清理线程变量，避免内存泄漏</span></span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> output.toBytes();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Kryo serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">            <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(bais);</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="comment">// 将 byte 数组反序列化为 T 对象</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">object</span> <span class="operator">=</span> kryo.readObject(input, clazz);</span><br><span class="line">            kryoThreadLocal.remove();</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Kryo deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Protostuff序列化"><a href="#Protostuff序列化" class="headerlink" title="Protostuff序列化"></a>Protostuff序列化</h3><p>Protostuff需要用一个<code>LinkedBuffer</code>作为临时写入区域，项目中提前分配一个共享的 <code>BUFFER</code>，避免每次都重新分配，提高性能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtostuffSerialization</span> <span class="keyword">implements</span> <span class="title class_">Serialization</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提前分配好 Buffer，避免每次进行序列化都需要重新分配 buffer 内存空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;LinkedBuffer&gt; BUFFER_THREAD_LOCAL =</span><br><span class="line">        ThreadLocal.withInitial(() -&gt; LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">        <span class="type">LinkedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> BUFFER_THREAD_LOCAL.get();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取对象的运行时 schema</span></span><br><span class="line">            <span class="type">Schema</span> <span class="variable">schema</span> <span class="operator">=</span> RuntimeSchema.getSchema(object.getClass());</span><br><span class="line">            <span class="comment">// 使用 protostuff 将对象转为字节数组</span></span><br><span class="line">            <span class="keyword">return</span> ProtostuffIOUtil.toByteArray(object, schema, buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Protostuff serialize failed.&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 使用完 buffer 后清空，避免内存泄漏</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Schema&lt;T&gt; schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="comment">// 创建空对象并填充数据</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">object</span> <span class="operator">=</span> schema.newMessage();</span><br><span class="line">            ProtostuffIOUtil.mergeFrom(bytes, object, schema);</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SerializeException</span>(<span class="string">&quot;Protostuff deserialize failed.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>在分布式系统中，不同服务之间应该如何通信呢？传统的方式可以通过 HTTP 请求调用、保存服务端的服务列表等，这样做需要开发者主动感知到服务端暴露的信息，系统之间耦合严重。为了更好地将客户端和服务端解耦，以及实现服务优雅上线和下线，于是注册中心就出现了。在RPC框架中，主要是使用注册中心来实现服务注册和发现的功能。服务端节点上线后自行向注册中心注册服务列表，节点下线时需要从注册中心将节点元数据信息移除。客户端向服务端发起调用时，自己负责从注册中心获取服务端的服务列表，然后在通过负载均衡算法选择其中一个服务节点进行调用。</p><p>现在思考一个问题，服务在下线时需要从注册中心移除元数据，那么注册中心怎么才能感知到服务下线呢？我们最先想到的方法就是节点主动通知的实现方式，当节点需要下线时，向注册中心发送下线请求，让注册中心移除自己的元数据信息。但是如果节点异常退出，例如断网、进程崩溃等，那么注册中心将会一直残留异常节点的元数据，从而可能造成服务调用出现问题。</p><p>为了避免上述问题，实现服务优雅下线比较好的方式是采用主动通知 + 心跳检测的方案。除了主动通知注册中心下线外，还需要增加节点与注册中心的心跳检测功能，这个过程也叫作探活。心跳检测可以由节点或者注册中心负责，例如注册中心可以向服务节点每 60s 发送一次心跳包，如果 3 次心跳包都没有收到请求结果，可以任务该服务节点已经下线。</p><p>采用注册中心的好处是可以解耦客户端和服务端之间错综复杂的关系，并且能够实现对服务的动态管理。服务配置可以支持动态修改，然后将更新后的配置推送到客户端和服务端，无须重启任何服务。</p><p>本项目计划实现以Zookeeper为注册中心。</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>关键字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会话超时时间，客户端在此时间内未与 zk 服务器保持心跳，则认为连接断开</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SESSION_TIMEOUT</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// zk 客户端连接 zk 服务器时的连接超时时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONNECT_TIMEOUT</span> <span class="operator">=</span> <span class="number">15</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 超时重试间隔时间，用于指数回退重试策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE_SLEEP_TIME</span> <span class="operator">=</span> <span class="number">3</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 最大重试次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RETRY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// zk中所有服务注册的根路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/rpc&quot;</span>;</span><br><span class="line"><span class="comment">// Curator 提供的 zk 客户端对象，封装了 zookeeper 的连接管理、重试、监听等功能</span></span><br><span class="line"><span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"><span class="comment">// Curator 的服务发现组件，用于查询、注册、注销服务实例</span></span><br><span class="line"><span class="keyword">private</span> ServiceDiscovery&lt;ServiceInfo&gt; serviceDiscovery;</span><br></pre></td></tr></table></figure><p>构造方法，传入Zookeeper地址并进行初始化：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ZookeeperServiceRegistry</span><span class="params">(String registryAddress)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建zk客户端示例</span></span><br><span class="line">        client = CuratorFrameworkFactory</span><br><span class="line">                .newClient(registryAddress, SESSION_TIMEOUT, CONNECT_TIMEOUT,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(BASE_SLEEP_TIME, MAX_RETRY));</span><br><span class="line">        <span class="comment">// 开启客户端通信</span></span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 ServiceDiscovery 服务注册中心</span></span><br><span class="line">        serviceDiscovery = ServiceDiscoveryBuilder.builder(ServiceInfo.class)</span><br><span class="line">                .client(client)</span><br><span class="line">                .serializer(<span class="keyword">new</span> <span class="title class_">JsonInstanceSerializer</span>&lt;&gt;(ServiceInfo.class))</span><br><span class="line">                .basePath(BASE_PATH)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        serviceDiscovery.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;An error occurred while starting the zookeeper registry: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册方法，将服务注册到zk中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServiceInfo serviceInfo)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceInstance&lt;ServiceInfo&gt; serviceInstance = ServiceInstance.&lt;ServiceInfo&gt;builder()</span><br><span class="line">                .name(serviceInfo.getServiceName())</span><br><span class="line">                .address(serviceInfo.getAddress())</span><br><span class="line">                .port(serviceInfo.getPort())</span><br><span class="line">                .payload(serviceInfo)</span><br><span class="line">                .build();</span><br><span class="line">        serviceDiscovery.registerService(serviceInstance);</span><br><span class="line">        log.info(<span class="string">&quot;Successfully registered [&#123;&#125;] service.&quot;</span>, serviceInstance.getName());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;An error occurred when rpc server registering [%s] service.&quot;</span>,</span><br><span class="line">                serviceInfo.getServiceName()), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务注销与删除方法，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unregister</span><span class="params">(ServiceInfo serviceInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ServiceInstance&lt;ServiceInfo&gt; serviceInstance = ServiceInstance.&lt;ServiceInfo&gt;builder()</span><br><span class="line">            .name(serviceInfo.getServiceName())</span><br><span class="line">            .address(serviceInfo.getAddress())</span><br><span class="line">            .port(serviceInfo.getPort())</span><br><span class="line">            .payload(serviceInfo)</span><br><span class="line">            .build();</span><br><span class="line">    serviceDiscovery.unregisterService(serviceInstance);</span><br><span class="line">    log.warn(<span class="string">&quot;Successfully unregistered &#123;&#125; service.&quot;</span>, serviceInstance.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    serviceDiscovery.close();</span><br><span class="line">    client.close();</span><br><span class="line">    log.info(<span class="string">&quot;Destroy zookeeper registry completed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>关键字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SESSION_TIMEOUT</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONNECT_TIMEOUT</span> <span class="operator">=</span> <span class="number">15</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BASE_SLEEP_TIME</span> <span class="operator">=</span> <span class="number">3</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_RETRY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BASE_PATH</span> <span class="operator">=</span> <span class="string">&quot;/rpc&quot;</span>;</span><br><span class="line"><span class="comment">// 负载均衡接口</span></span><br><span class="line"><span class="keyword">private</span> LoadBalance loadBalance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> org.apache.curator.x.discovery.ServiceDiscovery&lt;ServiceInfo&gt; serviceDiscovery;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ServiceCache: 将在zk中的服务数据缓存至本地，并监听服务变化，实时更新缓存</span></span><br><span class="line"><span class="comment"> * 服务本地缓存，将服务缓存到本地并增加 watch 事件，当远程服务发生改变时自动更新服务缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ServiceCache&lt;ServiceInfo&gt;&gt; serviceCacheMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 将服务列表缓存到本地内存，当服务发生变化时，由 serviceCache 进行服务列表更新操作，当 zk 挂掉时，将保存当前服务列表以便继续提供服务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;ServiceInfo&gt;&gt; serviceMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>构造方法，初始化zk客户端和服务发现对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ZookeeperServiceDiscovery</span><span class="params">(String registryAddress, LoadBalance loadBalance)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loadBalance = loadBalance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建zk客户端示例</span></span><br><span class="line">        client = CuratorFrameworkFactory</span><br><span class="line">                .newClient(registryAddress, SESSION_TIMEOUT, CONNECT_TIMEOUT,</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(BASE_SLEEP_TIME, MAX_RETRY));</span><br><span class="line">        <span class="comment">// 开启客户端通信</span></span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 ServiceDiscovery 服务注册中心</span></span><br><span class="line">        serviceDiscovery = ServiceDiscoveryBuilder.builder(ServiceInfo.class)</span><br><span class="line">                .client(client)</span><br><span class="line">                .serializer(<span class="keyword">new</span> <span class="title class_">JsonInstanceSerializer</span>&lt;&gt;(ServiceInfo.class))</span><br><span class="line">                .basePath(BASE_PATH)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 开启 服务发现</span></span><br><span class="line">        serviceDiscovery.start();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;An error occurred while starting the zookeeper discovery: &quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取服务列表：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ServiceInfo&gt; <span class="title function_">getServices</span><span class="params">(String serviceName)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!serviceMap.containsKey(serviceName)) &#123;</span><br><span class="line">        <span class="comment">// 首次调用时，为该服务名构建一个本地缓存，并开始监听 zk 目录下该服务名节点的变化</span></span><br><span class="line">        ServiceCache&lt;ServiceInfo&gt; serviceCache = serviceDiscovery.serviceCacheBuilder()</span><br><span class="line">                .name(serviceName)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 添加服务监听，当服务发生变化时主动更新本地缓存并通知</span></span><br><span class="line">        serviceCache.addListener(<span class="keyword">new</span> <span class="title class_">ServiceCacheListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cacheChanged</span><span class="params">()</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;The service [&#123;&#125;] cache has changed. The current number of service samples is &#123;&#125;.&quot;</span></span><br><span class="line">                        , serviceName, serviceCache.getInstances().size());</span><br><span class="line">                <span class="comment">// 更新本地缓存的服务列表</span></span><br><span class="line">                serviceMap.put(serviceName, serviceCache.getInstances().stream()</span><br><span class="line">                        .map(ServiceInstance::getPayload)</span><br><span class="line">                        .collect(Collectors.toList()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> &#123;</span><br><span class="line">                <span class="comment">// 当连接状态发生改变时，只打印提示信息，保留本地缓存的服务列表</span></span><br><span class="line">                log.info(<span class="string">&quot;The client &#123;&#125; connection status has changed. The current status is: &#123;&#125;.&quot;</span></span><br><span class="line">                        , client, newState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 开启服务缓存监听</span></span><br><span class="line">        serviceCache.start();</span><br><span class="line">        <span class="comment">// 将服务缓存对象存入本地</span></span><br><span class="line">        serviceCacheMap.put(serviceName, serviceCache);</span><br><span class="line">        <span class="comment">// 将服务列表缓存到本地</span></span><br><span class="line">        serviceMap.put(serviceName, serviceCacheMap.get(serviceName).getInstances()</span><br><span class="line">                .stream()</span><br><span class="line">                .map(ServiceInstance::getPayload)</span><br><span class="line">                .collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> serviceMap.get(serviceName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择服务实例，根据服务名 + 负载均衡策略选择一个可用的 <code>ServiceInfo</code> 服务实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">discover</span><span class="params">(RpcRequest request)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loadBalance.select(getServices(request.getServiceName()), request);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;Remote service discovery did not find service %s.&quot;</span>,</span><br><span class="line">                request.getServiceName()), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清理所有zk相关连接资源，确保优雅下线：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (ServiceCache&lt;ServiceInfo&gt; serviceCache : serviceCacheMap.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (serviceCache != <span class="literal">null</span>) &#123;</span><br><span class="line">            serviceCache.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (serviceDiscovery != <span class="literal">null</span>) &#123;</span><br><span class="line">        serviceDiscovery.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡算法"><a href="#负载均衡算法" class="headerlink" title="负载均衡算法"></a>负载均衡算法</h2><p>在分布式系统中，服务提供者和服务消费者都会有多台节点，如何保证服务提供者所有节点的负载均衡呢？</p><p>客户端在发起调用之前，需要感知有多少服务端节点可用，然后从中选取一个进行调用。客户端需要拿到服务端节点的状态信息，并根据不同的策略实现负载均衡算法</p><ul><li>Round-Robin轮询：依次轮询服务端节点</li><li>Weighted Round-Robin 权重轮询：对不同负载水平的服务端节点增加权重系数，这样可以通过权重系数降低性能较差或者配置较低的节点流量</li><li>Least Connections 最少连接数：客户端根据服务端节点当前的连接数进行负载均衡，客户端会选择连接数最少的一台服务器进行调用。Least Connections策略只是服务端其中一种维度，我们可以演化出最少请求数、CPU利用率最低等其他维度的负载均衡方案</li><li>Consistent Hash 一致性 Hash：目前主流推荐的负载均衡策略，Consistent Hash 是一种特殊的 Hash 算法，在服务端节点扩容或者下线时，尽可能保证客户端请求还是固定分配到同一台服务器节点。Consistent Hash 算法是采用哈希环来实现的，通过 Hash 函数将对象和服务器节点放置在哈希环上，一般来说服务器可以选择 IP + Port 进行 Hash，然后为对象选择对应的服务器节点，在哈希环中顺时针查找距离对象 Hash 值最近的服务器节点</li></ul><p>本项目实现Random、Round-Robin、Consistent Hash三种负载均衡算法</p><p>首先编写一个抽象类，定义实现负载均衡的方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLoadBalance</span> <span class="keyword">implements</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">select</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (invokers == <span class="literal">null</span> || invokers.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果服务列表中只有一个服务，无需进行负载均衡，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行负载均衡，由具体的子类实现</span></span><br><span class="line">        <span class="keyword">return</span> doSelect(invokers, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现具体负载均衡策略的选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers 服务列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  rpc 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回服务信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机负载均衡"><a href="#随机负载均衡" class="headerlink" title="随机负载均衡"></a>随机负载均衡</h3><p>随机选择一个节点即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(random.nextInt(invokers.size()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="轮询负载均衡"><a href="#轮询负载均衡" class="headerlink" title="轮询负载均衡"></a>轮询负载均衡</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers.get(getAndIncrement() % invokers.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回当前值并加一，通过 CAS 原子更新，当前值到达 &#123;<span class="doctag">@link</span> Integer#MAX_VALUE&#125; 时，重新设值为 0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回当前的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> prev, next;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prev = atomicInteger.get();</span><br><span class="line">            next = prev == Integer.MAX_VALUE ? <span class="number">0</span> : prev + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!atomicInteger.compareAndSet(prev, next));<span class="comment">//把prev更新成next</span></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一致性哈希负载均衡"><a href="#一致性哈希负载均衡" class="headerlink" title="一致性哈希负载均衡"></a>一致性哈希负载均衡</h3><p>在分布式系统中，负载均衡是将请求分发到多个服务节点上的关键手段。如果使用简单的哈希方式（比如：<code>hash(key) % 节点数量</code>），当服务节点发生变化（如新增或下线一个服务节点），所有请求的分发都会大范围变化，这会导致：</p><ul><li>原本某个 key 缓存在 A 节点，新请求可能被分配到 B，导致缓存失效</li><li>用户粘性丧失，会话丢失</li><li>系统效率大幅下降</li></ul><p>所以我们希望：<strong>节点数量变化时，尽量少地影响原有请求的分配规律</strong></p><p>一致性哈希算法就是为此设计的，它有两个目标：</p><ol><li>相同的请求key总是路由到同一个节点（请求一致性）</li><li>节点变动时，只有<strong>极少数 key</strong>被重新分配（低扰动性）</li></ol><h4 id="一致性哈希的基本原理"><a href="#一致性哈希的基本原理" class="headerlink" title="一致性哈希的基本原理"></a>一致性哈希的基本原理</h4><ol><li>将哈希空间想象成一个“环”</li></ol><ul><li>假设 hash 值范围是 0 ~ 2³²-1，我们可以把它画成一个圆环</li><li>所有节点（服务实例）都通过哈希函数映射到这个环上某个位置</li></ul><ol start="2"><li>将请求（根据其 key）也映射到环上</li></ol><ul><li>请求经过哈希函数也会得到一个 hash 值，在环上的某个点</li></ul><ol start="3"><li>如何选择目标节点？</li></ol><ul><li>从请求所在的 hash 点开始，顺时针查找，直到找到第一个节点</li><li>这个节点就是这个请求应该被分配到的服务节点</li></ul><p>举个例子：</p><p>假设环上有 3 个节点：</p><ul><li>A → 哈希值 1000</li><li>B → 哈希值 4000</li><li>C → 哈希值 7000</li></ul><p>如果请求 key 哈希值为 4200，它将落在 C（7000）上</p><p>如果 key 哈希值为 8000，环上没有节点比它大，就从头开始找，第一个是 A（1000），所以分到 A</p><h4 id="虚拟节点机制"><a href="#虚拟节点机制" class="headerlink" title="虚拟节点机制"></a>虚拟节点机制</h4><p>真实服务节点数量较少（如3~5个），哈希分布不均匀，可能会出现某个节点承载大量请求的情况，导致负载不均</p><p>虚拟节点的做法：</p><ul><li>每个真实节点被映射成多个虚拟节点（通常是160个）</li><li>每个虚拟节点 hash 后也放在环上</li><li>请求还是通过 hash 值查找最近的虚拟节点，然后找出它对应的真实节点</li></ul><p>效果</p><ul><li>请求被均匀地分布到多个虚拟节点上</li><li>从而间接实现真实节点的负载均衡</li></ul><h4 id="处理节点变更问题"><a href="#处理节点变更问题" class="headerlink" title="处理节点变更问题"></a>处理节点变更问题</h4><p>新增节点：</p><ul><li>会在环上增加一些新的虚拟节点</li><li>新虚拟节点会“截断”一小段原本属于其他节点的请求范围</li><li>只有这一小部分请求分配发生变化，其他绝大部分 key 对应的服务节点不变</li></ul><p>删除节点：</p><ul><li>其虚拟节点从环上移除</li><li>这些虚拟节点对应的请求会顺时针路由到下一个节点</li><li>同样只影响少部分请求</li></ul><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>编写静态内部类，实现一致性哈希的核心部分，维护一个<strong>虚拟节点环</strong>来实现平衡性和低扰动性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashSelector</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 TreeMap 存储虚拟节点（virtualInvokers 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构，底层使用红黑树，比HashMap查询速度要快）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, ServiceInfo&gt; virtualInvokers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invokers 的原始哈希码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> identityHashCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个 ConsistentHashSelector 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers         存储虚拟节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replicaNumber    虚拟节点数，默认为 160</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> identityHashCode invokers 的原始哈希码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsistentHashSelector</span><span class="params">(List&lt;ServiceInfo&gt; invokers, <span class="type">int</span> replicaNumber, <span class="type">int</span> identityHashCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.virtualInvokers = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.identityHashCode = identityHashCode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (ServiceInfo invoker : invokers) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> invoker.getAddress();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="comment">// 对 address + i 进行 md5 运算，得到一个长度为16的字节数组</span></span><br><span class="line">                <span class="type">byte</span>[] digest = md5(address + i);</span><br><span class="line">                <span class="comment">// 对 digest 部分字节进行4次 hash 运算，得到四个不同的 long 型正整数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                    <span class="comment">// h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算</span></span><br><span class="line">                    <span class="comment">// h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算</span></span><br><span class="line">                    <span class="comment">// h = 2, h = 3 时过程同上</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> hash(digest, h);</span><br><span class="line">                    <span class="comment">// 将 hash 到 invoker 的映射关系存储到 virtualInvokers 中</span></span><br><span class="line">                    virtualInvokers.put(m, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行 md5 运算，返回摘要字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 编码字符串 key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 编码后的摘要内容，长度为 16 的字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] md5(String key) &#123;</span><br><span class="line">        MessageDigest md;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] bytes = key.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">            md.update(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> md.digest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据摘要生成 hash 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> digest md5摘要内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number 当前索引数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> hash 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">hash</span><span class="params">(<span class="type">byte</span>[] digest, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (((<span class="type">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">                &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ServiceInfo <span class="title function_">select</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="comment">// 对参数 key 进行 md5 运算</span></span><br><span class="line">        <span class="type">byte</span>[] digest = md5(key);</span><br><span class="line">        <span class="comment">// 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，</span></span><br><span class="line">        <span class="comment">// 寻找合适的 Invoker</span></span><br><span class="line">        <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个大于等于 hash 值的服务信息，若没有则返回第一个</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash 哈希值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 服务信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ServiceInfo <span class="title function_">selectForKey</span><span class="params">(<span class="type">long</span> hash)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到 TreeMap 中查找第一个节点值大于或等于当前 hash 的 Invoker</span></span><br><span class="line">        Map.Entry&lt;Long, ServiceInfo&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class="line">        <span class="comment">// 如果 hash 大于 Invoker 在圆环上最大的位置，此时 entry = null，需要将 TreeMap 的头节点赋值给 entry</span></span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">            entry = virtualInvokers.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哈希方法步骤：</p><ol><li>用MD5算法生成摘要：对IP地址+端口号执行MD5，得到长度16字节的摘要</li><li>从摘要中提取出多个32-bit的无符号整数（即虚拟节点哈希值）<ul><li>每次从 16 字节的摘要中，取出连续的 4 字节</li><li>对这四个字节通过位运算拼接成一个32位的整数，代表一个hash值</li><li>执行4次，得到4个hash值</li></ul></li></ol><p>具体轮询方法实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ServiceInfo <span class="title function_">doSelect</span><span class="params">(List&lt;ServiceInfo&gt; invokers, RpcRequest request)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到请求的方法名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">    <span class="comment">// 构建对应的 key 值，key = 全限定类名 + &quot;.&quot; + 方法名，比如 com.xxx.DemoService.sayHello</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> request.getServiceName() + <span class="string">&quot;.&quot;</span> + method;</span><br><span class="line">    <span class="comment">// 获取 invokers 原始的 hashCode</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">identityHashCode</span> <span class="operator">=</span> System.identityHashCode(invokers);</span><br><span class="line">    <span class="comment">// 从 map 从获取对应的 selector</span></span><br><span class="line">    <span class="type">ConsistentHashSelector</span> <span class="variable">selector</span> <span class="operator">=</span> selectors.get(key);</span><br><span class="line">    <span class="comment">// 如果为 null，表示之前没有缓存过，如果 hashcode 不一致，表示缓存的服务列表发生变化</span></span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="literal">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">        <span class="comment">// 创建新的 selector 并缓存</span></span><br><span class="line">        selectors.put(key, <span class="keyword">new</span> <span class="title class_">ConsistentHashSelector</span>(invokers, <span class="number">160</span>, identityHashCode));</span><br><span class="line">        selector = selectors.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 ConsistentHashSelector 的 select 方法选择 Invoker</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">selectKey</span> <span class="operator">=</span> key;</span><br><span class="line">    <span class="comment">// 将 key 与 方法参数进行 hash 运算，因此 ConsistentHashLoadBalance 的负载均衡逻辑只受参数值影响，</span></span><br><span class="line">    <span class="comment">// 具有相同参数值的请求将会被分配给同一个服务提供者。ConsistentHashLoadBalance 不关系权重</span></span><br><span class="line">    <span class="keyword">if</span> (request.getParameterValues() != <span class="literal">null</span> &amp;&amp; request.getParameterValues().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        selectKey += Arrays.stream(request.getParameterValues());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selector.select(selectKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据方法名和参数生成哈希键，从缓存中获取一致性哈希选择器，根据选择器将相同参数请求始终路由到同一个服务节点，实现基于参数的一致性哈希负载均衡</p><h2 id="网络通信模块"><a href="#网络通信模块" class="headerlink" title="网络通信模块"></a>网络通信模块</h2><p>本项目实现了基于Netty、Http、Socket三种网络通信方式，关于这三种通信方式的区别，我会在另一个文章中说明</p><h3 id="Netty通信"><a href="#Netty通信" class="headerlink" title="Netty通信"></a>Netty通信</h3><p>首先编写通信处理入口，使用Netty启动TCP服务器监听指定端口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Integer port)</span> &#123;</span><br><span class="line">        <span class="comment">// boss 处理 accept 事件</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">// worker 处理 read/write 事件</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line"></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 是否开启 TCP 底层心跳机制</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    <span class="comment">// 表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG))</span><br><span class="line">                    <span class="comment">// 当客户端第一次请求时才会进行初始化</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 30s内没有收到客户端的请求就关闭连接，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">RpcFrameDecoder</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SharableRpcMessageCodec</span>());</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">NettyRpcRequestHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">// 绑定端口，同步等待绑定成功</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(inetAddress, port).sync();</span><br><span class="line">            log.debug(<span class="string">&quot;Rpc server add &#123;&#125; started on the port &#123;&#125;.&quot;</span>, inetAddress, port);</span><br><span class="line">            <span class="comment">// 等待服务端监听端口关闭</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException | InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;An error occurred while starting the rpc service.&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handler中我加入了NettyRpcRequestHandler，作为具体的业务实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyRpcRequestHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestHandler rpcRequestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NettyRpcRequestHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        threadPool.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">RpcMessage</span> <span class="variable">responseRpcMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcMessage</span>();</span><br><span class="line">                <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> msg.getHeader();</span><br><span class="line">                <span class="type">MessageType</span> <span class="variable">type</span> <span class="operator">=</span> MessageType.parseByType(header.getMessageType());</span><br><span class="line">                log.debug(<span class="string">&quot;The message received by the server is: &#123;&#125;&quot;</span>, msg.getBody());</span><br><span class="line">                <span class="comment">// 如果是心跳检测请求信息</span></span><br><span class="line">                <span class="keyword">if</span> (type == MessageType.HEARTBEAT_REQUEST) &#123;</span><br><span class="line">                    header.setMessageType(MessageType.HEARTBEAT_RESPONSE.getType());</span><br><span class="line">                    header.setMessageStatus(MessageStatus.SUCCESS.getCode());</span><br><span class="line">                    <span class="comment">// 设置响应头部信息</span></span><br><span class="line">                    responseRpcMessage.setHeader(header);</span><br><span class="line">                    responseRpcMessage.setBody(ProtocolConstants.PONG);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理 Rpc 请求信息</span></span><br><span class="line">                    <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> (RpcRequest) msg.getBody();</span><br><span class="line">                    <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">                    <span class="comment">// 设置头部消息类型</span></span><br><span class="line">                    header.setMessageType(MessageType.RESPONSE.getType());</span><br><span class="line">                    <span class="comment">// 反射调用</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 获取本地反射调用结果</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> rpcRequestHandler.handleRpcRequest(request);</span><br><span class="line">                        response.setReturnValue(result);</span><br><span class="line">                        header.setMessageStatus(MessageStatus.SUCCESS.getCode());</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        log.error(<span class="string">&quot;The service [&#123;&#125;], the method [&#123;&#125;] invoke failed!&quot;</span>, request.getServiceName(), request.getMethod());</span><br><span class="line">                        <span class="comment">// 若不设置，堆栈信息过多，导致报错</span></span><br><span class="line">                        response.setExceptionValue(<span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Error in remote procedure call, &quot;</span> + e.getMessage()));</span><br><span class="line">                        header.setMessageStatus(MessageStatus.FAIL.getCode());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置响应头部信息</span></span><br><span class="line">                    responseRpcMessage.setHeader(header);</span><br><span class="line">                    responseRpcMessage.setBody(response);</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;responseRpcMessage: &#123;&#125;.&quot;</span>, responseRpcMessage);</span><br><span class="line">                <span class="comment">// 将结果写入，传递到下一个处理器</span></span><br><span class="line">                ctx.writeAndFlush(responseRpcMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 确保 ByteBuf 被释放，防止发生内存泄露</span></span><br><span class="line">                ReferenceCountUtil.release(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义事件，当触发读空闲时，自动关闭客户端channel连接，netty自动调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="type">IdleState</span> <span class="variable">state</span> <span class="operator">=</span> ((IdleStateEvent) evt).state();</span><br><span class="line">            <span class="keyword">if</span> (state == IdleState.READER_IDLE) &#123;</span><br><span class="line">                log.warn(<span class="string">&quot;idle check happen, so close the connection.&quot;</span>);</span><br><span class="line">                ctx.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;</span><br><span class="line">        log.error(<span class="string">&quot;server catch exception&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Http通信"><a href="#Http通信" class="headerlink" title="Http通信"></a>Http通信</h3><p>编写http通信实现类，通过内置Tomcat实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRpcServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Integer port)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Tomcat</span> <span class="variable">tomcat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tomcat</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">Server</span> <span class="variable">server</span> <span class="operator">=</span> tomcat.getServer();</span><br><span class="line">            <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> server.findService(<span class="string">&quot;Tomcat&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Connector</span> <span class="variable">connector</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Connector</span>();</span><br><span class="line">            connector.setPort(port);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">hostname</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line"></span><br><span class="line">            <span class="type">StandardEngine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEngine</span>();</span><br><span class="line">            engine.setDefaultHost(hostname);</span><br><span class="line"></span><br><span class="line">            <span class="type">StandardHost</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardHost</span>();</span><br><span class="line">            host.setName(hostname);</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardContext</span>();</span><br><span class="line">            context.setPath(contextPath);</span><br><span class="line">            context.addLifecycleListener(<span class="keyword">new</span> <span class="title class_">Tomcat</span>.FixContextListener());</span><br><span class="line"></span><br><span class="line">            host.addChild(context);</span><br><span class="line">            engine.addChild(host);</span><br><span class="line"></span><br><span class="line">            service.setContainer(engine);</span><br><span class="line">            service.addConnector(connector);</span><br><span class="line"></span><br><span class="line">            tomcat.addServlet(contextPath, <span class="string">&quot;dispatcher&quot;</span>, <span class="keyword">new</span> <span class="title class_">DispatcherServlet</span>());</span><br><span class="line">            context.addServletMappingDecoded(<span class="string">&quot;/*&quot;</span>, <span class="string">&quot;dispatcher&quot;</span>);</span><br><span class="line"></span><br><span class="line">            tomcat.start();</span><br><span class="line">            tomcat.getServer().await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException | UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Tomcat server failed to start.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat接收到http请求后，会交给DispatcherServlet类进行统一处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前处理器数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cpuNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(cpuNum * <span class="number">2</span>, cpuNum * <span class="number">2</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">HttpRpcRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> SingletonFactory.getInstance(HttpRpcRequestHandler.class);</span><br><span class="line">        threadPool.submit(() -&gt; handler.handle(req, resp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后由DispatcherServlet将请求发给HttpRpcRequestHandler进行实际业务处理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRpcRequestHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestHandler rpcRequestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HttpRpcRequestHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(req.getInputStream());</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(resp.getOutputStream());</span><br><span class="line">            <span class="comment">// 读取客户端请求</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> (RpcRequest) ois.readObject();</span><br><span class="line">            log.debug(<span class="string">&quot;The server received message is &#123;&#125;.&quot;</span>, request);</span><br><span class="line">            <span class="comment">// 创建一个 RpcResponse 对象来响应客户端</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求的服务对应的实例对象反射调用方法的结果</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> rpcRequestHandler.handleRpcRequest(request);</span><br><span class="line">                response.setReturnValue(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;The service [&#123;&#125;], the method [&#123;&#125;] invoke failed!&quot;</span>, request.getServiceName(), request.getMethod());</span><br><span class="line">                <span class="comment">// 若不设置，堆栈信息过多，导致报错</span></span><br><span class="line">                response.setExceptionValue(<span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Error in remote procedure call, &quot;</span> + e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;The response is &#123;&#125;.&quot;</span>, response);</span><br><span class="line">            oos.writeObject(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The http server failed to handle client rpc request.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Socket通信"><a href="#Socket通信" class="headerlink" title="Socket通信"></a>Socket通信</h3><p>socket通信是最原始的通信方式，首先编写server类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketRpcServer</span> <span class="keyword">implements</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前处理器数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cpuNum</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程大小：这一点要看我们执行的任务是cpu密集型，还是io密集型</span></span><br><span class="line">    <span class="comment">// 如果有关于计算机计算，比较消耗资源的是cpu密集型，线程大小应该设置为：cpu 核数 + 1</span></span><br><span class="line">    <span class="comment">// 如果有关网络传输，连接数据库等，是io密集型，线程大小应该设置为：cpu * 2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(cpuNum * <span class="number">2</span>, cpuNum * <span class="number">2</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Integer port)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">hostAddress</span> <span class="operator">=</span> InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(hostAddress, port));</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="comment">// 循环接受客户端 Socket 连接（accept为阻塞时等待连接）</span></span><br><span class="line">            <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;The client connected [&#123;&#125;].&quot;</span>, socket.getInetAddress());</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> <span class="title class_">SocketRpcRequestHandler</span>(socket));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 服务端连断开，关闭线程池</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;The socket server failed to start on port %d.&quot;</span>, port), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是具体的请求处理逻辑，实现<code>Runnable</code>接口，配合线程池执行每一个客户端连接的请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SocketRpcRequestHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcRequestHandler rpcRequestHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketRpcRequestHandler</span><span class="params">(Socket socket)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socket = socket;</span><br><span class="line">        <span class="built_in">this</span>.rpcRequestHandler = SingletonFactory.getInstance(RpcRequestHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;The server handle client message by thread &#123;&#125;.&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(socket.getInputStream())) &#123;</span><br><span class="line">            <span class="comment">// 注意：SocketServer 接受和发送的数据为：RpcRequest, RpcResponse</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(socket.getOutputStream());</span><br><span class="line">            <span class="comment">// 直接读取客户端发送过来的 RpcRequest，此时不需要进行编解码，无需消息协议</span></span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> (RpcRequest) ois.readObject();</span><br><span class="line">            log.debug(<span class="string">&quot;The server received message is &#123;&#125;.&quot;</span>, request);</span><br><span class="line">            <span class="comment">// 创建一个 RpcResponse 对象用来响应给客户端</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取请求的服务对应的实例对象反射调用方法的结果</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> rpcRequestHandler.handleRpcRequest(request);</span><br><span class="line">                response.setReturnValue(result);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;The service [&#123;&#125;], the method [&#123;&#125;] invoke failed!&quot;</span>, request.getServiceName(), request.getMethod());</span><br><span class="line">                <span class="comment">// 若不设置，堆栈信息过多，导致报错</span></span><br><span class="line">                response.setExceptionValue(<span class="keyword">new</span> <span class="title class_">RpcException</span>(<span class="string">&quot;Error in remote procedure call, &quot;</span> + e.getMessage()));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;The response is &#123;&#125;.&quot;</span>, response);</span><br><span class="line">            oos.writeObject(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The socket server failed to handle client rpc request.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>RPC框架怎么做到像调用本地接口一样调用远端服务呢？这必须依赖动态代理来实现</p><p>需要创建一个代理对象，在代理对象中完成数据报文编码，然后发起调用发送数据给服务提供方，以此屏蔽RPC框架的调用细节。因为代理类是在运行时生成的，所以代理类的生成速度、生成的字节码大小都会影响RPC框架整体的性能和资源消耗</p><p>动态代理比较主流的实现方案有以下几种：JDK、Cglib、Javassist、ASM、ByteBuddy</p><ul><li>JDK：在运行时可以动态创建代理类，但是 JDK 动态代理的功能比较局限，代理对象必须实现一个接口，否则抛出异常。因为代理类会继承Proxy类，然而 Java 是不支持多重继承的，只能通过接口实现多态。JDK 动态代理所生成的代理类是接口的实现类，不能代理接口中不存在的方法。JDK 动态代理是通过反射调用的形式代理类中的方法，比直接调用肯定是性能要慢的</li><li>Cglib：Cglib是基于ASM字节码生成框架实现的，通过字节码技术生成的代理类，所以代理类的类型是不受限制的。而且Cglib生成的代理类是继承于被代理类，所以可以提供更加灵活的功能。在代理方法方面，Cglib 是有优势的，它采用了 FastClass 机制，为代理类和被代理类各自创建一个 Class，这个 Class会为代理类和被代理类的方法分配 index 索引，FastClass 就可以通过 index 直接定位要调用的方法，并直接调用，这是一种空间换时间的优化思路</li><li>Javassist和ASM。二者都是Java字节码操作框架，使用起来难度较大，需要开发者对 Class 文件结构以及 JVM 都有所了解，但是它们都比反射的性能要高</li><li>Byte Buddy 也是一个字节码生成和操作的类库，Byte Buddy 功能强大，相比于 Javassist 和 ASM，Byte Buddy 提供了更加便捷的 API，用于创建和修改 Java 类，无须理解字节码的格式，而且 Byte Buddy 更加轻量，性能更好</li></ul><p>本项目实现了JDK和CGLIB动态代理</p><p>具体的代理逻辑：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientStubProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务发现中心实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery discovery;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RpcClient 传输实现类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClient rpcClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端配置属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcClientProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientStubProxyFactory</span><span class="params">(ServiceDiscovery discovery, RpcClient rpcClient, RpcClientProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.discovery = discovery;</span><br><span class="line">        <span class="built_in">this</span>.rpcClient = rpcClient;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理对象缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; proxyMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz   服务接口类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version 版本号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;     代理对象的参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应版本的代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz, String version)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) proxyMap.computeIfAbsent(ServiceUtil.serviceKey(clazz.getName(), version), serviceName -&gt; &#123;</span><br><span class="line">            <span class="comment">// 如果目标类是一个接口或者 是 java.lang.reflect.Proxy 的子类 则默认使用 JDK 动态代理</span></span><br><span class="line">            <span class="keyword">if</span> (clazz.isInterface() || Proxy.isProxyClass(clazz)) &#123;</span><br><span class="line">                <span class="keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;clazz&#125;, <span class="comment">// 注意，这里的接口是 clazz 本身（要代理的实现类所实现的接口）</span></span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">ClientStubInvocationHandler</span>(discovery, rpcClient, properties, serviceName));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 使用 CGLIB 动态代理</span></span><br><span class="line">                <span class="comment">// 创建动态代理增加类</span></span><br><span class="line">                <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">                <span class="comment">// 设置类加载器</span></span><br><span class="line">                enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">                <span class="comment">// 设置被代理类</span></span><br><span class="line">                enhancer.setSuperclass(clazz);</span><br><span class="line">                <span class="comment">// 设置方法拦截器</span></span><br><span class="line">                enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">ClientStubMethodInterceptor</span>(discovery, rpcClient, properties, serviceName));</span><br><span class="line">                <span class="comment">// 创建代理类</span></span><br><span class="line">                <span class="keyword">return</span> enhancer.create();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Netty心跳机制与Channel复用"><a href="#Netty心跳机制与Channel复用" class="headerlink" title="Netty心跳机制与Channel复用"></a>Netty心跳机制与Channel复用</h2><p>为了解决每次请求客户端都要重新与服务端建立netty连接，非常耗时，增加心跳检查机制，保持长连接，复用channel连接；</p><ul><li>长连接：避免了每次调用新建TCP连接，提高了调用的响应速度</li><li>Channel 连接复用：避免重复连接服务端</li><li>多路复用：单个TCP连接可交替传输多个请求和响应的消息，降低了连接的等待闲置时间，从而减少了同样并发数下的网络连接数，提高了系统吞吐量</li></ul><h3 id="多路复用实现"><a href="#多路复用实现" class="headerlink" title="多路复用实现"></a>多路复用实现</h3><p>使用一个<code>ConcurrentHashMap</code>存放每个请求的等待结果区，当响应回来时，用sequenceId找到对应的Promise完成结果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Promise&lt;RpcMessage&gt;&gt; UNPROCESSED_RPC_RESPONSES = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>拿到已经返回结果的Promise：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">MessageType</span> <span class="variable">type</span> <span class="operator">=</span> MessageType.parseByType(msg.getHeader().getMessageType());</span><br><span class="line">        <span class="comment">// 如果是 RpcResponse 请求</span></span><br><span class="line">        <span class="keyword">if</span> (type == MessageType.RESPONSE) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> msg.getHeader().getSequenceId();</span><br><span class="line">            <span class="comment">// 拿到还未执行完成的 promise 对象</span></span><br><span class="line">            Promise&lt;RpcMessage&gt; promise = UNPROCESSED_RPC_RESPONSES.remove(sequenceId);</span><br><span class="line">            <span class="keyword">if</span> (promise != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">Exception</span> <span class="variable">exception</span> <span class="operator">=</span> ((RpcResponse) msg.getBody()).getExceptionValue();</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="literal">null</span>) &#123;</span><br><span class="line">                    promise.setSuccess(msg);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.setFailure(exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == MessageType.HEARTBEAT_RESPONSE) &#123; <span class="comment">// 如果是心跳检查请求</span></span><br><span class="line">            log.debug(<span class="string">&quot;Heartbeat info &#123;&#125;.&quot;</span>, msg.getBody());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放内存，防止内存泄漏</span></span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发出请求后，存放还未返回结果的Promise：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RpcMessage <span class="title function_">sendRpcRequest</span><span class="params">(RequestMetadata requestMetadata)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建接收返回结果的 promise</span></span><br><span class="line">    Promise&lt;RpcMessage&gt; promise;</span><br><span class="line">    <span class="comment">// 获取 Channel 对象</span></span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> getChannel(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(requestMetadata.getServerAddr(), requestMetadata.getPort()));</span><br><span class="line">    <span class="keyword">if</span> (channel.isActive()) &#123;</span><br><span class="line">        <span class="comment">// 创建 promise 来接受结果         指定执行完成通知的线程</span></span><br><span class="line">        promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(channel.eventLoop());</span><br><span class="line">        <span class="comment">// 获取请求的序列号 ID</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> requestMetadata.getRpcMessage().getHeader().getSequenceId();</span><br><span class="line">        <span class="comment">// 存入还未处理的请求</span></span><br><span class="line">        RpcResponseHandler.UNPROCESSED_RPC_RESPONSES.put(sequenceId, promise);</span><br><span class="line">        <span class="comment">// 发送数据并监听发送状态</span></span><br><span class="line">        channel.writeAndFlush(requestMetadata.getRpcMessage()).addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;The client send the message successfully, msg: [&#123;&#125;].&quot;</span>, requestMetadata);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                future.channel().close();</span><br><span class="line">                promise.setFailure(future.cause());</span><br><span class="line">                log.error(<span class="string">&quot;The client send the message failed.&quot;</span>, future.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">timeout</span> <span class="operator">=</span> requestMetadata.getTimeout();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待结果返回（让出cpu资源，同步阻塞调用线程main，其他线程去执行获取操作（eventLoop））</span></span><br><span class="line">        <span class="comment">// 如果没有指定超时时间，则 await 直到 promise 完成</span></span><br><span class="line">        <span class="keyword">if</span> (timeout == <span class="literal">null</span> || timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            promise.await();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在指定超时时间内等待结果返回</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> promise.await(requestMetadata.getTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                promise.setFailure(<span class="keyword">new</span> <span class="title class_">TimeoutException</span>(String.format(<span class="string">&quot;The Remote procedure call exceeded the &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;specified timeout of %dms.&quot;</span>, timeout)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (promise.isSuccess()) &#123;</span><br><span class="line">            <span class="comment">// 返回响应结果</span></span><br><span class="line">            <span class="keyword">return</span> promise.getNow();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(promise.cause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;The channel is inactivate.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="长连接实现"><a href="#长连接实现" class="headerlink" title="长连接实现"></a>长连接实现</h3><p>在client的响应消息处理器中添加自定义时间处理器，当检测到写空闲发生时自动发送一个心跳包：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户自定义事件处理器，处理写空闲，当检测到写空闲发生自动发送一个心跳检测数据包</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ctx ctx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evt evt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception ex</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((IdleStateEvent) evt).state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;Write idle happen [&#123;&#125;].&quot;</span>, ctx.channel().remoteAddress());</span><br><span class="line">            <span class="comment">// 构造 心跳检查 RpcMessage</span></span><br><span class="line">            <span class="type">RpcMessage</span> <span class="variable">rpcMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcMessage</span>();</span><br><span class="line">            <span class="type">MessageHeader</span> <span class="variable">header</span> <span class="operator">=</span> MessageHeader.build(SerializationType.KRYO.name());</span><br><span class="line">            header.setMessageType(MessageType.HEARTBEAT_REQUEST.getType());</span><br><span class="line">            rpcMessage.setHeader(header);</span><br><span class="line">            rpcMessage.setBody(ProtocolConstants.PING);</span><br><span class="line">            <span class="comment">// 发送心跳检测请求</span></span><br><span class="line">            ctx.writeAndFlush(rpcMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Channel连接复用"><a href="#Channel连接复用" class="headerlink" title="Channel连接复用"></a>Channel连接复用</h3><p>使用ConcurrentHashMap存放每个<code>IP+端口号</code>使用过的Channel，如果当前IP的端口再次发起rpc请求后，检测到之前的Channel还没关闭，就可以再次使用，避免重复连接服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储 Channel，key 为 ip:port，val 为 channel 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Channel&gt; channels = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">get</span><span class="params">(String hostname, Integer port)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> hostname + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">        <span class="comment">// 如果之前对应的 ip port 已经建立了 channel</span></span><br><span class="line">        <span class="keyword">if</span> (channels.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 取出 channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channels.get(key);</span><br><span class="line">            <span class="comment">// 如果 channel 不为 null，并且处于活跃状态（连接状态）</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span> &amp;&amp; channel.isActive()) &#123;</span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 为 null 或者已经关闭连接，从 map 中移除</span></span><br><span class="line">                channels.remove(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Channel <span class="title function_">get</span><span class="params">(InetSocketAddress inetSocketAddress)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> get(inetSocketAddress.getHostName(), inetSocketAddress.getPort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(String hostname, Integer port, Channel channel)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> hostname + <span class="string">&quot;:&quot;</span> + port;</span><br><span class="line">        channels.put(key, channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(InetSocketAddress inetSocketAddress, Channel channel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.set(inetSocketAddress.getHostName(), inetSocketAddress.getPort(), channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成Spring自定义注解"><a href="#集成Spring自定义注解" class="headerlink" title="集成Spring自定义注解"></a>集成Spring自定义注解</h2><p>首先编写RpcService注解类，提供服务接口、接口名和版本等元数据，供框架进行服务发现、注册和远程调用时使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口类型，默认为 void.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口名（全限定名），默认为 &quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本号，默认 1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写Spring扩展机制中的一个实现类，扫描被@RpcService标注的组件并将对应的BeanDefiniton对象注册到Spring</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span>, ResourceLoaderAware &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此方法会在 spring 自定义扫描执行之后执行，这个时候 beanDefinitionMap 已经有扫描到的 beanDefinition 对象了</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotationMetadata annotation metadata of the importing class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry           current bean definition registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata annotationMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 RpcComponentScan 注解的属性和值</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">annotationAttributes</span> <span class="operator">=</span> AnnotationAttributes</span><br><span class="line">                .fromMap(annotationMetadata.getAnnotationAttributes(RpcComponentScan.class.getName()));</span><br><span class="line">        String[] basePackages = &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (annotationAttributes != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处去获取RpcComponentScan 注解的 basePackages 值</span></span><br><span class="line">            basePackages = annotationAttributes.getStringArray(<span class="string">&quot;basePackages&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有指定名称的话,默认就用当前类所在包</span></span><br><span class="line">        <span class="keyword">if</span> (basePackages.length == <span class="number">0</span>) &#123;</span><br><span class="line">            basePackages = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;((StandardAnnotationMetadata) annotationMetadata).getIntrospectedClass().getPackage().getName()&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建一个浏览 RpcService 注解的 Scanner</span></span><br><span class="line">        <span class="type">RpcClassPathBeanDefinitionScanner</span> <span class="variable">rpcServiceScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcClassPathBeanDefinitionScanner</span>(registry, RpcService.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.resourceLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">            rpcServiceScanner.setResourceLoader(<span class="built_in">this</span>.resourceLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扫描包下的所有 Rpc bean 并返回注册成功的数量（scan方法会调用register方法去注册扫描到的类并生成 BeanDefinition 注册到 spring 容器）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rpcServiceScanner.scan(basePackages);</span><br><span class="line">        log.info(<span class="string">&quot;The number of BeanDefinition scanned and registered by RpcServiceScanner is &#123;&#125;.&quot;</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写RpcComponentScan注解类，调用上述具体实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(RpcBeanDefinitionRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcComponentScan &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扫描包路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;basePackages&quot;)</span></span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扫描包路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">    String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在经过调用链，服务已经被注册到Spring中了，接下来利用Spring框架自动将服务信息注册到注册中心：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span>, CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcServer rpcServer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RpcServerProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcServerBeanPostProcessor</span><span class="params">(ServiceRegistry serviceRegistry, RpcServer rpcServer, RpcServerProperties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">        <span class="built_in">this</span>.rpcServer = rpcServer;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在 bean 实例化后，初始化后，检测标注有 <span class="doctag">@RpcService</span> 注解的类，将对应的服务类进行注册，对外暴露服务，同时进行本地服务注册</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回增强后的 bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException Bean 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 判断当前 bean 是否被 @RpcService 注解标注</span></span><br><span class="line">        <span class="keyword">if</span> (bean.getClass().isAnnotationPresent(RpcService.class)) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;[&#123;&#125;] is annotated with [&#123;&#125;].&quot;</span>, bean.getClass().getName(), RpcService.class.getCanonicalName());</span><br><span class="line">            <span class="comment">// 获取到该类的 @RpcService 注解</span></span><br><span class="line">            <span class="type">RpcService</span> <span class="variable">rpcService</span> <span class="operator">=</span> bean.getClass().getAnnotation(RpcService.class);</span><br><span class="line">            String interfaceName;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(rpcService.interfaceName())) &#123;</span><br><span class="line">                interfaceName = rpcService.interfaceClass().getName();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                interfaceName = rpcService.interfaceName();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> rpcService.version();</span><br><span class="line">            <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> ServiceUtil.serviceKey(interfaceName, version);</span><br><span class="line">            <span class="comment">// 构建 ServiceInfo 对象</span></span><br><span class="line">            <span class="type">ServiceInfo</span> <span class="variable">serviceInfo</span> <span class="operator">=</span> ServiceInfo.builder()</span><br><span class="line">                    .appName(properties.getAppName())</span><br><span class="line">                    .serviceName(serviceName)</span><br><span class="line">                    .version(version)</span><br><span class="line">                    .address(properties.getAddress())</span><br><span class="line">                    .port(properties.getPort())</span><br><span class="line">                    .build();</span><br><span class="line">            <span class="comment">// 进行远程服务注册</span></span><br><span class="line">            serviceRegistry.register(serviceInfo);</span><br><span class="line">            <span class="comment">// 进行本地服务缓存注册</span></span><br><span class="line">            LocalServiceCache.addService(serviceName, bean);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开机自启动 - 此方法实现于 &#123;<span class="doctag">@link</span> CommandLineRunner&#125; 接口，基于 springboot</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args incoming main method arguments 命令行参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception 启动异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; rpcServer.start(properties.getPort())).start();</span><br><span class="line">        log.info(<span class="string">&quot;Rpc server [&#123;&#125;] start, the appName is &#123;&#125;, the port is &#123;&#125;&quot;</span>,</span><br><span class="line">                rpcServer, properties.getAppName(), properties.getPort());</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 当服务关闭之后，将服务从 注册中心 上清除（关闭连接）</span></span><br><span class="line">                serviceRegistry.destroy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个注解是服务提供方的，下面实现服务调用方的注解<code>RpcReference</code>，用于标记需要动态代理生成远程服务调用客户端的字段或方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口类型，默认为 void.class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对外暴露服务的接口名（全限定名），默认为 &quot;&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">interfaceName</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本号，默认 1.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">version</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负载均衡策略，合法的值包括：random, roundrobin, leastactive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">loadbalance</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service mock name, use interface name + Mock if not set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">mock</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务调用超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">timeout</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写打上注解标签后的实现细节，在Spring完成Bean实例化之后，扫描Bean中标注了<code>@RpcReference</code>注解的字段，并将这些字段替换为对应的客户端代理对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClientStubProxyFactory proxyFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcClientBeanPostProcessor</span><span class="params">(ClientStubProxyFactory proxyFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.proxyFactory = proxyFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在bean实例化完后，扫描bean中需要进行rpc注入的属性，将对应的属性使用代理对象进行替换</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean     bean 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName bean 名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 后置增强后的 bean 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException bean 异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取该 bean 的类的所有属性（getFields - 获取所有的public属性，getDeclaredFields - 获取所有声明的属性，不区分访问修饰符）</span></span><br><span class="line">        Field[] fields = bean.getClass().getDeclaredFields();</span><br><span class="line">        <span class="comment">// 遍历所有属性</span></span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            <span class="comment">// 判断是否被 RpcReference 注解标注</span></span><br><span class="line">            <span class="keyword">if</span> (field.isAnnotationPresent(RpcReference.class)) &#123;</span><br><span class="line">                <span class="comment">// 获得 RpcReference 注解</span></span><br><span class="line">                <span class="type">RpcReference</span> <span class="variable">rpcReference</span> <span class="operator">=</span> field.getAnnotation(RpcReference.class);</span><br><span class="line">                <span class="comment">// 默认类为属性当前类型</span></span><br><span class="line">                <span class="comment">// filed.class = java.lang.reflect.Field</span></span><br><span class="line">                <span class="comment">// filed.type = com.wxy.xxx.service.XxxService</span></span><br><span class="line">                Class&lt;?&gt; clazz = field.getType();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果指定了全限定类型接口名</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(rpcReference.interfaceName())) &#123;</span><br><span class="line">                        clazz = Class.forName(rpcReference.interfaceName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果指定了接口类型</span></span><br><span class="line">                    <span class="keyword">if</span> (rpcReference.interfaceClass() != <span class="keyword">void</span>.class) &#123;</span><br><span class="line">                        clazz = rpcReference.interfaceClass();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取指定类型的代理对象</span></span><br><span class="line">                    <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> proxyFactory.getProxy(clazz, rpcReference.version());</span><br><span class="line">                    <span class="comment">// 关闭安全检查</span></span><br><span class="line">                    field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 设置域的值为代理对象</span></span><br><span class="line">                    field.set(bean, proxy);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RpcException</span>(String.format(<span class="string">&quot;Failed to obtain proxy object, the type of field %s is %s, &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;and the specified loaded proxy type is %s.&quot;</span>, field.getName(), field.getClass(), clazz), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成SpringBoot实现自动装配"><a href="#集成SpringBoot实现自动装配" class="headerlink" title="集成SpringBoot实现自动装配"></a>集成SpringBoot实现自动装配</h2><p>编写对应的自动配置的配置类以及 <code>spring.factories</code> 文件，引入对应的<code>starter</code>即可完成自动配置功能。</p><p>server端的配置类，主要作用有</p><ul><li>将服务注册到注册中心</li><li>启动RPC服务，监听请求连接</li><li>开启Bean后处理器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RpcServerProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServerAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RpcServerProperties properties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建 ServiceRegistry 实例 bean，当没有配置时默认使用 zookeeper 作为配置中心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceRegistry&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;registry&quot;, havingValue = &quot;zookeeper&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceRegistry <span class="title function_">zookeeperServiceRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZookeeperServiceRegistry</span>(properties.getRegistryAddr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceRegistry&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;registry&quot;, havingValue = &quot;nacos&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceRegistry <span class="title function_">nacosServiceRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosServiceRegistry</span>(properties.getRegistryAddr());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当没有配置通信协议属性时，默认使用 netty 作为通讯协议</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcServer&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;transport&quot;, havingValue = &quot;netty&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServer <span class="title function_">nettyRpcServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NettyRpcServer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcServer&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;transport&quot;, havingValue = &quot;http&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(name = &#123;&quot;org.apache.catalina.startup.Tomcat&quot;&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServer <span class="title function_">httpRpcServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpRpcServer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcServer&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.server&quot;, name = &quot;transport&quot;, havingValue = &quot;socket&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServer <span class="title function_">socketRpcServer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SocketRpcServer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(&#123;ServiceRegistry.class, RpcServer.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcServerBeanPostProcessor <span class="title function_">rpcServerBeanPostProcessor</span><span class="params">(<span class="meta">@Autowired</span> ServiceRegistry serviceRegistry,</span></span><br><span class="line"><span class="params">                                                                 <span class="meta">@Autowired</span> RpcServer rpcServer,</span></span><br><span class="line"><span class="params">                                                                 <span class="meta">@Autowired</span> RpcServerProperties properties)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcServerBeanPostProcessor</span>(serviceRegistry, rpcServer, properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>client的自动配置类，主要作用有：</p><ul><li>配置负载均衡算法</li><li>服务发现</li><li>客户端网络通信，用来发送和接收响应</li><li>动态代理类</li><li>开启Bean后处理器</li><li>退出时清理组件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RpcClientProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientAutoConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 属性绑定的实现方式二：</span></span><br><span class="line"><span class="comment">     * - 创建 RpcClientProperties 对象，绑定到配置文件</span></span><br><span class="line"><span class="comment">     * - 如果使用此方法，可以直接给属性赋初始值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment 当前应用的环境（支持 yaml、properties 等文件格式）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的绑定属性类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@deprecated</span> 弃用，使用被 &#123;<span class="doctag">@link</span> org.springframework.boot.context.properties.ConfigurationProperties&#125; 标注的属性类代替，</span></span><br><span class="line"><span class="comment">     * 生成 metadata。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    @Bean</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> RpcClientProperties <span class="title function_">rpcClientProperties</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取绑定器，将对应的属性绑定到指定类上</span></span><br><span class="line">        BindResult&lt;RpcClientProperties&gt; bind = Binder.get(environment).bind(<span class="string">&quot;rpc.client&quot;</span>, RpcClientProperties.class);</span><br><span class="line">        <span class="comment">// 获取实例</span></span><br><span class="line">        <span class="keyword">return</span> bind.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RpcClientProperties rpcClientProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;loadBalance&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">// 不指定 value 则值默认为当前创建的类</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;loadbalance&quot;, havingValue = &quot;random&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalance <span class="title function_">randomLoadBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomLoadBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;loadBalance&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;loadbalance&quot;, havingValue = &quot;roundRobin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalance <span class="title function_">roundRobinLoadBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoundRobinLoadBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;loadBalance&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;loadbalance&quot;, havingValue = &quot;consistentHash&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> LoadBalance <span class="title function_">consistentHashLoadBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConsistentHashLoadBalance</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceDiscovery&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(LoadBalance.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;registry&quot;, havingValue = &quot;zookeeper&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceDiscovery <span class="title function_">zookeeperServiceDiscovery</span><span class="params">(<span class="meta">@Autowired</span> LoadBalance loadBalance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZookeeperServiceDiscovery</span>(rpcClientProperties.getRegistryAddr(), loadBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;serviceDiscovery&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(LoadBalance.class)</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;registry&quot;, havingValue = &quot;nacos&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ServiceDiscovery <span class="title function_">nacosServiceDiscovery</span><span class="params">(<span class="meta">@Autowired</span> LoadBalance loadBalance)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NacosServiceDiscovery</span>(rpcClientProperties.getRegistryAddr(), loadBalance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcClient&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;transport&quot;, havingValue = &quot;netty&quot;, matchIfMissing = true)</span></span><br><span class="line">    <span class="keyword">public</span> RpcClient <span class="title function_">nettyRpcClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">NettyRpcClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcClient&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;transport&quot;, havingValue = &quot;http&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcClient <span class="title function_">httpRpcClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpRpcClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;rpcClient&quot;)</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnProperty(prefix = &quot;rpc.client&quot;, name = &quot;transport&quot;, havingValue = &quot;socket&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RpcClient <span class="title function_">socketRpcClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SocketRpcClient</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnBean(&#123;ServiceDiscovery.class, RpcClient.class&#125;)</span></span><br><span class="line">    <span class="keyword">public</span> ClientStubProxyFactory <span class="title function_">clientStubProxyFactory</span><span class="params">(<span class="meta">@Autowired</span> ServiceDiscovery serviceDiscovery,</span></span><br><span class="line"><span class="params">                                                         <span class="meta">@Autowired</span> RpcClient rpcClient,</span></span><br><span class="line"><span class="params">                                                         <span class="meta">@Autowired</span> RpcClientProperties rpcClientProperties)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientStubProxyFactory</span>(serviceDiscovery, rpcClient, rpcClientProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> RpcClientBeanPostProcessor <span class="title function_">rpcClientBeanPostProcessor</span><span class="params">(<span class="meta">@Autowired</span> ClientStubProxyFactory clientStubProxyFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcClientBeanPostProcessor</span>(clientStubProxyFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="keyword">public</span> RpcClientExitDisposableBean <span class="title function_">rpcClientExitDisposableBean</span><span class="params">(<span class="meta">@Autowired</span> ServiceDiscovery serviceDiscovery)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcClientExitDisposableBean</span>(serviceDiscovery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/RPC/">RPC</category>
      
      
      <category domain="http://example.com/tags/RPC/">RPC</category>
      
      
      <comments>http://example.com/inori/2408437c.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Netty常见问题</title>
      <link>http://example.com/inori/4840342e.html</link>
      <guid>http://example.com/inori/4840342e.html</guid>
      <pubDate>Sun, 25 May 2025 09:02:19 GMT</pubDate>
      
      <description>Netty</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="什么是Netty"><a href="#什么是Netty" class="headerlink" title="什么是Netty"></a>什么是Netty</h3><p>Netty是一个基于Java NIO (Non-blocking I&#x2F;O)的网络通信框架，它提供了高性能、可扩展性和可靠性的网络编程解决方案，是一个广泛应用于分布式系统的网络通信库</p><h3 id="Netty有哪些核心组件"><a href="#Netty有哪些核心组件" class="headerlink" title="Netty有哪些核心组件"></a>Netty有哪些核心组件</h3><p>Netty由三层结构构成：</p><ul><li>网络通信层：有三个组件：Bootstrap、ServerBootstrap、Channel<ul><li>Bootstrap负责客户端启动，连接指定服务器</li><li>ServerBootstrap负责服务器启动，监听指定端口</li><li>Channel是网络通信的载体</li></ul></li><li>事件调度层：有EventLoopGroup、EventLoop<ul><li>EventLoopGroup本质上是一个线程池，主要是负责接受IO请求，分配线程处理请求</li><li>EventLoop是具体的一个线程</li></ul></li><li>服务编排层：ChannelPipline、ChannelHandler、ChannelHandlerContext<ul><li>ChannelPipline负责将多个ChannelHandler组成一个链，可以看成一个流水线</li><li>ChannelHandler是对数据进行处理，可以看作成一道道工序</li><li>ChannelHandlerContext用来保存ChannelHandler的上下文信息</li></ul></li></ul><h3 id="Netty有几种线程模型"><a href="#Netty有几种线程模型" class="headerlink" title="Netty有几种线程模型"></a>Netty有几种线程模型</h3><p>一共三种Reactor模型</p><ul><li>单线程单Reactor模型，有三个组件：<ul><li>Acceptor：处理客户端连接请求</li><li>Reactor：监听和分发事件</li><li>Handler：业务处理</li><li>缺点：<ul><li>如果有一个Handler阻塞，会影响整个服务的吞吐量</li><li>无法充分利用多核CPU的性能</li></ul></li></ul></li></ul><img src="/inori/4840342e/reactor.png" style="zoom:50%;"><ul><li>多线程多Reactor模型（主从多线程Reactor模型）<ul><li>把Reactor拆分为了：Main-Reactor和SubReactor</li><li>Main-Reactor负责接受连接，然后随机分配给SubReactor</li></ul></li><li>主从 Reactor 多线程 + 业务线程池（WorkerGroup + 自定义业务线程池）<ul><li>WorkerGroup 只做 IO（读写、解码、编码）</li><li>业务逻辑交由独立线程池执行（例如使用 <code>DefaultEventExecutorGroup</code>）</li><li>优点：避免耗时业务阻塞IO线程，更高的业务并发能力，线程资源更加分离</li><li>缺点：如果业务线程池设置不当，也可能成为瓶颈</li></ul></li></ul><h3 id="Netty的优势"><a href="#Netty的优势" class="headerlink" title="Netty的优势"></a>Netty的优势</h3><ul><li>使用简单：封装了NIO的很多细节，使用更简单</li><li>功能强大：预置了多种编解码功能，支持多种主流协议</li><li>定制能力强：可以通过ChannelHandler对通信框架进行灵活地扩展</li></ul><h3 id="Netty高性能表现在哪些方面"><a href="#Netty高性能表现在哪些方面" class="headerlink" title="Netty高性能表现在哪些方面"></a>Netty高性能表现在哪些方面</h3><ul><li>IO线程模型：同步非阻塞，用最少的资源做更多的事</li><li>内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输</li><li>内存池设计：申请的内存可以重用，主要指直接内存</li><li>串形化处理读写：避免使用锁带来的性能开销</li></ul><h3 id="Netty的心跳机制"><a href="#Netty的心跳机制" class="headerlink" title="Netty的心跳机制"></a>Netty的心跳机制</h3><p>Netty的心跳机制是指通过定时发送心跳包来保持连接的机制。通常情况下，当连接空闲一段时间后，就会发送心跳包，如果对端没有响应，则判断连接已经失效，需要进行重连或其他操作。Netty的心跳机制可以通过<code>IdleStateHandler</code>实现，它可以检测连接的空闲状态并触发相应事件</p><h3 id="Netty的内存管理机制"><a href="#Netty的内存管理机制" class="headerlink" title="Netty的内存管理机制"></a>Netty的内存管理机制</h3><p>Netty的内存管理机制采用了堆外内存池的方式，即通过ByteBuf实现内存的分配和回收。Netty提供了两种ByteBuf实现类：PooledByteBuf和UnpooledByteBuf，前者是基于内存池实现的，可以重复利用内存，提高了内存的利用率；后者是基于堆内存实现的，不需要进行内存的池化和池化管理</p><h3 id="Netty的常用协议"><a href="#Netty的常用协议" class="headerlink" title="Netty的常用协议"></a>Netty的常用协议</h3><ul><li>HTTP&#x2F;HTTPS</li><li>WebSocket</li><li>TCP&#x2F;UDP</li><li>DNS</li><li>STOMP</li></ul><h3 id="Netty的ChannelHandler有哪些类型"><a href="#Netty的ChannelHandler有哪些类型" class="headerlink" title="Netty的ChannelHandler有哪些类型"></a>Netty的ChannelHandler有哪些类型</h3><ul><li>ChannelInboundHandler：用于处理Channel的入站数据和事件</li><li>ChannelOutboundHandler：用于处理Channel的出站数据和事件</li><li>ChannelDuplexHandler：同时实现了ChannelInboundHandler和ChannelOutboundHandler接口，可以同时处理入站数据和出站数据</li><li>ChannelHandlerContext：用于传递ChannelHandler之间的上下文信息</li></ul><h3 id="Netty的ByteBuf和Java-NIO的ByteBuffer有什么区别"><a href="#Netty的ByteBuf和Java-NIO的ByteBuffer有什么区别" class="headerlink" title="Netty的ByteBuf和Java NIO的ByteBuffer有什么区别"></a>Netty的ByteBuf和Java NIO的ByteBuffer有什么区别</h3><ul><li>内存分配方式不同<ul><li>Netty的ByteBuf采用了池化的方式进行内存分配，可以重复利用内存，减少了内存的分配和回收开销</li><li>Java NIO的ByteBuffer采用了直接或堆内存的方式进行内存分配，需要进行内存的分配和回收管理。</li></ul></li><li>功能不同<ul><li>Netty的ByteBuf提供了更加丰富的API，支持对缓冲区进行动态扩容、切片、读写标记等操作</li><li>Java NIO的ByteBuffer只提供了基本的读写方法</li></ul></li></ul><h3 id="Netty的启动流程"><a href="#Netty的启动流程" class="headerlink" title="Netty的启动流程"></a>Netty的启动流程</h3><ul><li>创建EventLoopGroup对象，用于管理Channel的EventLoop</li><li>创建ServerBootstrap对象，用于配置ServerChannel和Channel的参数和属性</li><li>绑定ServerChannel监听端口，并调用bind()方法启动服务</li><li>创建ChannelInitializer对象，用于初始化Channel的处理器链</li><li>在ChannelPipeline中添加ChannelHandler处理器，用于处理Channel上的I&#x2F;O事件和数据</li></ul><h4 id="初始化（main线程调用）"><a href="#初始化（main线程调用）" class="headerlink" title="初始化（main线程调用）"></a>初始化（main线程调用）</h4><ol><li>创建NioServerSocketChannel</li><li>初始化handler等待调用</li></ol><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><ol><li>启动nio线程(main线程)</li><li>原生ServerSocketChannel注册至selector未关注事件(nio线程)</li><li>执行NioServerSocketChannel初始化handler(nio线程)</li></ol><h4 id="绑定监听端口-nio线程调用"><a href="#绑定监听端口-nio线程调用" class="headerlink" title="绑定监听端口(nio线程调用)"></a>绑定监听端口(nio线程调用)</h4><ol><li>原生ServerSocketChannel绑定</li><li>触发NioServerSocketChannel active事件</li></ol><h3 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h3><p>重要组成部分：selector、线程、任务队列</p><p>NioEventLoop即会处理io事件，也会处理普通事件</p><h4 id="selector何时创建"><a href="#selector何时创建" class="headerlink" title="selector何时创建"></a>selector何时创建</h4><p>在构造方法调用时创建</p><h4 id="EventLoop为什么有两个selector成员（selector和unwarppedSelector）"><a href="#EventLoop为什么有两个selector成员（selector和unwarppedSelector）" class="headerlink" title="EventLoop为什么有两个selector成员（selector和unwarppedSelector）"></a>EventLoop为什么有两个selector成员（selector和unwarppedSelector）</h4><p>为了增强灵活性、性能优化和对JDK selector的bug做规避处理</p><p>unwarppedSelector：Java NIO 的原始 Selector，Netty保留它为了保底、调试和 fallback</p><p>selector：Netty包装过的Selector，使用自定义的 <code>SelectedSelectionKeySet</code> 替换掉了 JDK 默认的 <code>HashSet</code>，避免频繁的内存分配和迭代开销</p><h4 id="EventLoop的nio线程什么时候启动"><a href="#EventLoop的nio线程什么时候启动" class="headerlink" title="EventLoop的nio线程什么时候启动"></a>EventLoop的nio线程什么时候启动</h4><p>在首次调用execute方法时启动，通过<code>state</code>状态位保证线程只会启动一次</p><h4 id="netty的weakup方法如何理解"><a href="#netty的weakup方法如何理解" class="headerlink" title="netty的weakup方法如何理解"></a>netty的weakup方法如何理解</h4><p>只有其他线程提交任务时，才会调用selector的weakup方法，并且方法使用weakenup变量，使用CAS来保证并发，如果有多个线程提交任务时，可以避免weakup方法被频繁调用</p><h4 id="每次循环时，什么时候进入SelectStrategy-SELECT分支"><a href="#每次循环时，什么时候进入SelectStrategy-SELECT分支" class="headerlink" title="每次循环时，什么时候进入SelectStrategy.SELECT分支"></a>每次循环时，什么时候进入SelectStrategy.SELECT分支</h4><p>没有任务时进入，有任务时会调用selectNow方法，顺便拿到io事件</p><h4 id="何时会select阻塞，阻塞多久"><a href="#何时会select阻塞，阻塞多久" class="headerlink" title="何时会select阻塞，阻塞多久"></a>何时会select阻塞，阻塞多久</h4><p>没有定时任务时，selectDeadLineNanos（截止时间）&#x3D; 当前时间 + 1s<br>timeoutMillis（超时时间）&#x3D; 1s + 0.5ms</p><h4 id="nio的空轮询bug在哪里体现的，netty是如何解决的"><a href="#nio的空轮询bug在哪里体现的，netty是如何解决的" class="headerlink" title="nio的空轮询bug在哪里体现的，netty是如何解决的"></a>nio的空轮询bug在哪里体现的，netty是如何解决的</h4><p>空轮询bug的表现：调用 <code>Selector.select()</code>（或 <code>select(timeout)</code>）无故立即返回0，且连续调用总是如此，即使没有任何事件准备好</p><p>问题现象：CPU占用飙升（100%），但程序没有实际处理任何I&#x2F;O事件，处于所谓的“空轮询死循环”状态</p><h5 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h5><p>这个bug的本质在于<strong>Selector与其内部的selectedKey集合状态不一致</strong>，通常由以下原因触发：</p><ul><li><p>Channel被取消注册但未从epoll数据结构中清理：例如调用了<code>SelectionKey.cancel()</code>，但实际底层并没有完全从 epoll 中注销该事件</p></li><li><p>并发取消key（多线程中对selector操作）</p></li><li><p>Signal中断（signal中断了selector的阻塞）：某些native信号中断了<code>select()</code>调用，会让它提前返回</p></li></ul><p>正常的流程应该是这样的：</p><ol><li>注册 SocketChannel，关注 OP_READ（读事件）</li><li>内核通过 epoll 机制监听这个 fd 的读事件</li><li>当数据来了，<code>Selector.select()</code> 会返回</li><li>Selector 内部会把这个 key 放进 <code>selectedKeys</code> 集合</li><li>你拿到 key 之后就可以处理读事件了</li></ol><p>这时候，Selector 和底层 epoll 的状态是一致的</p><p>状态失衡：</p><ol><li>取消某个 SelectionKey（调用了 <code>key.cancel()</code>）</li><li>按理说，这个 Channel 不再需要监听，应从 epoll 中注销</li><li>但由于某些 bug 或 race condition，epoll 并<strong>没有真正移除它</strong></li><li>下次 <code>select()</code> 调用时，epoll 返回“有事件”（因为它还在监听）</li><li>但 Java NIO 的 <code>selectedKeys</code> 集合<strong>中没有把它加入</strong>，因为 Selector 认为这个 Key 已经无效</li><li>于是，Selector <code>select()</code> 调用返回了，<strong>但你没有事件可处理</strong></li></ol><p>这就造成了 <strong>Selector（Java 层）认为没事件，epoll（内核层）认为有事件</strong>，二者状态不一致</p><p>再进一步，连续多次这样的状态不一致：</p><ul><li>Selector 每次调用 <code>select()</code>，都会立刻返回 0</li><li><code>selectedKeys</code> 是空的，没有任何事件</li><li>但是底层仍然返回一个假的触发（因为 epoll 没删干净）</li><li>于是主线程进入空转，形成了所谓的 <strong>空轮询 bug</strong></li></ul><p>解决办法：netty内部维护了一个selectCnt，记录循环次数，当连续<code>select()</code>返回0的次数超过阈值，Netty会判断可能遇到空轮询 bug，主动重建一个新的Selector，将旧selector中所有注册的channel重新注册到新selector，再关闭旧selector</p><h4 id="ioRadio控制什么，设置100有什么作用"><a href="#ioRadio控制什么，设置100有什么作用" class="headerlink" title="ioRadio控制什么，设置100有什么作用"></a>ioRadio控制什么，设置100有什么作用</h4><p>ioRadio控制io事件所占用的时间比例，一般是50，如果设置成100，不会把所有时间都分给io事件，而是先把所有io事件处理完之后，在finally块中运行所有任务</p><h4 id="selectedKeys优化"><a href="#selectedKeys优化" class="headerlink" title="selectedKeys优化"></a>selectedKeys优化</h4><p>默认对selectedKeys遍历采用的是set形式，netty中会尝试使用数组的形式对selectedKeys进行管理，优化遍历时间</p><h3 id="accept流程"><a href="#accept流程" class="headerlink" title="accept流程"></a>accept流程</h3><ol><li>selector.select()阻塞直到事件发生</li><li>遍历处理selectedKeys</li><li>拿到一个key，判断事件类型是否为accept</li><li>创建SocketChannel，设置非阻塞</li><li>将SocketChannel注册至selector</li><li>关注selectionKey的read事件</li></ol><h3 id="read流程"><a href="#read流程" class="headerlink" title="read流程"></a>read流程</h3><ol><li>selector.select()阻塞直到事件发生</li><li>遍历处理selectedKeys</li><li>拿到一个key，判断事件类型是否为read</li><li>读取操作</li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Netty/">Netty</category>
      
      
      <category domain="http://example.com/tags/Netty/">Netty</category>
      
      
      <comments>http://example.com/inori/4840342e.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Netty优化</title>
      <link>http://example.com/inori/25b752cd.html</link>
      <guid>http://example.com/inori/25b752cd.html</guid>
      <pubDate>Sun, 25 May 2025 06:54:55 GMT</pubDate>
      
      <description>Netty优化</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="扩展序列化算法"><a href="#扩展序列化算法" class="headerlink" title="扩展序列化算法"></a>扩展序列化算法</h2><p>序列化，反序列化主要用在消息正文的转换上</p><ul><li>序列化时，需要将Java对象变为要传输的数据（可以是byte[]，json等，最终都需要变成byte[]）</li><li>反序列化时，需要将传入的正文数据还原成Java对象，便于处理</li></ul><p>Java自带的序列化，反序列化机制，核心代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">byte</span>[] body = <span class="keyword">new</span> <span class="title class_">byte</span>[bodyLength];</span><br><span class="line">byteByf.readBytes(body);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(body));</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) in.readObject();</span><br><span class="line">message.setSequenceId(sequenceId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out).writeObject(message);</span><br><span class="line"><span class="type">byte</span>[] bytes = out.toByteArray();</span><br></pre></td></tr></table></figure><p>为了支持更多序列化算法，抽象一个Serializer接口，使用枚举类实现具体的算法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SerializerAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    Jdk(<span class="number">0</span>), Json(<span class="number">1</span>), Protostuff(<span class="number">2</span>), Kryo(<span class="number">3</span>), Hessian(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> type;</span><br><span class="line">    </span><br><span class="line">    SerializerAlgorithm(<span class="type">int</span> type) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Jdk</span></span><br><span class="line">    Jdk &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> in.readObject();</span><br><span class="line">                <span class="keyword">return</span> (T) object;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out).writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// Json 实现(引入了 Gson 依赖)</span></span><br><span class="line">    Json &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要从协议的字节中得到是哪种序列化算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SerializerAlgorithm <span class="title function_">getByInt</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[type];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Protostuff 实现</span></span><br><span class="line">    Protostuff &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="comment">// 获取类对应的 schema（序列化元数据）</span></span><br><span class="line">            Schema&lt;T&gt; schema = RuntimeSchema.getSchema(clazz);</span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> schema.newMessage(); <span class="comment">// 创建对象实例</span></span><br><span class="line">            <span class="comment">// 将字节数据合并反序列化到对象中</span></span><br><span class="line">            ProtostuffIOUtil.mergeFrom(bytes, obj, schema);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="comment">// 获取运行时 schema</span></span><br><span class="line">            Schema&lt;T&gt; schema = RuntimeSchema.getSchema((Class&lt;T&gt;) object.getClass());</span><br><span class="line">            <span class="comment">// 创建缓冲区</span></span><br><span class="line">            <span class="type">LinkedBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ProtostuffIOUtil.toByteArray(object, schema, buffer);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="comment">// Kryo 实现</span></span><br><span class="line">    Kryo &#123;</span><br><span class="line">        <span class="comment">// 使用 ThreadLocal 确保 Kryo 在多线程中安全使用</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">            kryo.setRegistrationRequired(<span class="literal">false</span>); <span class="comment">// 允许动态类型注册</span></span><br><span class="line">            <span class="keyword">return</span> kryo;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">            <span class="comment">// 使用 Kryo 反序列化对象</span></span><br><span class="line">            <span class="keyword">return</span> kryo.readObject(input, clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> kryoThreadLocal.get();</span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(out);</span><br><span class="line">            <span class="comment">// 使用 Kryo 序列化对象</span></span><br><span class="line">            kryo.writeObject(output, object);</span><br><span class="line">            output.close();</span><br><span class="line">            <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Hessian 实现</span></span><br><span class="line">    Hessian &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建 Hessian 输入流</span></span><br><span class="line">                <span class="type">HessianInput</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianInput</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">                <span class="keyword">return</span> (T) input.readObject(); <span class="comment">// 反序列化对象</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Hessian 反序列化失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">                <span class="comment">// 创建 Hessian 输出流并序列化对象</span></span><br><span class="line">                <span class="type">HessianOutput</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianOutput</span>(out);</span><br><span class="line">                output.writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Hessian 序列化失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化类型编号（建议用于协议中）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SerializerAlgorithm <span class="title function_">getByInt</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[type];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加配置类和配置文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Config.class.getResourceAsStream(<span class="string">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class="line">            properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getServerPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;server.port&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8080</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Serializer.Algorithm <span class="title function_">getSerializerAlgorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;serializer.algorithm&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.Java;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.valueOf(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改编解码器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式</span></span><br><span class="line">        out.writeByte(Config.getSerializerAlgorithm().ordinal());</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(msg);</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerAlgorithm</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte(); <span class="comment">// 0,1,2...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到反序列化算法</span></span><br><span class="line">        Serializer.<span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Serializer.Algorithm.values()[serializerAlgorithm];</span><br><span class="line">        <span class="comment">// 确定具体消息类型</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Message</span>&gt; messageClass = Message.getMessageClass(messageType);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> algorithm.deserialize(messageClass, bytes);</span><br><span class="line"><span class="comment">//        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);</span></span><br><span class="line"><span class="comment">//        log.debug(&quot;&#123;&#125;&quot;, message);</span></span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul><li><p>属于SocketChannal参数</p></li><li><p>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p></li><li><p>与SO_TIMEOUT的区别：SO_TIMEOUT主要用在阻塞IO，阻塞IO中accept，read等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConnectionTimeout</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">300</span>)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            future.sync().channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.debug(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><ul><li>属于 ServerSocketChannal 参数</li><li>用于设置服务端监听套接字（ServerSocket）可接受的连接请求队列的长度</li></ul><p>回忆一下TCP的三次握手：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant c as client</span><br><span class="line">participant s as server</span><br><span class="line">participant sq as syns queue</span><br><span class="line">participant aq as accept queue</span><br><span class="line"></span><br><span class="line">s -&gt;&gt; s : bind()</span><br><span class="line">s -&gt;&gt; s : listen()</span><br><span class="line">c -&gt;&gt; c : connect()</span><br><span class="line">c -&gt;&gt; s : 1. SYN</span><br><span class="line">Note left of c : SYN_SEND</span><br><span class="line">s -&gt;&gt; sq : put</span><br><span class="line">Note right of s : SYN_RCVD</span><br><span class="line">s -&gt;&gt; c : 2. SYN + ACK</span><br><span class="line">Note left of c : ESTABLISHED</span><br><span class="line">c -&gt;&gt; s : 3. ACK</span><br><span class="line">sq -&gt;&gt; aq : put</span><br><span class="line">Note right of s : ESTABLISHED</span><br><span class="line">aq --&gt;&gt; s : </span><br><span class="line">s -&gt;&gt; s : accept()</span><br></pre></td></tr></table></figure><ol><li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li><li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li><li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li></ol><ul><li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p></li><li><p>sync queue - 半连接队列</p><ul><li>大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li><p>accept queue - 全连接队列</p><ul><li>其大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><p>netty中可以通过 option(ChannelOption.SO_BACKLOG, 值)来设置大小</p><h3 id="ulimit-n"><a href="#ulimit-n" class="headerlink" title="ulimit -n"></a>ulimit -n</h3><ul><li>属于操作系统参数</li><li>用于设置当前用户能打开的最大文件描述符数量</li></ul><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul><li>属于 SocketChannal 参数</li><li>禁用 Nagle 算法，牺牲带宽效率，换来低延迟</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">bootstrap.childOption(ChannelOption.TCP_NODELAY, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="SO-SNDBUF-SO-RCVBUF"><a href="#SO-SNDBUF-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul><li>SO_SNDBUF 属于 SocketChannal 参数，socket发送缓冲区大小</li><li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上），socket接受缓冲区大小</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">bootstrap.childOption(ChannelOption.SO_SNDBUF, <span class="number">1024</span> * <span class="number">64</span>); <span class="comment">// 64KB 发送缓冲区</span></span><br><span class="line">bootstrap.childOption(ChannelOption.SO_RCVBUF, <span class="number">1024</span> * <span class="number">64</span>); <span class="comment">// 64KB 接收缓冲区</span></span><br></pre></td></tr></table></figure><h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul><li>属于 SocketChannal 参数</li><li>用来内存分配和缓冲区管理，分配 ByteBuf，ctx.alloc()</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">bootstrap</span><br><span class="line">    .group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT); <span class="comment">// 默认</span></span><br></pre></td></tr></table></figure><h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><p>默认情况下，Netty 会循环调用 <code>read()</code> 将数据从 socket 读取到内存，但：</p><ul><li>读太少 → 系统调用频繁，吞吐低；</li><li>读太多 → 无效分配，浪费内存，还可能引发 OOM。</li></ul><p>为此，Netty 引入了 <code>RecvByteBufAllocator</code> 接口，允许动态调整每次读取的字节数，提高效率。</p><ul><li>属于 SocketChannal 参数</li><li>控制 netty 接收缓冲区大小</li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line"></span><br><span class="line">bootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">AdaptiveRecvByteBufAllocator</span>(<span class="number">64</span>, <span class="number">1024</span>, <span class="number">65536</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Netty/">Netty</category>
      
      
      <category domain="http://example.com/tags/Netty/">Netty</category>
      
      
      <comments>http://example.com/inori/25b752cd.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Netty进阶篇</title>
      <link>http://example.com/inori/56930530.html</link>
      <guid>http://example.com/inori/56930530.html</guid>
      <pubDate>Thu, 22 May 2025 01:59:31 GMT</pubDate>
      
      <description>Netty进阶</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="黏包和半包"><a href="#黏包和半包" class="headerlink" title="黏包和半包"></a>黏包和半包</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><ul><li><p>TCP以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p><p><img src="/inori/56930530/tcp.png"></p></li><li><p>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</p><p><img src="/inori/56930530/tcp_window.png"></p></li><li><p>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</p><ul><li>图中深色的部分即要发送的数据，高亮的部分即窗口</li><li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li><li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li><li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li></ul></li></ul><h4 id="MSS限制"><a href="#MSS限制" class="headerlink" title="MSS限制"></a>MSS限制</h4><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p><ul><li><p>以太网的 MTU 是 1500</p></li><li><p>FDDI（光纤分布式数据接口）的 MTU 是 4352</p></li><li><p>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</p></li><li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p></li><li><p>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 &#x3D; 1460</p></li><li><p>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</p></li><li><p>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</p></li></ul><p><img src="/inori/56930530/mss.jpg"></p><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp希望尽可能发送足够大的数据，这就是Nagle算法产生的缘由</p><ul><li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul><li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li><li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li><li>如果 TCP_NODELAY &#x3D; true，则需要发送</li><li>已发送的数据都收到 ack 时，则需要发送</li><li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li><li>除上述情况，延迟发送</li></ul></li></ul><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><p><strong>黏包</strong>：</p><ul><li>现象，发送abc和def，接收abcdef</li><li>原因：<ul><li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle算法：会造成黏包</li></ul></li></ul><p><strong>半包</strong>：</p><ul><li>现象，发送abcdef，接收abc和def</li><li>原因：<ul><li>应用层：接收方 ByteBuf 小于实际发送数据量</li><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li><li>MSS限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul><p><u>本质是因为TCP是流式协议，消息无边界</u></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>短连接</li></ol><p>发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;conneted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>半包用这种办法不好解决，因为接收方的缓冲区大小是有限的</p></blockquote><ol start="2"><li>每一条消息采用固定长度</li></ol><p>让所有数据包长度固定（假设长度为8字节），服务器端加入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));</span><br></pre></td></tr></table></figure><p>客户端测试代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; r.nextInt(<span class="number">8</span>); j++) &#123;</span><br><span class="line">                                    bytes[j] = (<span class="type">byte</span>) c;</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                                buffer.writeBytes(bytes);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点是，数据包的大小不好把握</p><ul><li>长度定的太大，浪费</li><li>长度定的太小，对某些数据包又显得不够</li></ul><ol start="3"><li>每一条消息采用分隔符，例如\n</li></ol><p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure><p>客户端在每条消息之后，加入 \n 分隔符</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p><ol start="4"><li>每一条消息分为 head 和 body，head 中包含 body 的长度</li></ol><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">byte</span>) (r.nextInt(<span class="number">16</span>) + <span class="number">1</span>);</span><br><span class="line">                                <span class="comment">// 先写入长度</span></span><br><span class="line">                                buffer.writeByte(length);</span><br><span class="line">                                <span class="comment">// 再</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= length; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="协议的设计与解析"><a href="#协议的设计与解析" class="headerlink" title="协议的设计与解析"></a>协议的设计与解析</h2><p>TCP&#x2F;IP 中消息传输基于流的方式，没有边界。</p><p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p><h3 id="redis协议举例"><a href="#redis协议举例" class="headerlink" title="redis协议举例"></a>redis协议举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">byte</span>[] LINE = &#123;<span class="number">13</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">    bootstrap.group(worker);</span><br><span class="line">    bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="comment">// 会在连接 channel 建立成功后，会触发 active 事件</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    set(ctx);</span><br><span class="line">                    get(ctx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*2&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;get&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;bbb&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>).sync();</span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    worker.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><ul><li>魔数，用来在第一时间判定是否是无效数据包</li><li>版本号，可以支持协议的升级</li><li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li><li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li><li>请求序号，为了双工通信，提供异步能力</li><li>正文长度</li><li>消息正文</li></ul><h4 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h4><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(</span><br><span class="line">        <span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MessageCodec</span>()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// encode</span></span><br><span class="line"><span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//        channel.writeOutbound(message);</span></span><br><span class="line"><span class="comment">// decode</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>, message, buf);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s2</span> <span class="operator">=</span> buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">s1.retain(); <span class="comment">// 引用计数 2</span></span><br><span class="line">channel.writeInbound(s1); <span class="comment">// release 1</span></span><br><span class="line">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure><p>解读</p><p><img src="/inori/56930530/return.png"></p><h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><ul><li>当handler不保存状态时，就可以安全地在多线程下被共享</li><li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制</li><li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h2><p>原因</p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p>问题</p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><p>服务器端解决</p><ul><li>每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了读空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;已经 5s 没有读到数据了&quot;</span>);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>客户端定时心跳</p><ul><li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了写空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">PingMessage</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Netty/">Netty</category>
      
      
      <category domain="http://example.com/tags/Netty/">Netty</category>
      
      
      <comments>http://example.com/inori/56930530.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Netty基础入门</title>
      <link>http://example.com/inori/62b8c227.html</link>
      <guid>http://example.com/inori/62b8c227.html</guid>
      <pubDate>Tue, 13 May 2025 05:57:03 GMT</pubDate>
      
      <description>Netty入门</description>
      
      
      
      <content:encoded><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Netty is an asynchronous event-driven network application framework</span><br><span class="line">for rapid development of maintainable high performance protocol servers &amp; clients.</span><br></pre></td></tr></table></figure><p>Netty是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>开发一个简单的服务器端和客户端</p><ul><li>客户端向服务器端发送HelloWorld</li><li>服务器仅接收，不返回</li></ul><p>加入依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.100.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()); <span class="comment">// 5</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; <span class="comment">// 6</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>代码解读</p><ul><li><p>1 处，创建 NioEventLoopGroup，可以简单理解为<code>线程池 + Selector</code></p></li><li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现</p></li><li><p>3 处，childHandler是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p></li><li><p>4 处，ServerSocketChannel 绑定的监听端口</p></li><li><p>5 处，SocketChannel 的处理器，解码 ByteBuf &#x3D;&gt; String</p></li><li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p></li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">// 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>) <span class="comment">// 4</span></span><br><span class="line">    .sync() <span class="comment">// 5</span></span><br><span class="line">    .channel() <span class="comment">// 6</span></span><br><span class="line">    .writeAndFlush(HelloWorld!); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><p>代码解读</p><ul><li><p>1 处，创建NioEventLoopGroup，同Server</p></li><li><p>2 处，选择客户Socket实现类，NioSocketChannel表示基于NIO的客户端实现</p></li><li><p>3 处，添加SocketChannel的处理器，ChannelInitializer处理器（仅执行一次），它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器</p></li><li><p>4 处，指定要连接的服务器和端口</p></li><li><p>5 处，Netty中很多方法都是异步的，如connect，这时需要使用sync方法等待connect建立连接完毕</p></li><li><p>6 处，获取channel对象，它即为通道抽象，可以进行数据读写操作</p></li><li><p>7 处，写入消息并清空缓冲区</p></li><li><p>8 处，消息会经过通道handler处理，这里是将String &#x3D;&gt; ByteBuf发出</p></li><li><p>数据经过网络传输，到达服务器端，服务器端5和6处的handler先后被触发，走完一个流程</p></li></ul><h3 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h3><p><img src="/inori/62b8c227/helloworld.png"></p><ul><li>把 channel 理解为数据的通道</li><li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li><li>把 handler 理解为数据的处理工序<ul><li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li><li>handler 分 Inbound 和 Outbound 两类</li></ul></li><li>把 eventLoop 理解为处理数据的工人<ul><li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li><li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li></ul></li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="EventLoop-EventLoopGroup"><a href="#EventLoop-EventLoopGroup" class="headerlink" title="EventLoop &amp; EventLoopGroup"></a>EventLoop &amp; EventLoopGroup</h3><p>EventLoop是一个单线程执行器（内部维护了一个 Selector），里面有run方法处理Channel上源源不断的io事件</p><p>继承关系：</p><ul><li>一条线是继承自j.u.c.ScheduledExecutorService因此包含了线程池中所有的方法</li><li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此EventLoop</li><li>提供了parent方法来看看自己属于哪个EventLoopGroup</li></ul></li></ul><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><p>关闭：</p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h4 id="handler内部的切换逻辑"><a href="#handler内部的切换逻辑" class="headerlink" title="handler内部的切换逻辑"></a>handler内部的切换逻辑</h4><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是，直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果两个handler绑定的是同一个线程，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个handler的线程来调用</li></ul><h4 id="NioEventLoop-处理普通任务"><a href="#NioEventLoop-处理普通任务" class="headerlink" title="NioEventLoop 处理普通任务"></a>NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.execute(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;normal task...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>可以用来执行耗时较长的任务</p></blockquote><h4 id="NioEventLoop-处理定时任务"><a href="#NioEventLoop-处理定时任务" class="headerlink" title="NioEventLoop 处理定时任务"></a>NioEventLoop 处理定时任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><blockquote><p>可以用来执行定时任务</p></blockquote><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>channel的常用api</p><ul><li>close()用来关闭 channel</li><li>closeFuture()用来处理 channel 的关闭<ul><li>sync方法作用是同步等待 channel 关闭</li><li>而addListener方法是异步等待 channel 关闭</li></ul></li><li>pipeline()方法添加处理器</li><li>write()方法将数据写入</li><li>writeAndFlush()方法将数据写入并刷出</li></ul><h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>刚才的客户端代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .sync()</span><br><span class="line">    .channel()</span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><p>拆开来看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">channelFuture.sync().channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象</li></ul><p>注意connect方法是异步的，意味着不等连接建立，方法执行就返回了。因此channelFuture对象中不能【立刻】获得到正确的 Channel 对象，需要调用sync方法同步等待连接建立完成</p><p>除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    System.out.println(future.channel()); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法）</li></ul><h4 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        NioEventLoopGroup group <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">                    channel.close(); <span class="comment">// close 异步操作 1s 之后</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;input&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        <span class="comment">/*log.debug(&quot;waiting close...&quot;);</span></span><br><span class="line"><span class="comment">        closeFuture.sync();</span></span><br><span class="line"><span class="comment">        log.debug(&quot;处理关闭之后的操作&quot;);*/</span></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="comment">// 处理关闭之后的操作</span></span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异步的提升"><a href="#异步的提升" class="headerlink" title="异步的提升"></a>异步的提升</h4><ol><li><strong>资源利用率</strong></li></ol><ul><li>同步 I&#x2F;O 模型中，每有一个连接就需要一个线程去阻塞等待读写结果，线程数量一多，就会导致上下文切换频繁、内存占用和调度开销增大</li><li>异步模型中，少量的 I&#x2F;O 线程（EventLoop）就能同时驱动很多连接，极大地减少了线程数量、上下文切换和系统资源消耗</li></ul><ol start="2"><li><strong>吞吐量与并发能力</strong></li></ol><ul><li>同步阻塞模式下，线程在等待网络或磁盘 I&#x2F;O 时无法做其它事情，导致CPU利用率不高</li><li>异步非阻塞模式下，线程在 I&#x2F;O 未就绪时立即返回去处理其它事件，可充分利用CPU，提升整体吞吐量和并发连接数</li></ul><ol start="3"><li><strong>响应时延</strong></li></ol><ul><li>同步调用常因线程排队和切换导致响应延迟抖动，尤其在高负载下更明显</li><li>异步调用通过回调或Future通知一旦I&#x2F;O就绪即可处理，减少了排队等待，响应更加及时和稳定</li></ul><ol start="4"><li><strong>可伸缩性</strong></li></ol><ul><li>同步模型在并发量增长时，需要线性增加线程池大小，最终受限于操作系统线程数和CPU核心数</li><li>异步模型中，固定数目的 EventLoop 线程即可水平扩展，连接层面几乎不受线程数量瓶颈限制，应用具有更好的可伸缩性</li></ul><ol start="5"><li>xxxxxxxxxx &#x2F;&#x2F; 用来判断是不是 读空闲时间过长，或 写空闲时间过长&#x2F;&#x2F; 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件ch.pipeline().addLast(new IdleStateHandler(0, 3, 0));&#x2F;&#x2F; ChannelDuplexHandler 可以同时作为入站和出站处理器ch.pipeline().addLast(new ChannelDuplexHandler() {    &#x2F;&#x2F; 用来触发特殊事件    @Override    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception{        IdleStateEvent event &#x3D; (IdleStateEvent) evt;        &#x2F;&#x2F; 触发了写空闲事件        if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) {            ctx.writeAndFlush(new PingMessage());        }    }});java</li></ol><ul><li>异步模型能更好地隔离单个连接或单次 I&#x2F;O 的阻塞、慢启动等问题，一条慢连接不会拖垮整个线程池</li><li>通过超时、回调隔离等机制，更容易在网络波动时进行快速恢复和故障隔离</li></ul><h3 id="Future-Promise"><a href="#Future-Promise" class="headerlink" title="Future &amp; Promise"></a>Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口</p><blockquote><p>netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p></blockquote><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li></ul><table><thead><tr><th>功能&#x2F;名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h3 id="Handler-Pipeline"><a href="#Handler-Pipeline" class="headerlink" title="Handler &amp; Pipeline"></a>Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p><ul><li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li><li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li></ul><p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>服务端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">3</span>);</span><br><span class="line">                    ctx.channel().write(msg); <span class="comment">// 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">4</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">5</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">6</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 6</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">        future.channel().writeAndFlush(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>服务器端打印：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p><p><img src="/inori/62b8c227/handler1.png"></p><ul><li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul><li>如果注释掉 1 处代码，则仅会打印 1</li><li>如果注释掉 2 处代码，则仅会打印 1 2</li></ul></li><li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul><li>如果注释掉 3 处代码，则仅会打印 1 2 3</li></ul></li><li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul><li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li></ul></li><li>ctx.channel().write(msg) vs ctx.write(msg)<ul><li>都是触发出站处理器的执行</li><li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li><li>ctx.write(msg) 是从当前节点找上一个出站处理器</li><li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li><li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6自己</li></ul></li></ul><p>服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p><p><img src="/inori/62b8c227/handler2.png"></p><h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><p>对字节数据Bytebuffer的封装</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>log方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(ByteBuf buffer)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> buffer.readableBytes();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">        .append(<span class="string">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class="line">        .append(<span class="string">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class="line">        .append(<span class="string">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(buf, buffer);</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="直接内存-vs-堆内存"><a href="#直接内存-vs-堆内存" class="headerlink" title="直接内存 vs 堆内存"></a>直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><h4 id="池化-vs-非池化"><a href="#池化-vs-非池化" class="headerlink" title="池化 vs 非池化"></a>池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure><ul><li>Netty 4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li></ul><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>ByteBuf由四部分组成</p><p><img src="/inori/62b8c227/bytebuf.png"></p><p>最开始读写指针都在0位置</p><h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td>用一字节 01|00 代表 true|false</td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian，即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian，即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 ByteBuffer</td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td></td></tr></tbody></table><blockquote><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li><li>网络传输，默认习惯是 Big Endian</li></ul></blockquote><p>先写入 4 个字节</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:4 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>再写入一个 int 整数，也是 4 个字节</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">5</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>结果是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:8 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p><h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>默认初始容量为256字节，默认最大容量为Integer.MAX_VALUE</p><p>扩容规则是</p><ul><li>如何写入后数据大小未超过4MB，则每次扩容容量翻倍</li><li>如果写入后数据大小超过4MB，则每次增加4MB</li><li>扩容不能超过max capacity会报错</li></ul><h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>例如读了 4 次，每次一个字节</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>如果需要重复读取 int 整数 5，怎么办？</p><p>可以在 read 前先做个标记 mark</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.markReaderIndex();</span><br><span class="line">System.out.println(buffer.readInt());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">read index:8 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 06                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时要重复读取的话，重置到标记位置 reset</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.resetReaderIndex();</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure><p>这时</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p><h4 id="retain-release"><a href="#retain-release" class="headerlink" title="retain &amp; release"></a>retain &amp; release</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等GC垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty采用了引用计数法来控制回收内存，每个ByteBuf都实现了ReferenceCounted接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><p>谁来负责 release 呢？</p><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong></p><ul><li>起点，对于NIO实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline</li><li>入站 ByteBuf 处理原则<ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li><li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li><li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li><li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li>出站 ByteBuf 处理原则<ul><li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li></ul></li><li>异常处理原则<ul><li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li></ul></li></ul><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>零拷贝的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p><p><img src="/inori/62b8c227/slice.png"></p><p>例如，原始 ByteBuf 进行一些初始操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">origin</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">origin.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">slice</span> <span class="operator">=</span> origin.slice();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class="line"><span class="comment">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 04                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时的 slice 不受影响，因为它有独立的读写指针</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>如果 slice 的内容发生了更改</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slice.setByte(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 05                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 05                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h4 id="duplicate"><a href="#duplicate" class="headerlink" title="duplicate"></a>duplicate</h4><p>零拷贝的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p><p><img src="/inori/62b8c227/duplicate.png"></p><h4 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p><h4 id="CompositeByteBuf"><a href="#CompositeByteBuf" class="headerlink" title="CompositeByteBuf"></a>CompositeByteBuf</h4><p>的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p><p>有两个 ByteBuf 如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p><p>方法1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT</span><br><span class="line">    .buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class="line">buf3.writeBytes(buf1);</span><br><span class="line">buf3.writeBytes(buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>这种方法进行了数据的内存复制操作</p><p>方法2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line"><span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">buf3.addComponents(<span class="literal">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure><p>结果是一样的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p><ul><li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li><li>缺点，复杂了很多，多次操作会带来性能的损耗</li></ul><h4 id="Unpooled"><a href="#Unpooled" class="headerlink" title="Unpooled"></a>Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p><p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf4</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;);</span><br><span class="line">System.out.println(buf4.getClass());</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf4));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class io.netty.buffer.CompositeByteBuf</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure><h4 id="ByteBuf-优势"><a href="#ByteBuf-优势" class="headerlink" title="ByteBuf 优势"></a>ByteBuf 优势</h4><ul><li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li><li>可以自动扩容</li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Netty/">Netty</category>
      
      
      <category domain="http://example.com/tags/Netty/">Netty</category>
      
      
      <comments>http://example.com/inori/62b8c227.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Java网络IO</title>
      <link>http://example.com/inori/fd4f4c4d.html</link>
      <guid>http://example.com/inori/fd4f4c4d.html</guid>
      <pubDate>Fri, 09 May 2025 04:07:06 GMT</pubDate>
      
      <description>Java网络IO</description>
      
      
      
      <content:encoded><![CDATA[<p>java中的IO可以分为BIO(blocking io,阻塞IO)、NIO(non-blocking io,非阻塞IO)、AIO(Asynchronous IO,异步IO)</p><h2 id="IO中的三大组件"><a href="#IO中的三大组件" class="headerlink" title="IO中的三大组件"></a>IO中的三大组件</h2><h3 id="Channel与Buffer"><a href="#Channel与Buffer" class="headerlink" title="Channel与Buffer"></a>Channel与Buffer</h3><p>channel有一点类似于stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">channel --&gt; buffer</span><br><span class="line">buffer --&gt; channel</span><br></pre></td></tr></table></figure><p>常见的Channel有</p><ul><li>FileChannel：用于对文件进行读写操作的通道，支持随机访问和映射文件</li><li>DatagramChannel：用于基于UDP进行无连接数据发送和接收的通道</li><li>SocketChannel：用于基于TCP的客户端网络通信，支持非阻塞连接与数据传输</li><li>ServerSocketChannel用于监听TCP连接请求的服务端通道，生成SocketChannel</li></ul><p>buffer则用来缓冲读写数据，常见的buffer有</p><ul><li>ByteBuffer：存储字节数据的基本缓冲区类型，是所有IO操作的核心<ul><li>MappedByteBuffer：可将文件内容直接映射到内存中进行读写</li><li>DirectByteBuffer：分配在堆外内存，用于高性能I&#x2F;O传输</li><li>HeapByteBuffer：分配在Java堆上，速度较慢但创建成本低</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector是一个可以同时监听多个Channel的I&#x2F;O就绪事件的组件，实现用一个线程处理多个连接</p><p>不用Selector时，如果我们使用多线程管理各个socket：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 多线程版</span><br><span class="line">t1(thread) --&gt; s1(socket1)</span><br><span class="line">t2(thread) --&gt; s2(socket2)</span><br><span class="line">t3(thread) --&gt; s3(socket3)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这种方式虽然可以同时管理多个socket，但是：</p><ul><li>内存占用高</li><li>线程上下文切换成本高</li><li>只适合连接数少的场景</li></ul><p>优化一下，使用线程池：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 线程池版</span><br><span class="line">t4(thread) --&gt; s4(socket1)</span><br><span class="line">t5(thread) --&gt; s5(socket2)</span><br><span class="line">t4(thread) -.-&gt; s6(socket3)</span><br><span class="line">t5(thread) -.-&gt; s7(socket4)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在这种设计下，我们使用线程池中的每个线程管理多个socket，但是这种方式也有缺点：</p><ul><li>阻塞模式下，线程仅能处理一个socket连接</li><li>仅适合短连接场景，如果是长连接，会造成socket饥饿现象</li></ul><p>现在引入Selector，用一个线程来管理多个channel，获取这些channel上发生的事件，这些channel工作在非阻塞模式下，不会让线程吊死在一个channel上。适合连接数特别多，但流量低的场景。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>调用selector的select()会阻塞直到channel发生了读写就绪事件，这些事件发生，select方法就会返回这些事件交给thread来处理</p><h2 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h2><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li>向buffer写入数据，例如调用 channel.read(buffer)</li><li>调用flip()切换至<strong>读模式</strong></li><li>从buffer读取数据，例如调用buffer.get()</li><li>调用clear()或compact()切换至<strong>写模式</strong></li><li>重复1~4步骤</li></ol><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>有一普通文本文件data.txt，内容为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234567890abcd</span><br></pre></td></tr></table></figure><p>使用FileChannel来读取文件内容</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;helloword/data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);<span class="comment">// 空间为10的bytebuffer</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 向 buffer 写入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                log.debug(<span class="string">&quot;读到字节数：&#123;&#125;&quot;</span>, len);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换 buffer 读模式</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, (<span class="type">char</span>)buffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换 buffer 写模式</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1</span><br></pre></td></tr></table></figure><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>ByteBuffer 有以下重要属性</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>初始状态：</p><p><img src="/inori/fd4f4c4d/bytebuffer1.png"></p><p>写模式下，position是写入位置，limit等于容量，下图表示写入了4个字节后的状态</p><p><img src="/inori/fd4f4c4d/bytebuffer2.png"></p><p>flip动作发生后，position切换为读取位置，limit切换为读取限制</p><p><img src="/inori/fd4f4c4d/bytebuffer3.png"></p><p>读取4个字节后，状态</p><p><img src="/inori/fd4f4c4d/bytebuffer4.png"></p><p>compact方法，是把未读完的部分向前压缩，然后切换至写模式。</p><p><img src="/inori/fd4f4c4d/bytebuffer5.png"></p><p>clear后，bytebuffer复原为初始状态。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>分配空间</li></ul><p>使用allocate方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Bytebuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li><p>向buffer写入数据</p><ul><li><p>调用channel的read方法</p></li><li><p>调用buffer的put方法</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buf);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">buf.put((<span class="type">byte</span>)<span class="number">127</span>);</span><br></pre></td></tr></table></figure><ul><li><p>从buffer读取数据</p><ul><li><p>调用channel的write方法</p></li><li><p>调用buffer的get方法</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buf);</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buf.get();</span><br></pre></td></tr></table></figure><p>get方法会让position读指针向后走，如果想重复读取数据</p><ul><li>可以调用 rewind 方法将 position 重新置为 0</li><li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li></ul><ul><li>mark 和 reset</li></ul><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p><blockquote><p>rewind 和 flip 都会清除 mark 位置</p></blockquote><p>注意：</p><blockquote><p>⚠️ Buffer是<strong>非线程安全的</strong></p></blockquote><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>FileChannel 只能工作在阻塞模式下</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel 只能读</li><li>通过 FileOutputStream 获取的 channel 只能写</li><li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>会从channel读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1表示到达了文件的末尾</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>在while中调用channel.write是因为write方法并不能保证一次将buffer中的内容全部写入channel</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ...;</span><br><span class="line">buffer.put(...); <span class="comment">// 存入数据</span></span><br><span class="line">buffer.flip();   <span class="comment">// 切换读模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>channel必须关闭，调用了FileInputStream、FileOutputStream或者RandomAccessFile的close方法会间接地调用channel的close方法</p><h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用force(true)方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li><li>SocketChannel.read 会在没有数据可读时让线程暂停</li><li>阻塞的表现为线程暂停，暂停期间不会占用cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位jvm一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    log.debug(<span class="string">&quot;connecting...&quot;</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">    log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">    channels.add(sc);</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        log.debug(<span class="string">&quot;before read... &#123;&#125;&quot;</span>, channel);</span><br><span class="line">        channel.read(buffer); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        debugRead(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><ul><li>非阻塞模式下，相关方法都会不会让线程暂停<ul><li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li><li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept </li><li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li></ul></li><li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，浪费cpu</li><li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解非阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">        channels.add(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);<span class="comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugRead(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>单线程可以配合Selector完成对多个Channel可读写事件的监控，这称之为多路复用</p><ul><li>多路复用仅针对网络IO、普通文件IO没法利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel未必时时可写，一旦Channel可写，会触发Selector的可写事件</li></ul></li></ul></li></ul><h3 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure><h4 id="绑定Channel事件"><a href="#绑定Channel事件" class="headerlink" title="绑定Channel事件"></a>绑定Channel事件</h4><p>也称之为注册事件，绑定的事件selector才会关心 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure><ul><li>channel 必须工作在非阻塞模式</li><li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的事件类型可以有<ul><li>connect - 客户端连接成功时触发</li><li>accept - 服务器端成功接受连接时触发</li><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul><h4 id="监听Channel事件"><a href="#监听Channel事件" class="headerlink" title="监听Channel事件"></a>监听Channel事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少channel发生了事件</p><p>方法1，阻塞直到绑定事件发生</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br></pre></td></tr></table></figure><p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select(<span class="type">long</span> timeout);</span><br></pre></td></tr></table></figure><p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.selectNow();</span><br></pre></td></tr></table></figure><h4 id="select何时不阻塞"><a href="#select何时不阻塞" class="headerlink" title="select何时不阻塞"></a>select何时不阻塞</h4><ul><li>事件发生时<ul><li>客户端发起连接请求，会触发 accept 事件</li><li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li><li>channel 可写，会触发 write 事件</li><li>在 linux 下 nio bug 发生时</li></ul></li><li>调用selector.wakeup()</li><li>调用selector.close()</li><li>selector所在线程interrupt</li></ul><h3 id="处理-accept-事件"><a href="#处理-accept-事件" class="headerlink" title="处理 accept 事件"></a>处理 accept 事件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果不处理，就取消掉</span></span><br><span class="line">                    <span class="comment">// key.cancel();</span></span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><blockquote><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p></blockquote><h3 id="处理-read-事件"><a href="#处理-read-事件" class="headerlink" title="处理 read 事件"></a>处理 read 事件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        log.debug(<span class="string">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            sc.close();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debug(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为何要iter-remove"><a href="#为何要iter-remove" class="headerlink" title="为何要iter.remove()"></a>为何要iter.remove()</h4><blockquote><p>因为select在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p><ul><li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li><li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li></ul></blockquote><h4 id="cancel的作用"><a href="#cancel的作用" class="headerlink" title="cancel的作用"></a>cancel的作用</h4><blockquote><p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p></blockquote><h4 id="处理消息的边界"><a href="#处理消息的边界" class="headerlink" title="处理消息的边界"></a>处理消息的边界</h4><p><img src="/inori/fd4f4c4d/messageBound.png"></p><ul><li>固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li><li>按分隔符拆分，缺点是效率低</li><li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant c1 as 客户端1</span><br><span class="line">participant s as 服务器</span><br><span class="line">participant b1 as ByteBuffer1</span><br><span class="line">participant b2 as ByteBuffer2</span><br><span class="line">c1 -&gt;&gt; s: 发送 01234567890abcdef3333\r</span><br><span class="line">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 扩容</span><br><span class="line">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 第二次 read 存入 3333\r</span><br><span class="line">b2 -&gt;&gt; b2: 01234567890abcdef3333\r</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">        <span class="comment">// 找到一条完整消息</span></span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">            <span class="comment">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(length);</span><br><span class="line">            <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                target.put(source.get());</span><br><span class="line">            &#125;</span><br><span class="line">            debugAll(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact(); <span class="comment">// 0123456789abcdef  position 16 limit 16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 selector, 管理多个 channel</span></span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class="line">    <span class="comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// key 只关注 accept 事件</span></span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    log.debug(<span class="string">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        <span class="comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="comment">// accept, read</span></span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">            <span class="comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class="line">            iter.remove();</span><br><span class="line">            log.debug(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">            <span class="comment">// 5. 区分事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 如果是 accept</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>); <span class="comment">// attachment</span></span><br><span class="line">                <span class="comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                log.debug(<span class="string">&quot;scKey:&#123;&#125;&quot;</span>, scKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">// 如果是 read</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel(); <span class="comment">// 拿到触发事件的channel</span></span><br><span class="line">                    <span class="comment">// 获取 selectionKey 上关联的附件</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer); <span class="comment">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class="line">                    <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                        key.cancel();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        split(buffer);</span><br><span class="line">                        <span class="comment">// 需要扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            newBuffer.put(buffer); <span class="comment">// 0123456789abcdef3333\n</span></span><br><span class="line">                            key.attach(newBuffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    key.cancel();  <span class="comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ByteBuffer大小分配"><a href="#ByteBuffer大小分配" class="headerlink" title="ByteBuffer大小分配"></a>ByteBuffer大小分配</h4><ul><li>每个channel都需要记录可能被切分的消息，因为ByteBuffer不能被多个channel共同使用，因此需要为每个channel维护一个独立的ByteBuffer</li><li>ByteBuffer不能太大，比如一个ByteBuffer 1Mb的话，要支持百万连接就要1Tb内存，因此需要设计大小可变的ByteBuffer<ul><li>一种思路是首先分配一个较小的buffer，例如4k，如果发现数据不够，再分配8k的buffer，将4k buffer内容拷贝至8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能</li><li>另一种思路是用多个数组组成buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h3 id="处理-write-事件"><a href="#处理-write-事件" class="headerlink" title="处理 write 事件"></a>处理 write 事件</h3><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul><li>非阻塞模式下，无法保证把buffer中所有数据都写入channel，因此需要追踪write方法的返回值（代表实际写入字节数）</li><li>用selector监听所有channel的可写事件，每个channel都需要一个key来跟踪buffer，但这样又会导致占用内存过多，就有两阶段策略<ul><li>当消息处理器第一次写入消息时，才将channel注册到selector上</li><li>selector检查channel上的可写事件，如果所有的数据写完了，就取消channel的注册</li><li>如果不取消，会每次可写均会触发write事件</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sckey</span> <span class="operator">=</span> sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 1. 向客户端发送内容</span></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    <span class="comment">// 3. write 表示实际写了多少字节</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="comment">// 4. 如果有剩余未读字节，才需要关注写事件</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="comment">// read 1  write 4</span></span><br><span class="line">                        <span class="comment">// 在原有关注事件的基础上，多关注 写事件</span></span><br><span class="line">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 把 buffer 作为附件加入 sckey</span></span><br><span class="line">                        sckey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="comment">// 写完了</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                        key.attach(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="write为何要取消"><a href="#write为何要取消" class="headerlink" title="write为何要取消"></a>write为何要取消</h4><p>只要向channel发送数据时，socket缓冲可写，这个事件会频繁触发，因此应当只在socket缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p><h3 id="利用多线程优化"><a href="#利用多线程优化" class="headerlink" title="利用多线程优化"></a>利用多线程优化</h3><p>前面的代码只有一个选择器，没有充分利用多核cpu，如何改进呢？</p><p>分两组选择器</p><ul><li>单线程配一个选择器，专门处理 accept 事件</li><li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BossEventLoop</span>().register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BossEventLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Selector boss;</span><br><span class="line">        <span class="keyword">private</span> WorkerEventLoop[] workers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">                ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">                ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                boss = Selector.open();</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">ssckey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                ssckey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">                workers = initEventLoops();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, <span class="string">&quot;boss&quot;</span>).start();</span><br><span class="line">                log.debug(<span class="string">&quot;boss start...&quot;</span>);</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;</span><br><span class="line">            WorkerEventLoop[] workerEventLoops = <span class="keyword">new</span> <span class="title class_">WorkerEventLoop</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerEventLoops.length; i++) &#123;</span><br><span class="line">                workerEventLoops[i] = <span class="keyword">new</span> <span class="title class_">WorkerEventLoop</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> workerEventLoops;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    boss.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            log.debug(<span class="string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                            workers[index.getAndIncrement() % workers.length].register(sc);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkerEventLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Selector worker;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WorkerEventLoop</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                worker = Selector.open();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, <span class="string">&quot;worker-&quot;</span> + index).start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sckey</span> <span class="operator">=</span> sc.register(worker, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    sckey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    worker.selectNow();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            worker.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    worker.select();</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> tasks.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">                                <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    key.cancel();</span><br><span class="line">                                    sc.close();</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    buffer.flip();</span><br><span class="line">                                    log.debug(<span class="string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                                    debugAll(buffer);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                key.cancel();</span><br><span class="line">                                sc.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        iter.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拿到-cpu-个数"><a href="#拿到-cpu-个数" class="headerlink" title="拿到 cpu 个数"></a>拿到 cpu 个数</h4><blockquote><ul><li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li><li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li></ul></blockquote><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h4 id="传统IO问题"><a href="#传统IO问题" class="headerlink" title="传统IO问题"></a>传统IO问题</h4><p>传统的IO将一个文件通过socket写出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure><p>内部工作流程是这样的：</p><p><img src="/inori/fd4f4c4d/tradIO.png"></p><ol><li><p>java本身并不具备IO读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p><blockquote><p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p></blockquote></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间cpu会参与拷贝，无法利用DMA</p></li><li><p>调用write方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入<strong>socket 缓冲区</strong>，cpu会参与拷贝</p></li><li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p></li></ol><p>可以看到中间环节较多，java的IO实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次</li><li>数据拷贝了共 4 次</li></ul><h4 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h4><p>通过 DirectByteBuf </p><ul><li>ByteBuffer.allocate(10) HeapByteBuffer 使用的是java堆内存</li><li>ByteBuffer.allocateDirect(10) DirectByteBuffer使用的是操作系统直接内存</li></ul><p><img src="/inori/fd4f4c4d/nio.png"></p><p>这种优化中，java可以使用 DirectByteBuf将堆外内存映射到jvm内存中来直接访问使用</p><ul><li>这块内存不受jvm垃圾回收的影响，因此内存地址固定，有助于IO读写</li><li>java中的DirectByteBuf对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuf对象被垃圾回收，将虚引用加入引用队列</li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li></ul><p>进一步优化（底层采用了linux 2.1后提供的sendFile方法），java中对应着两个channel调用transferTo&#x2F;transferFrom方法拷贝数据</p><p><img src="/inori/fd4f4c4d/sendFile.png"></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用cpu</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li></ol><p>可以看到</p><ul><li>只发生了一次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><p>进一步优化（linux 2.4）</p><p><img src="/inori/fd4f4c4d/zeroCopy.png"></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>只会将一些 offset 和 length 信息拷入<strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将<strong>内核缓冲区</strong>的数据写入网卡，不会使用cpu</li></ol><p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了2次。所谓零拷贝，并不是真正无拷贝，而是在不会拷贝重复数据到jvm内存中，零拷贝的优点有</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/fd4f4c4d.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Zookeeper基础入门</title>
      <link>http://example.com/inori/f8d5b7cd.html</link>
      <guid>http://example.com/inori/f8d5b7cd.html</guid>
      <pubDate>Wed, 23 Apr 2025 02:05:45 GMT</pubDate>
      
      <description>Zookeeper入门</description>
      
      
      
      <content:encoded><![CDATA[<p>Zookeeper是一个分布式的、开源的分布式应用程序的协调服务，基于ZAB协议（ZooKeeper Atomic Broadcast）实现分布式数据一致性</p><p>Zookeeper内部的数据模型类似文件系统的树形结构（ZNode），每个节点可存储不超过1MB的数据</p><p>Zookeeper提供的主要功能包括：</p><ul><li>服务注册与发现</li><li>配置管理</li><li>分布式锁</li><li>集群管理</li></ul><h2 id="Zookeeper数据模型"><a href="#Zookeeper数据模型" class="headerlink" title="Zookeeper数据模型"></a>Zookeeper数据模型</h2><p>ZooKeeper是一个树形目录服务,其数据模型和Unix的文件系统目录树很类似，拥有一个层次化结构</p><p>这里面的每一个节点都被称为ZNode，每个节点上都会保存自己的数据和节点信息</p><p>节点可以拥有子节点，同时也允许少量（1MB）数据存储在该节点之下（可以通过jute.maxbuffer修改单个节点数据大小限制）</p><p>节点可以分为四大类：</p><ul><li>PERSISTENT：持久化节点，创建后永久存在（除非显式删除）</li><li>EPHEMERAL：临时节点 -e，会话结束后自动删除（用于实现服务注册与心跳检测）</li><li>PERSISTENT_SEQUENTIAL：持久化顺序节点 -s，顺序节点的名称后面会自动追加单调递增序号（如 <code>/lock/seq-0000000001</code>）</li><li>EPHEMERAL_SEQUENTIAL ：临时顺序节点 -es</li><li>TTL节点：3.6.0+ 版本支持，设置存活时间后自动删除</li></ul><p><img src="/inori/f8d5b7cd/zookeeper.png"></p><h2 id="Zookeeper常用命令"><a href="#Zookeeper常用命令" class="headerlink" title="Zookeeper常用命令"></a>Zookeeper常用命令</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><ul><li>启动ZooKeeper服务: .&#x2F;zkServer.sh start</li><li>查看ZooKeeper服务状态: .&#x2F;zkServer.sh status</li><li>停止ZooKeeper服务: .&#x2F;zkServer.sh stop</li><li>重启ZooKeeper服务: .&#x2F;zkServer.sh restart</li></ul><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><ul><li>连接ZooKeeper服务端：.&#x2F;zkCli.sh –server ip:port</li><li>断开连接：quit</li><li>设置节点值：set &#x2F;节点path value</li><li>删除单个节点：delete &#x2F;节点path</li><li>显示指定目录下节点：ls 目录</li><li>删除带有子节点的节点：deleteall &#x2F;节点path</li><li>创建节点：create &#x2F;节点path value</li><li>获取节点值：get &#x2F;节点path</li><li>创建临时节点：create -e &#x2F;节点path value</li><li>创建顺序节点：create -s &#x2F;节点path value</li><li>查询节点详细信息：ls –s &#x2F;节点path<ul><li>czxid：节点被创建的事务ID</li><li>ctime: 创建时间</li><li>mzxid: 最后一次被更新的事务ID</li><li>mtime: 修改时间</li><li>pzxid：子节点列表最后一次被更新的事务ID</li><li>cversion：子节点的版本号 </li><li>dataversion：数据版本号</li><li>aclversion：权限版本号</li><li>ephemeralOwner：用于临时节点，代表临时节点的事务ID，如果为持久节点则为0</li><li>dataLength：节点存储的数据的长度</li><li>numChildren：当前节点的子节点个数</li></ul></li></ul><h2 id="ZooKeeper-JavaAPI-操作"><a href="#ZooKeeper-JavaAPI-操作" class="headerlink" title="ZooKeeper JavaAPI 操作"></a>ZooKeeper JavaAPI 操作</h2><p><strong>Curator</strong>是Netflix开源的高级客户端，可以简化ZooKeeper客户端的使用</p><p>Curator API常用操作有：</p><ul><li>建立连接</li><li>添加节点</li><li>删除节点</li><li>修改节点</li><li>查询节点</li><li>Watch事件</li><li>监听</li><li>分布式锁实现</li></ul><p>添加Maven依赖并启动Zookeeper服务：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Curator 核心库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Curator 扩展工具 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建客户端连接：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CuratorDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ZK_ADDRESS</span> <span class="operator">=</span> <span class="string">&quot;localhost:2181&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CuratorFramework <span class="title function_">createClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 重试策略：初始等待1秒，最多重试3次</span></span><br><span class="line">        <span class="type">ExponentialBackoffRetry</span> <span class="variable">retry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(ZK_ADDRESS)<span class="comment">// ip地址+端口</span></span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)<span class="comment">// 会话超时时间（毫秒）</span></span><br><span class="line">                .connectionTimeoutMs(<span class="number">3000</span>)<span class="comment">// 连接建立超时时间（毫秒）</span></span><br><span class="line">            .namespace(<span class="string">&quot;/demo&quot;</span>)<span class="comment">// 设置命名空间（所有操作路径自动添加前缀）</span></span><br><span class="line">                .retryPolicy(retry)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> createClient();</span><br><span class="line">        client.start(); <span class="comment">// 启动连接</span></span><br><span class="line">        System.out.println(<span class="string">&quot;ZooKeeper 连接状态: &quot;</span> + client.getState());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">        client.close(); <span class="comment">// 关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建持久节点（默认开放权限）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> client.create()</span><br><span class="line">    .forPath(<span class="string">&quot;/persistent-node&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建临时顺序节点（会话结束后自动删除，名称追加序号）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">seqPath</span> <span class="operator">=</span> client.create()</span><br><span class="line">    .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)</span><br><span class="line">    .forPath(<span class="string">&quot;/temp-seq-&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>方法链</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>.withMode()</code></td><td>指定节点类型（共6种）</td><td><code>CreateMode.PERSISTENT_SEQUENTIAL</code></td></tr><tr><td><code>.withACL()</code></td><td>设置自定义权限列表</td><td><code>.withACL(ZooDefs.Ids.CREATOR_ALL_ACL)</code></td></tr><tr><td><code>.creatingParentsIfNeeded()</code></td><td>自动创建父节点（递归）</td><td>适用于深度路径如 <code>/a/b/c</code></td></tr><tr><td><code>.withTtl()</code></td><td>设置TTL（需ZK 3.5+，且需配置<code>ExtendedFeatureType.TTL</code>）</td><td><code>.withTtl(10000L)</code> &#x2F;&#x2F; 10秒后自动删除</td></tr><tr><td><code>.withProtection()</code></td><td>保护模式（防重放攻击）</td><td>配合临时顺序节点使用</td></tr></tbody></table><p>删除节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除叶子节点</span></span><br><span class="line">client.delete()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带版本号的删除（CAS）</span></span><br><span class="line">client.delete()</span><br><span class="line">    .withVersion(stat.getVersion())</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>方法链</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>.deletingChildrenIfNeeded()</code></td><td>递归删除子节点</td><td>用于删除非空目录</td></tr><tr><td><code>.guaranteed()</code></td><td>确保删除成功（持续重试直到ZK确认）</td><td>配合<code>.withVersion()</code>使用</td></tr><tr><td><code>.withVersion()</code></td><td>指定版本号（实现CAS删除）</td><td><code>.withVersion(5)</code></td></tr></tbody></table><p>修改节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基础更新</span></span><br><span class="line">client.setData()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;new-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带版本号的原子更新（CAS操作）</span></span><br><span class="line"><span class="type">Stat</span> <span class="variable">newStat</span> <span class="operator">=</span> client.setData()</span><br><span class="line">    .withVersion(stat.getVersion()) <span class="comment">// 使用之前获取的版本号</span></span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;cas-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无条件强制更新</span></span><br><span class="line">client.setData()</span><br><span class="line">    .withVersion(-<span class="number">1</span>) <span class="comment">// 忽略版本冲突</span></span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>, <span class="string">&quot;force-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步回调更新</span></span><br><span class="line">client.setData()</span><br><span class="line">    .inBackground((curator, event) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异步更新结果: &quot;</span> + event.getResultCode());</span><br><span class="line">    &#125;)</span><br><span class="line">    .forPath(<span class="string">&quot;/async-path&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><p>获取节点数据：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本读取（返回byte[]）</span></span><br><span class="line"><span class="type">byte</span>[] data = client.getData()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带状态读取（获取Stat元信息）</span></span><br><span class="line"><span class="type">Stat</span> <span class="variable">stat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stat</span>();</span><br><span class="line"><span class="type">byte</span>[] dataWithStat = client.getData()</span><br><span class="line">    .storingStatIn(stat) <span class="comment">// 存储节点状态</span></span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;版本号: &quot;</span> + stat.getVersion());</span><br></pre></td></tr></table></figure><p>子节点查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取子节点列表</span></span><br><span class="line">List&lt;String&gt; children = client.getChildren()</span><br><span class="line">    .forPath(<span class="string">&quot;/parent&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带监听器的查询（子节点变化时触发）</span></span><br><span class="line">List&lt;String&gt; watchedChildren = client.getChildren()</span><br><span class="line">    .usingWatcher((CuratorWatcher) event -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子节点变化: &quot;</span> + event.getType());</span><br><span class="line">    &#125;).forPath(<span class="string">&quot;/parent&quot;</span>);</span><br></pre></td></tr></table></figure><p>存在性检查：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查节点是否存在（返回Stat或null）</span></span><br><span class="line"><span class="type">Stat</span> <span class="variable">existsStat</span> <span class="operator">=</span> client.checkExists()</span><br><span class="line">    .forPath(<span class="string">&quot;/path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带监听的存在检查</span></span><br><span class="line">client.checkExists()</span><br><span class="line">    .usingWatcher((CuratorWatcher) event -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getType() == Watcher.Event.EventType.NodeCreated) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点被创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forPath(<span class="string">&quot;/path-to-watch&quot;</span>);</span><br></pre></td></tr></table></figure><p>事务操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建事务</span></span><br><span class="line"><span class="type">CuratorTransactionFinal</span> <span class="variable">txFinal</span> <span class="operator">=</span> client.inTransaction()</span><br><span class="line">    .create().forPath(<span class="string">&quot;/txn-node1&quot;</span>, <span class="string">&quot;data1&quot;</span>.getBytes()).and()</span><br><span class="line">    .setData().forPath(<span class="string">&quot;/txn-node2&quot;</span>, <span class="string">&quot;data2&quot;</span>.getBytes()).and()</span><br><span class="line">    .delete().forPath(<span class="string">&quot;/txn-node3&quot;</span>).and()</span><br><span class="line">    .commit(); <span class="comment">// 原子化执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查结果</span></span><br><span class="line"><span class="keyword">for</span> (CuratorTransactionResult result : txFinal.getResults()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;操作类型: &quot;</span> + result.getType() + <span class="string">&quot;, 路径: &quot;</span> + result.getForPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>批量操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建批量操作</span></span><br><span class="line">List&lt;CuratorOp&gt; ops = Arrays.asList(</span><br><span class="line">    client.transactionOp().create().forPath(<span class="string">&quot;/batch/new&quot;</span>, <span class="string">&quot;data&quot;</span>.getBytes()),</span><br><span class="line">    client.transactionOp().setData().forPath(<span class="string">&quot;/batch/existing&quot;</span>, <span class="string">&quot;update&quot;</span>.getBytes()),</span><br><span class="line">    client.transactionOp().delete().forPath(<span class="string">&quot;/batch/old&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行批量操作</span></span><br><span class="line">List&lt;CuratorTransactionResult&gt; results = client.transaction().forOperations(ops);</span><br></pre></td></tr></table></figure><h2 id="Watch事件监听"><a href="#Watch事件监听" class="headerlink" title="Watch事件监听"></a>Watch事件监听</h2><p>ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是ZooKeeper实现分布式协调服务的重要特性。</p><p>ZooKeeper中引入了Watcher机制来实现了发布&#x2F;订阅功能能，能够让多个订阅者同时监听某一个对象，当一个对象自身状态变化时，会通知所有订阅者。</p><p>ZooKeeper原生支持通过注册Watcher来进行事件监听，但是其使用并不是特别方便，需要开发人员自己反复注册Watcher，比较繁琐。Curator引入了Cache来实现对 ZooKeeper服务端事件的监听。</p><p>ZooKeeper提供了三种Watcher：</p><ul><li>NodeCache:只是监听某一个特定的节点</li><li>PathChildrenCache:监控一个ZNode的子节点</li><li>TreeCache:可以监控整个树上的所有节点，类似于PathChildrenCache和NodeCache的组合</li></ul><p>一次侦听：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.CuratorFramework;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.api.CuratorWatcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OneTimeWatcherDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加一次性Watcher（触发后自动移除）</span></span><br><span class="line">        <span class="type">byte</span>[] data = client.getData()</span><br><span class="line">                .usingWatcher((CuratorWatcher) event -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;【一次性监听】事件类型: &quot;</span> + event.getType() + <span class="string">&quot;, 路径: &quot;</span> + event.getPath());</span><br><span class="line">                &#125;)</span><br><span class="line">                .forPath(<span class="string">&quot;/test-watch&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试触发（修改节点数据）</span></span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-watch&quot;</span>, <span class="string">&quot;new-data&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">// 再次修改不会触发，因为Watcher已被移除</span></span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-watch&quot;</span>, <span class="string">&quot;another-data&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathChildrenCache持续侦听：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersistentWatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        client.create().creatingParentsIfNeeded().forPath(<span class="string">&quot;/test-parent&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建PathChildrenCache监听器</span></span><br><span class="line">        <span class="type">PathChildrenCache</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PathChildrenCache</span>(client, <span class="string">&quot;/test-parent&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        cache.start(PathChildrenCache.StartMode.BUILD_INITIAL_CACHE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听回调</span></span><br><span class="line">        cache.getListenable().addListener((client1, event) -&gt; &#123;</span><br><span class="line">            <span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> CHILD_ADDED:</span><br><span class="line">                    System.out.println(<span class="string">&quot;【子节点新增】路径: &quot;</span> + event.getData().getPath());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CHILD_UPDATED:</span><br><span class="line">                    System.out.println(<span class="string">&quot;【子节点更新】路径: &quot;</span> + event.getData().getPath() + </span><br><span class="line">                                     <span class="string">&quot;, 数据: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(event.getData().getData()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> CHILD_REMOVED:</span><br><span class="line">                    System.out.println(<span class="string">&quot;【子节点删除】路径: &quot;</span> + event.getData().getPath());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试操作</span></span><br><span class="line">        client.create().forPath(<span class="string">&quot;/test-parent/child1&quot;</span>, <span class="string">&quot;data1&quot;</span>.getBytes());</span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-parent/child1&quot;</span>, <span class="string">&quot;updated&quot;</span>.getBytes());</span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/test-parent/child1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        cache.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NodeCache节点全量监听:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.NodeCacheListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodeCacheDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        client.create().forPath(<span class="string">&quot;/test-node&quot;</span>, <span class="string">&quot;init&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建NodeCache监听指定节点</span></span><br><span class="line">        <span class="type">NodeCache</span> <span class="variable">nodeCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NodeCache</span>(client, <span class="string">&quot;/test-node&quot;</span>);</span><br><span class="line">        nodeCache.start(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听器</span></span><br><span class="line">        nodeCache.getListenable().addListener(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeCache.getCurrentData() != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;【节点数据变更】当前数据: &quot;</span> + </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span>(nodeCache.getCurrentData().getData()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;【节点被删除】&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试操作</span></span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-node&quot;</span>, <span class="string">&quot;changed&quot;</span>.getBytes());</span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/test-node&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        nodeCache.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TreeCache树形结构监听:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCache;</span><br><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.cache.TreeCacheEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeCacheDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        client.create().creatingParentsIfNeeded().forPath(<span class="string">&quot;/test-tree/sub1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建TreeCache监听子树</span></span><br><span class="line">        <span class="type">TreeCache</span> <span class="variable">treeCache</span> <span class="operator">=</span> TreeCache.newBuilder(client, <span class="string">&quot;/test-tree&quot;</span>).build();</span><br><span class="line">        treeCache.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加监听器</span></span><br><span class="line">        treeCache.getListenable().addListener((client1, event) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.getData() != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;【树形事件】类型: %s, 路径: %s, 数据: %s\n&quot;</span>,</span><br><span class="line">                    event.getType(),</span><br><span class="line">                    event.getData().getPath(),</span><br><span class="line">                    event.getData().getData() != <span class="literal">null</span> ? </span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">String</span>(event.getData().getData()) : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试操作</span></span><br><span class="line">        client.create().forPath(<span class="string">&quot;/test-tree/sub2&quot;</span>, <span class="string">&quot;sub2-data&quot;</span>.getBytes());</span><br><span class="line">        client.setData().forPath(<span class="string">&quot;/test-tree/sub1&quot;</span>, <span class="string">&quot;update&quot;</span>.getBytes());</span><br><span class="line">        client.delete().forPath(<span class="string">&quot;/test-tree/sub1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        treeCache.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>事件类型</strong></th><th><strong>触发条件</strong></th><th><strong>适用监听器</strong></th></tr></thead><tbody><tr><td>NodeCreated</td><td>节点被创建</td><td>Watcher&#x2F;NodeCache</td></tr><tr><td>NodeDeleted</td><td>节点被删除</td><td>所有监听器</td></tr><tr><td>NodeDataChanged</td><td>节点数据变更</td><td>所有监听器</td></tr><tr><td>NodeChildrenChanged</td><td>子节点数量变化（不包含数据变更）</td><td>PathChildrenCache</td></tr><tr><td>INITIALIZED</td><td>TreeCache初始化完成</td><td>TreeCache</td></tr><tr><td>CONNECTION_LOST</td><td>连接断开</td><td>所有监听器</td></tr></tbody></table><h2 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h2><p>核心思想：当客户端要获取锁，则创建节点，使用完锁，则删除该节点。</p><ol><li>客户端获取锁时，在lock节点下创建<strong>临时顺序</strong>节点。</li><li>然后获取lock下面的所有子节点，客户端获取到所有的子节点之后，如果发现自己创建的子节点序号最小，那么就认为该客户端获取到了锁。使用完锁后，将该节点删除。</li><li>如果发现自己创建的节点并非lock所有子节点中最小的，说明自己还没有获取到锁，此时客户端需要找到比自己小的那个节点，同时对其注册事件监听器，监听删除事件。（每个节点只监听比自己小的、最大的那个节点）</li><li>如果发现比自己小的那个节点被删除，则客户端的Watcher会收到相应通知，此时再次判断自己创建的节点是否是lock子节点中序号最小的，如果是则获取到了锁，如果不是则重复以上步骤继续获取到比自己小的一个节点并注册监听。</li></ol><h3 id="锁类型及其应用"><a href="#锁类型及其应用" class="headerlink" title="锁类型及其应用"></a>锁类型及其应用</h3><p>互斥锁（InterProcessMutex）：基于临时顺序节点实现，通过竞争最小序号获得锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.curator.framework.recipes.locks.InterProcessMutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MutexLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CuratorFramework</span> <span class="variable">client</span> <span class="operator">=</span> CuratorFrameworkFactory.newClient(<span class="string">&quot;localhost:2181&quot;</span>, <span class="keyword">new</span> <span class="title class_">RetryNTimes</span>(<span class="number">3</span>, <span class="number">1000</span>));</span><br><span class="line">        client.start();</span><br><span class="line">        </span><br><span class="line">        <span class="type">InterProcessMutex</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/locks/mutex&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取锁（阻塞等待，支持超时设置）</span></span><br><span class="line">            <span class="keyword">if</span> (lock.acquire(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获得锁&quot;</span>);</span><br><span class="line">                <span class="comment">// 模拟业务处理</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock.isAcquiredInThisProcess()) &#123;</span><br><span class="line">                    lock.release();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 释放锁&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁（InterProcessReadWriteLock）:</p><ul><li>读锁：共享锁，多个客户端可同时持有</li></ul><ul><li>写锁：独占锁，与其他所有锁互斥</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InterProcessReadWriteLock</span> <span class="variable">rwLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessReadWriteLock</span>(client, <span class="string">&quot;/locks/rwlock&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">readLock</span> <span class="operator">=</span> rwLock.readLock();</span><br><span class="line">readLock.acquire();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line"><span class="type">InterProcessMutex</span> <span class="variable">writeLock</span> <span class="operator">=</span> rwLock.writeLock();</span><br><span class="line">writeLock.acquire();</span><br></pre></td></tr></table></figure><p>联锁（InterProcessMultiLock）:同时锁定多个路径，<strong>原子性</strong>获取&#x2F;释放多个锁。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;InterProcessLock&gt; locks = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/locks/lock1&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InterProcessMutex</span>(client, <span class="string">&quot;/locks/lock2&quot;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="type">InterProcessMultiLock</span> <span class="variable">multiLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessMultiLock</span>(locks);</span><br><span class="line">multiLock.acquire(); <span class="comment">// 所有锁同时获取</span></span><br><span class="line">multiLock.release(); <span class="comment">// 所有锁同时释放</span></span><br></pre></td></tr></table></figure><p>信号量（InterProcessSemaphoreV2）:控制同时访问资源的客户端数量。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">InterProcessSemaphoreV2</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterProcessSemaphoreV2</span>(client, <span class="string">&quot;/locks/semaphore&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">Lease</span> <span class="variable">lease</span> <span class="operator">=</span> semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">semaphore.returnLease(lease);      <span class="comment">// 释放许可</span></span><br></pre></td></tr></table></figure><h2 id="Zookeeper集群"><a href="#Zookeeper集群" class="headerlink" title="Zookeeper集群"></a>Zookeeper集群</h2><p>节点角色：</p><table><thead><tr><th><strong>角色</strong></th><th><strong>职责</strong></th><th><strong>数量要求</strong></th></tr></thead><tbody><tr><td><strong>Leader</strong></td><td>处理所有写请求，发起提案投票</td><td>1（唯一活跃）</td></tr><tr><td><strong>Follower</strong></td><td>参与投票，处理读请求（可能返回旧数据）</td><td>≥1</td></tr><tr><td><strong>Observer</strong></td><td>仅同步数据，不参与投票（扩展读性能）</td><td>可选（可水平扩展）</td></tr></tbody></table><h3 id="Leader的选举（Fast-Leader-Election算法）"><a href="#Leader的选举（Fast-Leader-Election算法）" class="headerlink" title="Leader的选举（Fast Leader Election算法）"></a>Leader的选举（Fast Leader Election算法）</h3><p>Serverid：服务器ID，比如有三台服务器，编号分别是1,2,3。编号越大在选择算法中的权重越大。</p><p>Zxid：数据ID，服务器中存放的最大数据ID。值越大说明数据越新，在选举算法中数据越新权重越大。</p><p>在Leader选举的过程中，如果某台ZooKeeper获得了超过半数的选票，则此ZooKeeper就可以成为Leader了。</p><p>并且在选取leader后新增节点，只要leader节点不挂，就不会重新选举</p><h3 id="核心机制"><a href="#核心机制" class="headerlink" title="核心机制"></a>核心机制</h3><p>ZAB协议（ZooKeeper Atomic Broadcast）</p><ul><li>两种模式<ol><li>崩溃恢复：选举新Leader并同步数据</li><li>消息广播：Leader将写请求转化为Proposal广播给所有Follower</li></ol></li><li>数据一致性<ul><li>顺序一致性：所有请求按全局顺序执行</li><li>原子性：更新要么全部成功，要么全部失败</li></ul></li></ul><p>会话管理</p><ul><li>会话周期：客户端连接时创建，超时或断开时结束</li><li>临时节点：会话结束自动删除（用于实现服务注册）</li></ul><p>数据同步流程</p><ol><li>客户端向Leader发起写请求</li><li>Leader生成Proposal广播给所有Follower</li><li>Follower持久化Proposal后返回ACK</li><li>Leader收到半数以上ACK后提交Commit</li><li>Leader通知所有节点应用变更</li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>如果Leader挂了，其他节点没挂会怎么样？</li></ol><p>那么会在其他Follower中选取新Leader，如果节点数量过少，就直接显示不可用</p><ol start="2"><li>如果Follower挂了会怎么样？</li></ol><p>不怎么样，其他节点继续工作，但是如果剩余节点过少，就显示不可用</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/Zookeeper/">Zookeeper</category>
      
      
      <category domain="http://example.com/tags/Zookeeper/">Zookeeper</category>
      
      
      <comments>http://example.com/inori/f8d5b7cd.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
