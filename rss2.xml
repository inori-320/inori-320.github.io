<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>楪祈のBlog</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>星座になれたら。</description>
    <pubDate>Fri, 14 Mar 2025 08:45:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>JVM类与类加载</title>
      <link>http://example.com/inori/e45c1800.html</link>
      <guid>http://example.com/inori/e45c1800.html</guid>
      <pubDate>Fri, 14 Mar 2025 06:22:49 GMT</pubDate>
      
      <description>JVM类加载部分</description>
      
      
      
      <content:encoded><![CDATA[<p>java的类字节码文件如何加载到内存中的？</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="类加载的触发条件"><a href="#类加载的触发条件" class="headerlink" title="类加载的触发条件"></a>类加载的触发条件</h3><p>JVM并不会一次性加载所有类，而是采用<strong>“按需加载”</strong>策略，即在需要的时候才会进行类的加载。</p><h4 id="触发类加载的操作"><a href="#触发类加载的操作" class="headerlink" title="触发类加载的操作"></a>触发类加载的操作</h4><p>一般在这些情况下，如果类没有被加载，那么会被自动加载：</p><ul><li>使用 <code>new</code> 关键字创建对象时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure><ul><li>访问类的静态变量（包括读取或写入，不是 <code>final</code> 修饰的常量）时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> MyClass.staticField;</span><br></pre></td></tr></table></figure><ul><li>调用类的静态方法时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyClass.staticMethod();</span><br></pre></td></tr></table></figure><ul><li>使用反射机制（如 <code>Class.forName()</code>、<code>Class.getMethod()</code> 等）时</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>子类初始化时，如果父类尚未初始化，会先触发父类的加载</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>; &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123; <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>; &#125;</span><br><span class="line">System.out.println(B.b); <span class="comment">// 先加载 A，再加载 B</span></span><br></pre></td></tr></table></figure><ul><li>作为 <code>main</code> 方法所在的类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; &#125; <span class="comment">// Main 类被加载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不会触发类加载的操作"><a href="#不会触发类加载的操作" class="headerlink" title="不会触发类加载的操作"></a>不会触发类加载的操作</h4><ul><li>访问 <code>final</code> 修饰的静态变量,<code>final</code> 变量在编译时已确定，不会触发类的初始化</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(A.CONSTANT);<span class="comment">// A 类不会被加载</span></span><br></pre></td></tr></table></figure><ul><li>通过数组定义类的引用,只是创建了一个引用类型数组，并未真正使用A类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A[] array = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">10</span>];<span class="comment">// A 类不会被加载</span></span><br></pre></td></tr></table></figure><ul><li>通过子类访问父类的静态变量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line">System.out.println(B.a);<span class="comment">// 只会触发 A 的加载，B 不会被加载</span></span><br></pre></td></tr></table></figure><h3 id="类加载过程-1"><a href="#类加载过程-1" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>Java 类的加载过程主要包括<strong>加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）</strong>五个阶段</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><ol><li>通过类的全限定名查找字节码文件（如<code>.class</code>文件）</li><li>将字节码文件转换为内存中的二进制数据</li><li>在方法区（JDK 8之前）或元空间（JDK 8及之后）中创建类的运行时数据结构</li><li>在堆内存中生成一个<code>Class</code>对象，作为方法区或元空间中数据的访问入口</li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ul><li>检查字节码文件的正确性和安全性，确保其符合JVM规范</li><li>包括文件格式验证、元数据验证、字节码验证和符号引用验证<ul><li>文件格式验证：是否符合 <code>.class</code> 文件规范（开头八位数，即魔数<code>CAFEBABE</code>）</li><li>元数据验证：类、方法、字段的定义是否合法</li><li>字节码检查：方法调用是否合法，是否越界访问</li><li>符号引用检查：解析阶段前，确保引用的类、方法、字段存在</li></ul></li><li>如果验证失败，会抛出 <code>VerifyError</code></li></ul><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><ul><li>为<strong>类的静态变量</strong>分配内存，并赋默认值（非初始化值）</li><li>变量赋的是<strong>默认值</strong>（<code>int</code> -&gt; <code>0</code>，<code>boolean</code> -&gt; <code>false</code>，<code>reference</code> -&gt; <code>null</code>）。</li><li>如果静态变量是常量（<code>final</code>），则直接赋值为指定的初始值</li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>将常量池中的<u>符号引用</u>转换为<u>直接引用</u></p><p>符号引用：类的字段、方法的名称和描述符</p><ul><li><code>com/example/A</code> 之类的字符串引用类</li><li><code>A.f</code> 代表字段</li><li><code>A.m()</code> 代表方法</li></ul><p>直接引用：字段、方法在内存中的实际地址</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>执行类的初始化代码，包括静态变量的赋值和静态代码块的执行</p><p>按照<strong>定义顺序</strong>执行类的静态初始化代码，包括：</p><ul><li><strong>静态变量赋值</strong></li><li><strong>静态代码块</strong></li><li><strong>执行 <code>&lt;clinit&gt;()</code> 方法</strong></li></ul><p>执行顺序：</p><ol><li>父类静态变量 &amp; 静态代码块</li><li>子类静态变量 &amp; 静态代码块</li><li>父类实例变量 &amp; 构造代码块</li><li>父类构造方法</li><li>子类实例变量 &amp; 构造代码块</li><li>子类构造方法</li></ol><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><p>条件：</p><ul><li>类的 <code>ClassLoader</code> 被回收</li><li>该类的所有实例都不可达（GC）</li><li>没有其他类引用该类</li></ul><p>特点：</p><ul><li>只会卸载<strong>用户自定义类</strong>，JDK的核心类不会被卸载</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>Java提供了类加载器，以便更好地控制类加载，可以自定义类加载器，也可以使用官方自带的类加载器去加载类。对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性。也就是说，一个类可以由不同的类加载器加载，并且，不同的类加载器加载的出来的类，即使来自同一个Class文件，也是不同的，<strong>只有两个类来自同一个Class文件并且是由同一个类加载器加载的，才能判断为是同一个</strong>。</p><p>默认情况下，所有的类都是由JDK自带的类加载器进行加载，类加载器实现了类的动态加载、隔离和安全性控制。</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>类加载器是JVM的一部分，用于查找、加载和定义Java类。主要负责：</p><ol><li><strong>加载类文件</strong>（从磁盘、网络、JAR包等）</li><li><strong>将字节码转换为 Class 对象</strong></li><li><strong>缓存已加载的类</strong>，避免重复加载</li></ol><p>Java采用双亲委派机制来组织多个类加载器，确保类的加载顺序和安全性</p><p>主要有三种由JDK提供的类加载器：</p><table><thead><tr><th>类加载器</th><th>作用</th><th>负责加载的类</th></tr></thead><tbody><tr><td><strong>Bootstrap ClassLoader（启动类加载器）</strong></td><td>最顶层的类加载器，由 JVM 实现</td><td><code>rt.jar</code>（如 <code>java.lang.String</code>、<code>java.util.List</code>）</td></tr><tr><td><strong>Extension ClassLoader（扩展类加载器）</strong></td><td>加载扩展库中的类</td><td><code>lib/ext</code> 目录下的 JAR</td></tr><tr><td><strong>Application ClassLoader（应用类加载器）</strong></td><td>加载应用程序的类</td><td><code>classpath</code> 指定的类</td></tr></tbody></table><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><ol><li>检查缓存：如果类已加载，则直接返回Class对象（避免重复加载）</li><li>双亲委派<ul><li>先让父类加载器尝试加载类</li><li>如果找不到，再由当前类加载器加载</li></ul></li><li>转换&amp;解析<ul><li>将字节码转换成Class对象，并存入JVM方法区</li></ul></li><li>返回Class对象，允许实例化对象</li></ol><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><ol><li>当一个类加载器要加载某个类时，先让自己的“父加载器”尝试加载</li><li>如果父加载器找不到该类，才由当前类加载器自己加载</li></ol><p>工作流程：</p><ol><li>类加载请求从最底层的<code>ClassLoader</code>向上层传递。</li><li>顶层加载器（Bootstrap ClassLoader）先尝试加载</li><li>如果上层加载器找不到类，才交给当前类加载器进行加载</li><li>如果类已加载，直接返回<code>Class</code>对象</li></ol><p><img src="/inori/e45c1800/parents_.png" alt="parents_"></p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p>Java允许自定义类加载器，用于加载网络、加密、动态生成的类，通过继承 <code>java.lang.ClassLoader</code> 类，可以实现自定义的类加载器。举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath; <span class="comment">// 类路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 读取字节码文件</span></span><br><span class="line">            <span class="type">byte</span>[] data = loadClassData(name);</span><br><span class="line">            <span class="comment">// 生成 Class 对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;类未找到: &quot;</span> + name, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载字节码文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String name) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> classPath + name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">             <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>()) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建自定义类加载器</span></span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">myClassLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;path/to/classes/&quot;</span>);</span><br><span class="line">        <span class="comment">// 加载类</span></span><br><span class="line">        Class&lt;?&gt; clazz = myClassLoader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">        <span class="comment">// 实例化对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;类加载器: &quot;</span> + clazz.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>findClass</code>方法：</p><ul><li>自定义类加载器需要重写<code>findClass</code>方法，用于加载类的字节码文件</li></ul><p><code>defineClass</code>方法：</p><ul><li>将字节码文件转换为<code>Class</code>对象</li></ul><p><code>loadClassData</code>方法：</p><ul><li>从指定路径读取字节码文件</li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/JVM/">JVM</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/e45c1800.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM垃圾回收机制</title>
      <link>http://example.com/inori/4af053c8.html</link>
      <guid>http://example.com/inori/4af053c8.html</guid>
      <pubDate>Fri, 14 Mar 2025 04:55:14 GMT</pubDate>
      
      <description>JVM垃圾回收部分</description>
      
      
      
      <content:encoded><![CDATA[<p>Java会自动管理和释放内存，它不像C&#x2F;C++那样要求我们手动管理内存，JVM提供了一套全自动的内存管理机制，当一个Java对象不再用到时，JVM会自动将其进行回收并释放内存，那么对象所占内存在什么时候被回收，如何判定对象可以被回收，以及如何去进行回收工作也是JVM需要关注的问题。</p><h2 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h2><p>对象在什么情况下可以被判定为不再使用已经可以回收了？</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>如果要经常操作一个对象，那么首先一定会创建一个引用变量：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//str就是一个引用类型的变量，它持有对后面字符串对象的引用，可以代表后面这个字符串对象本身</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p>只要一个对象还有使用价值，就可以通过它的引用变量来进行操作，那么可否这样判断一个对象是否还需要被使用：</p><ul><li>每个对象都包含一个引用计数器，用于存放引用计数（存放被引用的次数）</li><li>每当有一个地方引用此对象时，引用计数<code>+1</code></li><li>当引用失效（比如离开了局部变量的作用域或是引用被设定为<code>null</code>）时，引用计数<code>-1</code></li><li>当引用计数为<code>0</code>时，表示此对象不可能再被使用，因为这时我们已经没有任何方法可以得到此对象的引用了</li></ul><p>但是这样存在一个问题，如果两个对象相互引用呢？                  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        a.another = b;</span><br><span class="line">        b.another = a;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里直接把a和b赋值为null，这样前面的两个对象我们不可能再得到了</span></span><br><span class="line">        a = b = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        Test another;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照引用计数算法，那么当出现以上情况时，虽然无法得到此对象的引用，并且此对象也无需再使用，但是由于这两个对象直接存在相互引用的情况，那么引用计数器的值将会永远是<code>1</code>，永远不会被回收，引用计数法并不是最好的解决方案。</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>目前比较主流的编程语言，一般都会使用可达性分析算法来判断对象是否存活，它采用了类似于树结构的搜索机制。</p><p>首先每个对象的引用都有机会成为树的根节点（GC Roots），可以被选定作为根节点条件如下：</p><ul><li><strong>虚拟机栈中的局部变量</strong>：当前正在执行的方法中的局部变量引用的对象</li><li><strong>方法区中的静态变量</strong>：类的静态成员变量引用的对象。</li><li><strong>方法区中的常量</strong>：运行时常量池中的常量引用的对象（如字符串常量）</li><li><strong>本地方法栈中的 JNI 引用</strong>：Native 方法引用的对象</li><li><strong>被添加了锁的对象</strong>：比如synchronized关键字</li><li><strong>JVM 内部的特殊对象</strong>：如基本数据类型对应的 Class 对象、异常对象等</li></ul><p>一旦已经存在的根节点不满足存在的条件时，那么根节点与对象之间的连接将被断开。此时虽然对象1仍存在对其他对象的引用，但是由于其没有任何根节点引用，所以此对象即可被判定为不再使用。只要某个对象无法到达任何GC Roots，则证明此对象是不可能再被使用的，就可以被回收。</p><h3 id="最终判定"><a href="#最终判定" class="headerlink" title="最终判定"></a>最终判定</h3><p>虽然在经历了可达性分析算法之后基本可能判定哪些对象能够被回收，但是并不代表此对象一定会被回收，我们依然可以在最终判定阶段对其进行挽留。</p><p><code>finalize()</code>是 Java 中的一个对象生命周期方法，定义在<code>Object</code>类中。它允许对象在垃圾回收之前执行一些清理操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called by the garbage collector on an object when garbage collection</span></span><br><span class="line"><span class="comment"> * determines that there are no more references to the object.</span></span><br><span class="line"><span class="comment"> * A subclass overrides the &#123;<span class="doctag">@code</span> finalize&#125; method to dispose of</span></span><br><span class="line"><span class="comment"> * system resources or to perform other cleanup.</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br></pre></td></tr></table></figure><p>如果子类重写了此方法，那么子类对象在被判定为可回收时，会进行二次确认，也就是执行<code>finalize()</code>方法，而在此方法中，当前对象是完全有可能重新建立GC Roots的。</p><p>所以，如果在二次确认后对象不满足可回收的条件，那么此对象不会被回收，巧妙地逃过了垃圾回收的命运。比如下面这个例子：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里直接把a赋值为null，这样前面的对象不可能再得到了</span></span><br><span class="line">        a  = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动申请执行垃圾回收操作（注意只是申请，并不一定会执行，但是一般情况下都会执行）</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等垃圾回收</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(a);<span class="comment">// 仍然没有被回收</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            a = <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>finalize()</code>方法并不是在主线程调用的，而是虚拟机自动建立的一个<strong>低优先级</strong>的<code>Finalizer</code>线程进行处理。同一个对象的<code>finalize()</code>方法只会有一次调用机会，也就是说，如果连续两次这样操作，那么第二次，对象必定被回收：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    a = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    a = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    <span class="comment">// 再来一次</span></span><br><span class="line">    a = <span class="literal">null</span>;</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(a);<span class="comment">// a没了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，<code>finalize()</code>方法也并不是专门防止对象被回收的，我们可以使用它来释放一些程序使用中的资源等。<code>finalize()</code>方法的使用需要非常谨慎，因为它可能导致性能问题和不可预测的行为。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>垃圾收集器会不定期地检查堆中的对象，查看它们是否满足被回收的条件。我们该如何对这些对象进行回收？</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>标记清楚算法会标记出所有需要回收的对象，然后再依次回收掉被标记的对象，或是标记出所有不需要回收的对象，只回收未标记的对象。</p><p><img src="/inori/4af053c8/clear.png" alt="clear"></p><p>虽然此方法非常简单，但是缺点也是非常明显的 ，首先如果内存中存在大量的对象，那么可能就会存在大量的标记，并且大规模进行清除。</p><p>并且一次标记清除之后，连续的内存空间可能会出现许许多多的空隙，碎片化会导致连续内存空间利用率降低</p><h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><p>标记复制算法就是将内存区域划分为大小相同的两块区域，每次只使用其中的一块区域，每次垃圾回收结束后，将所有存活的对象全部复制到另一块区域中，并一次性清空当前区域。虽然浪费了一些时间进行复制操作，但是这样能够很好地解决对象大面积回收后空间碎片化严重的问题</p><p><img src="/inori/4af053c8/copy.png" alt="copy"></p><p>这种算法非常适用于新生代（因为新生代的回收效率极高，一般不会留下太多的对象）的垃圾回收，新生代Survivor区就是这个思路，包括8:1:1的比例也正是为了对标记复制算法进行优化而采取的</p><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>虽然标记-复制算法能够很好地应对新生代高回收率的场景，但是放到老年代，它就显得很鸡肋了。一般长期不回收的对象，才有机会进入到老年代，所以老年代一般都是些钉子户，可能一次GC后，仍然存留很多对象。而标记复制算法会在GC后完整复制整个区域内容，并且会折损50%的区域，显然这并不适用于老年代。</p><p>标记整理算法在标记所有待回收对象之后，不急着去进行回收操作，而是将所有待回收的对象整齐排列在一段内存空间中，而需要回收的对象全部往后丢，这样，前半部分的所有对象都是无需进行回收的，而后半部分直接一次性清除即可。</p><p><img src="/inori/4af053c8/mark_clean.png" alt="mark_clean"></p><p>虽然这样能保证内存空间充分使用，并且也没有标记复制算法那么繁杂，但是缺点是效率比前两者都低。甚至，由于需要修改对象在内存中的位置，此时程序必须要暂停才可以，在极端情况下，可能会导致整个程序发生停顿</p><p>一般将标记清除算法和标记整理算法混合使用，在内存空间还不是很凌乱的时候，采用标记清除算法，当内存空间凌乱到一定程度后，进行一次标记整理算法</p><h3 id="分代收集机制"><a href="#分代收集机制" class="headerlink" title="分代收集机制"></a>分代收集机制</h3><p>JVM将堆内存划分为<strong>新生代</strong>、<strong>老年代</strong>和<strong>永久代</strong>（其中永久代是HotSpot虚拟机特有的概念，在JDK8之前方法区实际上就是采用的永久代作为实现，而在JDK8之后，方法区由<strong>元空间</strong>实现，并且使用的是本地内存，容量大小取决于物理机实际大小）</p><p>不同的分代内存回收机制也存在一些不同之处，在HotSpot虚拟机中，新生代被划分为三块，一块较大的Eden空间和两块较小的Survivor空间，默认比例为8：1：1，老年代的GC评率相对较低，永久代一般存放类信息等（其实就是方法区的实现）</p><p><img src="/inori/4af053c8/heap_memo.png" alt="heap_memo"></p><p>新生代</p><ul><li>存放新创建的对象</li><li>特点：<ul><li>大多数对象的生命周期很短，因此新生代是垃圾回收最频繁的区域</li><li>新生代采用<u>标记-复制算法</u>进行垃圾回收</li></ul></li><li>分区：<ul><li><strong>Eden区</strong>：新创建的对象首先分配到 Eden 区</li><li><strong>Survivor区</strong>：分为 <code>From</code> 区和 <code>To</code> 区，用于存放经过垃圾回收后仍然存活的对象</li></ul></li></ul><p>老年代</p><ul><li>存放生命周期较长的对象</li><li>特点：<ul><li>对象在新生代经过多次垃圾回收后仍然存活，会被晋升到老年代</li><li>老年代的垃圾回收频率较低，但每次回收的时间较长</li><li>老年代采用<u>标记-清除算法</u>或<u>标记-整理算法</u>进行垃圾回收</li></ul></li></ul><p>新生代的垃圾回收称为<strong>Minor GC</strong>：</p><p>首先，所有新创建的对象，在一开始都会进入到新生代的Eden区（如果是大对象会被直接丢进老年代），在进行新生代区域的垃圾回收时，首先会对所有新生代区域的对象进行扫描，并回收那些不再使用对象</p><p>接着，在一次垃圾回收之后，Eden区域没有被回收的对象，会进入到Survivor区。在一开始From和To都是空的，而GC之后，所有Eden区域存活的对象都会直接被放入到To区，最后From和To会发生一次交换，即From区是有数据的，To区是空的</p><p>下一次垃圾回收操作与上面是一样的，不过这时由于我们From区域中已经存在对象了，所有From区的对象会进行一次年龄判定（每经历一轮GC年龄<code>+1</code>，如果对象的年龄大于<code>默认值为15</code>，会直接进入到老年代），在Eden区和From区的存活对象复制到To区之后，清空Eden区和From区，交换From区和To区</p><p><strong>Major GC</strong>是针对老年代（Old Generation）的垃圾回收：</p><p>当老年代空间不足时，从GC Roots开始，标记老年代中的存活对象，使用标记-清除算法清除未标记的对象，再用整理算法将存活对象整理到内存的一端，避免内存碎片</p><p>Full GC 是对整个堆内存（包括新生代、老年代和元空间的垃圾回收：</p><p>触发条件：</p><ul><li><strong>老年代空间不足</strong>：当老年代无法容纳从新生代晋升的对象时，触发 Full GC。</li><li><strong>元空间空间不足</strong>：当元空间无法分配新的类元数据时，触发 Full GC。</li><li>**显式调用 System.gc()**：调用 <code>System.gc()</code> 可能触发 Full GC，但 JVM 不保证立即执行。</li></ul><p>过程：</p><ol><li>新生代回收<ul><li>执行 Minor GC，回收新生代中的垃圾</li></ul></li><li>老年代回收<ul><li>执行 Major GC，回收老年代中的垃圾</li></ul></li><li>元空间回收<ul><li>回收不再使用的类元数据</li></ul></li></ol><table><thead><tr><th><strong>特性</strong></th><th><strong>Minor GC</strong></th><th><strong>Major GC</strong></th><th><strong>Full GC</strong></th></tr></thead><tbody><tr><td><strong>回收区域</strong></td><td>新生代（Eden 区、Survivor 区）。</td><td>老年代。</td><td>整个堆内存（新生代、老年代）和元空间。</td></tr><tr><td><strong>触发条件</strong></td><td>Eden 区空间不足。</td><td>老年代空间不足。</td><td>老年代空间不足、元空间空间不足、显式调用 <code>System.gc()</code>。</td></tr><tr><td><strong>频率</strong></td><td>高，因为大多数对象的生命周期很短。</td><td>低，因为老年代的对象生命周期较长。</td><td>低，触发条件较为严格。</td></tr><tr><td><strong>速度</strong></td><td>快，采用复制算法。</td><td>慢，采用标记-清除或标记-整理算法。</td><td>最慢，需要处理整个堆内存和元空间。</td></tr><tr><td><strong>暂停时间</strong></td><td>短，对应用程序的影响较小。</td><td>较长，对应用程序的影响较大。</td><td>最长，对应用程序的影响最大。</td></tr></tbody></table><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>思考一下，有没有这样一种极端情况（正常情况下新生代的回收率是很高的，所以说不用太担心会经常出现这种问题），在一次GC后，新生代Eden区仍然存在大量的对象超出Survivor区的容量，那么该怎么办？</p><p>这时就需要用到空间分配担保机制了，可以把Survivor区无法容纳的对象直接送到老年代，让老年代进行分配担保</p><p>要是老年代也装不下新生代的数据呢？</p><p>这样的话，首先会判断一下<u>之前的每次垃圾回收进入老年代的平均大小是否小于当前老年代的剩余空间</u></p><ul><li>如果小于，那么说明<strong>也许</strong>可以放得下</li><li>否则，会先来一次Full GC，进行一次大规模垃圾回收，尝试腾出空间，再次判断老年代是否有空间存放</li><li>要是还是装不下，抛出Out Of Memory异常</li></ul><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>JDK8之前，Hotspot虚拟机的方法区是永久代实现的。在JDK8之后不再使用永久代，而是采用了全新的元空间，元空间主要用于存储以下内容：</p><ol><li><strong>类的元数据</strong><ul><li>类的全限定名</li><li>类的父类、接口信息</li><li>类的字段、方法、字节码等</li></ul></li><li><strong>运行时常量池</strong><ul><li>字符串常量、数字常量等</li></ul></li><li><strong>方法区内容</strong></li></ol><p>元空间没有使用堆内存，而是与堆不相连的本地内存区域。所以，理论上系统可以使用的内存有多大，元空间就有多大，所以不会出现永久代存在时的内存溢出问题。元空间中的类元数据在类卸载时会被垃圾回收，且垃圾回收效率比永久代更高</p><p><img src="/inori/4af053c8/jvm2.png" alt="jvm2"></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>这是一款单线程的垃圾收集器，也就是说，当开始进行垃圾回收时，需要暂停所有的线程，直到垃圾收集工作结束。它的新生代收集算法采用的是标记复制算法，老年代采用的是标记整理算法。</p><img src="/inori/4af053c8/serial.png" alt="serial" style="zoom:50%;"><p>这个收集器的缺点是当进入到垃圾回收阶段时，所有的用户线程必须等待GC线程完成工作</p><p>但是在用户的桌面应用场景中，内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收器是可以接受的，所以，在客户端模式（一般用于一些桌面级图形化界面应用程序）下的新生代中，默认垃圾收集器至今依然是Serial收集器</p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>这款垃圾收集器相当于是Serial收集器的多线程版本，它能够支持多线程垃圾收集</p><img src="/inori/4af053c8/parnew.png" alt="parnew" style="zoom:50%;"><p>除了多线程支持以外，其他内容基本与Serial收集器一致，目前某些JVM默认的服务端模式新生代收集器就是使用的ParNew收集器</p><h3 id="Parallel-Scavenge-Parallel-Old收集器"><a href="#Parallel-Scavenge-Parallel-Old收集器" class="headerlink" title="Parallel Scavenge&#x2F;Parallel Old收集器"></a>Parallel Scavenge&#x2F;Parallel Old收集器</h3><p>与ParNew收集器不同的是，它会自动衡量一个吞吐量，并根据吞吐量来决定每次垃圾回收的时间，这种自适应机制，能够很好地权衡当前机器的性能，根据性能选择最优方案</p><p>吞吐量&#x3D;应用程序运行时间&#x2F;总时间（应用程序运行时间 + 垃圾回收时间)×100%，目标是尽可能提高吞吐量，即让应用程序的运行时间占比最大化。</p><ul><li>垃圾回收器会监控应用程序的运行时间和垃圾回收时间。</li><li>如果垃圾回收时间占比超过目标值，垃圾回收器会调整垃圾回收的频率和每次回收的时间，以确保吞吐量目标</li><li>如果吞吐量低于目标值，垃圾回收器可能会减少垃圾回收的频率，延长每次垃圾回收的时间</li><li>如果吞吐量高于目标值，垃圾回收器可能会增加垃圾回收的频率，缩短每次垃圾回收的时间</li></ul><img src="/inori/4af053c8/parallel.png" alt="parallel" style="zoom:50%;"><p>目前JDK8采用的就是这种 Parallel Scavenge + Parallel Old的垃圾回收方案</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器是HotSpot虚拟机中第一款真正意义上的并发（注意这里的并发和之前的并行是有区别的，并发可以理解为同时运行用户线程和GC线程，而并行可以理解为多条GC线程同时工作）收集器，它第一次实现了让垃圾收集线程与用户线程同时工作，他主要采用标记清除算法。</p><img src="/inori/4af053c8/cms.png" alt="cms" style="zoom:50%;"><p>它的垃圾回收分为4个阶段：</p><ul><li>初始标记（需要暂停用户线程）：这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象，速度比较快，不用担心会停顿太长时间</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与应用程序并发运行</li><li>重新标记（需要暂停用户线程）：修正并发标记期间因应用程序运行而导致的标记变化</li><li>并发清除：最后就可以直接将所有标记好的无用对象进行删除，因为这些对象程序中也用不到了，所以可以与用户线程并发运行</li><li>并发重置：重置CMS收集器的内部状态，为下一次垃圾回收做准备</li></ul><p>虽然它的优点非常之大，但是缺点也是显而易见的，我们之前说过，标记清除算法会产生大量的内存碎片，导致可用连续空间逐渐变少，长期这样下来，会有更高的概率触发Full GC，并且在与用户线程并发执行的情况下，也会占用一部分的系统资源，导致用户线程的运行速度一定程度上减慢</p><p>从JDK9开始，CMS收集器被标记为弃用（Deprecated），在JDK14中完全移除</p><h3 id="Garbage-First-G1-收集器"><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First (G1) 收集器"></a>Garbage First (G1) 收集器</h3><p>它是一款主要面向于服务端的垃圾收集器，并且在JDK9时，取代了JDK8默认的Parallel Scavenge + Parallel Old的回收方案</p><p>垃圾回收分为<code>Minor GC</code>、<code>Major GC </code>和<code>Full GC</code>，它们分别对应的是新生代，老年代和整个堆内存的垃圾回收，而G1收集器绕过了这些，它将整个Java堆划分成多个大小相同的独立<code>Region</code>块，每个<code>Region</code>块的大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且都为2的N次幂。所有的<code>Region</code>大小相同，且在JVM的整个生命周期内不会发生改变，G1优先回收垃圾最多的区域</p><p>每一个<code>Region</code>都可以根据需要，自由决定扮演哪个角色（Eden、Survivor和老年代），收集器会根据对应的角色采用不同的回收策略。此外，G1收集器还存在一个<code>Humongous</code>区域，它专门用于存放大对象（一般认为大小超过了Region容量一半的对象为大对象）这样，新生代、老年代在物理上，不再是一个连续的内存区域，而是到处分布的</p><img src="/inori/4af053c8/g1.png" alt="g1" style="zoom:50%;"><p>回收过程与CMS大体类似，分为以下四个步骤：</p><ul><li>初始标记（暂停用户线程）：仅仅只是标记GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿</li><li>并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行</li><li>最终标记（暂停用户线程）：对用户线程做一个短暂的暂停，用于处理并发标记阶段漏标的那部分对象</li><li>筛选回收：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多个收集器线程并行完成的</li></ul><img src="/inori/4af053c8/g1_process.png" alt="g1_process" style="zoom:50%;"><h2 id="其他引用类型"><a href="#其他引用类型" class="headerlink" title="其他引用类型"></a>其他引用类型</h2><p>在Java中，如果变量是一个对象类型的，那么它实际上存放的是对象的引用，但是如果是一个基本类型，那么存放的就是基本类型的值。平时代码中类似于<code>Object o = new Object()</code>这样的的引用类型，细分之后可以称为<code>强引用</code>。</p><p>当JVM内存空间不足时，JVM宁愿抛出OutOfMemoryError使程序异常终止，也不会靠随意回收具有强引用的存活对象来解决内存不足的问题</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>软引用不像强引用那样不可回收，当JVM认为内存不足时，会去试图回收软引用指向的对象，即JVM会确保在抛出<code>OutOfMemoryError</code>之前，清理软引用指向的对象。如果内存充足，是不会轻易被回收的</p><p>可以通过以下方式来创建一个软引用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//强引用写法：Object obj = new Object();</span></span><br><span class="line">        <span class="comment">//软引用写法：</span></span><br><span class="line">        SoftReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        <span class="comment">//使用get方法就可以获取到软引用所指向的对象了</span></span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>软引用还存在一个带队列的构造方法，软引用可以和一个引用队列联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用本身加入到与之关联的引用队列中</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用比软引用的生命周期还要短，在进行垃圾回收时，不管当前内存空间是否充足，都会回收它的内存</p><p>创建一个弱引用：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        WeakReference&lt;Object&gt; reference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法和软引用是差不多的，但是如果在这之前进行一次GC：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//手动GC</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;软引用对象：&quot;</span>+softReference.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;弱引用对象：&quot;</span>+weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>弱引用对象被回收了，而软引用对象没有被回收。同样的，它也支持ReferenceQueue，和软引用用法一致。</p><p><code>WeakHashMap</code>是一种类似于弱引用的HashMap类，如果Map中的Key没有其他引用那么此Map会自动丢弃此键值对：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        WeakHashMap&lt;Integer, String&gt; weakHashMap = <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>&lt;&gt;();</span><br><span class="line">        weakHashMap.put(a, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line"></span><br><span class="line">        a = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        System.out.println(weakHashMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当变量a的引用断开后，这时只有WeakHashMap本身对此对象存在引用，所以在GC之后，这个键值对就自动被舍弃了。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>虚引用相当于没有引用，随时都有可能会被回收。虚引用是最弱的一种引用类型，主要用于跟踪对象被垃圾回收的时机，通常用于实现更精细的资源管理或清理机制。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个虚引用，指向 obj，并关联引用队列</span></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 虚引用的 get() 方法始终返回 null</span></span><br><span class="line">        System.out.println(<span class="string">&quot;PhantomRef.get(): &quot;</span> + phantomRef.get()); <span class="comment">// 输出 null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 obj 置为 null，使其成为垃圾</span></span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查引用队列</span></span><br><span class="line">        <span class="keyword">if</span> (queue.poll() != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象已被回收，虚引用被加入队列&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对象未被回收&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>虚引用的 <code>get()</code> 方法始终返回 <code>null</code>，因此无法通过虚引用访问对象</li><li>当对象被垃圾回收时，虚引用会被加入到引用队列中</li><li>通过检查引用队列，可以确定对象是否已被回收</li></ul><h3 id="四种引用对象对比"><a href="#四种引用对象对比" class="headerlink" title="四种引用对象对比"></a>四种引用对象对比</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>强引用</strong></th><th><strong>软引用</strong></th><th><strong>弱引用</strong></th><th><strong>虚引用</strong></th></tr></thead><tbody><tr><td><strong>引用强度</strong></td><td>最强</td><td>较强</td><td>较弱</td><td>最弱</td></tr><tr><td><strong>回收时机</strong></td><td>不会被垃圾回收</td><td>内存不足时回收</td><td>下一次垃圾回收时回收</td><td>对象被回收后加入引用队列</td></tr><tr><td><strong><code>get()</code> 方法</strong></td><td>返回对象</td><td>返回对象（如果未被回收）</td><td>返回对象（如果未被回收）</td><td>始终返回 <code>null</code></td></tr><tr><td><strong>使用场景</strong></td><td>默认引用类型</td><td>缓存</td><td>缓存、监听器</td><td>对象回收的跟踪、资源管理</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/JVM/">JVM</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/4af053c8.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JVM概述与内存管理</title>
      <link>http://example.com/inori/a89a12f2.html</link>
      <guid>http://example.com/inori/a89a12f2.html</guid>
      <pubDate>Thu, 13 Mar 2025 02:19:28 GMT</pubDate>
      
      <description>JVM内存管理部分</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="JVM启动流程"><a href="#JVM启动流程" class="headerlink" title="JVM启动流程"></a>JVM启动流程</h1><p>虚拟机的启动入口位于<code>jdk/src/share/bin/java.c</code>的<code>JLI_Launch</code>函数，整个流程分为如下几个步骤：</p><ol><li>配置JVM装载环境</li><li>解析虚拟机参数</li><li>设置线程栈大小</li><li>执行JavaMain方法</li></ol><p><code>JLI_Launch</code>函数的定义，在入口点的参数有很多个，其中包括当前的完整版本名称、简短版本名称、运行参数、程序名称、启动器名称等：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">JLI_Launch</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv,              <span class="comment">/* main argc, argc */</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> jargc, <span class="type">const</span> <span class="type">char</span>** jargv,          <span class="comment">/* java args */</span></span></span><br><span class="line"><span class="params">        <span class="type">int</span> appclassc, <span class="type">const</span> <span class="type">char</span>** appclassv,  <span class="comment">/* app classpath */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* fullversion,                <span class="comment">/* full version defined */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* dotversion,                 <span class="comment">/* dot version defined */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* pname,                      <span class="comment">/* program name */</span></span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span>* lname,                      <span class="comment">/* launcher name */</span></span></span><br><span class="line"><span class="params">        jboolean javaargs,                      <span class="comment">/* JAVA_ARGS */</span></span></span><br><span class="line"><span class="params">        jboolean cpwildcard,                    <span class="comment">/* classpath wildcard */</span></span></span><br><span class="line"><span class="params">        jboolean javaw,                         <span class="comment">/* windows-only javaw */</span></span></span><br><span class="line"><span class="params">        jint     ergo_class                     <span class="comment">/* ergnomics policy */</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>首先会进行一些初始化操作以及Debug信息打印配置等：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">InitLauncher(javaw);</span><br><span class="line">DumpState();</span><br><span class="line"><span class="keyword">if</span> (JLI_IsTraceLauncher()) &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Command line args:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc ; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    AddOption(<span class="string">&quot;-Dsun.java.launcher.diag=true&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着选择合适的JRE版本：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Make sure the specified version of the JRE is running.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are three things to note about the SelectVersion() routine:</span></span><br><span class="line"><span class="comment"> *  1) If the version running isn&#x27;t correct, this routine doesn&#x27;t</span></span><br><span class="line"><span class="comment"> *     return (either the correct version has been exec&#x27;d or an error</span></span><br><span class="line"><span class="comment"> *     was issued).</span></span><br><span class="line"><span class="comment"> *  2) Argc and Argv in this scope are *not* altered by this routine.</span></span><br><span class="line"><span class="comment"> *     It is the responsibility of subsequent code to ignore the</span></span><br><span class="line"><span class="comment"> *     arguments handled by this routine.</span></span><br><span class="line"><span class="comment"> *  3) As a side-effect, the variable &quot;main_class&quot; is guaranteed to</span></span><br><span class="line"><span class="comment"> *     be set (if it should ever be set).  This isn&#x27;t exactly the</span></span><br><span class="line"><span class="comment"> *     poster child for structured programming, but it is a small</span></span><br><span class="line"><span class="comment"> *     price to pay for not processing a jar file operand twice.</span></span><br><span class="line"><span class="comment"> *     (Note: This side effect has been disabled.  See comment on</span></span><br><span class="line"><span class="comment"> *     bugid 5030265 below.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SelectVersion(argc, argv, &amp;main_class);</span><br></pre></td></tr></table></figure><p>接着创建JVM执行环境，例如需要确定数据模型，是32位还是64位，以及jvm本身的一些配置在jvm.cfg文件中读取和解析：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CreateExecutionEnvironment(&amp;argc, &amp;argv,</span><br><span class="line">                               jrepath, <span class="keyword">sizeof</span>(jrepath),</span><br><span class="line">                               jvmpath, <span class="keyword">sizeof</span>(jvmpath),</span><br><span class="line">                               jvmcfg,  <span class="keyword">sizeof</span>(jvmcfg));</span><br></pre></td></tr></table></figure><p>此函数只在头文件中定义，具体的实现是根据不同平台而定的。接着会动态加载jvm.so这个共享库，并把jvm.so中的相关函数导出并且初始化，而启动JVM的函数也在其中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!LoadJavaVM(jvmpath, &amp;ifn)) &#123;</span><br><span class="line">    <span class="keyword">return</span>(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是对JVM进行初始化：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> JVMInit(&amp;ifn, threadStackSize, argc, argv, mode, what, ret);</span><br></pre></td></tr></table></figure><p>初始化后在新的线程中执行<code>JavaMain</code>函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Initialize the virtual machine */</span></span><br><span class="line">start = CounterGet();</span><br><span class="line"><span class="keyword">if</span> (!InitializeJVM(&amp;vm, &amp;env, &amp;ifn)) &#123;</span><br><span class="line">    JLI_ReportErrorMessage(JVM_ERROR1);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步初始化虚拟机，如果报错直接退出。</p><p>接着加载主类，因为主类Java程序的入口点：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get the application&#x27;s main class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * See bugid 5030265.  The Main-Class name has already been parsed</span></span><br><span class="line"><span class="comment"> * from the manifest, but not parsed properly for UTF-8 support.</span></span><br><span class="line"><span class="comment"> * Hence the code here ignores the value previously extracted and</span></span><br><span class="line"><span class="comment"> * uses the pre-existing code to reextract the value.  This is</span></span><br><span class="line"><span class="comment"> * possibly an end of release cycle expedient.  However, it has</span></span><br><span class="line"><span class="comment"> * also been discovered that passing some character sets through</span></span><br><span class="line"><span class="comment"> * the environment has &quot;strange&quot; behavior on some variants of</span></span><br><span class="line"><span class="comment"> * Windows.  Hence, maybe the manifest parsing code local to the</span></span><br><span class="line"><span class="comment"> * launcher should never be enhanced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hence, future work should either:</span></span><br><span class="line"><span class="comment"> *     1)   Correct the local parsing code and verify that the</span></span><br><span class="line"><span class="comment"> *          Main-Class attribute gets properly passed through</span></span><br><span class="line"><span class="comment"> *          all environments,</span></span><br><span class="line"><span class="comment"> *     2)   Remove the vestages of maintaining main_class through</span></span><br><span class="line"><span class="comment"> *          the environment (and remove these comments).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This method also correctly handles launching existing JavaFX</span></span><br><span class="line"><span class="comment"> * applications that may or may not have a Main-Class manifest entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mainClass = LoadMainClass(env, mode, what);</span><br></pre></td></tr></table></figure><p>某些没有主方法的Java程序比如JavaFX应用，会获取<code>ApplicationMainClass</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * In some cases when launching an application that needs a helper, e.g., a</span></span><br><span class="line"><span class="comment"> * JavaFX application with no main method, the mainClass will not be the</span></span><br><span class="line"><span class="comment"> * applications own main class but rather a helper class. To keep things</span></span><br><span class="line"><span class="comment"> * consistent in the UI we need to track and report the application main class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appClass = GetApplicationClass(env);</span><br></pre></td></tr></table></figure><p>初始化完成：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * PostJVMInit uses the class name as the application name for GUI purposes,</span></span><br><span class="line"><span class="comment"> * for example, on OSX this sets the application name in the menu bar for</span></span><br><span class="line"><span class="comment"> * both SWT and JavaFX. So we&#x27;ll pass the actual application class here</span></span><br><span class="line"><span class="comment"> * instead of mainClass as that may be a launcher or helper class instead</span></span><br><span class="line"><span class="comment"> * of the application class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PostJVMInit(env, appClass, vm);</span><br></pre></td></tr></table></figure><p>获取主类中的主方法:       </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The LoadMainClass not only loads the main class, it will also ensure</span></span><br><span class="line"><span class="comment"> * that the main method&#x27;s signature is correct, therefore further checking</span></span><br><span class="line"><span class="comment"> * is not required. The main method is invoked here so that extraneous java</span></span><br><span class="line"><span class="comment"> * stacks are not in the application stack trace.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">mainID = (*env)-&gt;GetStaticMethodID(env, mainClass, <span class="string">&quot;main&quot;</span>, <span class="string">&quot;([Ljava/lang/String;)V&quot;</span>);</span><br></pre></td></tr></table></figure><p>在字节码中<code>void main(String[] args)</code>表示为<code>([Ljava/lang/String;)V</code>。接着调用主方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Invoke main method. */</span></span><br><span class="line">(*env)-&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);</span><br></pre></td></tr></table></figure><p>调用后，Java程序开始运行，直到走到主方法的最后一行返回：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The launcher&#x27;s exit code (in the absence of calls to</span></span><br><span class="line"><span class="comment"> * System.exit) will be non-zero if main threw an exception.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ret = (*env)-&gt;ExceptionOccurred(env) == <span class="literal">NULL</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">LEAVE();</span><br></pre></td></tr></table></figure><p>在最后LEAVE函数中会销毁JVM。</p><p><img src="/inori/a89a12f2/jvm_launch.png" alt="jvm_launch"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>在C&#x2F;C++中，经常通过使用申请内存的方式来创建对象或是存放某些数据，但是这样也带来了一些额外的问题，要在何时释放这些内存，怎么才能使得内存的使用最高效？</p><p>比如通过C语言动态申请内存，并存放数据：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//动态申请4个int大小的内存空间</span></span><br><span class="line">    <span class="type">int</span>* memory = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//修改第一个int空间的值</span></span><br><span class="line">    memory[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//修改第二个int空间的值</span></span><br><span class="line">    memory[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//遍历内存区域中所有的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, memory[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放指针所指向的内存区域</span></span><br><span class="line">    <span class="built_in">free</span>(memory);</span><br><span class="line">    <span class="comment">//最后将指针赋值为NULL</span></span><br><span class="line">    memory = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中，这种操作实际上是不允许的，Java只支持直接使用基本数据类型和对象类型，至于内存到底如何分配，并不是由我们来处理，而是JVM帮助我们进行控制，这样可以节省很多内存上的工作，虽然带来了很大的便利，但是，一旦出现内存问题，我们就无法像C&#x2F;C++那样对所管理的内存进行合理地处理，因为所有的内存操作都是由JVM在进行，只有了解了JVM的内存管理机制，才能够在出现内存相关问题时找到解决方案。</p><h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p>JVM对内存的管理采用的是分区治理，不同的内存区域有着各自的职责所在。</p><p><img src="/inori/a89a12f2/jvm_memory.png" alt="jvm_memory"></p><p>内存区域一共分为5个区域：方法区，堆，虚拟机栈，本地方法栈，程序计数器。其中方法区和堆是所有线程共享的区域，随着虚拟机的创建而创建，虚拟机的结束而销毁，而虚拟机栈、本地方法栈、程序计数器都是线程之间相互隔离的，每个线程都有一个自己的区域，并且线程启动时会自动创建，结束之后会自动销毁。内存划分完成之后，JVM执行引擎和本地库接口，也就是Java程序开始运行之后就会根据分区合理地使用对应区域的内存了。</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>JVM中的程序计数器是当前线程所执行字节码的指令地址指示器。字节码解释器在工作时会根据程序计数器的值执行指令，并在执行完毕后更新程序计数器的值，以指向下一条即将执行的指令。</p><p>在Java的多线程环境中，每个线程都有独立的程序计数器。JVM通过线程调度机制（如操作系统的时间片轮转算法）切换线程的执行。当一个线程被切换出去时，它的程序计数器会记录当前执行的字节码指令地址；当该线程再次被调度执行时，JVM会根据程序计数器的值继续执行后续指令。</p><p>程序计数器只需要记录当前线程执行的字节码指令地址，因此它占用的内存非常小，通常是JVM内存结构中占用最少的部分。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈就是一个非常关键的部分，看名字就知道它是一个栈结构，每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧（其实就是栈里面的一个元素），栈帧中包括了当前方法的一些信息，比如局部变量表、操作数栈、动态链接、方法出口等。</p><img src="/inori/a89a12f2/vmstack.png" alt="vmstack" style="zoom:70%;"><ul><li>其中局部变量表就是方法中的局部变量，局部变量表在class文件中就已经定义好了</li><li>操作数栈就是之前字节码执行时使用到的栈结构</li><li>每个栈帧保存了一个可以指向当前方法所在类的运行时常量池，当前方法中如果需要调用其他方法的时候，能够从<strong>运行时常量池</strong>中找到对应的符号引用，然后将符号引用转换为直接引用，然后就能直接调用对应方法，这就是动态链接</li><li>方法出口，也就是方法该如何结束，是抛出异常还是正常返回。</li></ul><p>举个例子：              </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> a();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">a</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">b</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">c</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们的主方法执行后，会依次执行三个方法<code>a() -&gt; b() -&gt; c() -&gt; 返回</code></p><p>首先是<code>main</code>方法调用：</p><ul><li>局部变量表：<code>args</code>（<code>main</code> 方法的参数）</li><li>操作数栈：空</li><li>动态链接：指向 <code>main</code> 方法的引用</li><li>返回地址：无（<code>main</code> 方法是程序的入口）</li></ul><p>然后<code>main</code>方法调用<code>a()</code>：</p><ul><li>局部变量表：空（<code>a()</code> 无参数）</li><li>操作数栈：空</li><li>动态链接：指向 <code>a()</code> 方法的引用</li><li>返回地址：<code>main</code> 方法中调用 <code>a()</code> 的下一条指令</li><li>栈状态，由顶到底：<code>a(),main()</code></li></ul><p>…</p><p>到<code>c()</code>调用后：</p><p>栈帧</p><ul><li>局部变量表：<code>a = 10</code>，<code>b = 20</code></li><li>操作数栈：存储 <code>a + b</code> 的计算结果</li><li>动态链接：指向 <code>c()</code> 方法的引用</li><li>返回地址：<code>b()</code> 方法中调用 <code>c()</code> 的下一条指令</li><li>栈状态，由顶到底：<code>c(),b(),a(),main()</code></li></ul><p>然后按照栈弹出顺序返回，最后输出结果。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈与虚拟机栈作用差不多，用于支持Native方法（非 Java 方法，通常用 C&#x2F;C++ 实现）的执行</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是整个Java应用程序共享的区域，它用于存储所有的类信息、常量、静态变量、动态编译缓存等数据，可以大致分为两个部分，一个是类信息表，一个是运行时常量池</p><img src="/inori/a89a12f2/jvm_method.png" alt="jvm_method" style="zoom:67%;"><p>主要用于存储以下内容：</p><ol><li><strong>类信息</strong>：<ul><li>类的全限定名</li><li>类的直接父类的全限定名</li><li>类的修饰符（如 <code>public</code>、<code>abstract</code>、<code>final</code> 等）</li><li>类的接口信息</li></ul></li><li><strong>字段信息</strong>：<ul><li>字段的名称、类型、修饰符（如 <code>public</code>、<code>private</code>、<code>static</code> 等）</li></ul></li><li><strong>方法信息</strong>：<ul><li>方法的名称、返回类型、参数列表、修饰符（如 <code>public</code>、<code>static</code> 等）</li><li>方法的字节码（Bytecode）、操作数栈、局部变量表等</li></ul></li><li><strong>运行时常量池（Runtime Constant Pool）</strong>：<ul><li>存储编译期生成的字面量（如字符串、数字常量）和符号引用（如类、方法、字段的引用）</li><li>运行时常量池是方法区的一部分，每个类或接口都有自己的运行时常量池</li></ul></li><li><strong>静态变量（Static Variables）</strong>：<ul><li>类的静态变量（<code>static</code> 修饰的变量）存储在方法区中</li></ul></li><li><strong>类加载器引用</strong>：<ul><li>存储加载该类的类加载器的引用</li></ul></li><li><strong>方法代码</strong>：<ul><li>存储方法的字节码和相关的元数据</li></ul></li></ol><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是整个Java应用程序共享的区域，也是整个虚拟机最大的一块内存空间，此区域的职责就是存放和管理对象和数组，后续提到的垃圾回收机制也是主要作用于这一部分内存区域</p><h2 id="爆堆与爆栈"><a href="#爆堆与爆栈" class="headerlink" title="爆堆与爆栈"></a>爆堆与爆栈</h2><p>在Java程序运行时，内存容量不可能是无限制的，当我们的对象创建过多或是数组容量过大时，就会导致我们的堆内存不足以存放更多新的对象或是数组，这时就会出现错误，比如： </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOverflowExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 不断创建对象，耗尽堆内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后JVM会抛出 <code>java.lang.OutOfMemoryError: Java heap space</code> 错误，也就是堆内存溢出错误。</p><p>当程序在栈内存中分配的栈帧过多，导致栈内存耗尽时，就会发生爆栈。栈内存用于存储方法调用的栈帧，包括局部变量、操作数栈、方法返回地址等，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        infiniteRecursion(); <span class="comment">// 无限递归，导致爆栈</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">infiniteRecursion</span><span class="params">()</span> &#123;</span><br><span class="line">        infiniteRecursion(); <span class="comment">// 递归调用自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后JVM会抛出<code>java.lang.StackOverflowError</code>错误。</p><table><thead><tr><th><strong>特性</strong></th><th><strong>爆堆（Heap Overflow）</strong></th><th><strong>爆栈（Stack Overflow）</strong></th></tr></thead><tbody><tr><td><strong>内存区域</strong></td><td>堆内存</td><td>栈内存</td></tr><tr><td><strong>存储内容</strong></td><td>对象实例、数组</td><td>方法调用的栈帧（局部变量、操作数栈、方法返回地址等）</td></tr><tr><td><strong>错误类型</strong></td><td><code>java.lang.OutOfMemoryError: Java heap space</code></td><td><code>java.lang.StackOverflowError</code></td></tr><tr><td><strong>常见原因</strong></td><td>内存泄漏、对象过多、堆内存设置过小</td><td>递归调用过深、栈内存设置过小</td></tr><tr><td><strong>解决方法</strong></td><td>检查内存泄漏、增加堆内存、优化代码</td><td>检查递归终止条件、增加栈内存、优化代码</td></tr></tbody></table><h2 id="申请堆外内存"><a href="#申请堆外内存" class="headerlink" title="申请堆外内存"></a>申请堆外内存</h2><p>除了堆内存可以存放对象数据以外，我们也可以申请堆外内存（直接内存），也就是不受JVM管控的内存区域，这部分区域的内存需要我们自行去申请和释放，实际上本质就是JVM通过C&#x2F;C++调用<code>malloc</code>函数申请的内存。直接内存会受到本机最大内存的限制，有可能抛出<code>OutOfMemoryError</code>异常</p><p>这里需要提到一个堆外内存操作类：<code>Unsafe</code>，这个类不让new，也没有直接获取方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Unsafe</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">        sun.reflect.Reflection.registerMethodsToFilter(Unsafe.class, <span class="string">&quot;getUnsafe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Unsafe</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Unsafe</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(caller.getClassLoader()))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Unsafe&quot;</span>);   <span class="comment">//不是JDK的类，不让用。</span></span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过反射拿到Unsafe类之后，就可以开始申请堆外内存了，比如现在要申请一个int大小的内存空间，并在此空间中存放一个int类型的数据：                   </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">    <span class="comment">// 通过反射拿到Unsafe类</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">unsafeField</span> <span class="operator">=</span> Unsafe.class.getDeclaredFields()[<span class="number">0</span>];</span><br><span class="line">    unsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) unsafeField.get(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请4字节大小的内存空间，并得到对应位置的地址</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">address</span> <span class="operator">=</span> unsafe.allocateMemory(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//在对应的地址上设定int的值</span></span><br><span class="line">    unsafe.putInt(address, <span class="number">6666666</span>);</span><br><span class="line">    <span class="comment">//获取对应地址上的Int型数值</span></span><br><span class="line">    System.out.println(unsafe.getInt(address));<span class="comment">// 输出666666</span></span><br><span class="line">    <span class="comment">//释放申请到的内容</span></span><br><span class="line">    unsafe.freeMemory(address);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于内存已经释放，这时数据就没了</span></span><br><span class="line">    System.out.println(unsafe.getInt(address));<span class="comment">// 野指针，输出随机数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/JVM/">JVM</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/a89a12f2.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>设计模式——行为型模式</title>
      <link>http://example.com/inori/ec6efbf1.html</link>
      <guid>http://example.com/inori/ec6efbf1.html</guid>
      <pubDate>Mon, 10 Mar 2025 05:41:47 GMT</pubDate>
      
      <description>设计模式中的行为型模式</description>
      
      
      
      <content:encoded><![CDATA[<p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式分为：</p><ul><li>模板方法模式</li><li>策略模式</li><li>命令模式</li><li>职责链模式</li><li>状态模式</li><li>观察者模式</li><li>中介者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li><li>解释器模式</li></ul><p>以上11种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式</p><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2><p>解释器顾名思义，就是对语言进行解释，根据不同的语义来做不同的事情。笼统点来讲就是给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。</p><p>比如计算器就是根据输入的算式，去进行解析，并根据不同的运算符来不断进行计算。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当语言的文法较为简单，且执行效率不是关键问题时</li><li>当问题重复出现，且可以用一种简单的语言来进行表达时</li><li>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候</li></ul><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在浏览器中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p><p>不过备忘录模式为了去保存对象的状态，会占用大量的资源，尤其是那种属性很多的对象，需要合理的使用才能保证程序稳定运行。</p><h2 id="模版方法模式"><a href="#模版方法模式" class="headerlink" title="模版方法模式"></a>模版方法模式</h2><p>模板方法模式可以定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但另外一些步骤的具体实现还未知，或者说另外一些步骤的实现与具体的环境相关，暂时还不能在这个类中实现。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BankClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">workProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.getNum();<span class="comment">//取号</span></span><br><span class="line">        <span class="built_in">this</span>.queue();<span class="comment">// 排队</span></span><br><span class="line">        <span class="built_in">this</span>.businessHandling();<span class="comment">// 具体业务办理</span></span><br><span class="line">        <span class="built_in">this</span>.evaluate();<span class="comment">// 工作人员评价</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取号都是一样的，直接在该类中写好逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;取号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;排队&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个人办理业务的逻辑和流程可能是不一样的，要在子类中实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">businessHandling</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evaluate</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对工作人员打分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonA</span> <span class="keyword">extends</span> <span class="title class_">BankClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">businessHandling</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;取钱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonB</span> <span class="keyword">extends</span> <span class="title class_">BankClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;存钱&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//A来办理业务</span></span><br><span class="line">        <span class="type">AbstractBank</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonA</span>();</span><br><span class="line">        A.workProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//B来办理业务</span></span><br><span class="line">        <span class="type">AbstractBank</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PersonB</span>();</span><br><span class="line">        B.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：为防止恶意操作，一般模板方法都加上<code>final</code>关键字</p></blockquote><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，提高了代码阅读的难度</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制</li></ul><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p><p>举例，现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 numStart 及以上的所有天数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(numStart, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理 numStart 到 numEnd 的天数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leave.getNum() &gt;= <span class="built_in">this</span>.numStart &amp;&amp; leave.getNum() &lt;= <span class="built_in">this</span>.numEnd) &#123;</span><br><span class="line">            <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line">            System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> != <span class="built_in">this</span>.nextHandler) &#123;</span><br><span class="line">            <span class="built_in">this</span>.nextHandler.submit(leave);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无更高权限领导处理，流程终止&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//请假条</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导</span></span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><p>降低了对象之间的耦合度</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的if或者if···else语句</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用</li></ul><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理</p><p>举例，去餐厅点单时，顾客只需要把订单交给服务器，然后等待上菜即可，不用关心菜是如何做出来的，是谁做的，对于厨师也相同，只需要按照订单做菜即可，不需要关心是谁点的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;<span class="comment">//只需要定义一个统一的执行方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有接受者对象</span></span><br><span class="line">    <span class="keyword">private</span> SeniorChef receiver;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCommand</span><span class="params">(SeniorChef receiver, Order order)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">        <span class="built_in">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>  &#123;</span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的订单：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = order.getFoodDic().keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            receiver.makeFood(order.getFoodDic().get(key),key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);<span class="comment">//停顿一下 模拟做饭的过程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的饭弄好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">// 餐桌号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> diningTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来存储餐名并记录份数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDiningTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDiningTable</span><span class="params">(<span class="type">int</span> diningTable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.diningTable = diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">getFoodDic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foodDic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoodDic</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        foodDic.put(name,num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资深大厨类 是命令的Receiver</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeniorChef</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">(<span class="type">int</span> num,String foodName)</span> &#123;</span><br><span class="line">        System.out.println(num + <span class="string">&quot;份&quot;</span> + foodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Command&gt; commands;<span class="comment">//可以持有很多的命令对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Waitor</span><span class="params">()</span> &#123;</span><br><span class="line">        commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command cmd)</span>&#123;</span><br><span class="line">        commands.add(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发出命令 喊 订单来了，厨师开始执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderUp</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;新订单来了.......&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; commands.size(); i++) &#123;</span><br><span class="line">            <span class="type">Command</span> <span class="variable">cmd</span> <span class="operator">=</span> commands.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">                cmd.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建2个order</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order1.setDiningTable(<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;西红柿鸡蛋面&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;小杯可乐&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order2.setDiningTable(<span class="number">3</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;尖椒肉丝盖饭&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;小杯雪碧&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建接收者</span></span><br><span class="line">        SeniorChef receiver=<span class="keyword">new</span> <span class="title class_">SeniorChef</span>();</span><br><span class="line">        <span class="comment">//将订单和接收者封装成命令对象</span></span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order1);</span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order2);</span><br><span class="line">        <span class="comment">//创建调用者 waitor</span></span><br><span class="line">        <span class="type">Waitor</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waitor</span>();</span><br><span class="line">        invoker.setCommand(cmd1);</span><br><span class="line">        invoker.setCommand(cmd2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将订单带到柜台 并向厨师喊 订单来了</span></span><br><span class="line">        invoker.orderUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，满足“开闭原则”，对扩展比较灵活</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复</li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类</li><li>系统结构更加复杂</li></ul><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作</li></ul><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。</p><p>策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><p>举例，一家百货公司在定年度的促销活动。针对不同的节日推出不同的促销活动，由促销员将促销活动展示给客户</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义百货公司所有促销活动的共同接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义具体策略角色,每个节日具体的促销活动</span></span><br><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义环境角色，用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SalesMan</span> <span class="variable">salesMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SalesMan</span>(<span class="keyword">new</span> <span class="title class_">StrategyA</span>);</span><br><span class="line">        salesMan.salesManShow();<span class="comment">// 推销</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合开闭原则</p></li><li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想</p></li></ul><p><strong>缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量</li></ul><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为</li></ul><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示</p><p>举例，定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现:-</p><p>定义迭代器接口，声明hasNext、next方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Student <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的迭代器类，重写所有的抽象方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">currentStudent</span> <span class="operator">=</span> list.get(position);</span><br><span class="line">        position ++;</span><br><span class="line">        <span class="keyword">return</span> currentStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的容器类，重写所有的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();  <span class="comment">// 学生列表</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.add(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentIteratorImpl</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li>支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足开闭原则要求</li></ul><h3 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当需要为聚合对象提供多种遍历方式时</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时</li></ul><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式也叫做调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p><p>比如我们想要去外面租房，但是我们怎么知道哪里有可以租的房子呢？于是我们就会上各大租房APP上去找房源，同样的，如果我们现在有房子需要出租，我们也不知道谁会想要租房子，同样的我们也会把房子挂在租房APP上展示，而当我们去租房时或是出租时，就会有一个称为中介的人来跟我们对接，实际上就是一种中介者模式。</p><p>案例实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;   <span class="comment">//房产中介</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, User&gt; userMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();   <span class="comment">//在出售的房子需要存储一下</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String address, User user)</span>&#123;   <span class="comment">//出售房屋的人，需要告诉中介他的房屋在哪里</span></span><br><span class="line">        userMap.put(address, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(String address)</span>&#123;   <span class="comment">//通过此方法来看看有没有对应的房源</span></span><br><span class="line">        <span class="keyword">return</span> userMap.get(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户有两种角色，一种是租房者，一种是出租者：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;   <span class="comment">//用户可以是出售房屋的一方，也可以是寻找房屋的一方</span></span><br><span class="line">    String name;</span><br><span class="line">    String tel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, String tel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.tel = tel;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">find</span><span class="params">(String address, Mediator mediator)</span>&#123;   <span class="comment">//找房子的话，需要一个中介和你具体想找的地方</span></span><br><span class="line">        <span class="keyword">return</span> mediator.find(address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">&quot; (电话：&quot;</span>+tel+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：                   </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;10086&quot;</span>);   <span class="comment">//出租人</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;小红&quot;</span>, <span class="string">&quot;10010&quot;</span>);   <span class="comment">//找房人</span></span><br><span class="line">    <span class="type">Mediator</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Mediator</span>();   <span class="comment">// 中介</span></span><br><span class="line"></span><br><span class="line">    mediator.register(<span class="string">&quot;地址A&quot;</span>, user0);   <span class="comment">// 先把房子给中介挂上去</span></span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> user1.find(<span class="string">&quot;地址B&quot;</span>, mediator);  <span class="comment">//开始找房子</span></span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>) System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line"></span><br><span class="line">    user = user1.find(<span class="string">&quot;地址A&quot;</span>, mediator);  <span class="comment">//开始找房子</span></span><br><span class="line">    System.out.println(user);   <span class="comment">//成功找到对应房源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中介者模式优化了原有的复杂多对多关系，而是将其简化为一对多的关系。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>在Java中，一个对象的状态发生改变，可能就会影响到其他的对象，与之相关的对象可能也会联动的进行改变。还有我们之前遇到过的监听器机制，当具体的事件触发时，我们在一开始创建的监听器就可以执行相关的逻辑。可以使用观察者模式来实现这样的功能，当对象发生改变时，观察者能够立即观察到并进行一些联动操作。</p><p>观察者模式又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p>我们先定义一个观察者接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;   <span class="comment">//观察者接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;   <span class="comment">//当对象有更新时，会回调此方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来写一个支持观察者的实体类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Observer&gt; observerSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">observe</span><span class="params">(Observer observer)</span> &#123;   <span class="comment">//添加观察者</span></span><br><span class="line">        observerSet.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span> &#123;   <span class="comment">//模拟对象进行修改</span></span><br><span class="line">        observerSet.forEach(Observer::update);   <span class="comment">//当对象发生修改时，会通知所有的观察者，并进行方法回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们就可以测试一下了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    subject.observe(() -&gt; System.out.println(<span class="string">&quot;我是一号观察者！&quot;</span>));</span><br><span class="line">    subject.observe(() -&gt; System.out.println(<span class="string">&quot;我是二号观察者！&quot;</span>));</span><br><span class="line">    subject.modify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就简单实现了一下观察者模式，JDK也提供了实现观察者模式相关的接口：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;    <span class="comment">//java.util包下提供的观察者抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subject</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;   <span class="comment">//继承此抽象类表示支持观察者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">modify</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对对象进行修改！&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.setChanged();    <span class="comment">//当对对象修改后，需要setChanged来设定为已修改状态</span></span><br><span class="line">        <span class="built_in">this</span>.notifyObservers(<span class="keyword">new</span> <span class="title class_">Date</span>());   <span class="comment">//使用notifyObservers方法来通知所有的观察者</span></span><br><span class="line">      <span class="comment">//注意只有已修改状态下通知观察者才会有效，并且可以给观察者传递参数，这里传递了一个时间对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line">    <span class="comment">// 添加subject为观察者</span></span><br><span class="line">    subject.addObserver((o, arg) -&gt; System.out.println(<span class="string">&quot;观察者1：监听到变化，并得到参数：&quot;</span> + arg));</span><br><span class="line">    subject.addObserver((o, arg) -&gt; System.out.println(<span class="string">&quot;观察者1：监听到变化，并得到参数：&quot;</span> + arg));</span><br><span class="line">    subject.addObserver((o, arg) -&gt; System.out.println(<span class="string">&quot;观察者1：监听到变化，并得到参数：&quot;</span> + arg));</span><br><span class="line">  <span class="comment">//注意这里的Observer是java.util包下提供的</span></span><br><span class="line">    subject.modify();   <span class="comment">//进行修改操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>在标准大气压下，水在0度时会结冰变成固态，在0-100度之间时，会呈现液态，100度以上会变成气态，水这种物质在不同的温度下呈现出不同的状态，而Java中的对象，可能也会像这样存在很多种状态，甚至在不同的状态下会有不同的行为，就可以通过状态模式来实现。</p><p>状态模式可以对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><p>举例，假设有一个电灯开关，电灯有两种状态：开和关。按下开关时，电灯会根据当前状态切换行为：</p><p>如果电灯是“开”状态，按下开关后会关闭电灯。</p><p>如果电灯是“关”状态，按下开关后会打开电灯。</p><p>状态抽象类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span>; <span class="comment">// 定义与状态相关的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体状态类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电灯已打开&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OffState</span> <span class="keyword">implements</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电灯已关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电灯开关：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LightSwitch</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> State currentState; <span class="comment">// 当前状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LightSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState = <span class="keyword">new</span> <span class="title class_">OffState</span>(); <span class="comment">// 初始状态为关</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(State state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按下开关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pressSwitch</span><span class="params">()</span> &#123;</span><br><span class="line">        currentState.handle(); <span class="comment">// 委托给当前状态处理</span></span><br><span class="line">        <span class="keyword">if</span> (currentState <span class="keyword">instanceof</span> OffState) &#123;</span><br><span class="line">            setState(<span class="keyword">new</span> <span class="title class_">OnState</span>()); <span class="comment">// 切换到开状态</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentState <span class="keyword">instanceof</span> OnState) &#123;</span><br><span class="line">            setState(<span class="keyword">new</span> <span class="title class_">OffState</span>()); <span class="comment">// 切换到关状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LightSwitch</span> <span class="variable">lightSwitch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LightSwitch</span>();</span><br><span class="line">        lightSwitch.pressSwitch(); <span class="comment">// 打开电灯</span></span><br><span class="line">        lightSwitch.pressSwitch(); <span class="comment">// 关闭电灯</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态模式更加强调当前的对象所处的状态，我们需要根据对象不同的状态决定其他的处理逻辑。</p><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p><p>举例，现在养宠物的人特别多，宠物分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p><p>创建抽象访问者接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建不同的具体访问者角色（主人和其他人），都需要实现 <code>Person</code>接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Owner</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Someone</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象节点——宠物：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义实现<code>Animal</code>接口的具体节点：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义对象结构，即主人的家：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal node : nodeList) &#123;</span><br><span class="line">            node.accept(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        nodeList.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Home</span> <span class="variable">home</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Home</span>();</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>();</span><br><span class="line">        home.action(owner);</span><br><span class="line"></span><br><span class="line">        <span class="type">Someone</span> <span class="variable">someone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Someone</span>();</span><br><span class="line">        home.action(someone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同的访问者对于某一件事务的处理可能会不同。访问者模式把数据结构和作用于结构上的操作解耦，使得操作集合可相对自由地演化。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <category domain="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>http://example.com/inori/ec6efbf1.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>设计模式——结构型模式</title>
      <link>http://example.com/inori/6b3cc4f4.html</link>
      <guid>http://example.com/inori/6b3cc4f4.html</guid>
      <pubDate>Sat, 08 Mar 2025 10:58:02 GMT</pubDate>
      
      <description>设计模式中的结构型模式</description>
      
      
      
      <content:encoded><![CDATA[<p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下7种：</p><ul><li>代理模式</li><li>适配器模式</li><li>装饰者模式</li><li>桥接模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>火车站买票案例，如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。火车站是目标对象，代售点是代理对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代售点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object object;   <span class="comment">//这里需要保存一下被代理的对象，下面需要用到</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用代理对象的对应方法时会进入，需要编写如何进行代理</span></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//method是调用的代理对象的方法，args是实参数组</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(object, args);   <span class="comment">//在代理中调用被代理对象原本的方法</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(station);</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxy</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(</span><br><span class="line">            station.getClass().getClassLoader(),    <span class="comment">//需要传入被代理的类的类加载器</span></span><br><span class="line">            station.getClass().getInterfaces(),    <span class="comment">//需要传入被代理的类的接口列表</span></span><br><span class="line">            handler);    <span class="comment">//最后传入我们实现的代理处理逻辑实现类</span></span><br><span class="line">    proxy.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>JDK提供的动态代理只能使用接口，如果换成我们一开始的抽象类就不可以了，这时我们可以使用一些第三方框架来实现更多方式的动态代理，比如Spring都在使用的CGLib框架，Maven依赖如下：                      </p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于CGlib底层使用ASM框架进行字节码编辑，所以能够实现不仅仅局限于对接口的代理:          </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//火车站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation)enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o： 代理对象</span></span><br><span class="line"><span class="comment">            method： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();<span class="comment">// 代理对象的sell方法被调用时，CGLib会自动调用intercept方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂度</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><p>远程（Remote）代理</p><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节</p></li><li><p>防火墙（Firewall）代理</p><p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器</p></li><li><p>保护（Protect or Access）代理</p><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p></li></ul><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求了解现有组件库中的相关组件的内部结构。</p><h3 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h3><p>想定场景：现有一台电脑只能读取SD卡，现在需要读取TF卡中的内容</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;sd card read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;tf card read msg : hello word tf card&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义适配器类（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>();</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式需要占用一个继承位，如果此时Target不是接口而是抽像类的话，由于Java不支持多继承，那么就无法实现了，且类适配器模式违背了合成复用原则。</p><p>类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p><h3 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h3><p>类适配器模式的代码，只需要修改适配器类（SDAdapterTF）和测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TFCard</span> <span class="variable">tfCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TFCardImpl</span>();</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将对象以组合的形式存放在<code>SDAdapterTF</code>中，通过存放的对象调用具体实现</p><h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p>装饰模式的核心在于不改变一个对象本身功能的基础上，给对象添加额外的行为，并且它是通过组合的形式完成的，而不是传统的继承关系。</p><p>比如有一个普通的功能类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;   <span class="comment">//顶层抽象类，定义了一个test方法执行业务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;                     </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseImpl</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是业务方法&quot;</span>);   <span class="comment">//具体的业务方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过现在的实现类太单调了，添加一点装饰上去：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;   <span class="comment">//装饰者需要将装饰目标组合到类中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Base base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Base base)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.base = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        base.test();    <span class="comment">//这里暂时还是使用目标的原本方法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorImpl</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span>&#123;   <span class="comment">//装饰实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DecoratorImpl</span><span class="params">(Base base)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;    <span class="comment">//对原本的方法进行装饰，我们可以在前后都去添加额外操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;装饰方法：我是操作前逻辑&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.test();</span><br><span class="line">        System.out.println(<span class="string">&quot;装饰方法：我是操作后逻辑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就通过装饰模式对类的功能进行了扩展：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaseImpl</span>();</span><br><span class="line">    <span class="type">Decorator</span> <span class="variable">decorator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecoratorImpl</span>(base);  <span class="comment">//将Base实现装饰一下</span></span><br><span class="line">    <span class="type">Decorator</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DecoratorImpl</span>(decorator);  <span class="comment">//装饰者还可以嵌套</span></span><br><span class="line">    decorator.test();</span><br><span class="line">    outer.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就实现了装饰模式</p><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系，可以发现有很多的类，假如再增加几个形状或再增加一种颜色，就需要创建更多的类。在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p><p>桥接模式可以将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><p>例如需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//视频文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//avi文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVIFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;avi视频文件：&quot;</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmvb文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">REVBBFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rmvb文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作系统版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;<span class="comment">// 桥接：通过组合连接视频文件格式</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OperatingSystemVersion</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Windows</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mac版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mac</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OperatingSystem</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>(<span class="keyword">new</span> <span class="title class_">AVIFile</span>());</span><br><span class="line">        os.play(<span class="string">&quot;视频&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统</p><p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化</p><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>当一个类存在多个独立变化的维度，且这些维度都需要进行扩展时</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系</li></ul><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p>外观模式是“迪米特法则”的典型应用</p><p>举例，小明每次起床时都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来比较麻烦。所以小明买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//灯类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能音箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartAppliancesFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartAppliancesFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        airCondition = <span class="keyword">new</span> <span class="title class_">AirCondition</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(message.contains(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            on();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(message.contains(<span class="string">&quot;关闭&quot;</span>)) &#123;</span><br><span class="line">            off();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//起床后一键开电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床了&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//睡觉一键关电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建外观对象</span></span><br><span class="line">        <span class="type">SmartAppliancesFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartAppliancesFacade</span>();</span><br><span class="line">        <span class="comment">//客户端直接与外观对象进行交互</span></span><br><span class="line">        facade.say(<span class="string">&quot;打开&quot;</span>);</span><br><span class="line">        facade.say(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处：</strong></p><p>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类</p><p>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易</p><p><strong>缺点：</strong></p><p>不符合开闭原则，修改麻烦</p><h3 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性</li></ul><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式又名部分整体模式，用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次，它创建了对象组的树形结构。</p><p>实际上就是将多个组件进行组合，让用户可以对它们进行一致性处理。比如我们的文件夹，一个文件夹中可以有很多个子文件夹或是文件。像一个树形结构一样，有分支有叶子，组合模式可以对整个树形结构上的所有节点进行递归处理。</p><p>举例，使用文件和文件夹例子：                    </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先创建一个组件抽象，组件可以包含组件，组件有自己的业务方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span>;    <span class="comment">//添加子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span>;   <span class="comment">//删除子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span>;   <span class="comment">//获取子组件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;   <span class="comment">//执行对应的业务方法，比如修改文件名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写两种实现类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;   <span class="comment">//目录可以包含多个文件或目录</span></span><br><span class="line"></span><br><span class="line">    List&lt;Component&gt; child = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();   <span class="comment">//这里我们使用List来存放目录中的子组件</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        child.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> child.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称修改成功！&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">        child.forEach(Component::test);   <span class="comment">//将继续调用所有子组件的test方法执行业务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File</span> <span class="keyword">extends</span> <span class="title class_">Component</span>&#123;   <span class="comment">//文件就相当于是树叶</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();   <span class="comment">//不支持这些操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeComponent</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Component <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;文件名称修改成功！&quot;</span>+<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Directory</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>();   <span class="comment">//新建一个外层目录</span></span><br><span class="line">    <span class="type">Directory</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Directory</span>();   <span class="comment">//新建一个内层目录</span></span><br><span class="line">    outer.addComponent(inner);</span><br><span class="line">    outer.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());   <span class="comment">//在内层目录和外层目录都添加点文件</span></span><br><span class="line">    inner.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());</span><br><span class="line">    inner.addComponent(<span class="keyword">new</span> <span class="title class_">File</span>());</span><br><span class="line">    outer.test();    <span class="comment">//开始文件名称修改操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享原模式"><a href="#享原模式" class="headerlink" title="享原模式"></a>享原模式</h2><p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><p>举例，比如现在有两个服务都需要使用数据库操作，实际上这个工具类没必要创建多个，这时就可以使用享元模式，让数据库类作为享元类，通过享元工厂来提供一个共享的数据库工具类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectDB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库操作...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtilFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DBUtil</span> <span class="variable">UTIL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBUtil</span>();   <span class="comment">//享元对象被存放在工厂中</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DBUtil <span class="title function_">getFlyweight</span><span class="params">()</span>&#123;   <span class="comment">//获取享元对象</span></span><br><span class="line">        <span class="keyword">return</span> UTIL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要使用享元对象时，调用享元工厂类：                 </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DBUtil</span> <span class="variable">util</span> <span class="operator">=</span> DBUtilFactory.getFlyweight();</span><br><span class="line">        util.selectDB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <category domain="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>http://example.com/inori/6b3cc4f4.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>设计模式——创建型模式</title>
      <link>http://example.com/inori/b8618489.html</link>
      <guid>http://example.com/inori/b8618489.html</guid>
      <pubDate>Sat, 08 Mar 2025 08:57:52 GMT</pubDate>
      
      <description>设计模式中的创建型模式</description>
      
      
      
      <content:encoded><![CDATA[<p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p><p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><p>创建型模式分为：</p><ul><li>单例模式</li><li>工厂方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>即在整个程序中，同一个类始终只会有一个对象来进行操作。比如数据库连接类，实际上只需要创建一个对象或是直接使用静态方法就可以了，没必要去创建多个对象。</p><p>单例设计模式分类两种：</p><ul><li>饿汉式：类加载就会导致该单实例对象被创建</li><li>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</li></ul><p>饿汉式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式</span></span><br><span class="line"><span class="comment"> * 静态变量创建类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p><ul><li>懒汉式-方式1</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p><ul><li>懒汉式-方式2（双重检查锁）</li></ul><p>再来讨论一下懒汉模式中加锁的问题，对于<code>getInstance()</code>方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用<code>volatile</code>关键字, <code>volatile</code>关键字可以保证可见性和有序性</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重检查方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加<code>volatile</code>关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题</p><ul><li>懒汉式-方式3（静态内部类方式）</li></ul><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><p>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的。所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>需求：设计一个咖啡店点餐系统</p><p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;  <span class="comment">// 获取咖啡名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;     <span class="comment">// 准备咖啡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备美式咖啡：加水，加咖啡豆&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备拿铁咖啡：加牛奶，加咖啡豆&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过工厂创建咖啡对象</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> CoffeeFactory.createCoffee(type);</span><br><span class="line">        <span class="comment">// 准备咖啡</span></span><br><span class="line">        coffee.prepare();</span><br><span class="line">        <span class="comment">// 返回咖啡</span></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂（factory）处理创建对象的细节，一旦有了<code>SimpleCoffeeFactory</code>，<code>CoffeeStore</code>类中的<code>orderCoffee()</code>就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><p>利用对扩展开放，对修改关闭的性质，定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。改进：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;  <span class="comment">// 获取咖啡名称</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span>;     <span class="comment">// 准备咖啡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备美式咖啡：加水，加咖啡豆&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">prepare</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;准备拿铁咖啡：加牛奶，加咖啡豆&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;  <span class="comment">// 创建咖啡</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory coffeeFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeStore</span><span class="params">(CoffeeFactory coffeeFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coffeeFactory = coffeeFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过工厂创建咖啡对象</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> coffeeFactory.createCoffee();</span><br><span class="line">        <span class="comment">// 准备咖啡</span></span><br><span class="line">        coffee.prepare();</span><br><span class="line">        <span class="comment">// 返回咖啡</span></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程，并且在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则。</p><p>但是这种方法每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机等。</p><p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p>抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p><p><img src="/inori/b8618489/project.png" alt="project"></p><p>假设上面案例中，咖啡工厂不止生成咖啡，还生产甜点，我们可以用抽象工厂模式扩展：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CafeFactory</span> &#123;</span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;  <span class="comment">// 创建咖啡</span></span><br><span class="line">    Dessert <span class="title function_">createDessert</span><span class="params">()</span>; <span class="comment">// 创建甜点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCafeFactory</span> <span class="keyword">implements</span> <span class="title class_">CafeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cake</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCafeFactory</span> <span class="keyword">implements</span> <span class="title class_">CafeFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pudding</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stone类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> CafeFactory cafeFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeStore</span><span class="params">(CafeFactory cafeFactory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cafeFactory = cafeFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> cafeFactory.createCoffee();</span><br><span class="line">        coffee.prepare();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">orderDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Dessert</span> <span class="variable">dessert</span> <span class="operator">=</span> cafeFactory.createDessert();</span><br><span class="line">        dessert.serve();</span><br><span class="line">        <span class="keyword">return</span> dessert;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。这样当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p>缺点是当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象</p><p>原型模式的克隆分为浅克隆和深克隆。</p><blockquote><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址</p><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址</p></blockquote><p>Java中的Object类中提供了 <code>clone()</code>方法来实现浅克隆。 Cloneable接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。举例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    Address(String city) &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    Person(String name, Address address) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, address);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.address.city); <span class="comment">// 输出: Beijing</span></span><br><span class="line">        System.out.println(person2.address.city); <span class="comment">// 输出: Beijing</span></span><br><span class="line"></span><br><span class="line">        person2.address.city = <span class="string">&quot;Shanghai&quot;</span>; <span class="comment">// 修改 person2 的地址</span></span><br><span class="line">        System.out.println(person1.address.city); <span class="comment">// 输出: Shanghai（person1 也受到影响）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这两者不是同一对象，但是这两者指向的对象是同一个，修改任意一方的数据，对另一方也生效。</p><p>深克隆就需要把克隆对象的内部字段也克隆一遍：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String city;</span><br><span class="line"></span><br><span class="line">    Address(String city) &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Address) <span class="built_in">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    Address address;</span><br><span class="line"></span><br><span class="line">    Person(String name, Address address) &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深克隆</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">cloned</span> <span class="operator">=</span> (Person) <span class="built_in">super</span>.clone();</span><br><span class="line">            cloned.address = <span class="built_in">this</span>.address.clone(); <span class="comment">// 递归克隆引用类型字段</span></span><br><span class="line">            <span class="keyword">return</span> cloned;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Address</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Address</span>(<span class="string">&quot;Beijing&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, address);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.address.city); <span class="comment">// 输出: Beijing</span></span><br><span class="line">        System.out.println(person2.address.city); <span class="comment">// 输出: Beijing</span></span><br><span class="line"></span><br><span class="line">        person2.address.city = <span class="string">&quot;Shanghai&quot;</span>; <span class="comment">// 修改 person2 的地址</span></span><br><span class="line">        System.out.println(person1.address.city); <span class="comment">// 输出: Beijing（person1 不受影响）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示，适用于某个对象的构建过程复杂的情况</p><ul><li>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象</li><li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用</li><li>可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节</li></ul><p>举例，假如有一个学生类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">int</span> grade;</span><br><span class="line">    String name;</span><br><span class="line">    String college;</span><br><span class="line">    String profession;</span><br><span class="line">    List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, <span class="type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.college = college;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">        <span class="built_in">this</span>.awards = awards;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们通过new去创建：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;计算机学院&quot;</span>, <span class="string">&quot;计算机科学与技术&quot;</span>, Arrays.asList(<span class="string">&quot;A奖&quot;</span>, <span class="string">&quot;B奖&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，光是填参数就非常麻烦，这种情况下就可以使用建造者模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 使用建造者来创建，不对外直接开放</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Student</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> age, <span class="type">int</span> grade, String name, String college, String profession, List&lt;String&gt; awards)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StudentBuilder <span class="title function_">builder</span><span class="params">()</span>&#123;   <span class="comment">//通过builder方法直接获取建造者</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StudentBuilder</span>&#123;   <span class="comment">// 创建内部类</span></span><br><span class="line">        <span class="comment">// Builder也需要将所有的参数都进行暂时保存，所以Student怎么定义的这里就怎么定义</span></span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> grade;</span><br><span class="line">        String name;</span><br><span class="line">        String college;</span><br><span class="line">        String profession;</span><br><span class="line">        List&lt;String&gt; awards;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">id</span><span class="params">(<span class="type">int</span> id)</span>&#123;    <span class="comment">//直接调用建造者对应的方法，为对应的属性赋值</span></span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;   <span class="comment">//为了支持链式调用，这里直接返回建造者本身，下同</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">age</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> StudentBuilder <span class="title function_">awards</span><span class="params">(String... awards)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.awards = Arrays.asList(awards);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> Student <span class="title function_">build</span><span class="params">()</span>&#123;    <span class="comment">//最后我们只需要调用建造者提供的build方法即可根据我们的配置返回一个对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(id, age, grade, name, college, profession, awards);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们就可以使用建造者来为我们生成对象了：                     </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> Student.builder()   <span class="comment">//获取建造者</span></span><br><span class="line">            .id(<span class="number">1</span>)    <span class="comment">//逐步配置各个参数</span></span><br><span class="line">            .age(<span class="number">18</span>)</span><br><span class="line">            .grade(<span class="number">3</span>)</span><br><span class="line">            .name(<span class="string">&quot;小明&quot;</span>)</span><br><span class="line">            .awards(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>)</span><br><span class="line">            .build();   <span class="comment">//最后直接建造我们想要的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以让这些参数对号入座了，并且也比之前的方式优雅许多。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <category domain="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>http://example.com/inori/b8618489.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>设计模式——设计原则</title>
      <link>http://example.com/inori/4c95ffe2.html</link>
      <guid>http://example.com/inori/4c95ffe2.html</guid>
      <pubDate>Sat, 08 Mar 2025 02:57:26 GMT</pubDate>
      
      <description>面向对象设计原则</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><ul><li><p><strong>创建型模式</strong></p><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。含有单例、原型、工厂方法、抽象工厂、建造者5种创建型模式</p></li><li><p><strong>结构型模式</strong></p><p>用于描述如何将类或对象按某种布局组成更大的结构，即类或对象的组合，含有代理、适配器、桥接、装饰、外观、享元、组合7种结构型模式</p></li><li><p><strong>行为型模式</strong></p><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责，即类或对象之间的交互和通信。含有模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器11种行为型模式</p></li></ul><table><thead><tr><th align="center"><strong>类别</strong></th><th align="center"><strong>模式</strong></th><th align="center"><strong>核心思想</strong></th><th align="center"><strong>典型应用场景</strong></th></tr></thead><tbody><tr><td align="center"><strong>创建型</strong></td><td align="center">单例模式</td><td align="center">确保一个类只有一个实例</td><td align="center">全局唯一对象（如配置管理器）</td></tr><tr><td align="center"></td><td align="center">工厂方法模式</td><td align="center">由子类决定实例化哪个类</td><td align="center">框架中对象的创建</td></tr><tr><td align="center"></td><td align="center">抽象工厂模式</td><td align="center">创建相关对象的家族</td><td align="center">跨平台的 UI 组件库</td></tr><tr><td align="center"></td><td align="center">建造者模式</td><td align="center">分离复杂对象的构建与表示</td><td align="center">复杂对象的创建（如 HTML 文档生成器）</td></tr><tr><td align="center"></td><td align="center">原型模式</td><td align="center">通过复制现有对象创建新对象</td><td align="center">对象的创建成本较高时</td></tr><tr><td align="center"><strong>结构型</strong></td><td align="center">适配器模式</td><td align="center">将一个接口转换成客户端期望的另一个接口</td><td align="center">兼容旧系统、第三方库的集成</td></tr><tr><td align="center"></td><td align="center">桥接模式</td><td align="center">将抽象与实现分离</td><td align="center">多维度的类扩展（如形状和颜色）</td></tr><tr><td align="center"></td><td align="center">组合模式</td><td align="center">表示“部分-整体”的层次结构</td><td align="center">文件系统、UI 组件树</td></tr><tr><td align="center"></td><td align="center">装饰器模式</td><td align="center">动态地给对象添加额外的职责</td><td align="center">动态扩展对象功能（如 Java I&#x2F;O 流）</td></tr><tr><td align="center"></td><td align="center">外观模式</td><td align="center">提供一个统一的接口访问子系统</td><td align="center">简化复杂系统的调用</td></tr><tr><td align="center"></td><td align="center">享元模式</td><td align="center">通过共享技术支持大量细粒度对象</td><td align="center">文本编辑器中的字符对象</td></tr><tr><td align="center"></td><td align="center">代理模式</td><td align="center">控制对其他对象的访问</td><td align="center">远程代理、虚拟代理</td></tr><tr><td align="center"><strong>行为型</strong></td><td align="center">责任链模式</td><td align="center">解耦请求的发送者和接收者</td><td align="center">审批流程、异常处理</td></tr><tr><td align="center"></td><td align="center">命令模式</td><td align="center">将请求封装为对象</td><td align="center">撤销操作、任务队列</td></tr><tr><td align="center"></td><td align="center">解释器模式</td><td align="center">定义语言的文法并解释句子</td><td align="center">编译器、正则表达式</td></tr><tr><td align="center"></td><td align="center">迭代器模式</td><td align="center">顺序访问聚合对象中的元素</td><td align="center">集合类的遍历</td></tr><tr><td align="center"></td><td align="center">中介者模式</td><td align="center">封装一系列对象的交互</td><td align="center">聊天室、GUI 组件交互</td></tr><tr><td align="center"></td><td align="center">备忘录模式</td><td align="center">捕获并外部化对象的内部状态</td><td align="center">撤销操作、游戏存档</td></tr><tr><td align="center"></td><td align="center">观察者模式</td><td align="center">定义对象间的一对多依赖关系</td><td align="center">事件驱动系统、MVC 框架</td></tr><tr><td align="center"></td><td align="center">状态模式</td><td align="center">允许对象在其内部状态改变时改变其行为</td><td align="center">订单状态机、游戏角色状态</td></tr><tr><td align="center"></td><td align="center">策略模式</td><td align="center">定义一系列可互换的算法</td><td align="center">排序算法、支付方式</td></tr><tr><td align="center"></td><td align="center">模板方法模式</td><td align="center">定义算法的框架，将一些步骤延迟到子类中</td><td align="center">框架中的钩子方法</td></tr><tr><td align="center"></td><td align="center">访问者模式</td><td align="center">在不改变元素类的前提下定义作用于这些元素的新操作</td><td align="center">编译器中的语法树操作</td></tr></tbody></table><h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，要尽量根据7条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本</p><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则（Simple Responsibility Pinciple，SRP）是最简单的面向对象设计原则，它用于控制类的粒度大小。该原则要求一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String email, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 发送邮件逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>User</code>类承担了登录和发送邮件两个职责，如果登录逻辑或邮件发送逻辑需要修改，都需要修改<code>User</code>类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">login</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 登录逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmailSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(String email, String message)</span> &#123;</span><br><span class="line">        <span class="comment">// 发送邮件逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>User</code>类的职责分离为两个类：<code>User</code>负责登录，<code>EmailSender</code>负责发送邮件，这样就符合了单一职责原则</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><p>简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们需要使用接口和抽象类。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><p>比如银行有农业银行，交通银行，建设银行等，而他们都是银行，而具体是什么银行则是另外一回事，我们可以将银行抽象成一个统一的接口或是抽象类，这样我们就满足了开闭原则的第一个要求：对扩展开放；不同的银行可以自由地决定他们的业务。而具体哪个银行开设了哪种业务，不需要其他银行干涉，所以满足第二个要求：对修改关闭</p><h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p>任何基类可以出现的地方，子类一定可以出现。通俗理解：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大</p><p>比如:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">        <span class="built_in">this</span>.height = width; <span class="comment">// 修改了父类的行为</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = height; <span class="comment">// 修改了父类的行为</span></span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Square</code> 类修改了 <code>Rectangle</code> 类的行为（设置宽高时强制宽高相等），导致 <code>Square</code> 无法替换 <code>Rectangle</code></p><p>修正:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> width;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">int</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHeight</span><span class="params">(<span class="type">int</span> height)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> side;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSide</span><span class="params">(<span class="type">int</span> side)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.side = side;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> side * side;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Square</code>和<code>Rectangle</code>都继承自<code>Shape</code>，但各自实现自己的行为，互不影响</p><p>里氏替换也是实现开闭原则的重要方式之一</p><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合</p><p>举例，在Spring之前，我们的业务实现：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//CRUD...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserMapper</span>();</span><br><span class="line">        <span class="comment">//业务....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserService</span>();</span><br><span class="line">        <span class="comment">//业务....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果业务需求变化，Service变化，就会导致Controller层也发生变化，</p><p>有Spring框架之后，我们的开发模式变为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserController</span> <span class="variable">controller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserController</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//CRUD定义</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserMapperImpl</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">        <span class="comment">//CRUD</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">        <span class="comment">//业务定义....</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">        <span class="meta">@Resource</span>   <span class="comment">//现在由Spring来为我们选择一个指定的实现类，然后注入，而不是由我们在类中硬编码进行指定</span></span><br><span class="line">        UserMapper mapper;</span><br><span class="line">        <span class="comment">//业务...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">        <span class="meta">@Resource</span></span><br><span class="line">        UserService service;   <span class="comment">//直接使用接口</span></span><br><span class="line">        <span class="comment">//业务...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上</p><p>举例，我们需要创建一个A品牌的保险箱，该保险箱具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SafetyBox</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASafetyBox</span> <span class="keyword">implements</span> <span class="title class_">SafetyBox</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个B品牌的安全门，而该安全门只具有防盗、防水功能，很显然如果实现SafetyBox接口就违背了接口隔离原则，改正后代码如下：</p><p><strong>AntiTheft（接口）：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AntiTheft</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Fireproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fireproof</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Waterproof（接口）：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Waterproof</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ASafetyBox（类）：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ASafetyBox</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>,Fireproof,Waterproof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BSafetyBox（类）：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BSafetyBox</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>,Fireproof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireproof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p><strong>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong>。</p><p>通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>举例，B类需要使用A类中的某些功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AFunction</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;    <span class="comment">//直接通过继承的方式，得到A的逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是B的方法，我需要A&quot;</span>);</span><br><span class="line">        AFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这样看起来可行，但是耦合度太高了</p><p>可以看到通过继承的方式实现复用，我们是将类B直接指定继承自类A的，那么如果有一天，由于业务的更改，现有业务不再由A来负责，而是由新来的C去负责，那么这个时候，我们就不得不将需要复用A中方法的子类全部进行修改。并且还有一个问题就是，通过继承子类会得到一些父类中的实现细节，比如某些字段或是方法，这样直接暴露给子类，并不安全。</p><p>所以，我们要实现复用时，可以优先考虑引入一个A参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">AFunction</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(A a)</span>&#123;   <span class="comment">//在构造时指定</span></span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是B的方法，我需要A&quot;</span>);</span><br><span class="line">        a.AFunction();   <span class="comment">//通过对象A去执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则又叫最少知识原则，是对程序内部数据交互的限制。</p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的直接通信对象是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>简单来说就是，一个类&#x2F;模块对其他的类&#x2F;模块有越少的交互越好。当一个类发生改动，那么，与其相关的类（比如用到此类啥方法的类）需要尽可能少的受影响（比如修改了方法名、字段名等，可能其他用到这些方法或是字段的类也需要跟着修改）这样我们在维护项目的时候会更加轻松一些。</p><p>举例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployeeCity</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        <span class="comment">// 违反迪米特法则：与间接对象通信</span></span><br><span class="line">        System.out.println(employee.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Company</code> 类通过 <code>Employee</code> 对象间接访问了 <code>Address</code> 对象，违反了迪米特法则</p><p>可以使用中介对象获取信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Address <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Address</span><span class="params">(String city)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.city = city;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Employee employee;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Company</span><span class="params">(Employee employee)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.employee = employee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printEmployeeCity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过中介对象 Employee 获取信息</span></span><br><span class="line">        System.out.println(employee.getAddress().getCity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Company</code> 通过中介对象 <code>Employee</code> 获取 <code>Address</code> 的信息，减少直接依赖</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <category domain="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</category>
      
      
      <comments>http://example.com/inori/4c95ffe2.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis内存回收</title>
      <link>http://example.com/inori/228807ea.html</link>
      <guid>http://example.com/inori/228807ea.html</guid>
      <pubDate>Mon, 03 Mar 2025 02:39:21 GMT</pubDate>
      
      <description>redis入门</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Redis内存回收机制"><a href="#Redis内存回收机制" class="headerlink" title="Redis内存回收机制"></a>Redis内存回收机制</h1><p>Redis中的内存策略主要包含下列四点：</p><ol><li>内存清除策略（Eviction Policy）：当Redis内存空间不足时，会根据特定的算法删除一些key来释放内存。其中，常用的算法有LRU（最少最近使用）、LFU（最少使用频率）和随机算法</li><li>内存淘汰策略（Expiration）：在插入或更新key的时候，可以指定key的过期时间（expire）时间。过期后，Redis会自动将key删除，释放内存</li><li>内存回收策略（Memory Reclamation）：在使用Redis时，可能会因为未正确释放内存而导致内存泄漏。Redis针对这种情况实现了自动内存回收机制来防止内存泄漏的问题</li><li>内存优化策略（Memory Optimization）：Redis提供了各种内存优化策略，例如使用压缩（压缩整数值、压缩非常短的字符串）、使用哈希对象来优化内存使用等，以最大限度地减少内存使用。Redis也使用专门的数据结构来实现某些特定的数据类型，例如基数计数器和位数组，这些也是为了优化内存使用而设计的</li></ol><h2 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h2><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis提供了一些策略实现内存回收：Key过期策略.可以通过<code>expire key 5</code>命令（设置TTL为5秒）给Redis的key设置TTL（存活时间），当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。</p><h3 id="Redis如何Key是否过期"><a href="#Redis如何Key是否过期" class="headerlink" title="Redis如何Key是否过期"></a>Redis如何Key是否过期</h3><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在Dict结构中</p><p>Redis判断一个key是否过期：<strong>在其database结构体中，有两个Dict：一个用来记录key-value；另一个用来记录key-TTL</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    dict *dict;<span class="comment">/*存放所有key及value，也被称为keyspace*/</span></span><br><span class="line">    dict *expires;<span class="comment">/*存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key*/</span></span><br><span class="line">    dict *blocking_keys;<span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line">    dict *ready_keys;<span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;<span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="type">int</span> id;<span class="comment">/* Database ID, 0~15 */</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> avg_ttl;<span class="comment">/*记录平均TTL时长*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires_cursor;<span class="comment">/*expire检查时在dict中抽样的索引|位置*/</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;<span class="comment">/*等待碎片整理的key列表*/</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h3 id="TTL到期后的删除策略"><a href="#TTL到期后的删除策略" class="headerlink" title="TTL到期后的删除策略"></a>TTL到期后的删除策略</h3><p><strong>惰性删除</strong>：并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除。也就是在增删改查的时候才会去检查这个key去判断这个key是否有过期</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找一个key执行写操作</span></span><br><span class="line">robj *<span class="title function_">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span>&#123;</span><br><span class="line">    <span class="comment">// 检查key是否过期</span></span><br><span class="line">    expirelfNeeded(db, key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找一个key执行读操作</span></span><br><span class="line">robj *<span class="title function_">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    robj *val;</span><br><span class="line">    <span class="comment">// 检查key是否过期</span></span><br><span class="line">    <span class="keyword">if</span> (expirelfNeeded(db,key) == <span class="number">1</span>) (</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expirelfNeeded</span><span class="params">(redisDb *db, robj *key)</span>&#123;</span><br><span class="line">    <span class="comment">//判断是否过期，如果未过期直接结束并返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!keylsExpired(db,key)) <span class="keyword">return</span> O;</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">    <span class="comment">// 删除过期key</span></span><br><span class="line">    deleteExpiredKeyAndPropagate(db,key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>周期删除</strong>：通过一个定时任务，周期性的抽样部分过期的key，执行删除，执行周期有两种：</p><ol><li>在Redis服务初始化函数initServer()中设置定时任务serverCron()，按照server.hz的频率来执行过期key清理，模式为SLOW</li><li>在Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</li></ol><p>SLOW模式：</p><ul><li>执行频率受server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms。</li><li>执行清理耗时不超过一次执行周期的25%.默认slow模式耗时不超过25ms</li><li>逐个遍历db，逐个遍历db中的bucket（可以理解为hash列表中的每个下标），抽取20个key判断是否过期</li><li>如果没达到时间上限（25ms）并且过期key比例大于10%(就是过期的key和数据库中总的key进行对比)，再进行一次抽样，否则结束</li></ul><p>FAST模式规则（过期key比例小于10%不执行）：</p><ul><li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li><li>执行清理耗时不超过1ms</li><li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期，如果没达到时间上限（1ms）并且过期key比例大于10%，再进行一次抽样，否则结束</li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>当Redis内存使用达到设置的上限时，主动挑选部分key删除以释放更多内存的流程。Redis会在处理客户端命令的方法processCommand()中尝试做内存淘汰</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">processCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果服务器设置了server.maxmemory属性，并且没有执行lua脚本</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="comment">//尝试进行内存淘汰performEvictions</span></span><br><span class="line">        <span class="type">int</span> out_of_memory = (performEvictions()) == EVICT_FAIL);</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redis支持8种不同策略来选择要删除的key：</p><ol><li>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，默认就是这种策略</li><li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</li><li>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选</li><li>allkeys-lru： 对全体key，基于LRU算法进行淘汰</li><li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</li><li>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰。</li><li>LRU（Least Recently Used），最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高</li><li>LFU（Least Frequently Used），最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高</li></ol><p>之前记录过的RedisObject：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type: <span class="number">4</span>;<span class="comment">//对象类型</span></span><br><span class="line">    <span class="type">unsigned</span> encoding: <span class="number">4</span>; <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="type">unsigned</span> lru: LRU_BITS;<span class="comment">//LRU:以秒为单位记录最近一次访问时间，长度24bit</span></span><br><span class="line">    <span class="comment">//LFU：高16位以分钟为单位记录最近一次访问时间，低8位记录逻辑访问次数</span></span><br><span class="line">    <span class="type">int</span> refcount;<span class="comment">//引用计数，计数为0则可以回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;<span class="comment">//数据指针，指向真实数据</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>LFU的访问次数之所以叫做逻辑访问次数，是因为并不是每次key被访问都计数，而是通过运算：</p><ol><li>生成0~1之间的随机数R</li><li>计算旧次数*lfu_log_factor+1&#96;，记录为P</li><li>如果R&lt;P ，则计数器+1，且最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间每隔<code>lfu_decay_time</code>分钟，计数器-1</li></ol><blockquote><p>当Redis使用的内存超出maxmemory设置时，会根据指定的淘汰策略在键空间中选择要删除的键值对。在删除键值对时，Redis会先检查该键值对是否在使用中（例如，有没有客户端正在访问该键值对），然后再根据具体的淘汰策略选择一个待删除的键值对，并将其从缓存中清除。</p></blockquote><p><img src="D:\Blog\source\img\elimination.png" alt="elimination"></p><p>如果把redis全部的key都拿出来进行比较再淘汰，消耗的时间就会大大的增加。所以这里就引入了一个叫<code>eviction_pool</code>（驱逐池）它会抽取的一些样本，将样本放到池子里，再去比较看看谁应该被淘汰，这里<code>maxmemory_samples</code>默认值是5，但是策略不同淘汰的方式不同，这样实现就会比较麻烦所以这里进行了统一，就是按照key其中的某一个值的升序排列，值越大的优先淘汰</p><p>例如LFU最少频率使用，使用的越少就应该越早被淘汰，但是是升序排列的，那么就用255-LFU计算，LFU越少255-LFU就越大越应该被淘汰</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/redis/">redis</category>
      
      
      <category domain="http://example.com/tags/redis/">redis</category>
      
      
      <comments>http://example.com/inori/228807ea.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis网络模型</title>
      <link>http://example.com/inori/e34c024b.html</link>
      <guid>http://example.com/inori/e34c024b.html</guid>
      <pubDate>Sat, 01 Mar 2025 00:30:39 GMT</pubDate>
      
      <description>redis入门</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Linux网络模型"><a href="#Linux网络模型" class="headerlink" title="Linux网络模型"></a>Linux网络模型</h1><p>在《UNIX网络编程》一书中，总结归纳了5种IO模型：</p><ul><li>阻塞IO（Blocking IO）</li><li>非阻塞IO（Nonblocking IO）</li><li>IO多路复用（IO Multiplexing）</li><li>信号驱动IO（Signal Driven IO）</li><li>异步IO（Asynchronous IO）</li></ul><h2 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h2><p>应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是2，如果是阻塞IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。</p><p><img src="/inori/e34c024b/redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%5CBlocking_IO.png" alt="Blocking_IO"></p><p>用户去读取数据时，会去先发起recvform一个命令，去尝试从内核上加载数据，如果内核没有数据，那么用户就会等待，此时内核会去从硬件上读取数据，内核读取数据之后，会把数据拷贝到用户态，并且返回ok，整个过程，都是阻塞等待的，这就是阻塞IO</p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>非阻塞IO的recvfrom操作会立即返回结果而不是阻塞用户进程</p><p>阶段一：</p><ul><li>用户进程尝试读取数据（比如网卡数据）</li><li>此时数据尚未到达，内核需要等待数据</li><li>返回异常给用户进程</li><li>用户进程拿到error后，再次尝试读取</li><li>循环往复，直到数据就绪</li></ul><p>阶段二：</p><ul><li>将内核数据拷贝到用户缓冲区</li><li>拷贝过程中，用户进程依然阻塞等待</li><li>拷贝完成，用户进程解除阻塞，处理数据</li></ul><p>可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增</p><p><img src="/inori/e34c024b/redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%5CNonblocking_IO.png" alt="Nonblocking_IO"></p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：</p><ul><li>如果调用recvfrom时，恰好没有数据，阻塞IO会使CPU阻塞，非阻塞IO使CPU空转，都不能充分发挥CPU的作用</li><li>如果调用recvfrom时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据</li></ul><p>而在单线程情况下，只能依次处理IO事件，如果正在处理的IO事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO事件都必须等待，性能表现很差</p><p>想要提高IO事件效率，可以使用多线程，或者即时通知（哪个数据就绪，用户进程就读取这个数据）</p><p>那么用户进程如何知道内核中数据是否就绪呢？</p><p>这个问题的解决依赖于提出的文件描述符。</p><p>文件描述符（File Descriptor）：简称FD，是一个从0开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）</p><p>通过FD，我们的网络模型可以利用一个线程监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源</p><p>用IO复用模式，可以确保去读数据的时候，数据是一定存在的，他的效率比原来的阻塞IO和非阻塞IO性能都要高</p><p>IO多路复用即线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：</p><ol><li>select</li><li>poll</li><li>epoll</li></ol><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select是Linux最早是由的I&#x2F;O多路复用技术。</p><p>具体可以描述为：我们把需要处理的数据封装成FD，然后在用户态时创建一个fd的集合（这个集合的大小是要监听的那个FD的最大值+1），这个集合的长度大小是有限制的，同时在这个集合中，标明出来我们要控制哪些数据</p><p>比如要监听的数据，是1,2,5三个数据，此时会执行select函数，然后将整个fd发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再将处理掉没有准备好的数据，最后再将这个FD集合写回到用户态中去，此时用户态就知道了，奥，有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点，再去发起读请求</p><p>seletc模式存在的问题：</p><ul><li>需要将整个fd_set用户空间拷贝到内核空间，select结束还要再次拷贝回用户空间</li><li>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</li><li>fd_set监听的fd数量不能超过1024</li></ul><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><p>poll模式对select模式做了简单改进，但性能提升不明显，IO流程：</p><ol><li>创建pollfd数组，向其中添加关注的fd信息，<strong>数组大小自定义</strong></li><li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li><li>内核遍历fd，判断是否就绪</li><li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li><li>用户进程判断n是否大于0,大于0则遍历pollfd数组，找到就绪的fd</li></ol><p>与select对比：</p><ul><li><p>select模式中的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</p></li><li><p>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</p></li></ul><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll模式是对select和poll的改进，它提供了三个函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span><span class="comment">// 一颗红黑树，记录要监听的FD</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlist</span>;</span><span class="comment">// 一个链表，记录就绪的FD</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建一个epoll实例,内部是event poll，返回对应的句柄epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将一个FD添加到epoll的红黑树中，并设置ep_pollL_callback</span></span><br><span class="line"><span class="comment">// callback触发时，就把对应的FD加入到rdlist这个就绪列表中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd; <span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> op;<span class="comment">//要执行的操作，包括：ADD、MOD、DEL</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> fd; <span class="comment">//要监听的FD</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *event;<span class="comment">//要监听的事件类型:读、写、异常等</span></span></span><br><span class="line"><span class="params">&#125;;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="comment">// 3.检查rdlist列表是否为空，不为空则返回就绪的FD的数量</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> epoll_wait(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> epfd;<span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> epoll_event *events;<span class="comment">//空event数组，用于接收就绪的FD</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> maxevents;<span class="comment">//events数组的最大长度</span></span></span><br><span class="line"><span class="params">    <span class="type">int</span> timeout;<span class="comment">// 超时时间，-1用不超时，0不阻塞；大于0为阻塞时间</span></span></span><br><span class="line"><span class="params">&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>使用epoll_create创建epoll实例</li><li>紧接着调用epoll_ctl操作，将要监听的数据添加到红黑树上去，并且给每个fd设置一个监听函数，这个函数会在fd数据就绪时触发，把fd数据添加到list_head中去，epoll_ctl中的epfd表明要将监听的fd添加到eventepoll中</li><li>使用epoll_wait等待fd就绪，在用户态创建一个空的events数组，当就绪之后，我们的回调函数会把数据添加到list_head中去，当调用这个函数的时候，会去检查list_head，如果在此过程中，检查到了list_head中有数据会将数据添加到链表中，此时将数据放入到events数组中，并且返回对应的操作的数量</li><li>用户态的此时收到响应后，从events中拿到对应准备好的数据的节点，再去调用方法去拿数据</li></ol><h4 id="epoll中的事件通知模式"><a href="#epoll中的事件通知模式" class="headerlink" title="epoll中的事件通知模式"></a>epoll中的事件通知模式</h4><p>当FD有数据可读时，我们调用epoll_wait可以得到通知。但是事件通知的模式有两种：</p><ul><li>LevelTriggered：简称LT，也叫做水平触发。只要某个FD中有数据可读，每次调用epoll_wait都会得到通知。</li><li>EdgeTriggered：简称ET，也叫做边沿触发。只有在某个FD有状态变化时，调用epoll_wait才会被通知。</li></ul><p>假设一个客户端socket对应的FD已经注册到了epoll实例中，客户端socket发送了2kb的数据，服务端调用epoll_wait，得到通知说FD就绪，服务端从FD读取了1kb数据</p><ul><li>如果我们采用LT模式，因为FD中仍有1kb数据，调用epoll_wait依然会返回结果，并且得到通知</li><li>如果我们采用ET模式，因为已经消费了FD可读事件，后续FD状态没有变化，因此epoll_wait不会返回，数据无法读取，客户端响应超时</li></ul><table><thead><tr><th><strong>特性</strong></th><th><strong>LT 模式</strong></th><th><strong>ET 模式</strong></th></tr></thead><tbody><tr><td><strong>触发条件</strong></td><td>只要条件满足，持续通知。</td><td>只有状态变化时通知一次。</td></tr><tr><td><strong>通知频率</strong></td><td>高</td><td>低</td></tr><tr><td><strong>性能</strong></td><td>较低，适合低并发场景。</td><td>较高，适合高并发场景。</td></tr><tr><td><strong>编程复杂度</strong></td><td>简单，无需担心事件丢失。</td><td>复杂，需要确保一次性处理完数据。</td></tr><tr><td><strong>适用场景</strong></td><td>简单的 I&#x2F;O 操作或初学者。</td><td>高并发、高性能的网络服务器。</td></tr></tbody></table><h2 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h2><p>信号驱动IO是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其它业务，无需阻塞等待。</p><p>流程：</p><ol><li>用户进程调用sigaction，注册信号处理函数</li><li>内核返回成功，开始监听FD</li><li>用户进程不阻塞等待，可以执行其它业务</li><li>当内核数据就绪后，回调用户进程的SIGIO处理函数</li><li>收到SIGIO回调信号后，用户进程调用recvfrom，读取</li><li>内核将数据拷贝到用户空间</li><li>用户进程处理数据</li></ol><p>当有大量IO操作时，信号较多，SIGIO处理函数不能及时处理可能导致信号队列溢出，而且内核空间与用户空间的频繁信号交互性能也较低。</p><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p>这种方式，不仅仅是用户态在试图读取数据后，不阻塞，而且当内核的数据准备完成后，也不会阻塞</p><p>他会由内核将所有数据处理完成后，由内核将数据写入到用户态中，然后才算完成，所以性能极高，不会有任何阻塞，全部都由内核完成，可以看到，异步IO模型中，用户进程在两个阶段都是非阻塞状态</p><p><img src="/inori/e34c024b/redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%5CasyncIO.png" alt="asyncIO"></p><p>异步IO避免了同步I&#x2F;O中的等待时间，提高了CPU和I&#x2F;O设备的利用率，但是这种方式对内核的负载很大，在高并发场景下可能会因为内存占用过多出现崩溃现象。如果要使用必须要做并发访问的限流</p><h1 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h1><p><strong>Redis到底是单线程还是多线程？</strong></p><ul><li>如果仅仅聊Redis的核心业务部分（命令处理），答案是单线程</li><li>如果是聊整个Redis，那么答案是多线程</li></ul><p>在Redis版本迭代过程中，在两个重要的时间节点上引入了多线程的支持：</p><ul><li>Redis v4.0：引入多线程异步处理一些耗时较久的任务，例如异步删除命令unlink</li><li>Redis v6.0 ：在核心网络模型中引入多线程，进一步提高对多核cpu的利用率</li></ul><p>因此，对于Redis的核心网络模型，在Redis6.0之前确实都是单线程。是利用epoll（Linux系统）这样的IO多路复用技术在事件循环中不断处理客户端情况</p><p><strong>为什么Redis要选择单线程？</strong></p><ul><li>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升</li><li>多线程会导致过多的上下文切换，带来不必要的开销</li><li>引入多线程会面临线程安全问题，必然要引入线程锁这样的安全手段，实现复杂度增高，而且性能会降低</li></ul><h2 id="Redis单线程网络模型执行流程"><a href="#Redis单线程网络模型执行流程" class="headerlink" title="Redis单线程网络模型执行流程"></a>Redis单线程网络模型执行流程</h2><ol><li>监听端口：Redis服务器开始监听指定的端口，等待客户端连接。</li><li>接收客户端连接：当有客户端请求连接到Redis服务器时，服务器会接受连接请求，并创建一个客户端套接字，用于与客户端通信。</li><li>接收命令：一旦客户端与服务器建立连接，客户端可以发送命令请求到服务器。Redis服务器通过套接字接收到客户端发送的命令。</li><li>命令解析：服务器会对接收到的命令进行解析，以确定客户端请求的具体操作。</li><li>执行命令：根据解析的结果，服务器会执行相应的命令操作。由于Redis使用单线程模型，每个命令都会按顺序依次执行，不会并发执行。</li><li>数据读写：在执行命令期间，如果需要读取或修改数据，服务器会从内存中读取数据或将修改后的数据写回内存。</li><li>命令回复：执行完命令后，服务器会将执行结果封装为响应，并通过套接字发送回客户端。</li><li>关闭连接：命令执行完成后，服务器会关闭与客户端的连接，等待下一个连接请求</li></ol><p><img src="/inori/e34c024b/redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%5Credis_netModel.png" alt="redis_netModel"></p><h3 id="多线程改进"><a href="#多线程改进" class="headerlink" title="多线程改进"></a>多线程改进</h3><p>由于影响网络模型速率的是IO操作，所以可以在命令请求处理器的请求数据写入部分使用多线程和将数据写入buf或reply部分使用多线程来提高速度</p><h1 id="Redis通信协议"><a href="#Redis通信协议" class="headerlink" title="Redis通信协议"></a>Redis通信协议</h1><p>Redis是一个CS架构的软件，通信一般分两步（不包括pipeline和PubSub）：</p><ol><li>客户端（client）向服务端（server）发送一条命令</li><li>服务端解析并执行命令，返回响应结果给客户端</li></ol><p>因此客户端发送命令的格式、服务端响应结果的格式必须有一个规范，这个规范就是通信协议。</p><p>而在Redis中采用的是RESP（Redis Serialization Protocol）协议：</p><ol><li>Redis 1.2版本引入了RESP协议</li><li>Redis 2.0版本中成为与Redis服务端通信的标准，称为RESP2</li><li>Redis 6.0版本中，从RESP2升级到了RESP3协议，增加了更多数据类型并且支持6.0的新特性–客户端缓存</li></ol><p>但目前，默认使用的依然是RESP2协议。</p><p>在RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p><ol><li>单行字符串：首字节是 <code>&#39;+&#39;</code> ，后面跟上单行字符串，以CRLF（ <code>&quot;\r\n&quot;</code> ）结尾。例如返回”OK”： <code>&quot;+OK\r\n&quot;</code></li><li>错误（Errors）：首字节是 <code>&#39;-&#39; </code>，与单行字符串格式一样，只是字符串是异常信息，例如：<code>&quot;-Error message\r\n&quot;</code></li><li>数值：首字节是 <code>&#39;:&#39; </code>，后面跟上数字格式的字符串，以CRLF结尾。例如：<code>&quot;:10\r\n&quot;</code></li><li>多行字符串：首字节是 <code>&#39;$&#39;</code> ，表示二进制安全的字符串，最大支持512MB：<ol><li>如果大小为0，则代表空字符串：<code>&quot;$0\r\n\r\n&quot;</code></li><li>如果大小为-1，则代表不存在：<code>&quot;$-1\r\n&quot;</code></li></ol></li><li>数组：首字节是 <code>&#39;*&#39;</code>， 后面跟上数组元素个数，再跟上元素，元素数据类型不限，如：</li></ol><blockquote><p>*3\r\n</p><p>:10\r\n</p><p>$5\r\nhello\r\n</p><p>*2\r\n$3\r\nage\r\n:10\r\n</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/redis/">redis</category>
      
      
      <category domain="http://example.com/tags/redis/">redis</category>
      
      
      <comments>http://example.com/inori/e34c024b.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>redis数据结构</title>
      <link>http://example.com/inori/abcb1f8f.html</link>
      <guid>http://example.com/inori/abcb1f8f.html</guid>
      <pubDate>Wed, 26 Feb 2025 08:34:39 GMT</pubDate>
      
      <description>redis入门</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h2><p>Redis中保存的key是字符串，value往往是字符串或者字符串的集合。可以说字符串是Redis中最常见的数据结构。</p><p>不过Redis中没有直接使用C语言中的字符串，而是构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String）。</p><p>比如我们执行命令<code>set name Jack</code>，那么Redis将在底层创建两个SDS，其中一个是包含<code>name</code>的SDS，另一个是包含<code>Jack</code>的SDS。</p><p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((<span class="title">packed</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len;<span class="comment">// buf已保存的字符串字节数，不包含结束标示\0</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc;<span class="comment">// buf申请的总字节数，不包含结束标示\0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags;<span class="comment">// 不同的SDS的头类型，用来控制SDS头大小</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>flag对应的种类有五五种</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_5 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_8 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDS_TYPE_64 4</span></span><br></pre></td></tr></table></figure><p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如有一个内容为<code>abc</code>的SDS，其中<code>len=2,alloc=2,flag=1,h,i,\0</code>，我们要给他追加一段字符串<code>defgh</code>，首先会申请新的内存空间：</p><ul><li>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1</li><li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1</li></ul><p><strong>动态字符串优点</strong>：</p><ol><li>获取字符串长度的时间复杂度为0(1)[因为长度已经存在于结构体中]</li><li>支持动态扩容</li><li>减少内存分配次数</li><li>二进制安全（可以存储特殊字符，无需考虑结束符的问题）</li></ol><h2 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h2><p>Redis为了优化内存和性能，会根据Set中元素的特性自动选择底层实现：</p><ol><li>所有元素都是整数</li><li>元素数量不超过配置的阈值</li></ol><ul><li>Redis配置项<code>set-max-intset-entries</code>定义了IntSet的最大元素数量，默认值为512</li><li>如果元素数量超过该阈值，Redis 会将IntSet转换为HashTable</li></ul><p>IntSet基于整数数组来实现，具备长度可变，有序（便于查找）等特性。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding; <span class="comment">// 编码方式（int16_t、int32_t、int64_t）</span></span><br><span class="line">    <span class="type">uint32_t</span> length;   <span class="comment">// 集合中元素的数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];  <span class="comment">// 存储整数的数组</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>其中的encoding包含三种模式，表示存储的整数大小不同：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))<span class="comment">/*2字节整数,范围类似java的short */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))<span class="comment">/* 4字节整数,范围类似java的int */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))<span class="comment">/* 8字节整数,范围类似java的long */</span></span></span><br></pre></td></tr></table></figure><p>为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，内部结构类似于<code>encoding:INTSET_ENC_INT16,length:3,5,10,15</code>。</p><blockquote><p>寻址公式：startPtr【开始的起始地址为0】+（sizeof(int16) 【数据类型的字节大小】* index【它对应的下标】）就可以快速找到对应的数据</p></blockquote><h3 id="IntSet升级"><a href="#IntSet升级" class="headerlink" title="IntSet升级"></a>IntSet升级</h3><p>现在，假设有一个intset,元素为{5,10,20}，采用的编码为INTSET_ENC_INT16，则每个整数占2字节。如果现在我想添加50000，这个数字超出了int16_t的范围，intset会自动升级编码方式到合适的大小。</p><p>以当前案例来说流程如下：</p><ol><li>升级编码为INTSET_ENC_INT32, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li><li>倒序依次将数组中的元素拷贝到扩容后的正确位置（倒叙放是为了防止字节扩大时将后面的数据给覆盖掉）</li><li>将待添加的元素放入数组末尾</li><li>将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li></ol><p>如果插入的元素位于IntSet中间或者开头，底层会使用二分查找确定插入位置，然后再执行移动和插入操作。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>IntSet可以看做是特殊的整数数组</li></ul><ul><li>IntSet中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><h2 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h2><p>Redis是一个键值型的数据库，我们可以根据键实现快速的增删改查，而键与值的映射关系正是通过Dict来实现的</p><p>Dict由三部分组成：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>每个哈希表由数个entry组成，每个桶是一个链表，用于解决哈希冲突</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      <span class="comment">// entry数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;     <span class="comment">// 哈希表的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">// 用于计算索引的掩码（size - 1）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;     <span class="comment">// 已使用的entry数量</span></span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><h3 id="哈希节点"><a href="#哈希节点" class="headerlink" title="哈希节点"></a>哈希节点</h3><p>每个键值对存储在一个 <code>dictEntry</code> 结构中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;              <span class="comment">// 键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">void</span> *val;          <span class="comment">// 值</span></span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个节点（解决哈希冲突）</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h3 id="字典结构"><a href="#字典结构" class="headerlink" title="字典结构"></a>字典结构</h3><p>Dict 包含两个哈希表（<code>ht[0]</code>和<code>ht[1]</code>），以及Rehash相关的状态信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;         <span class="comment">// dict类型，内置不同的hash函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;         <span class="comment">// 私有数据</span></span><br><span class="line">    dictht ht;          <span class="comment">// 两个哈希表，一个是当前数据，另一个一般是空，rehash时使用</span></span><br><span class="line">    <span class="type">long</span> rehashidx;         <span class="comment">// Rehash 的进度（-1 表示未进行 Rehash）</span></span><br><span class="line">    <span class="type">int16_t</span> pauserehash;<span class="comment">// rehash是否暂停，1表示暂停，0则继续</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用<code>h&amp;sizemask</code>来计算元素应该存储到数组中的哪个索引位置。我们存储k1&#x3D;v1，假设k1的哈希值h&#x3D;1，则1&amp;3&#x3D;1，因此k1&#x3D;v1要存储到数组角标1位置，键值对内部结构使用的是链表，新插入的节点使用的是头插法。</p><h3 id="Dict的扩容和收缩"><a href="#Dict的扩容和收缩" class="headerlink" title="Dict的扩容和收缩"></a>Dict的扩容和收缩</h3><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p><p>Dict在每次新增键值对时都会检查负载因子（<code>LoadFactor = used/size</code>），满足以下两种情况时会触发哈希表扩容：</p><ul><li>哈希表的LoadFactor &gt;&#x3D; 1，并且服务器没有执行BGSAVE或者BGREWRITEAOF等后台进程（因为这种操作对性能要求高，如果我再进行rehash的操作就可能导致阻塞）</li><li>哈希表的LoadFactor &gt; 5</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 检查是否需要扩容 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> _dictExpandIfNeeded(dict *d) &#123;</span><br><span class="line">    <span class="comment">// 如果正在进行 Rehash，则不需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    <span class="comment">// 如果哈希表为空，则初始化为默认大小（4）</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht.size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果负载因子超过1并且没有进行bgrewrite等子进程操作，则触发扩容</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht.used &gt;= d-&gt;ht.size &amp;&amp;</span><br><span class="line">        (dict_can_resize || d-&gt;ht.used/d-&gt;ht.size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当哈希表的负载因子低于<code>0.1</code>，并且<code>size &gt; 4</code>时，Redis会触发收缩操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 检查是否需要收缩 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dictResize</span><span class="params">(dict *d)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> minimal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果正在进行 Rehash 或 dict_can_resize 为 0，则不能收缩</span></span><br><span class="line">    <span class="keyword">if</span> (!dict_can_resize || dictIsRehashing(d)) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取used，也就是entry个数</span></span><br><span class="line">    minimal = d-&gt;ht[<span class="number">0</span>].used;</span><br><span class="line">    <span class="comment">// 如果used小于4，则重置为4</span></span><br><span class="line">    <span class="keyword">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">        minimal = DICT_HT_INITIAL_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 dictExpand 进行收缩，值为第一个大于等于minimal的2^n</span></span><br><span class="line">    <span class="keyword">return</span> dictExpand(d, minimal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h3><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ul><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：<ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul></li><li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx &#x3D; 0，标示开始rehash</li><li>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将<code>dict.ht[0].table[rehashidx]</code>的entry链表rehash到dict.ht[1]，并且将<code>rehashidx ++</code>。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><h2 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h2><p>ZipList是一种特殊的“双端链表”（其实不是链表），由一系列特殊编码的连续内存块组成。可以在任意一端进行压入&#x2F;弹出操作, 并且该操作的时间复杂度为O(1)</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>Ziplist由三部分组成：</p><ol><li>头部</li></ol><ul><li><code>zlbytes</code>：Ziplist的总字节数（4字节）</li><li><code>zltail</code>：最后一个节点的偏移量（4字节），便于定位到最后一个entry节点</li><li><code>zllen</code>：entry节点的数量（2字节）</li></ul><ol start="2"><li>entry节点(长度不固定)</li></ol><ul><li>每个entry节点包含以下字段：<ul><li><code>previous_entry_len</code>：前一个节点的长度（1或5字节）<ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为<code>0xfe</code>，后四个字节才是真实长度数据</li></ul></li><li><code>encoding</code>：当前节点的编码方式（1、2或5字节）</li><li><code>content</code>：实际存储的数据（字符串或整数）</li></ul></li></ul><ol start="3"><li>尾部</li></ol><ul><li><code>zlend</code>：Ziplist的结束标志（1字节，固定值<code>0xff</code>）</li></ul><p>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</p><h3 id="Encodeing编码"><a href="#Encodeing编码" class="headerlink" title="Encodeing编码"></a>Encodeing编码</h3><p>ZipListEntry中的encoding编码分为字符串和整数两种：<br>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</p><table><thead><tr><th align="center">编码</th><th align="center">编码长度</th><th>字符串大小</th></tr></thead><tbody><tr><td align="center">|00pppppp|</td><td align="center">1 bytes</td><td>&lt;&#x3D; 63 bytes</td></tr><tr><td align="center">|01pppppp|qqqqqqqq|</td><td align="center">2 bytes</td><td>&lt;&#x3D; 16383 bytes</td></tr><tr><td align="center">|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td><td align="center">5 bytes</td><td>&lt;&#x3D; 4294967295 bytes</td></tr></tbody></table><p>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</p><table><thead><tr><th align="center">编码</th><th align="center">编码长度</th><th align="center">整数类型</th></tr></thead><tbody><tr><td align="center">11000000</td><td align="center">1</td><td align="center">int16_t（2 bytes）</td></tr><tr><td align="center">11010000</td><td align="center">1</td><td align="center">int32_t（4 bytes）</td></tr><tr><td align="center">11100000</td><td align="center">1</td><td align="center">int64_t（8 bytes）</td></tr><tr><td align="center">11110000</td><td align="center">1</td><td align="center">24位有符整数(3 bytes)</td></tr><tr><td align="center">11111110</td><td align="center">1</td><td align="center">8位有符整数(1 bytes)</td></tr><tr><td align="center">1111xxxx</td><td align="center">1</td><td align="center">直接在xxxx位置保存数值，范围从0001~1101，减1后结果为实际值</td></tr></tbody></table><h3 id="连锁更新问题"><a href="#连锁更新问题" class="headerlink" title="连锁更新问题"></a>连锁更新问题</h3><p>前面提到过，ZipList的每个Entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：</p><ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul><p>当插入或删除节点时，可能导致后续节点的<code>prevlen</code>字段发生变化。如果<code>prevlen</code>的长度从1字节变为5字节，则需要扩展当前节点的空间，这可能导致后续节点的<code>prevlen</code>字段也需要更新，从而引发连锁更新</p><p>不过发生的可能性较低，redis并没有解决这个问题</p><h2 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h2><p>Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，链表中的每个节点都是一个ZipList。可以用多个ZipList来分片存储数据</p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5CQuickList.png" alt="QuickList"></p><p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：<code>list-max-ziplist-size</code></p><ul><li>如果值为正，则代表ZipList的允许的entry个数的最大值</li><li>如果值为负，则代表ZipList的最大内存大小，分5种情况：<ul><li>-1：每个ZipList的内存占用不能超过4kb</li><li>-2：每个ZipList的内存占用不能超过8kb（默认值）</li><li>-3：每个ZipList的内存占用不能超过16kb</li><li>-4：每个ZipList的内存占用不能超过32kb</li><li>-5：每个ZipList的内存占用不能超过64kb</li></ul></li></ul><p>QuickList源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头节点指针</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    <span class="comment">// 尾节点指针</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="comment">// 所有ziplist的entry的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count;</span><br><span class="line">    <span class="comment">// ziplists总数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">// ziplist的entry上限，默认值 -2</span></span><br><span class="line">    <span class="type">int</span> fill: QL_FILL_BITS;</span><br><span class="line">    <span class="comment">// 首尾不压缩的节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress:QL_COMP_BITS;</span><br><span class="line">    <span class="comment">// 内存重分配时的书签数量及数组，一般用不到</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bookmark count: QL_BM_BITS;</span><br><span class="line">    quicklistBookmark bookmarks[];</span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><p>QuickListNode源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 下一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 当前节点的ZipList指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;</span><br><span class="line">    <span class="comment">// 当前节点的Ziplist的字节大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="comment">// 当前节点的ZipList的entry个数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count: <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 编码方式:1.ZipList; 2.lzf压缩模式</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding: <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 数据容器类型(预留):1.其它; 2.ZipList</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container: <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 是否被解压缩。1说明被解压了，将来要重新压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress: <span class="number">1</span>; <span class="comment">//测试用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra: <span class="number">10</span>;<span class="comment">/*预留字段*/</span></span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><p>ZipList的压缩可以选择头尾几个链表不压缩，一般crud都在头尾，只压缩中间的ZipList</p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Cquicklist_ziplist.png" alt="quicklist_ziplist"></p><h2 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h2><p>SkipList是链表，但是与传统链表有些差异，具有以下特点：</p><ul><li>节点按照score值排序，score值一样则按照ele字典排序</li><li>节点可能包含多个指针，指针跨度不同</li><li>查找、插入和删除操作的平均时间复杂度为O(logn)</li><li>SkipList的索引层级是动态调整的，插入新元素时会随机生成其层级</li><li>跳跃表是一个双向链表，每一个节点都包含score和ele值</li></ul><p>SkipList的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span><span class="comment">// 头尾节点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;<span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">int</span> level;<span class="comment">// 最大的索引层级，默认是1</span></span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure><p>SkipListNode的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;                      <span class="comment">// 元素值</span></span><br><span class="line">    <span class="type">double</span> score;                   <span class="comment">// 分值，排序、查找用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">// 前一个节点指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 下一个节点指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> span;             <span class="comment">// 索引跨度</span></span><br><span class="line">    &#125; level[];                        <span class="comment">// 多级索引数组</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Cskiplist.png" alt="skiplist"></p><h2 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h2><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，它是Redis数据存储的基础，通过封装数据的类型、编码方式和实际值，提供了统一的接口来操作各种数据类型。源码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type: <span class="number">4</span>;<span class="comment">// 5种数据结构类型，占4bit</span></span><br><span class="line">    <span class="type">unsigned</span> encoding: <span class="number">4</span>;<span class="comment">// 底层编码方式，共11种，占4bit</span></span><br><span class="line">    <span class="type">unsigned</span> lru： LRU_BITS;<span class="comment">// lru表示该对象最后一次被访问的时间，占24bit,便于判断空闲时间太久的key</span></span><br><span class="line">    <span class="type">int</span> refcount;<span class="comment">// 对象引用计数器，计数器为0则说明对象无人引用，可以被回收</span></span><br><span class="line">    <span class="type">void</span> *ptr;<span class="comment">// 指针，指向存放实际数据的空间</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h3 id="Redis的编码方式"><a href="#Redis的编码方式" class="headerlink" title="Redis的编码方式"></a>Redis的编码方式</h3><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><table><thead><tr><th align="center">编号</th><th align="center">编码方式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OBJ_ENCODING_RAW</td><td align="center">raw编码动态字符串</td></tr><tr><td align="center">1</td><td align="center">OBJ_ENCODING_INT</td><td align="center">long类型的整数的字符串</td></tr><tr><td align="center">2</td><td align="center">OBJ_ENCODING_HT</td><td align="center">hash表（字典dict）</td></tr><tr><td align="center">3</td><td align="center">OBJ_ENCODING_ZIPMAP</td><td align="center">已废弃</td></tr><tr><td align="center">4</td><td align="center">OBJ_ENCODING_LINKEDLIST</td><td align="center">双端链表</td></tr><tr><td align="center">5</td><td align="center">OBJ_ENCODING_ZIPLIST</td><td align="center">压缩列表</td></tr><tr><td align="center">6</td><td align="center">OBJ_ENCODING_INTSET</td><td align="center">整数集合</td></tr><tr><td align="center">7</td><td align="center">OBJ_ENCODING_SKIPLIST</td><td align="center">跳表</td></tr><tr><td align="center">8</td><td align="center">OBJ_ENCODING_EMBSTR</td><td align="center">embstr的动态字符串</td></tr><tr><td align="center">9</td><td align="center">OBJ_ENCODING_QUICKLIST</td><td align="center">快速列表</td></tr><tr><td align="center">10</td><td align="center">OBJ_ENCODING_STREAM</td><td align="center">Stream流</td></tr></tbody></table><h3 id="五种数据结构对应的编码"><a href="#五种数据结构对应的编码" class="headerlink" title="五种数据结构对应的编码"></a>五种数据结构对应的编码</h3><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p><table><thead><tr><th align="center">数据类型</th><th align="center">编码方式</th></tr></thead><tbody><tr><td align="center">OBJ_STRING</td><td align="center">int、embstr、raw</td></tr><tr><td align="center">OBJ_LIST</td><td align="center">LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td></tr><tr><td align="center">OBJ_SET</td><td align="center">intset、HT</td></tr><tr><td align="center">OBJ_ZSET</td><td align="center">ZipList、HT、SkipList</td></tr><tr><td align="center">OBJ_HASH</td><td align="center">ZipList、HT</td></tr></tbody></table><h2 id="五种数据结构"><a href="#五种数据结构" class="headerlink" title="五种数据结构"></a>五种数据结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String是Redis中最常见的数据存储类型</p><ul><li>其基本编码方式是RAW，基于简单动态字符串（SDS）实现，存储上限为512MB</li><li>如果存储的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高</li><li>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码，直接将数据保存在RedisObject的ptr指针位置(刚好8字节)，不需要SDS</li></ul><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p><code>OBJ_ENCODING_RAW</code>的实现就是<code>RedisObject</code>中的ptr指向一个SDS</p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Craw.png" alt="raw"></p><p><code>EMBSTR</code>的形式为RedisObject后直接跟SDS，而不是两个分开的地址空间</p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Cembstr.png" alt="embstr"></p><p><code>INT</code>形式删除了SDS，直接把数据保存在ptr位置</p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5CINT.png" alt="INT"></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis的List类型可以从首、尾操作列表中的元素，哪一个数据结构能满足上述特征？</p><ul><li>LinkedList：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li><li>ZipList：压缩列表，可以从双端访问，内存占用低，存储上限低</li><li>QuickList：<code>LinkedList + ZipList</code>，可以从双端访问，内存占用较低，包含多个ZipList，存储上限高</li></ul><p>在3.2版本之前，Redis采用ZipList和LinkedList来实现List，当元素数量<code>&lt;512</code>并且元素大小<code>&lt;64字节</code>时使用ZipList编码，超过则采用LinkedList编码</p><p>在3.2版本之后，Redis统一采用QuickList来实现List</p><p>创建List：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pushGenericCommand</span><span class="params">(client *c, <span class="type">int</span> where, <span class="type">int</span> xx)</span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">// 尝试找到KEY对应的list</span></span><br><span class="line">    robj *lobj= lookupKeyWrite(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 检查类型是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (checkType(c, lobj, OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 检查是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) &#123;</span><br><span class="line">        addReply(c, shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为空，则创建新的QuickList</span></span><br><span class="line">        lobj= createQuicklistObject();</span><br><span class="line">        quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size, server.list_compress_depth);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Quicklist：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createQuicklistObject</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 申请内存并初始化QuickList</span></span><br><span class="line">    quicklist *l = quicklistCreate();</span><br><span class="line">    <span class="comment">// 创建RedisObject，type为OBJ_LIST</span></span><br><span class="line">    <span class="comment">// ptr指向QuickList</span></span><br><span class="line">    robj *o = createObject(OBJ_LIST,l);</span><br><span class="line">    <span class="comment">// 设置编码为 QuickList</span></span><br><span class="line">    <span class="number">0</span>-&gt;encoding = OBJ_ENCODING_QUICKLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Credis_List.png" alt="redis_List"></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set是Redis中的单列集合，满足下列特点：</p><ul><li>不保证有序性</li><li>保证元素唯一</li><li>支持求交集、并集、差集</li></ul><p>可以看出，Set对查询元素的效率要求非常高，所以底层使用了IntSet和Dict实现。</p><p>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null。</p><p>当存储的所有数据都是整数，并且元素数量不超过<code>set-max-intset-entries(默认512)</code>时，Set会采用IntSet编码，以节省内存</p><p>创建Set的源码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">setTypeCreate</span><span class="params">(sds value)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断value是否是数值类型long long</span></span><br><span class="line">    <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value, <span class="literal">NULL</span>)==C_OK)</span><br><span class="line">    <span class="comment">// 如果是数值类型，则采用IntSet编码</span></span><br><span class="line">    <span class="keyword">return</span> createIntsetObject();</span><br><span class="line">    <span class="comment">//否则采用默认编码，也就是HT</span></span><br><span class="line">    <span class="keyword">return</span> createSetObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是数值类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createIntsetobject</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 初始化INTSET并申请内存空间</span></span><br><span class="line">    intset *is= intsetNew();</span><br><span class="line">    <span class="comment">// 创建RedisObject</span></span><br><span class="line">    robj *o= createObject(OBJ_SET, is);</span><br><span class="line">    <span class="comment">// 指定编码为INTSET</span></span><br><span class="line">    <span class="number">0</span>-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认编码HT：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createSetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化Dict类型，并申请内存</span></span><br><span class="line">    dict *d = dictCreate(&amp;setDictType, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建RedisObject</span></span><br><span class="line">    robj *o= createObject(OBJ_SET, d);</span><br><span class="line">    <span class="comment">// 设置encoding为HT</span></span><br><span class="line">    <span class="number">0</span>-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果原本set中存储的元素使5,10,20，然后执行命令<code>sadd s1 m1</code>，因为新插入的元素是字符串，redis需要转换编码，会新建一个Dict，把原本IntSet中的元素和m1都存入Dict中，然后转换RedisObject中的ptr，指向Dict，最后更改encoding为<code>OBJ_ENCODING_HT</code></p><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Credis_set.png" alt="redis_set"></p><h3 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h3><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值：</p><ul><li>可以根据score值排序后</li><li>member必须唯一</li><li>可以根据member查询分数</li></ul><p>因此，zset底层数据结构必须满足键值存储、键必须唯一、可排序这几个需求。</p><ul><li>SkipList：可以排序，并且可以同时存储score和ele值（member）</li><li>HT（Dict）：可以键值存储，并且可以根据key找value</li></ul><p>zset会同时使用两个结构，需要查找，维护键唯一时使用HT，需要排序时使用SkipList</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// zset结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    <span class="comment">// Dict指针</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// SkipList指针</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">robj *<span class="title function_">createZsetObject</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line"><span class="comment">// 创建Dict</span></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建SkipList</span></span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(OBJ_ZSET, zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line"><span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Czset.png" alt="zset"></p><p>当元素数量不多时，HT和SkipList的优势不明显，而且更耗内存。因此zset还会采用ZipList结构来节省内存，不过需要同时满足两个条件:</p><ul><li>元素数量小于zset_max_ziplist_entries，默认值128</li><li>每个元素都小于zset_max_ziplist_value字节，默认值64</li></ul><p>ziplist本身没有排序功能，而且没有键值对的概念，因此需要有zset通过编码实现：</p><ul><li>ZipList是连续内存，因此score和element是紧挨在一起的两个entry，element在前，score在后(当我们查询的时候就可以直接遍历即可，当我们要找m1的score，只需要找到m1在找下一个即可)</li><li>score越小越接近队首，score越大越接近队尾，按照score值升序排列</li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash结构与Redis中的Zset非常类似：</p><ul><li>都是键值存储</li><li>都需求根据键获取值</li><li>键必须唯一</li></ul><p>区别：</p><ul><li>zset的键是member，值是score，hash的键和值都是任意值</li><li>zset要根据score排序；hash则无需排序</li></ul><p>Hash的底层实现也与zset类似，只不过不需要用于排序的SkipList。</p><p>Hash结构默认采用ZipList编码，用以节省内存。ZipList中相邻的两个entry分别保存key和value，随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下：</p><ul><li><code>hash-max-ziplist-entries &gt; 512</code></li><li><code>hash-max-ziplist-value &gt; 64</code></li></ul><p>当满足上面两个条件其中之一的时候，Redis就使用dict字典来实现hash。Redis的hash之所以这样设计，是因为当ziplist变得很大的时候，它有如下几个缺点：</p><ul><li>每次插入或修改引发的realloc操作会有更大的概率造成内存拷贝，从而降低性能</li><li>一旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更大的一块数据</li><li>当ziplist数据项过多的时候，在它上面查找指定的数据项就会性能变得很低，因为ziplist上的查找需要进行遍历</li></ul><p><img src="/inori/abcb1f8f/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Credis_hash.png" alt="redis_hash"></p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/redis/">redis</category>
      
      
      <category domain="http://example.com/tags/redis/">redis</category>
      
      
      <comments>http://example.com/inori/abcb1f8f.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
