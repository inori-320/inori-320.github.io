<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>楪祈のBlog</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>星座になれたら。</description>
    <pubDate>Wed, 06 Mar 2024 07:21:08 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Java命名规范</title>
      <link>http://example.com/inori/1761bce2.html</link>
      <guid>http://example.com/inori/1761bce2.html</guid>
      <pubDate>Wed, 06 Mar 2024 07:18:56 GMT</pubDate>
      
      <description>java命名规范</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol><li>由字母、下划线、美元符号和数字组成，长度不限</li><li>首字符不能是数字</li><li>不能是关键字</li><li>不能是true、false和null，尽管这三个不是关键字</li><li>区分大小写</li></ol><h2 id="变量名（驼峰命名法）"><a href="#变量名（驼峰命名法）" class="headerlink" title="变量名（驼峰命名法）"></a>变量名（驼峰命名法）</h2><p>​    变量的名字可大小写混用，但首字符应小写。词由大写字母分隔，限制用下划线，限制使用美元符（$），因为这个字符对内部类有特殊的含义。</p><p>​    如：inputTextSize。</p><h2 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h2><p>​    包的名字应该都是由一个小写单词组成。</p><p>​    如：net.test.modules。</p><h2 id="类名和接口名"><a href="#类名和接口名" class="headerlink" title="类名和接口名"></a>类名和接口名</h2><p>​    类名每个单词的首字母都要大写，通常由多个单词合成一个类名。</p><p>​    如：DataFile、InfoParser。</p><h2 id="常量名"><a href="#常量名" class="headerlink" title="常量名"></a>常量名</h2><p>​    常量命名则前面应该是static final，后面变量的名字全部大写。</p><p>​    如：static final MAX &#x3D; 1024。</p><h2 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h2><p>​    方法名的第一个单词应该是动词，但首字母小写，后面每个单词的首字母大写。大写字母将词分隔并限制使用下划线。方法如果有传入参数，参数的名字必须和变量的命名规范一致。使用有意义的参数命名，如果可能的话，使用和要赋值的字段一样的名字。</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/1761bce2.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JDBC和连接池</title>
      <link>http://example.com/inori/78c36787.html</link>
      <guid>http://example.com/inori/78c36787.html</guid>
      <pubDate>Sat, 02 Mar 2024 04:43:24 GMT</pubDate>
      
      <description>JDBC</description>
      
      
      
      <content:encoded><![CDATA[<p>​JDBC是为访问不同数据库提供的统一接口，为使用者屏蔽了细节问题。可以利用JDBC连接任何提供了JDBC驱动程序的数据库系统，从而完成对数据库的各种操作。</p><h2 id="数据库连接方式"><a href="#数据库连接方式" class="headerlink" title="数据库连接方式"></a>数据库连接方式</h2><p>连接数据库主要有2种方式</p><ol><li>使用Class.forName自动完成注册驱动，直接连接数据库：</li></ol><blockquote><p>Class.forName(“com.mysql.cj.jdbc.Driver”);</p><p>Connection connection &#x3D; DriverManager.getConnection(url, user, password);&#x2F;&#x2F;其中的参数最好在使用时从文件中提取出来，方便修改</p></blockquote><ol start="2"><li>jdk1.5以后使用了jdbc4，不再需要显示调用Class.forName注册驱动，可以直接使用语句<code>Connection connection = DriverManager.getConnection(url, info);</code>连接数据库</li></ol><h2 id="在Java中输入SQL语句"><a href="#在Java中输入SQL语句" class="headerlink" title="在Java中输入SQL语句"></a>在Java中输入SQL语句</h2><p>在连接建立后，如果需要对数据库进行访问，执行命名或者SQL语句，可以通过Statement、<u>PreparedStatement</u>、CallableStatement，在开发中不会使用Statement，因为其存在SQL注入问题，一般使用PerparedStatement：</p><ul><li>PreparedStatement：执行的SQL语句中的参数用问号(?)来表示，调用相应的set方法来设置对应的参数。set方法有两个参数，第一个参数要设置SQL语句中的?的参数索引（从1开始），第二个是设置SQL语句中参数的值</li></ul><p>在使用DML语句时，直接使用String即可，在使用DQL语句时需要借助ResultSet获取结果：</p><ul><li>ResultSet：保持一个光标指向其当前的数据行。最初光标位于第一行之前。next方法可以将光标移动到下一行，并且在ResultSet对象中没有更多行时返回false，所以可以用while循环遍历结果集。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>使用localhost的test数据库，登录root用户完成对emp表的增删改查。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">info</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">// 从Properties文件中获取数据</span></span><br><span class="line">        info.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;driver&quot;</span>);     <span class="comment">// com.mysql.cj.jdbc.Driver</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> info.getProperty(<span class="string">&quot;url&quot;</span>);           <span class="comment">// jdbc:mysql://localhost/test</span></span><br><span class="line">        Class.forName(driver);</span><br><span class="line">        <span class="type">String</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="string">&quot;insert into emp values(null, &#x27;小明&#x27;, 18)&quot;</span>;<span class="comment">// 增</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">update</span> <span class="operator">=</span> <span class="string">&quot;update emp set name=&#x27;小红&#x27; where id = 1&quot;</span>;<span class="comment">// 改</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">select</span> <span class="operator">=</span> <span class="string">&quot;select id from emp where name=?&quot;</span>;<span class="comment">// 查</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">drop</span> <span class="operator">=</span> <span class="string">&quot;delete from emp where id = 1&quot;</span>;<span class="comment">// 删</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);<span class="comment">// 连接数据库</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(select);</span><br><span class="line">        preparedStatement.executeUpdate(insert);</span><br><span class="line">        preparedStatement.executeUpdate(update);</span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;小明&quot;</span>);<span class="comment">// 设置第一个问号处填写的值</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();<span class="comment">// 使用ResultSet获取select的返回结果</span></span><br><span class="line">        <span class="keyword">while</span> (resultSet.next())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">        preparedStatement.executeUpdate(drop);</span><br><span class="line">        preparedStatement.close();<span class="comment">// 关闭连接</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDBC处理事务"><a href="#JDBC处理事务" class="headerlink" title="JDBC处理事务"></a>JDBC处理事务</h3><p>使用<code>Connection connection = DriverManager.getConnection(url, user, password);</code>得到数据库连接之后，可以<code>connection.setAutoCommit(false)</code>设置事务不自动提交，然后在正常结束的逻辑后面使用<code>connection.commit()</code>提交事务，如果发生了异常，使用<code>connection.rollback()</code>回滚事务</p><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。使用批处理功能时需要在url后面加入参数<code>?rewriteBatchedStatements=true</code>。批处理往往和PreparedStatement一起使用。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><p>addBatch():添加需要批量处理的SQL语句或参数</p></li><li><p>executeBatch():执行批量处理语句</p></li><li><p>clearBatch():清空批处理的语句</p></li></ul><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><h3 id="传统连接的问题"><a href="#传统连接的问题" class="headerlink" title="传统连接的问题"></a>传统连接的问题</h3><ul><li>传统的JDBC数据库连接使用DriverManager获取，每次向数据库建立连接时都要将Connection加载到内存中，再验证IP地址，用户名和密码。频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃</li><li>每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏，最终将导致数据库重启</li><li>传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄漏，数据库崩溃。</li><li>解决传统开发中的数据库连接问题,可以采用数据库连接池技术</li></ul><h3 id="连接池原理"><a href="#连接池原理" class="headerlink" title="连接池原理"></a>连接池原理</h3><ol><li>预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从中取出一个，使用完毕之后再放回去</li><li>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</li><li>当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中</li></ol><h3 id="连接池种类"><a href="#连接池种类" class="headerlink" title="连接池种类"></a>连接池种类</h3><ol><li>JDBC的数据库连接池使用javax.sql.DataSource表示，DataSource是一个接口，通常由第三方提供实现</li><li><u>C3P0</u>连接池，速度相对较慢，稳定性强(hibernate, spring底层使用该连接池)</li><li>DBCP连接池，速度较快，不稳定</li><li>Proxool数据库连接池，可以监控连接池状态，稳定性较差</li><li>BoneCP数据库连接池，速度快</li><li><u>Druid</u>(德鲁伊)是阿里提供的连接池，集DBCP、C3PO、Proxool优点于一身的数据库连接池</li></ol><h3 id="C3P0连接池"><a href="#C3P0连接池" class="headerlink" title="C3P0连接池"></a>C3P0连接池</h3><p>要使用C3P0连接池，首先要导入C3P0的jar包，并且把jar包当做library加入到项目中</p><p>使用时：</p><ol><li>实例化<code>ComboPooledDataSource</code>数据源对象</li><li>通过配置文件获取数据库相关信息</li><li>通过方法给数据源设置相关参数<code>setDriverClass</code>、<code>setJdbcUrl</code>、<code>setUser</code>、<code>setPassword</code></li><li>设置初始化连接数（连接池中一开始的连接数量）和最大连接数（最多能有多少连接）：<code>setInitialPoolSize(n)</code>、<code>setMaxPoolSize(n)</code></li><li>拿到连接：<code>Connection connection = comboPooledDataSource.getConnection()</code></li></ol><h3 id="Druid连接池"><a href="#Druid连接池" class="headerlink" title="Druid连接池"></a>Druid连接池</h3><ol><li>首先配置Properties文件，在文件中写明driver、url、user、password、initialSize、minIdle、maxActive、maxWait参数</li><li>创建指定参数的数据库连接池<code>DataSource ds = DruidDataSourceFactory.createDataSource(properties)</code></li><li>拿到连接：<code>Connection connection = ds.getConnection()</code></li></ol><h2 id="ApDBUtils"><a href="#ApDBUtils" class="headerlink" title="ApDBUtils"></a>ApDBUtils</h2><p>commons-dbutils是一个JDBC工具类库，可以极大简化jdbc编码的工作量。</p><h3 id="DbUtils类"><a href="#DbUtils类" class="headerlink" title="DbUtils类"></a>DbUtils类</h3><ul><li>QueryRunner类：封装了SQL的执行，可以实现增删改查和批处理操作，线程安全</li><li>ResultSetHandler：用于出来ResultSet，按照数据要求转换成另一种形式<ul><li>BeanHandler:将结果集中的第一行数据封装到一个对应的JavaBean实例中</li><li>BeanListHandler:将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里</li><li>ScalarHandler:查询单行单列信息时，将该信息包装成一个Object对象返回</li><li>update:执行增删改操作，返回受影响的行数</li></ul></li></ul><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>首先导入commons-dbutils.jar包，然后才能使用其提供的方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        data.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));<span class="comment">// 从文件中读取driver、url、user、password</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(data);<span class="comment">// 创建德鲁伊数据源对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ds.getConnection();·<span class="comment">// 获取连接</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">select</span> <span class="operator">=</span> <span class="string">&quot;select * from emp where id &gt;= ?&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">update</span> <span class="operator">=</span> <span class="string">&quot;update emp set name = ? where id = ?&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">insert</span> <span class="operator">=</span> <span class="string">&quot;insert into emp values(null, ?, ?)&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">update</span> <span class="operator">=</span> <span class="string">&quot;delete from emp where id = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// query执行sql语句，得到resultset并封装到ArrayList中，需要传入connection、sql语句、BeanListHandler对象, 最后的数字是给?赋值，可以有多个</span></span><br><span class="line">        List&lt;Actor&gt; list = queryRunner.query(connection, select, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(Actor.class), <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 执行DML语句使用update方法，传入连接，sql和需要赋值的?</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> queryRunner.update(connection, update, <span class="string">&quot;小明&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        rows = queryRunner.update(connection, insert, <span class="string">&quot;小白&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        rows = queryRunner.update(connection, drop, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(Actor a: list)&#123;</span><br><span class="line">            System.out.println(a.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        connection.close();<span class="comment">// 只需要关闭connection，resultset和perparedStatement由queryRunner自动关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/78c36787.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL进阶篇（上）</title>
      <link>http://example.com/inori/f4c950eb.html</link>
      <guid>http://example.com/inori/f4c950eb.html</guid>
      <pubDate>Thu, 29 Feb 2024 07:53:08 GMT</pubDate>
      
      <description>MySQL进阶篇</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>​存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，也可以被成为表类型。</p><ul><li>创建表时可以指定存储引擎，在CREATE TABLE语句后面添加<code>ENGINE=存储引擎名</code></li><li>查询数据库支持的存储引擎：<code>SHOW ENGINES;</code></li></ul><h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="D:\Blog\source\img\mysqlStruct.png" alt="mysqlStruct"></p><p>MySQL的服务端是分层实现的：</p><ol><li>连接层：接收客户端连接，完成安全处理，授权和校验权限等操作</li><li>服务层：核心部分，实现SQL接口，解析器，查询优化器，缓存等，所有跨存储引擎的功能也在这一层实现，如过程，函数等</li><li>引擎层：存储引擎负责MySQL中数据的存储和提取的方式，服务器通过API和存储引擎通信。不同的存储引擎有不同的功能</li><li>存储层：存储数据库数据</li></ol><h2 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h2><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，MySQL5.5之后默认的存储引擎为InnoDB</p><p>特点：</p><ul><li>DML操作遵循ACID模型，支持事务</li><li>行级锁，提高并发访问性能</li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性</li></ul><p>文件：xxx.ibd，xxx表示表名，InnoDB每张表都会对应这样一个表空间文件，存储表结构（frm，sdi）、数据和索引。</p><h4 id="InnoDB的逻辑存储结构"><a href="#InnoDB的逻辑存储结构" class="headerlink" title="InnoDB的逻辑存储结构"></a>InnoDB的逻辑存储结构</h4><p><img src="D:\Blog\source\img\mysql_innodb.png" alt="mysql_innodb"></p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MySQL早期的默认存储引擎</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：xxx.MYD、xxx.MYI、xxx.sdi。sdi文件存储表结构信息，MYD文件存放数据，MYI文件存储索引</p><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>表数据存储在内存中，可能会受到硬件问题或断电问题影响，只能将这些表作为临时表或者缓存使用</p><p>特点：</p><ul><li>存放在内存中，访问速度更快</li><li>支持hash索引</li></ul><p>文件：xxx.sdi。存储表结构信息</p><h3 id="三个存储引擎特点对比"><a href="#三个存储引擎特点对比" class="headerlink" title="三个存储引擎特点对比"></a>三个存储引擎特点对比</h3><p><img src="D:\Blog\source\img\mysql_engineSpecial.png" alt="mysql_engineSpecial"></p><h3 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h3><ul><li><u>InnoDB</u>：适合对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询外还包括更新、删除操作的场景</li><li>MyISAM：适合以读和插入操作为主，对事务的完整性、并发性要求不高的场景，可以被MongoDB替代</li><li>MEMORY：通常作为临时表和缓存，可以被Redis替代</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>​索引是帮助MySQL高效获取数据的<u>有序</u>数据结构。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据，可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p>​索引可以提高数据检索的效率，降低数据库的IO成本，并且通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。带来好处的同时，索引降低了更新表的速度，对表进行增删改时效率降低，但是在正常业务中，增删改的频率要远小于查询，基本可以忽略这个缺点。</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种：</p><table><thead><tr><th align="center">索引结构</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">B+ Tree</td><td align="center">最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td align="center">Hash</td><td align="center">使用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询。Memory支持该索引</td></tr><tr><td align="center">R-tree空间索引</td><td align="center">主要用于地理空间数据类型，使用较少，MyISAM的特殊索引类型</td></tr><tr><td align="center">Full-text全文索引</td><td align="center">通过建立倒排索引，快速匹配文档的方式，类似于Lucene，Solr，ES。InnoDB和MyISAM支持该索引。</td></tr></tbody></table><p>平常说的索引一般都是B+ Tree索引</p><h4 id="为什么InnoDB存储引擎选择使用B-tree索引？"><a href="#为什么InnoDB存储引擎选择使用B-tree索引？" class="headerlink" title="为什么InnoDB存储引擎选择使用B+tree索引？"></a>为什么InnoDB存储引擎选择使用B+tree索引？</h4><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>相对于B Tree，无论是叶子节点还是非叶子节点，都会保存数据，这会导致一页中存储的键值和指针减少，进而导致树的层级变深，性能降低</li><li>相对于Hash索引，B+ Tree支持范围匹配和排序</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><img src="D:\Blog\source\img\mysql_indexType.png" alt="mysql_indexType"></p><p>在InnoDB中，根据索引的存储形式，又可以分为<u>聚集索引</u>和<u>二级索引</u>：</p><p><img src="D:\Blog\source\img\mysql_InnoDBIndexType.png" alt="mysql_InnoDBIndexType"></p><p>在进行查找时，如果查找的不是主键，则需要先在二级索引找到对应的主键，再去聚集索引找到全部信息，这叫做回表查询。</p><h3 id="索引的语法"><a href="#索引的语法" class="headerlink" title="索引的语法"></a>索引的语法</h3><ul><li>创建索引：<code>CREATE [UNIUQE|FULLTEXT] INDEX 索引名 ON 表名(字段列表);</code></li><li>查看索引：<code>SHOW INDEX FROM 表名;</code></li><li>删除索引：<code>DROP INDEX 索引名 ON 表名;</code></li></ul><h3 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h3><ul><li><p>SQL执行频率：MySQL客户端连接成功后，通过<code>show[session|global] status</code>命令可以提供服务器状态信息。</p><p>如：<code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code>查看数据库增删改查的使用频率</p></li><li><p>慢查询日志：记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>默认是关闭状态，可以通过sql语句<code>set global slow_query_log=ON;</code>和<code>set long_query_time=x;</code>打开慢查询日志记录和设置慢查询门槛时间</p></li><li><p>profile详情：<code>show profiles</code>能够在做SQL优化时帮助我们了解各种操作耗费时间的详情。</p><p>默认profile是关闭状态，通过<code>set global profiling=1;</code>打开。</p><ul><li>查看每一条SQL语句的耗时情况：<code>show profiles;</code></li><li>查看指定query_id的SQL语句各个阶段的耗时情况：<code>show profile for query query_id;</code></li><li>查看指定query_id的SQL语句CPU使用情况：<code>show prifile cpu for query query_id;</code></li></ul></li><li><p>explain执行计划：可以使用explain或者desc命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。语法为EXPLAIN&#x2F;DESC + SELECT语句。</p><p>explain各字段的含义：</p><ul><li>id：表示查询中执行select子句或者是操作表的顺序（id号大的先执行，id相同，执行顺序从上到下）</li><li>select_type：表示select的类型，常见的取值有simple（简单表，不使用表连接和子查询）、primary（主查询）、union（union后面的查询语句）、subquery（子查询语句）</li><li><u>type</u>：表示连接类型，性能由好到差的连接类型为：NULL、system、const、eq_ref、ref、range、index、all</li><li><u>possible_key</u>：显示可能应用在这张表上的索引</li><li><u>key</u>：实际用到的索引</li><li><u>key_len</u>：索引中使用的字节数，索引字段最大可能长度</li><li>rows：MySQL认为必须要执行查询的行数，估计值</li><li>filtered：表示返回结果的行数占续读取行数的百分比，值越大越好</li></ul></li></ul><h3 id="索引使用注意事项"><a href="#索引使用注意事项" class="headerlink" title="索引使用注意事项"></a>索引使用注意事项</h3><ul><li><p>遵守最左前缀法则：如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是**<u>在查询时</u>**select语句必须要从建立索引的最左列开始，并且不跳过索引中的列。如果跳过某一列，后面字段的索引将失效。</p></li><li><p>避免范围查询：在联合索引中，如果出现了范围查询（&gt;、&lt;），范围查询右侧的列索引失效。但是如果使用(&gt;&#x3D;,&lt;&#x3D;)则不会失效，所以在查询时尽量使用&gt;&#x3D;和&lt;&#x3D;。</p></li><li><p>避免索引列运算：在索引列上进行运算操作，索引会失效</p></li><li><p>字符串加引号：如果查询时字符串不加单引号，索引失效</p></li><li><p>避免头部模糊匹配：使用模糊匹配时，使用尾部模糊匹配，索引不会失效，使用头部模糊匹配时，索引失效</p></li><li><p>or连接：用or关键字分割开的条件，只要有一个条件没有建立索引，所有条件的索引都会失效</p></li><li><p>数据分布影响：如果MySQL评估使用索引比全表扫描还慢，则不使用索引</p></li><li><p>SQL提示：优化数据库的一个重要手段，在SQL语句中加入一些人为的提示信息来达到优化操作的目的</p><ul><li>use index(建议使用):<code>EXPLAIN SELECT 字段名 FROM 表名 USE INDEX(索引名) WHERE 条件;</code></li><li>ignore index(不要使用):<code>EXPLAIN SELECT 字段名 FROM 表名 IGNORE INDEX(索引名) WHERE 条件;</code></li><li>force index(强制使用):<code>EXPLAIN SELECT 字段名 FROM 表名 FORCE INDEX(索引名) WHERE 条件;</code></li></ul></li><li><p>尽量使用覆盖索引（需要查找的字段只需要一次索引就能找全，不需要回表），避免select *</p></li><li><p>前缀索引：当字段类型为字符串时，有时需要索引很长的字符串，可以直将字符串的一部分前缀建立索引，达到节约索引空间，提高效率的效果。</p><p>语法：<code>CREATE INDEX 索引名 ON 表名(字段名(n))</code>其中n是想要建立索引的字段前缀长度</p><p>长度选择：可以通过<code>SELECT COUNT(distinct substring(字段名,1,n))/COUNT(*) FROM 表名;</code>来计算索引性，选择合适的长度，越接近1越好</p></li><li><p>联合索引：如果存在多个查询条件，针对查询字段建立联合索引可以做到覆盖查询，提高效率。建立联合索引时要注意字段位置</p></li></ul><h3 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h3><ol><li>数据量较大（大于一百万），且查询比较频繁的表</li><li>针对于常作为查询条件(where)、排序（order by)、分组(group by)操作的字段建立索引</li><li>选择区分度高的列作为索引，建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段的长度较长，可以针对字段建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，只建立有必要的索引，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，需要在创建表时使用NOT NULL约束。这样优化器知道每列是否包含NULL值，可以更好地确定哪个索引更有效</li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/MySQL/">MySQL</category>
      
      
      <comments>http://example.com/inori/f4c950eb.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>MySQL基础篇</title>
      <link>http://example.com/inori/337fcc87.html</link>
      <guid>http://example.com/inori/337fcc87.html</guid>
      <pubDate>Tue, 27 Feb 2024 02:15:40 GMT</pubDate>
      
      <description>MySQL基础篇</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="MySQL概述"><a href="#MySQL概述" class="headerlink" title="MySQL概述"></a>MySQL概述</h2><table><thead><tr><th align="center">名称</th><th align="center">解释</th><th align="center">简称</th></tr></thead><tbody><tr><td align="center">数据库</td><td align="center">将数据有组织的存储的仓库</td><td align="center">DataBase(DB)</td></tr><tr><td align="center">数据库管理系统</td><td align="center">操纵和管理数据库的大型软件</td><td align="center">DBMS</td></tr><tr><td align="center">SQL</td><td align="center">操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准</td><td align="center">Structured Query Language</td></tr></tbody></table><p>工程师通过SQL操作DBMS，间接管理数据库中的数据</p><p>Oracle、MySQL等系统是关系型数据库管理系统，支持使用SQL语言进行数据库操作。</p><p>关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</p><h3 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h3><p>安装：这里推荐安装Mysql8版本，可以参考<a href="https://zhuanlan.zhihu.com/p/645347983?utm_id=0">这篇文章</a>安装MySQL</p><p>启动与停止：</p><blockquote><p>net start mysql80</p><p>net stop mysql80</p></blockquote><p>客户端连接：<code>mysql [-h 127.0.0.1] [-P 3306] -u root -p</code></p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul><li>SQL语句可以单行或多行书写，以分号结尾</li><li>MySQL中的SQL语句不区分大小写，但是关键字推荐使用大写</li><li>注释：<ul><li>单行注释：<code>-- 注释内容</code>或<code># 注释内容</code>(MySQL特有)</li><li>多行注释：<code>/*注释内容*/</code></li></ul></li></ul><h3 id="SQL数值类型"><a href="#SQL数值类型" class="headerlink" title="SQL数值类型"></a>SQL数值类型</h3><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p><img src="D:\Blog\source\img\mysql_intDataType.png" alt="mysql_datatype"></p><p>无符号数<code>TINYINT UNSIGNED</code>，DECIMAL类型<code>DECIMAL(x,y)</code>，x代表数字的整体长度&#x3D;整数长度+小数长度，y代表小数的长度</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p><img src="D:\Blog\source\img\mysql_charDataType.png" alt="mysql_datatype"></p><p>​CHAR为定长字符串，开多少空间就占用多少空间，VARCHAR为变长字符串，根据存储的数据动态计算空间。</p><p>​长文本数据分为<u>BLOB</u>和<u>TEXT</u>类型，BLOB表示二进制数据，可以是音频、视频、图像等数据，可以将其存储在数据库中，但是在开发时很少这么做，一般采用专门的文件服务器进行存储。</p><h4 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h4><p><img src="D:\Blog\source\img\mysql_timeDataType.png" alt="mysql_timeDataType"></p><h3 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h3><table><thead><tr><th align="center">分类</th><th align="center">全称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">DDL</td><td align="center">Data Definition Language</td><td align="center">数据定义语言，定义数据库对象（数据库，表，字段）</td></tr><tr><td align="center">DML</td><td align="center">Data Manipulation Language</td><td align="center">数据操作语言，对数据库表中的数据进行增删改</td></tr><tr><td align="center">DQL</td><td align="center">Data Query Language</td><td align="center">数据查询语言，查询表中的记录</td></tr><tr><td align="center">DCL</td><td align="center">Data Control Language</td><td align="center">数据控制语言，创建数据库用户、控制访问权限</td></tr></tbody></table><h3 id="DDL语句"><a href="#DDL语句" class="headerlink" title="DDL语句"></a>DDL语句</h3><p><code>[...]</code>部分为可选参数</p><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><ul><li>查询所有数据库：<code>SHOW DATABASES;</code></li><li>查询当前数据库：<code>SELECT DATABASE();</code></li><li>创建：<code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]; </code></li><li>删除：<code>DROP DATABASE [IF EXISTS] 数据库名;</code></li><li>使用：<code>USE 数据库名;</code></li></ul><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><ul><li>查询数据库所有表：<code>SHOW TABLES;</code></li><li>查询表结构：<code>DESE 表名;</code></li><li>查询指定表的建表语句：<code>SHOW CREATE TABLE 表名;</code></li><li>创建表：</li></ul><blockquote><p>CREATE TABLE 表名(</p><p>​字段1 字段1类型[COMMENT 字段1注释],</p><p>​字段2 字段2类型[COMMENT 字段2注释],</p><p>​…..,</p><p>​字段n 字段n类型[COMMENT 字段n注释]</p><p>)[COMMENT 表注释];</p></blockquote><ul><li>添加字段：<code>ALTER TABLE 表名 ADD 字段名 类型 [comment] [约束];</code></li><li>修改数据类型：<code>ALTER TABLE 表名 MODIFY 字段名 新类型;</code></li><li>修改字段名和类型：<code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 [comment] [约束];</code></li><li>修改表名：<code>ALTER TABLE 表名 RENAME TO 新表名;</code></li><li>删除字段：<code>ALTER TABLE 表名 DROP 字段名;</code></li><li>删除表：<code>DROP TABLE [IF EXISTS] 表名;</code></li><li>删除指定表并重新创建（格式化该表）：<code>TRUNCATE TABLE 表名;</code></li></ul><h3 id="DML语句"><a href="#DML语句" class="headerlink" title="DML语句"></a>DML语句</h3><ul><li>给指定字段添加数据：<code>INSERT INTO 表名（字段1，字段2...） VALUES（值1，值2...）;</code></li><li>给全部字段添加数据：<code>INSERT INTO 表名 VALUES（值1，值2...）;</code></li><li>批量添加数据：</li></ul><blockquote><p>INSERT INTO 表名（字段1，字段2…） VALUES（值1，值2…）,（值1，值2…）…;</p><p>INSERT INTO 表名 VALUES（值1，值2…）,（值1，值2…）…;</p></blockquote><ul><li>修改数据：<code>UPDATE 表名 SET 字段1=值1, 字段2=值2...[WHERE 条件];</code></li><li>删除数据：<code>DELETE FROM 表名 [WHERE 条件];</code></li></ul><h3 id="DQL语句"><a href="#DQL语句" class="headerlink" title="DQL语句"></a>DQL语句</h3><ul><li><p>查询多个字段：<code>SELECT 字段1,字段2,... FROM 表名;</code></p></li><li><p>查询全部字段：<code>SELECT * FROM 表名;</code></p></li><li><p>设置别名：<code>SELECT 字段1 AS 别名1,字段2 AS 别名2,... FROM 表名;</code></p></li><li><p>去重：<code>SELECT DISTINCT 字段列表 FROM 表名;</code></p></li><li><p>条件查询：<code>SELECT 字段列表 FROM WHERE 条件列表;</code></p><p><u>此处的条件列表与其他编程语言的条件判断基本一致</u>，个别不一样的中常用的有<code>LIKE 占位符</code>表示模糊匹配（_匹配单个字符，%匹配任意字符）</p></li><li><p>使用聚合函数查询：<code>SELECT 聚合函数(字段列表) FROM 表名;</code></p></li></ul><p>​常用的聚合函数有：<u>count(),max(),min(),avg(),sum()</u>,按列进行计算</p><ul><li><p>分组查询：<code>SELECT 字段列表 FROM 表名 [WHERE 分组前过滤条件] GROUP BY 分组字段名 [HAVING 分组后的过滤条件];</code>（其中having中可以使用聚合函数过滤，where中不可以，并且分组之后查询的字段一般为分组字段和聚合函数）</p></li><li><p>排序查询：<code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1,字段2 排序方式2;</code></p><p><u>排序方式有两种：ASC：升序（默认），DESC：降序。</u>如果是多字段排序，当且仅当第一个字段相同时按照第二个排。</p></li><li><p>分页查询：<code>SELECT 字段列表 FROM 表名 LIMIT 起始索引,查询记录数;</code></p><ul><li>索引从0开始编号，起始索引&#x3D;（查询页面-1）*每页的记录数</li><li>分页查询时数据库的方言，不同的数据库中实现语句不同，MySQL中是LIMIT</li><li>如果查的是第一页的数据，起始索引可以省略</li></ul></li></ul><h4 id="DQL语句编写顺序与执行顺序"><a href="#DQL语句编写顺序与执行顺序" class="headerlink" title="DQL语句编写顺序与执行顺序"></a>DQL语句编写顺序与执行顺序</h4><p><img src="D:\Blog\source\img\mysql_DQLSequence.png" alt="mysql_DQLSequence"></p><h3 id="DCL语句"><a href="#DCL语句" class="headerlink" title="DCL语句"></a>DCL语句</h3><ul><li>查询用户：<code>SELECT * FROM user;</code></li><li>创建用户：<code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></li><li>修改用户密码：<code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password &#39;新密码&#39;;</code></li><li>删除用户：<code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>查询用户权限：<code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>授予权限：<code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>撤销权限：<code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></li></ul><h4 id="常用的权限"><a href="#常用的权限" class="headerlink" title="常用的权限"></a>常用的权限</h4><table><thead><tr><th align="center">权限</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">all&#x2F;all privileges</td><td align="center">所有权限</td></tr><tr><td align="center">select</td><td align="center">查询数据</td></tr><tr><td align="center">insert</td><td align="center">插入数据</td></tr><tr><td align="center">update</td><td align="center">修改数据</td></tr><tr><td align="center">delete</td><td align="center">删除数据</td></tr><tr><td align="center">alter</td><td align="center">修改表</td></tr><tr><td align="center">drop</td><td align="center">删除数据库、表、视图</td></tr><tr><td align="center">create</td><td align="center">创建数据库、表</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在数据库中，函数指的是可以直接被另一段程序调用的程序或代码。</p><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CONCAT(S1,S2,…,Sn)</td><td align="center">字符串拼接，将给定的字符串拼成一个</td></tr><tr><td align="center">LOWER(str)</td><td align="center">str全部字符转成小写</td></tr><tr><td align="center">UPPER(str)</td><td align="center">str全部字符转成大写</td></tr><tr><td align="center">LPAD(str,n,pad)</td><td align="center">左填充，用字符串pad对str的左边进行填充直到长度到达n</td></tr><tr><td align="center">RPAD(str,n,pad)</td><td align="center">右填充，用字符串pad对str的右边进行填充直到长度到达n</td></tr><tr><td align="center">TRIM(str)</td><td align="center">去掉收尾空格</td></tr><tr><td align="center">SUBSTRING(str,start,len)</td><td align="center">返回字符串str从start开始len长度的字符串，索引从1开始</td></tr><tr><td align="center">LENGTH(str)</td><td align="center">返回字符串长度</td></tr></tbody></table><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CEIL(x)</td><td align="center">上取整</td></tr><tr><td align="center">FLOOR(x)</td><td align="center">下取整</td></tr><tr><td align="center">MOD(x,y)</td><td align="center">返回x&#x2F;y的模</td></tr><tr><td align="center">RAND()</td><td align="center">返回0~1的随机数</td></tr><tr><td align="center">ROUND(x,y)</td><td align="center">求x的四舍五入，保留y位小数</td></tr></tbody></table><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CURDATE()</td><td align="center">返回当前日期</td></tr><tr><td align="center">CURTIME()</td><td align="center">获取当前时间</td></tr><tr><td align="center">NOW()</td><td align="center">获取当前日期和时间</td></tr><tr><td align="center">YEAR(date)</td><td align="center">返回指定date的年份</td></tr><tr><td align="center">MONTH(date)</td><td align="center">返回指定date的月份</td></tr><tr><td align="center">DAY(date)</td><td align="center">返回指定date的日</td></tr><tr><td align="center">DATE_ADD(date,INTERVAL expr type)</td><td align="center">返回一个日期&#x2F;时间加上一个时间间隔expr后的时间</td></tr><tr><td align="center">DATEDIFF(date1,date2)</td><td align="center">返回date1和date2之间间隔的天数，date1-date2</td></tr></tbody></table><h3 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h3><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">IF(value,t,f)</td><td align="center">如果value为true，返回t，否则返回f</td></tr><tr><td align="center">IFNULL(value1,value2)</td><td align="center">如果value1不为空，返回value1，否则返回value2</td></tr><tr><td align="center">CASE WHEN [val1] THEN [res1]…ELSE[default]END</td><td align="center">如果val1为true，返回res1,…否则返回默认值</td></tr><tr><td align="center">CASE [expr] WHEN [val1] THEN [res1]…ELSE[default]END</td><td align="center">如果expr的值等于val1，返回res1,…否则返回默认值</td></tr></tbody></table><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>​约束是作用于表中字段上的规则，在创建表或修改表的时候添加约束，用于限制存储在表中的数据。可以保证数据的正确，有效性和完整性。</p><h3 id="约束的分类"><a href="#约束的分类" class="headerlink" title="约束的分类"></a>约束的分类</h3><p><img src="D:\Blog\source\img\mysql_limitTyoe.png" alt="mysql_limitTyoe"></p><p>添加约束时只需要在后面直接添加关键字即可，不同约束使用空格隔开</p><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>​外键用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性，具有外键的称为子表&#x2F;从表，外键所关联的表称为父表&#x2F;主表。</p><ul><li>建立外键关联</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可以在创建表时直接指明外键</span><br><span class="line">CREATE TABLE name(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">    ...,</span><br><span class="line">    [CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 或者建表之后额外添加</span><br><span class="line">ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表(主表字段);</span><br></pre></td></tr></table></figure><ul><li>删除外键：<code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</code></li></ul><h3 id="外键约束-1"><a href="#外键约束-1" class="headerlink" title="外键约束"></a>外键约束</h3><p><img src="D:\Blog\source\img\mysql_fkType.png" alt="mysql_fkType"></p><p>使用时在外键命令后面添加<code>ON UPDATE 行为 ON DELETE 行为</code></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>多表查询即从多张表中查询数据。可以分为<u>连接查询</u>和<u>子查询</u></p><ul><li><p>连接查询</p><ul><li><p>内连接</p></li><li><p>外连接</p><ul><li><p>左外连接</p></li><li><p>右外连接</p></li></ul></li><li><p>自连接</p></li></ul></li><li><p>子查询</p></li></ul><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li><p>一对一：</p><ul><li>案例：个人与个人信息</li><li>关系：每个人有每个人自己的个人信息</li><li>实现：将基础字段放在一张表中，详情信息放在另一张表中，在任意一方加入外键，关联另一方的主键，并设置外键为UNIQUE</li></ul></li><li><p>一对多&#x2F;多对一：</p><ul><li>案例：部门与员工</li><li>关系：一个部门对应多个员工，一个员工对应一个部门</li><li>实现：在多的一方建立外键，指向一的一方的主键</li></ul></li><li><p>多对多：</p><ul><li>案例：学生与课程</li><li>关系：一个学生可以选修多门课程，一门课程可以有多个学生选择</li><li>实现：建立一张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul></li></ul><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>查询A、B交集部分的数据</p><ul><li>隐式内连接：<code>SELECT 字段列表 FROM 表1,表2 WHERE 条件;</code></li><li>显示内连接：<code>SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件;</code></li></ul><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>查询左表所有数据，以及两张表交集部分的数据</p><p><code>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件; </code></p><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>查询右表所有数据，以及两张表交集部分的数据</p><p><code>SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件; </code></p><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>当前表与自身的连接查询，自连接必须使用表别名。自连接可以是内连接查询，也可以是外连接查询</p><p><code>SELECT 字段列表 FROM 表1 别名1 JOIN 表2 别名2 ON 条件; </code></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>SQL语句中嵌套SELECT语句称为嵌套查询，也叫子查询，子查询外部的语句可以是增删改查任意一个</p><p>例如：<code>SELECT 字段列表 FROM 表1 WHERE 字段1=(SELECT 字段1 FROM 表2); </code></p><p>根据子查询结果不同，分为：</p><ul><li><p>标量子查询（子查询结果为单个值）：直接嵌套查询即可</p></li><li><p>列子查询：</p><p>常用的操作符：IN(指定范围内),NOT IN(不在指定范围内),ANY(返回列表中任意一个满足条件即可),SOME(同ANY),ALL(条件必须全部满足)</p></li><li><p>行子查询:</p><p>常用的操作符：&#x3D;,&lt;&gt;,IN,NOT IN</p></li><li><p>表子查询（多行多列）:</p><p>常用的操作符：IN</p></li></ul><h3 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h3><p>联合查询使用union(合并后去重)，union all(合并)命令，可以把多次查询的结果合并起来，形成一个新的查询结果集</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 ...</span><br><span class="line">UNION[ALL]</span><br><span class="line">SELECT 字段列表 FROM 表1 ...;</span><br></pre></td></tr></table></figure><p>联合查询中多张表的列数必须保持一致，字段类型也要一致。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>​事务是一组操作的集合，是不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或者撤销操作请求。</p><p>​默认MySQL的事务是自动提交的，即执行DML语句时，MySQL会立即隐式的提交事务。</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><p>操作事务有两种方式：1.关闭事务的自动提交 2.通过指令显式开启事务</p><ul><li>查看事务提交方式：<code>SELECT @@autocommit;</code></li><li>设置事务提交方式(1为自动提交，0为手动提交）：<code>SET @@autocommit=0;</code> </li><li>开启事务：<code>START TRANSACTION;</code></li><li>提交事务：<code>COMMIT;</code></li><li>回滚事务：<code>ROLLBACK;</code></li></ul><h3 id="事务四大特性ACID"><a href="#事务四大特性ACID" class="headerlink" title="事务四大特性ACID"></a>事务四大特性ACID</h3><ul><li>原子性A：事务不可分割，事务中的操作要么同时成功，要么同时失败。</li><li>一致性C：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性I：数据库系统提供的隔离机制，保证事务在不收外部并发操作影响的独立环境下运行</li><li>持久性D：事务一旦提交或回滚，对数据的改变就是永久的</li></ul><h3 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h3><p>多个并发事务在执行过程当中所出现的问题</p><table><thead><tr><th align="center">问题</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">脏读</td><td align="center">一个事务读取到另一个事务还没有提交的数据</td></tr><tr><td align="center">不可重复读</td><td align="center">一个事物先后读取到同一条数据，但两次读取的数据不同</td></tr><tr><td align="center">幻读</td><td align="center">一个事物按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>√表示该隔离级别会出现对应问题，从上到下隔离级别由低到高，性能由高到低</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read committed</td><td align="center">x</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable Read</td><td align="center">x</td><td align="center">x</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><p>MySQL中的默认隔离级别是<u>Repeatable Read</u>，Oracle是<u>Read committed</u></p><ul><li>查看事务隔离级别：<code>SELECT @@transaction_isolation;</code></li><li>设置事务隔离级别：<code>SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;隔离级别&#125;;</code></li></ul>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://example.com/tags/MySQL/">MySQL</category>
      
      
      <comments>http://example.com/inori/337fcc87.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java反射</title>
      <link>http://example.com/inori/e29c8e30.html</link>
      <guid>http://example.com/inori/e29c8e30.html</guid>
      <pubDate>Fri, 23 Feb 2024 11:48:29 GMT</pubDate>
      
      <description>java反射基础</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>利用反射机制，可以通过外部文件配置，在不修改源码的情况下控制程序，符合设计模型中OCP原则</p><ol><li>反射机制允许程序在执行期间借助于<code>Reflection</code>API取得任何类的内部信息（成员变量、构造器、成员方法等），并能操作对象的属性及方法。</li><li>加载类之后，在堆中产生了一个<code>Class</code>类型的对象，这个对象包括了类的完整结构信息。这个对象就像一面镜子，通过这个镜子看到类的结构，所以称之为：反射</li><li>反射可以做到的事：<ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时得到任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>生成动态代理</li></ul></li><li>使用反射后，程序的执行速度会受到影响</li></ol><h2 id="反射相关的类"><a href="#反射相关的类" class="headerlink" title="反射相关的类"></a>反射相关的类</h2><p>常用的反射相关的类都在<code>java.lang</code>包中</p><ol><li>Class:代表一个类，表示某个类加载后在堆中的对象</li><li>reflect.Method:类的方法</li><li>reflect.Field:类的成员变量，<u>不能得到private属性</u></li><li>reflect.Constructor:构造器</li></ol><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ol><li>Class类也是继承Object的类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class对象，在内存中只有一份，因为类只加载一次（比如在使用反射加载类对象之前已经实例化过一次该类，就不会再调用loadClass方法）</li><li>Class对象存放在堆中</li><li>类的字节码二进制数据存放在方法区，称为类的元数据</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">static Class forName（）</td><td align="center">返回指定类名的Class对象</td></tr><tr><td align="center">Object newInstance()</td><td align="center">返回Class对象的一个实例</td></tr><tr><td align="center">String gatName()</td><td align="center">返回Class对象所表示的实体（类，接口，基本类型等）的名称</td></tr><tr><td align="center">Class getSuperClass()</td><td align="center">返回其父类</td></tr><tr><td align="center">Constructor[] getConstructors()</td><td align="center">返回本类的构造器</td></tr><tr><td align="center">ClassLoader getClassLoader()</td><td align="center">返回类的加载器</td></tr><tr><td align="center">Field[] getFields()</td><td align="center">返回所有public修饰的属性，包括本类及父类</td></tr><tr><td align="center">Field[] getDeclaredFields()</td><td align="center">返回本类所有属性</td></tr><tr><td align="center">Method[] getMethods()</td><td align="center">返回所有public修饰的方法，包括本类及父类</td></tr><tr><td align="center">Method[] getDeclaredMethods()</td><td align="center">返回本类所有方法</td></tr></tbody></table><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><ol><li>若已知一个类的完整路径“包名.类名”，可以通过Class类的<code>forName()</code>获取。<u>应用场景</u>：配置文件，读取类全路径，加载类</li><li>若已知具体的类，可以通过<code>类.class</code>获取，该方式也可以获取基本数据类型的Class对象。<u>应用场景</u>：用于参数传递，如通过反射的对应构造器对象。</li><li>如果已经有该类的实例，可以通过<code>对象.getClass()</code>获取Class对象</li><li>通过类加载器获取：</li></ol><blockquote><p>ClassLoader classLoader &#x3D; test.getClass().getClassLoader();</p><p>Class cls &#x3D; classLoader.loadClass(classAllPath);&#x2F;&#x2F; classAllPath为类的完整路径</p></blockquote><ol start="5"><li>基本数据类型的包装类（Integer，Boolean等）可以通过<code>.TYPE</code>获取Class对象</li></ol><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p>类加载分为<u>静态加载</u>和<u>动态加载</u>。</p><p>静态加载：编译时加载相关的类，如果没有则报错，哪怕不一定会用到这个类，也会加载</p><p>动态加载：运行时加载需要的类，如果运行时不用该类就不会报错，反射使用的就是动态加载方案</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scanf.nextInt();</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();<span class="comment">// 静态加载，哪怕可能不会使用到这个类也会加载，会直接报错</span></span><br><span class="line">                dog.method();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;Dog&quot;</span>);<span class="comment">// 动态加载，当使用到的时候才会报错</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">m</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">                m.invoke();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h5><p>大体流程如下图所示。</p><p><img src="D:\Blog\source\img\ClassLoad.png"></p><p>​首先对源码进行编译，生成字节码文件，在运行时进入类加载，由类加载器将类的class文件读入内存，并创建一个Class对象。</p><p>然后进入连接阶段，把二进制数据合并到JRE中，<u>验证：</u>对文件安全性进行验证，<u>准备：</u>对静态变量进行默认初始化并分配空间，解析：把符号引用转成直接引用（地址引用）。最后进行初始化，由JVM负责，执行<code>&lt;clinit&gt;()</code>方法。</p><p>​<code>&lt;clinit&gt;()</code>方法是由编译器按照语句在源文件中出现的顺序，依次自动收集类中所有静态变量的赋值动作和静态代码块中的语句，并进行合并。虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁，同步。如果多个线程同时去初始化一个类，同一时间内只允许一个线程执行此方法。</p><h3 id="Field类常用方法"><a href="#Field类常用方法" class="headerlink" title="Field类常用方法"></a>Field类常用方法</h3><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">getModifiers()</td><td align="center">以int形式返回修饰符</td></tr><tr><td align="center">getType()</td><td align="center">以Class形式获取返回类型</td></tr><tr><td align="center">getName()</td><td align="center">返回属性名</td></tr><tr><td align="center">getParameterTypes()</td><td align="center">以Class[] 返回参数类型数组</td></tr></tbody></table><p>注：在<code>getModifiers()</code>方法中，返回的int形式为：默认是0，public是1，private是2，protected是4，static是8，final是16。如果有多个修饰符就代数相加。</p><h2 id="反射暴破"><a href="#反射暴破" class="headerlink" title="反射暴破"></a>反射暴破</h2><p>使用反射机制访问private属性、方法、构造器，称为暴破（暴力破解），可以破坏封装特性。  </p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取person类的Class对象</span></span><br><span class="line">        Class&lt;?&gt; person = Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> person.getDeclaredConstructor().newInstance();  <span class="comment">// 创建无参实例</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建private有参实例</span></span><br><span class="line">        Constructor&lt;?&gt; privateConstructor = person.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        privateConstructor.setAccessible(<span class="literal">true</span>); <span class="comment">// 暴破</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> privateConstructor.newInstance(<span class="string">&quot;Mary&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> person.getDeclaredField(<span class="string">&quot;name&quot;</span>);   <span class="comment">// 获取name属性</span></span><br><span class="line">        name.set(o, <span class="string">&quot;Jack&quot;</span>);    <span class="comment">// 修改name</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">toString</span> <span class="operator">=</span> person.getMethod(<span class="string">&quot;toString&quot;</span>);     <span class="comment">// 获取toString方法</span></span><br><span class="line">        <span class="comment">// 如果方法有返回值，统一返回Object，但是运行类型和方法定义的返回类型一致</span></span><br><span class="line">        System.out.println(toString.invoke(o));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取private属性age</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> person.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.setAccessible(<span class="literal">true</span>);    <span class="comment">// 暴破</span></span><br><span class="line">        age.set(o, <span class="number">23</span>); <span class="comment">// 修改age</span></span><br><span class="line">        System.out.println(age.get(o)); <span class="comment">// 获取age的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取private方法say，如果方法中要求传参，则需要在后面输入参数对应的Class类</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">say</span> <span class="operator">=</span> person.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, String.class, <span class="type">int</span>.class);</span><br><span class="line">        say.setAccessible(<span class="literal">true</span>);    <span class="comment">// 暴破</span></span><br><span class="line">        say.invoke(o1, <span class="string">&quot;success&quot;</span>, <span class="number">1</span>);  <span class="comment">// 激活方法并传入参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String word, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用say方法：&quot;</span> + word);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person [name=&quot;</span> + name + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/e29c8e30.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java网络编程基础</title>
      <link>http://example.com/inori/bc47619b.html</link>
      <guid>http://example.com/inori/bc47619b.html</guid>
      <pubDate>Wed, 21 Feb 2024 00:47:18 GMT</pubDate>
      
      <description>java网络编程</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p> 大都是计算机网络的基础知识，这里仅复习一下重点概念。</p><ol><li>IP地址&#x3D;网络地址+主机地址</li><li>IPv4最大的问题在于网络地址资源有限，制约了互联网的应用与发展。IPv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</li><li>端口号用于标识计算机上某个特定的网络程序，范围是<strong>0~65535</strong>，其中<strong>0~1024</strong>已经被占用，当浏览器或程序要请求特定IP的某些服务时，需要使用IP地址+端口号的形式访问</li><li>常见的端口号：</li></ol><blockquote><p>ssh:22 ftp:21 smtp:25 http: 80</p><p>tomcat: 8080 mysql:3306 oracle:1521 sqlserver:1433</p></blockquote><ol start="5"><li>OSI七层模型是理论上的，并没有实际使用。主要使用的是TCP&#x2F;IP模型四层模型，分为：应用层、传输层、网际层、网络接口层</li><li>TCP协议：<ul><li>使用TCP前需要“三次握手”建立连接，形成传输数据通道，进行可靠传输</li><li>TCP协议进行通信的两个应用进程：客户端、服务端</li><li>在连接中可进行大数据量的传输</li><li>传输完毕需要释放已建立的连接，效率较低</li></ul></li><li>UDP协议：<ul><li>将数据、源、目的地封装成数据包，不需要建立连接，不可靠传输</li><li>每个数据包大小限制64KB</li><li>传输效率高</li></ul></li></ol><h2 id="Java网络编程"><a href="#Java网络编程" class="headerlink" title="Java网络编程"></a>Java网络编程</h2><p>一般使用java.net包进行网络编程</p><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><ol><li>getLocalHost:获取本机的InetAddress对象</li><li>getByName:根据指定的主机名&#x2F;域名获取IP地址对象</li><li>getHostName:获取InetAddress对象的主机名</li><li>getHostAddress:获取InetAddress对象的IP地址</li></ol><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>Socket（套接字）已经成为开发网络应用程序的标准，两台机器进行网络通信时，两端都要有Socket，作为两台机器间通信的端点，网络通信本质上就是Socket间的通信。</p><p>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输，一般主动发起通信的应用程序为客服端，等待通信请求的是服务端。</p><h4 id="Socket-TCP通信"><a href="#Socket-TCP通信" class="headerlink" title="Socket-TCP通信"></a>Socket-TCP通信</h4><p>当需要TCP进行通讯时，使用<code>socket.getOutputStream()和socket.getInputStream()</code>，当客户端连接到服务端时，客户端会由TCP&#x2F;IP协议分配一个端口与服务端进行通信。</p><p>服务器端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(port);</span><br><span class="line">        System.out.println(<span class="string">&quot;服务器端正在侦听&quot;</span> + port + <span class="string">&quot;端口&quot;</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> serverSocket.accept();  <span class="comment">// 没侦听到程序就会阻塞在这，如果侦听到了就会返回Socket对象</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> readLen;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>((readLen = inputStream.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            str += <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用完毕后要关闭连接</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getLoaclHost(), <span class="number">9999</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        outputStream.write(<span class="string">&quot;Hello,Server&quot;</span>.getBytes());</span><br><span class="line">        outputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Socket-UDP通信"><a href="#Socket-UDP通信" class="headerlink" title="Socket-UDP通信"></a>Socket-UDP通信</h4><ol><li>类<strong>DategramSocket</strong>和<strong>DatagramPacket</strong>实现了基于UDP协议的网络通信</li><li>没有明确的服务端和客户端，只有数据的发送端与接收端，并且两者身份可互换</li><li>接收数据和发送数据是通过<strong>DatagramSocket</strong>对象完成</li><li>将数据封装到<strong>DatagramPacket</strong>对象中装包</li><li>当接收到<strong>DatagramPacket</strong>对象时需要进行拆包，取出数据</li></ol><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>端口1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Port1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9999</span>);</span><br><span class="line">        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length);</span><br><span class="line">        ds.receive(res);<span class="comment">// 开一个缓冲区，从其他端口处接收消息</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> res.getLength();</span><br><span class="line">        <span class="type">byte</span>[] data = res.getData();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        ds.close();<span class="comment">// 最后要关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>端口2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Port2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;你想说什么？&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanf.next();</span><br><span class="line">        <span class="type">byte</span>[] buf = s.getBytes();</span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9998</span>);</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">sen</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buf, buf.length, InetAddress.getLocalHost(), <span class="number">9999</span>);<span class="comment">// 发送数据到指定端口</span></span><br><span class="line">        ds.send(sen);</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/bc47619b.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>javaIO流</title>
      <link>http://example.com/inori/47e3b155.html</link>
      <guid>http://example.com/inori/47e3b155.html</guid>
      <pubDate>Fri, 09 Feb 2024 03:55:07 GMT</pubDate>
      
      <description>java文件IO</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>​文件在程序中是以流的形式来操作的，文件保存在硬盘中，通过输入流被java程序读取，程序再通过输出流输出进文件中。流是数据在数据源和程序之间经历的路径，输入流是数据从数据源到程序的路径，输出流是程序到数据源的路径。</p><p>​java.io包中提供了各种流类和接口，以获取不同种类的数据，并通过方法输入或输出数据。</p><h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ul><li>按照数据单位可以分为：字节流（8bit）、字符流</li><li>按照数据流向分为：输入流、输出流</li><li>按照流的角色不同分为：节点流、处理流&#x2F;包装流</li></ul><h2 id="常用的文件操作"><a href="#常用的文件操作" class="headerlink" title="常用的文件操作"></a>常用的文件操作</h2><ol><li><p>创建文件对象相关构造器和方法</p><ul><li><code>new File(String pathname)</code>：根据路径创建文件对象</li><li><code>new File(File parent, String child)</code>：根据父目录文件+子路径构建</li><li><code>new File(String parent, String child)</code>：同上</li></ul></li><li><p>获取文件相关信息</p><ul><li><code>getName</code>：获取文件名</li><li><code>getAbsolutePath</code>：获取绝对路径</li><li><code>getParent</code>：获取文件父目录</li><li><code>length</code>：获取文件占用字节</li><li><code>exists</code>：文件是否存在</li><li><code>isFile</code>：是否为文件</li><li><code>isDirectory</code>：是否为文件夹</li><li><code>delete</code>：删除文件</li><li><code>mkdir/mkdirs</code>创建目录&#x2F;多级目录</li></ul></li></ol><h2 id="常用IO类"><a href="#常用IO类" class="headerlink" title="常用IO类"></a>常用IO类</h2><ol><li><p>InputStream&#x2F;OutputStream：从文件中读取字节的类，有基本的字节输入输出功能，常使用byte数组进行接收和写入</p><ul><li>使用<code>getBytes</code>将字符串转成Byte数组，从而对文件进行写入</li><li>使用完输出输入流之后一定要关闭流，可以使用<code>try-with-resources</code>语句来确保资源的正确关闭。</li></ul></li></ol><p>综合使用示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="string">&quot;/source.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destinationFilePath</span> <span class="operator">=</span> <span class="string">&quot;/destination.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try-with-resources语法：在try语句中初始化流类</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFilePath));</span><br><span class="line">            <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destinationFilePath))</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取并写入文件</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;File copied successfully.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Reader&#x2F;Writer：从文件中读取字符的类，主要用于处理字符数据。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceFilePath</span> <span class="operator">=</span> <span class="string">&quot;/source.txt&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destinationFilePath</span> <span class="operator">=</span> <span class="string">&quot;/destination.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// try-with-resources语法：在try语句中初始化流类</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(sourceFilePath);</span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destinationFilePath)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> bytesRead;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取并写入文件</span></span><br><span class="line">            <span class="keyword">while</span> ((bytesRead = bis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;File copied successfully.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>节点流可以从一个特定的数据源读写数据，如上面使用的FileReader、FileWriter。节点流是底层流，直接与数据源相接。</p></li><li><p>处理流（包装流）是连接已存在的流，以增加缓冲的方式来提高输入输出的效率，为程序提供更为强大的读写功能，也更加灵活，如BufferedReader、BufferedWritter。处理流既可以消除不同节点流的实现差异，也可以提供方便的方法来完成输入输出。处理流使用了修改器设计模式，不会与数据直接相连。</p></li><li><p>对象流ObjectInputStream&#x2F;ObjectOutputStream是用于对象序列化和反序列化的类。它们可以将对象转换为字节流，以便在网络上传输或保存到文件中。</p><ul><li><p>序列化就是在保存数据时，保存数据的值和数据类型</p></li><li><p>反序列就是在恢复数据时，恢复数据的值和数据类型</p></li><li><p>如果想让某个对象支持序列化，则其类必须实现<strong>Serializable</strong>(推荐，该类为标记接口，不需要实现方法）和<strong>Externalizable</strong>两个接口<u>其中之一</u></p></li><li><p>反序列化时，读取的顺序需要和序列化的顺序一致，并且返回的是Object类型，需要向下转型</p></li><li><p>序列化的类中建议添加<code>SerialVersionUID</code>，为了提高版本兼容性</p></li><li><p>序列化对象时，默认里面所有属性都会序列化（所以要求该类中所有的属性必须可序列化），除了<code>static</code>或<code>transient</code>修饰的成员</p></li><li><p>序列化可继承，父类实现了序列化，则其所有子类都可以序列化</p></li></ul></li></ol><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">20</span>, <span class="string">&quot;blue&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">testPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\test.dat&quot;</span>;</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(testPath));</span><br><span class="line">        oos.writeObject(person);</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(testPath));</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person_</span> <span class="operator">=</span> (Person)ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;<span class="comment">// 测试用的序列化类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String likedColor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String likedColor)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.likedColor = likedColor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, likedColor=&#x27;&quot;</span> + likedColor + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><p>标准输入输出流<code>System.in/System.out</code>：</p><ul><li><p><code>System.in</code>编译类型为InputStream，运行类型为BufferedInputStream，输入对象为键盘</p></li><li><p><code>System.out</code>编译类型和运行类型均为PrintStream，输出对象为显示器</p></li></ul></li><li><p>转换流<code>InputStreamReader/OutputStreamWriter</code>：</p><ul><li><code>InputStreamReader</code>：可以将<code>InputStream</code>包装成<code>Reader</code></li><li><code>OutputStreamWriter</code>：可以将<code>OutputStream</code>包装成<code>Writer</code></li><li>可以在使用时指定编码格式</li></ul></li></ol><p><img src="D:\Blog\source\img\IOType.png"></p><h2 id="Properties读写文件"><a href="#Properties读写文件" class="headerlink" title="Properties读写文件"></a>Properties读写文件</h2><p>​在java集合类中介绍过，Properties类是一种专门用于读写配置文件的集合类。在项目过程中经常要从数据库中读文件，读取的文件类型经常是.properties文件。在Properties文件中配置文件的格式为：<code>key=value</code>，默认格式为String。</p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ol><li>load：加载配置文件的键值对到Properties对象</li><li>store：将Properties中的键值对存储到配置文件，在IDEA中，保存时如果有中文，会存储为unicode码</li><li>list：将数据显示到指定设备&#x2F;流对象</li><li><code>getProperty(key)</code>：根据键获取值</li><li><code>setProperty(key, value)</code>：设置键值对到Properties对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        pro.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">// 把键值对显示到控制台</span></span><br><span class="line">        pro.list(System.out);</span><br><span class="line">        <span class="comment">// 根据键获取值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;pwd&quot;</span>);</span><br><span class="line">        <span class="comment">// 存储键值对到Properties文件中</span></span><br><span class="line">        pro.setProperty(<span class="string">&quot;user2&quot;</span>, <span class="string">&quot;inori&quot;</span>);</span><br><span class="line">        pro.setProperty(<span class="string">&quot;pwd2&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        pro.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/mysql2.properties&quot;</span>), <span class="literal">null</span>); <span class="comment">// 想要写入必须保存，第二个参数为想要写入的注释，如果不为null的话会写在文件的第一行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/47e3b155.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java多线程基础部分</title>
      <link>http://example.com/inori/9da8abfe.html</link>
      <guid>http://example.com/inori/9da8abfe.html</guid>
      <pubDate>Wed, 07 Feb 2024 05:02:01 GMT</pubDate>
      
      <description>java线程</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="待更新（等学完JUC一起更）"><a href="#待更新（等学完JUC一起更）" class="headerlink" title="待更新（等学完JUC一起更）"></a>待更新（等学完JUC一起更）</h1>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/9da8abfe.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java集合</title>
      <link>http://example.com/inori/4b0d9081.html</link>
      <guid>http://example.com/inori/4b0d9081.html</guid>
      <pubDate>Sun, 04 Feb 2024 10:37:45 GMT</pubDate>
      
      <description>java集合</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="集合的好处"><a href="#集合的好处" class="headerlink" title="集合的好处"></a>集合的好处</h2><p>之前保存多个数据的时候一直都是用的数组，但是数组</p><ol><li>长度开始时必须指定，而且一旦指定，不能更改</li><li>保存的必须为同一类型的元素</li><li>使用数组进行增加&#x2F;删除元素时比较麻烦</li></ol><p>但是集合避免了这些缺点，可以动态保存任意多个对象。</p><p>常用的集合主要可以分为两类</p><ol><li>单列集合Collection<ul><li>List：ArrayList、LinkedList、Vector</li><li>Set：HashSet、TreeSet</li></ul></li><li>双列集合Map：HashMap、TreeMap、Hashtable、Properties</li></ol><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>Collection是一个接口，不可以实例化。该类提供了一些通用方法，供实现该接口的类使用。</p><ol><li>size：集合中元素个数</li><li>isEmpty：检查集合是否为空</li><li>clear：清空集合</li></ol><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List实现了Collection接口，除了通用方法外，还含有：</p><ol><li>add（i,b)：把b元素添加到集合的i位置</li><li>addAll(i,b)：从i位置开始，把b中所有元素添加进来</li><li>get(i)：得到i位置上的元素</li><li>indexOf(a)&#x2F;lastIndexOf(a)：返回a在List中第一次&#x2F;最后一次出现的位置</li><li>remove(i)：移除并返回i位置上的元素</li><li>set(i,a)：将位置i上的元素替换成a</li><li>subList(i,j)：返回集合下标[i,j)的子集</li></ol><p><strong>ArrayList的扩容机制</strong>：当实例化对象时，可以指定大小。如果使用的无参构造器，则初始化大小为0，添加元素时，扩容为10。无论是否指定了初始大小，如果需要再次扩容，则每次扩充为原大小的1.5倍。</p><p><strong>Vector的扩容机制</strong>：当实例化对象时，可以指定大小。如果使用无参构造器，则初始化大小为10。如果需要扩容则按照两倍扩容。</p><p>Vector相比于ArrayList效率较低，但是Vector在源码中添加了<code>synchronized</code>修饰，保证了线程安全，因此在开发中，需要线程同步安全时，要考虑Vector。</p><p><strong>LinkedList</strong>：本质是双向链表，具有双向链表的一切特性，头尾部增删很快，改查很慢，不适合改查操作多的环境。</p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>集合内元素唯一，且不能通过索引查找，遍历顺序不能保证与插入顺序一致。可以使用<code>add</code>、<code>remove</code>方法。</p><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li>HashSet的底层是HashMap</li><li>添加一个元素时，先得到hash值，使用hash值转化成索引值</li><li>找到存储数据表table，看这个索引位置是否有已经存放的元素，如果没有就加入，如果有并且元素不同（使用equals比较），就添加到最后</li><li>在jdk8中，如果一条链表长度超过<code>TREEIFY_THRESHOLD</code>（默认是8），并且table大小≥<code>MIN_TREEIFY_CAPACITY</code>（默认是64），就会变成红黑树。</li><li>第一次添加元素时，table数组扩容到16，<code>临界值=threShold*loadFactor=最大长度*0.75=16*0.75=12</code></li><li>如果数组长度到了临界值，就会再次进行扩容，<code>容量=当前最大长度*2</code>，直到达到了树化条件，<code>新的临界值=最大长度*0.75</code></li><li>如果想保证元素的遍历顺序等于插入顺序，可以使用<strong>LinkedHashSet</strong>。</li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><p>TreeSet是即有序集合，底层基于红黑树，能够确保集合元素按照升序或降序排列。</p><p>相比于HashSet新增的方法有：</p><ol><li>firse&#x2F;last：获取第一个&#x2F;最后一个元素</li><li>floor(a)&#x2F;ceiling(a)：获取小于等于&#x2F;大于等于a的最大&#x2F;最小元素</li></ol><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map与Collection并列存在，用于保存具有映射关系的数据：键值对。Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中。</p><p>Map接口常用方法：</p><ol><li><code>put(key, value)</code>：添加键值对</li><li><code>remove()</code>：根据键删除映射关系</li><li><code>get(key)</code>：根据键获取值</li><li>size：获取元素个数</li><li>isEmpty：判断Map是否为空</li><li>clear：清空</li><li>containsKey：查找键是否存在</li><li>keySet：返回所有键的集合</li></ol><p>HashMap键值对的两种遍历方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.遍历键，找到值</span></span><br><span class="line">        <span class="keyword">for</span> (String key: hashMap.keySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> hashMap.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.使用entrySet获取键值对</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hashMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;: &quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap没有实现同步，不保证线程安全。</p><p>HashTable与HashMap使用的方法基本一致，区别在于：</p><ol><li>HashTable的键和值都不能为null，否则会报空指针异常</li><li>HashTable是线程安全的，多个线程不能同时修改HashTable中的内容</li><li>HashTable在性能上比HashMap略差</li></ol><p>Properties类是用于处理属性文件的类，继承自HashTable类，并实现了Map接口，特点与HashTable类似。Properties主要用于从properties文件中加载数据到Properties类对象，并进行读取和修改。</p><p>方法：</p><ol><li><code>setProperty(key, value)</code>：添加属性</li><li><code>getProperty(key)</code>：获取属性</li><li>load：加载属性文件</li><li>store：保存属性文件</li></ol><p>TreeMap即有序键值对，可以保证插入的键有序排列，方法与HashMap大致相同，但是TreeMap不允许键为null，只允许值接null。</p><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>Collections是一个操作Set、List、Map等集合的工具类，其中提供了一系列的static方法对元素进行排序、查询和修改等操作。</p><p>主要方法：</p><ol><li>sort：对List进行升序排序，其中可以编写比较器对List指定排序方法</li><li>shuffle：打乱List中元素的顺序</li><li>reverse：对List进行翻转</li><li>swap：交换List中两个元素的位置</li><li>max&#x2F;min：返回集合中最大&#x2F;最小的元素</li><li><code>frequency(Collection, Object)</code>：返回Collection集合中Object的出现次数</li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/4b0d9081.html#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>java常用类及其方法</title>
      <link>http://example.com/inori/12697782.html</link>
      <guid>http://example.com/inori/12697782.html</guid>
      <pubDate>Fri, 02 Feb 2024 07:05:41 GMT</pubDate>
      
      <description>java常用类</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>针对八种基本数据类型相应的引用类型，有了类的特点，就能调用类中的方法。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table><h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>​这两个过程的主要用途在于使得在需要使用对象的场景中能够使用基本数据类型，以及在需要使用基本数据类型的场景中能够使用对象。例如，在集合类中，只能存储对象而不能存储基本数据类型，因此需要通过装箱将基本数据类型转换为对应的包装类对象。</p><p>​在jdk5之前，需要手动装箱与拆箱，jdk5及之后使用自动装箱与拆箱。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 手动装箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(num);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> Integer.valueOf(num);</span><br><span class="line">        <span class="comment">// 手动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i.intValue();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自动装箱和拆箱</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ol><li>字符串的字符使用Unicode字符编码，无论字母还是汉字都占2字节</li><li>String类有很多构造器和构造器的重载，常用的有：</li></ol><blockquote><p>String s1 &#x3D; new String();</p><p>String s2 &#x3D; new String(String original);</p><p>String s3 &#x3D; new String(char[] a);</p><p>String s4 &#x3D; new String(char[] a, int startIndex, int count);</p><p>String s5 &#x3D; new String(byte[] b);</p></blockquote><ol start="3"><li>String类实现了接口Serializable（串行化：可以在网络传输）和接口Comparable（比较大小）</li><li>String是final类，不能被继承</li><li>String有属性private final char value[]，用于存放字符串内容</li></ol><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li>equals：区分大小写，判断内容是否相等</li><li>equalsIgnoreCase：忽略大小写，判断内容是否相等</li><li>length：返回字符串长度</li><li>substring：截取指定范围的子串，前闭后开区间</li><li>trim：去掉前后空格</li><li>charAt：获取索引处字符</li><li>toUpperCase：把字符串全部转换成大写</li><li>toLowerCase：把字符串全部转换成小写</li><li>replace：<code>str.replace(a,b)</code>将str中所有的a替换成b</li><li>split：字符串分割，类似于Python的split，需要用列表接收</li><li>toCharArray：将字符串转化成字符数组<code>char[]</code></li><li>format：用法类似于c的printf</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String str;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.14159265</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(<span class="string">&quot;a=%d,b=%s,c=%c,d=%.2f&quot;</span>, a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>​StringBuffer是一个容器，因为是线程安全的(方法添加了synchronized修饰)，所以一般用于多线程，代表可变的字符序列，可以对字符串内容进行增删，方法与String大体相同。</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><blockquote><p>StringBuffer()：构造一个不带字符的缓冲区，大小为16</p><p>StringBuffer(int capacity)：构造一个不带字符，容量为capacity的缓冲区</p><p>StringBuffer(String str)：构造一个内容为str，大小为str.length()+16的缓冲区</p></blockquote><h4 id="转换机制"><a href="#转换机制" class="headerlink" title="转换机制"></a>转换机制</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String -&gt; StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuffer -&gt; String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb.toString();</span><br></pre></td></tr></table></figure><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><ol><li>append：向后面添加字符串</li><li>delete：<code>delete(a,b)</code>删除指定范围的字符，左闭右开，即删除[a,b)内的字符</li><li>replace：<code>replace(a,b)</code>用法同delete，删除改为替换</li><li>indexOf：查找指定子串在字符串中第一次出现的位置，没找到返回-1</li><li>insert：<code>insert(a,b)</code>在a位置插入字符串b</li></ol><h3 id="StringBulider类"><a href="#StringBulider类" class="headerlink" title="StringBulider类"></a>StringBulider类</h3><p>​StringBulider和StringBuffer类均代表可变的字符序列，但是StringBulider效率更高，两者方法相同，所以使用和StringBuffer一样，但是StringBulider一般用于单线程。</p><p>效率：StringBulider &gt; StringBuffer &gt; String</p><h2 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h2><p>包含用于执行基本数学运算的方法。</p><ol><li>abs：绝对值</li><li>pow：幂运算，<code>pow(a,b)</code>指求a的b次方</li><li>ceil：向上取整</li><li>floor：向下取整</li><li>sqrt：开方</li><li>random：返回一个[0,1)之间的double类型的随机数</li><li>max&#x2F;min：求最值</li></ol><h2 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h2><p>Arrays用于管理或操作数组。</p><ol><li>toString：将数组内容变成字符串，便于输出查看内容</li><li>sort：将数组排序，可以使用匿名内部类改变排序方法</li><li>binarySearch：通过二分查找有序数组的某一个数，如果存在返回索引。不存在返回<code>-(本应该在的位置+1)</code></li><li>fill：<code>fill(arr, num)</code>将arr数组内容全部变成num</li><li>asList：将一组值转换成list</li></ol><h2 id="大数处理方案"><a href="#大数处理方案" class="headerlink" title="大数处理方案"></a>大数处理方案</h2><p><strong>BigInteger</strong>适合保存超出<code>long</code>表示范围的整数。<strong>BigDecimal</strong>适合保存超出<code>double</code>表示范围的浮点型。</p><p>加减乘除不能使用正常的数学符号，必须使用类给定的方法。</p><p>用法（以BigInteger为例，BigDecimal与之相同）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;9999999999999999999999999999999999&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">add</span> <span class="operator">=</span> num1.add(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">sub</span> <span class="operator">=</span> num1.subtract(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">mul</span> <span class="operator">=</span> num1.multiply(num2);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">div</span> <span class="operator">=</span> num1.divide(num2);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 注意，BigDecimal的除法可能与BigInteger不同</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;10.999999999999999999999999999999999991&quot;</span>);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果除数除不尽的话会报异常，解决办法：</span></span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">div2</span> <span class="operator">=</span> num3.divide(num4, BigDecimal.ROUND_CEILING); <span class="comment">// 保留与被除数相同的精度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="第一代日期类"><a href="#第一代日期类" class="headerlink" title="第一代日期类"></a>第一代日期类</h3><p>用于获得系统时间。</p><ol><li>Date：<code>new Date()</code>获取当前系统时间。</li><li>SimpleDateFormat：将日期转换成指定格式的字符串<code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;)</code>E表示星期</li></ol><h3 id="第二代日期类"><a href="#第二代日期类" class="headerlink" title="第二代日期类"></a>第二代日期类</h3><p>指Calendar类，Calendar是一个抽象类，构造器使用private修饰。可以通过getInstance()获取实例。Calendar没有专门的格式化方法，需要自己组合显示。</p><ol><li><code>Calendar c = Calendar.getInstance()</code>创建日历类对象，包含Calendar字段</li><li>获取日历：</li></ol><blockquote><p>c.get(Calendar.YEAR)</p><p>c.get(Calendar.MONTH) + 1 &#x2F;&#x2F; 月默认从0开始</p><p>c.get(Calendar.DAY_OF_MONTH)</p><p>c.get(Calendar.HOUR)</p><p>c.get(Calendar.MINUTE)</p><p>c.get(Calendar.SECOND)</p></blockquote><h3 id="第三代日期类"><a href="#第三代日期类" class="headerlink" title="第三代日期类"></a>第三代日期类</h3><p>为了改善前两代日期类的不足，在jdk8中推出了第三代日期类</p><ol><li>LocalDate：年月日</li><li>LocalTime：时分秒</li><li>LocalDateTime：日期+时间</li></ol><blockquote><p>LocalDateTime ldt &#x3D; LoaclDateTime.now()</p><p>ldt.getYear()</p><p>ldt.getMonthValue()</p><p>ldt.getDayOfMonth()</p><p>ldt.getHour()</p><p>ldt.getMinute()</p><p>ldt.getSecond()</p></blockquote><ol start="4"><li>SimpleDateFormat：格式日期类</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LoaclDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH小时mm分钟ss秒&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format();</span><br></pre></td></tr></table></figure><ol start="5"><li>plus系列方法：<code>plusDay</code>、<code>plusMinutes</code>等方法，可以查看多少天&#x2F;分钟后的日期是什么</li><li>minus系列方法：可以查看给定时间之前的日期是什么</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>​泛型是一种在设计和使用类、接口和方法时，允许更广泛地操作各种数据类型的机制。泛型提供了一种在代码中使用一般类型而不是具体类型的方式，在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值类型、参数类型，这样可以提高代码的重用性、可读性和类型安全性，使用任何字母都可以，通常使用<code>&lt;E&gt;</code>、<code>&lt;T&gt;</code>、<code>&lt;K&gt;</code>表示。Java的源码中使用了大量泛型以提高代码复用性。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Test&lt;Integer&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;(<span class="number">1</span>);<span class="comment">// 使用Integer代替E</span></span><br><span class="line">        System.out.println(test.function()); <span class="comment">// 返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt;&#123;</span><br><span class="line">T s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(T s)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">function</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t, R r)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>给泛型指定数据类型时，只能使用引用类型，不能是基本数据类型</li><li>在给泛型指定具体类型时，可以传入该类型或者该类型的子类型</li><li>使用泛型的数组不能初始化（因为不知道这里要用什么样的类型，不知道要开多大空间）</li><li>静态属性和静态方法中不能使用泛型（因为静态是和类相关的，在类加载时，对象还没有创建，如果静态属性和静态方法使用了泛型，JVM就无法完成初始化）</li><li>泛型方法可以在普通类中，也可以在泛型类中</li><li>如果创建类时没有指定类型，默认为Object</li><li>若在接口类中使用泛型，类型在继承接口或者实现接口时确定</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IUsb</span>&lt;U, R&gt;&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    R <span class="title function_">get</span><span class="params">(U u)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(R r)</span>;</span><br><span class="line">    <span class="keyword">default</span> R <span class="title function_">method</span><span class="params">(U u)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> <span class="keyword">extends</span> <span class="title class_">IUsb</span>&lt;String, Double&gt; &#123;......&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">implements</span> <span class="title class_">IUsb</span>&lt;String, Double&gt; &#123;......&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>泛型的通配符：<ul><li><code>&lt;?&gt;</code>代表支持任意泛型类型</li><li><code>&lt;? extends A&gt;</code>代表支持A类以及A的子类，规定了泛型类型的上限</li><li><code>&lt;? super A&gt;</code>代表支持A类以及A的父类，规定了泛型类型的下限</li></ul></li></ol>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/java%E5%9F%BA%E7%A1%80/">java基础</category>
      
      
      <category domain="http://example.com/tags/java/">java</category>
      
      
      <comments>http://example.com/inori/12697782.html#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
